/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ITERATE_KEY": () => (/* binding */ ITERATE_KEY),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "customRef": () => (/* binding */ customRef),
/* harmony export */   "effect": () => (/* binding */ effect),
/* harmony export */   "enableTracking": () => (/* binding */ enableTracking),
/* harmony export */   "isProxy": () => (/* binding */ isProxy),
/* harmony export */   "isReactive": () => (/* binding */ isReactive),
/* harmony export */   "isReadonly": () => (/* binding */ isReadonly),
/* harmony export */   "isRef": () => (/* binding */ isRef),
/* harmony export */   "markRaw": () => (/* binding */ markRaw),
/* harmony export */   "pauseTracking": () => (/* binding */ pauseTracking),
/* harmony export */   "proxyRefs": () => (/* binding */ proxyRefs),
/* harmony export */   "reactive": () => (/* binding */ reactive),
/* harmony export */   "readonly": () => (/* binding */ readonly),
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "resetTracking": () => (/* binding */ resetTracking),
/* harmony export */   "shallowReactive": () => (/* binding */ shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* binding */ shallowReadonly),
/* harmony export */   "shallowRef": () => (/* binding */ shallowRef),
/* harmony export */   "stop": () => (/* binding */ stop),
/* harmony export */   "toRaw": () => (/* binding */ toRaw),
/* harmony export */   "toRef": () => (/* binding */ toRef),
/* harmony export */   "toRefs": () => (/* binding */ toRefs),
/* harmony export */   "track": () => (/* binding */ track),
/* harmony export */   "trigger": () => (/* binding */ trigger),
/* harmony export */   "triggerRef": () => (/* binding */ triggerRef),
/* harmony export */   "unref": () => (/* binding */ unref)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");

const targetMap = new WeakMap();
const effectStack = [];
let activeEffect;
const ITERATE_KEY = Symbol( true ? 'iterate' : 0);
const MAP_KEY_ITERATE_KEY = Symbol( true ? 'Map key iterate' : 0);

function isEffect(fn) {
  return fn && fn._isEffect === true;
}

function effect(fn, options = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ) {
  if (isEffect(fn)) {
    fn = fn.raw;
  }

  const effect = createReactiveEffect(fn, options);

  if (!options.lazy) {
    effect();
  }

  return effect;
}

function stop(effect) {
  if (effect.active) {
    cleanup(effect);

    if (effect.options.onStop) {
      effect.options.onStop();
    }

    effect.active = false;
  }
}

let uid = 0;

function createReactiveEffect(fn, options) {
  const effect = function reactiveEffect() {
    if (!effect.active) {
      return fn();
    }

    if (!effectStack.includes(effect)) {
      cleanup(effect);

      try {
        enableTracking();
        effectStack.push(effect);
        activeEffect = effect;
        return fn();
      } finally {
        effectStack.pop();
        resetTracking();
        activeEffect = effectStack[effectStack.length - 1];
      }
    }
  };

  effect.id = uid++;
  effect.allowRecurse = !!options.allowRecurse;
  effect._isEffect = true;
  effect.active = true;
  effect.raw = fn;
  effect.deps = [];
  effect.options = options;
  return effect;
}

function cleanup(effect) {
  const {
    deps
  } = effect;

  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }

    deps.length = 0;
  }
}

let shouldTrack = true;
const trackStack = [];

function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}

function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}

function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === undefined ? true : last;
}

function track(target, type, key) {
  if (!shouldTrack || activeEffect === undefined) {
    return;
  }

  let depsMap = targetMap.get(target);

  if (!depsMap) {
    targetMap.set(target, depsMap = new Map());
  }

  let dep = depsMap.get(key);

  if (!dep) {
    depsMap.set(key, dep = new Set());
  }

  if (!dep.has(activeEffect)) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);

    if ( true && activeEffect.options.onTrack) {
      activeEffect.options.onTrack({
        effect: activeEffect,
        target,
        type,
        key
      });
    }
  }
}

function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);

  if (!depsMap) {
    // never been tracked
    return;
  }

  const effects = new Set();

  const add = effectsToAdd => {
    if (effectsToAdd) {
      effectsToAdd.forEach(effect => {
        if (effect !== activeEffect || effect.allowRecurse) {
          effects.add(effect);
        }
      });
    }
  };

  if (type === "clear"
  /* CLEAR */
  ) {
      // collection being cleared
      // trigger all effects for target
      depsMap.forEach(add);
    } else if (key === 'length' && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
    depsMap.forEach((dep, key) => {
      if (key === 'length' || key >= newValue) {
        add(dep);
      }
    });
  } else {
    // schedule runs for SET | ADD | DELETE
    if (key !== void 0) {
      add(depsMap.get(key));
    } // also run for iteration key on ADD | DELETE | Map.SET


    switch (type) {
      case "add"
      /* ADD */
      :
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
          add(depsMap.get(ITERATE_KEY));

          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
            add(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)) {
          // new index added to array -> length changes
          add(depsMap.get('length'));
        }

        break;

      case "delete"
      /* DELETE */
      :
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
          add(depsMap.get(ITERATE_KEY));

          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
            add(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }

        break;

      case "set"
      /* SET */
      :
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
          add(depsMap.get(ITERATE_KEY));
        }

        break;
    }
  }

  const run = effect => {
    if ( true && effect.options.onTrigger) {
      effect.options.onTrigger({
        effect,
        target,
        key,
        type,
        newValue,
        oldValue,
        oldTarget
      });
    }

    if (effect.options.scheduler) {
      effect.options.scheduler(effect);
    } else {
      effect();
    }
  };

  effects.forEach(run);
}

const isNonTrackableKeys = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map(key => Symbol[key]).filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol));
const get = /*#__PURE__*/createGetter();
const shallowGet = /*#__PURE__*/createGetter(false, true);
const readonlyGet = /*#__PURE__*/createGetter(true);
const shallowReadonlyGet = /*#__PURE__*/createGetter(true, true);
const arrayInstrumentations = /*#__PURE__*/createArrayInstrumentations();

function createArrayInstrumentations() {
  const instrumentations = {};
  ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
    const method = Array.prototype[key];

    instrumentations[key] = function (...args) {
      const arr = toRaw(this);

      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get"
        /* GET */
        , i + '');
      } // we run the method using the original args first (which may be reactive)


      const res = method.apply(arr, args);

      if (res === -1 || res === false) {
        // if that didn't work, run it again using raw values.
        return method.apply(arr, args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
    const method = Array.prototype[key];

    instrumentations[key] = function (...args) {
      pauseTracking();
      const res = method.apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}

function createGetter(isReadonly = false, shallow = false) {
  return function get(target, key, receiver) {
    if (key === "__v_isReactive"
    /* IS_REACTIVE */
    ) {
        return !isReadonly;
      } else if (key === "__v_isReadonly"
    /* IS_READONLY */
    ) {
        return isReadonly;
      } else if (key === "__v_raw"
    /* RAW */
    && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }

    const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);

    if (!isReadonly && targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }

    const res = Reflect.get(target, key, receiver);

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }

    if (!isReadonly) {
      track(target, "get"
      /* GET */
      , key);
    }

    if (shallow) {
      return res;
    }

    if (isRef(res)) {
      // ref unwrapping - does not apply for Array + integer key.
      const shouldUnwrap = !targetIsArray || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key);
      return shouldUnwrap ? res.value : res;
    }

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
      // Convert returned value into a proxy as well. we do the isObject check
      // here to avoid invalid value warning. Also need to lazy access readonly
      // and reactive here to avoid circular dependency.
      return isReadonly ? readonly(res) : reactive(res);
    }

    return res;
  };
}

const set = /*#__PURE__*/createSetter();
const shallowSet = /*#__PURE__*/createSetter(true);

function createSetter(shallow = false) {
  return function set(target, key, value, receiver) {
    let oldValue = target[key];

    if (!shallow) {
      value = toRaw(value);
      oldValue = toRaw(oldValue);

      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }

    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key) ? Number(key) < target.length : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    const result = Reflect.set(target, key, value, receiver); // don't trigger if target is something up in the prototype chain of original

    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add"
        /* ADD */
        , key, value);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
        trigger(target, "set"
        /* SET */
        , key, value, oldValue);
      }
    }

    return result;
  };
}

function deleteProperty(target, key) {
  const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);

  if (result && hadKey) {
    trigger(target, "delete"
    /* DELETE */
    , key, undefined, oldValue);
  }

  return result;
}

function has(target, key) {
  const result = Reflect.has(target, key);

  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {
    track(target, "has"
    /* HAS */
    , key);
  }

  return result;
}

function ownKeys(target) {
  track(target, "iterate"
  /* ITERATE */
  , (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? 'length' : ITERATE_KEY);
  return Reflect.ownKeys(target);
}

const mutableHandlers = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,

  set(target, key) {
    if (true) {
      console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }

    return true;
  },

  deleteProperty(target, key) {
    if (true) {
      console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }

    return true;
  }

};
const shallowReactiveHandlers = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
}); // Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.

const shallowReadonlyHandlers = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, readonlyHandlers, {
  get: shallowReadonlyGet
});

const toReactive = value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;

const toReadonly = value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;

const toShallow = value => value;

const getProto = v => Reflect.getPrototypeOf(v);

function get$1(target, key, isReadonly = false, isShallow = false) {
  // #1772: readonly(reactive(Map)) should return readonly + reactive version
  // of the value
  target = target["__v_raw"
  /* RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);

  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "get"
    /* GET */
    , key);
  }

  !isReadonly && track(rawTarget, "get"
  /* GET */
  , rawKey);
  const {
    has
  } = getProto(rawTarget);
  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;

  if (has.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    // #3602 readonly(reactive(Map))
    // ensure that the nested reactive `Map` can do tracking for itself
    target.get(key);
  }
}

function has$1(key, isReadonly = false) {
  const target = this["__v_raw"
  /* RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);

  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "has"
    /* HAS */
    , key);
  }

  !isReadonly && track(rawTarget, "has"
  /* HAS */
  , rawKey);
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}

function size(target, isReadonly = false) {
  target = target["__v_raw"
  /* RAW */
  ];
  !isReadonly && track(toRaw(target), "iterate"
  /* ITERATE */
  , ITERATE_KEY);
  return Reflect.get(target, 'size', target);
}

function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);

  if (!hadKey) {
    target.add(value);
    trigger(target, "add"
    /* ADD */
    , value, value);
  }

  return this;
}

function set$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const {
    has,
    get
  } = getProto(target);
  let hadKey = has.call(target, key);

  if (!hadKey) {
    key = toRaw(key);
    hadKey = has.call(target, key);
  } else if (true) {
    checkIdentityKeys(target, has, key);
  }

  const oldValue = get.call(target, key);
  target.set(key, value);

  if (!hadKey) {
    trigger(target, "add"
    /* ADD */
    , key, value);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
    trigger(target, "set"
    /* SET */
    , key, value, oldValue);
  }

  return this;
}

function deleteEntry(key) {
  const target = toRaw(this);
  const {
    has,
    get
  } = getProto(target);
  let hadKey = has.call(target, key);

  if (!hadKey) {
    key = toRaw(key);
    hadKey = has.call(target, key);
  } else if (true) {
    checkIdentityKeys(target, has, key);
  }

  const oldValue = get ? get.call(target, key) : undefined; // forward the operation before queueing reactions

  const result = target.delete(key);

  if (hadKey) {
    trigger(target, "delete"
    /* DELETE */
    , key, undefined, oldValue);
  }

  return result;
}

function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget =  true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target) ? new Map(target) : new Set(target) : 0; // forward the operation before queueing reactions

  const result = target.clear();

  if (hadItems) {
    trigger(target, "clear"
    /* CLEAR */
    , undefined, undefined, oldTarget);
  }

  return result;
}

function createForEach(isReadonly, isShallow) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"
    /* RAW */
    ];
    const rawTarget = toRaw(target);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate"
    /* ITERATE */
    , ITERATE_KEY);
    return target.forEach((value, key) => {
      // important: make sure the callback is
      // 1. invoked with the reactive map as `this` and 3rd arg
      // 2. the value received should be a corresponding reactive/readonly.
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}

function createIterableMethod(method, isReadonly, isShallow) {
  return function (...args) {
    const target = this["__v_raw"
    /* RAW */
    ];
    const rawTarget = toRaw(target);
    const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);
    const isPair = method === 'entries' || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === 'keys' && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate"
    /* ITERATE */
    , isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY); // return a wrapped iterator which returns observed versions of the
    // values emitted from the real iterator

    return {
      // iterator protocol
      next() {
        const {
          value,
          done
        } = innerIterator.next();
        return done ? {
          value,
          done
        } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },

      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }

    };
  };
}

function createReadonlyMethod(type) {
  return function (...args) {
    if (true) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }

    return type === "delete"
    /* DELETE */
    ? false : this;
  };
}

function createInstrumentations() {
  const mutableInstrumentations = {
    get(key) {
      return get$1(this, key);
    },

    get size() {
      return size(this);
    },

    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations = {
    get(key) {
      return get$1(this, key, false, true);
    },

    get size() {
      return size(this);
    },

    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations = {
    get(key) {
      return get$1(this, key, true);
    },

    get size() {
      return size(this, true);
    },

    has(key) {
      return has$1.call(this, key, true);
    },

    add: createReadonlyMethod("add"
    /* ADD */
    ),
    set: createReadonlyMethod("set"
    /* SET */
    ),
    delete: createReadonlyMethod("delete"
    /* DELETE */
    ),
    clear: createReadonlyMethod("clear"
    /* CLEAR */
    ),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations = {
    get(key) {
      return get$1(this, key, true, true);
    },

    get size() {
      return size(this, true);
    },

    has(key) {
      return has$1.call(this, key, true);
    },

    add: createReadonlyMethod("add"
    /* ADD */
    ),
    set: createReadonlyMethod("set"
    /* SET */
    ),
    delete: createReadonlyMethod("delete"
    /* DELETE */
    ),
    clear: createReadonlyMethod("clear"
    /* CLEAR */
    ),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
  iteratorMethods.forEach(method => {
    mutableInstrumentations[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations[method] = createIterableMethod(method, true, false);
    shallowInstrumentations[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
  });
  return [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations];
}

const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/createInstrumentations();

function createInstrumentationGetter(isReadonly, shallow) {
  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive"
    /* IS_REACTIVE */
    ) {
        return !isReadonly;
      } else if (key === "__v_isReadonly"
    /* IS_READONLY */
    ) {
        return isReadonly;
      } else if (key === "__v_raw"
    /* RAW */
    ) {
        return target;
      }

    return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}

const mutableCollectionHandlers = {
  get: /*#__PURE__*/createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /*#__PURE__*/createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /*#__PURE__*/createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /*#__PURE__*/createInstrumentationGetter(true, true)
};

function checkIdentityKeys(target, has, key) {
  const rawKey = toRaw(key);

  if (rawKey !== key && has.call(target, rawKey)) {
    const type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);
    console.warn(`Reactive ${type} contains both the raw and reactive ` + `versions of the same object${type === `Map` ? ` as keys` : ``}, ` + `which can lead to inconsistencies. ` + `Avoid differentiating between the raw and reactive versions ` + `of an object and only use the reactive version if possible.`);
  }
}

const reactiveMap = new WeakMap();
const shallowReactiveMap = new WeakMap();
const readonlyMap = new WeakMap();
const shallowReadonlyMap = new WeakMap();

function targetTypeMap(rawType) {
  switch (rawType) {
    case 'Object':
    case 'Array':
      return 1
      /* COMMON */
      ;

    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return 2
      /* COLLECTION */
      ;

    default:
      return 0
      /* INVALID */
      ;
  }
}

function getTargetType(value) {
  return value["__v_skip"
  /* SKIP */
  ] || !Object.isExtensible(value) ? 0
  /* INVALID */
  : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));
}

function reactive(target) {
  // if trying to observe a readonly proxy, return the readonly version.
  if (target && target["__v_isReadonly"
  /* IS_READONLY */
  ]) {
    return target;
  }

  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */


function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
/**
 * Creates a readonly copy of the original object. Note the returned copy is not
 * made reactive, but `readonly` can be called on an already reactive object.
 */


function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */


function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}

function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
    if (true) {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }

    return target;
  } // target is already a Proxy, return it.
  // exception: calling readonly() on a reactive object


  if (target["__v_raw"
  /* RAW */
  ] && !(isReadonly && target["__v_isReactive"
  /* IS_REACTIVE */
  ])) {
    return target;
  } // target already has corresponding Proxy


  const existingProxy = proxyMap.get(target);

  if (existingProxy) {
    return existingProxy;
  } // only a whitelist of value types can be observed.


  const targetType = getTargetType(target);

  if (targetType === 0
  /* INVALID */
  ) {
      return target;
    }

  const proxy = new Proxy(target, targetType === 2
  /* COLLECTION */
  ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}

function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"
    /* RAW */
    ]);
  }

  return !!(value && value["__v_isReactive"
  /* IS_REACTIVE */
  ]);
}

function isReadonly(value) {
  return !!(value && value["__v_isReadonly"
  /* IS_READONLY */
  ]);
}

function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}

function toRaw(observed) {
  return observed && toRaw(observed["__v_raw"
  /* RAW */
  ]) || observed;
}

function markRaw(value) {
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, "__v_skip"
  /* SKIP */
  , true);
  return value;
}

const convert = val => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(val) ? reactive(val) : val;

function isRef(r) {
  return Boolean(r && r.__v_isRef === true);
}

function ref(value) {
  return createRef(value);
}

function shallowRef(value) {
  return createRef(value, true);
}

class RefImpl {
  constructor(_rawValue, _shallow) {
    this._rawValue = _rawValue;
    this._shallow = _shallow;
    this.__v_isRef = true;
    this._value = _shallow ? _rawValue : convert(_rawValue);
  }

  get value() {
    track(toRaw(this), "get"
    /* GET */
    , 'value');
    return this._value;
  }

  set value(newVal) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(toRaw(newVal), this._rawValue)) {
      this._rawValue = newVal;
      this._value = this._shallow ? newVal : convert(newVal);
      trigger(toRaw(this), "set"
      /* SET */
      , 'value', newVal);
    }
  }

}

function createRef(rawValue, shallow = false) {
  if (isRef(rawValue)) {
    return rawValue;
  }

  return new RefImpl(rawValue, shallow);
}

function triggerRef(ref) {
  trigger(toRaw(ref), "set"
  /* SET */
  , 'value',  true ? ref.value : 0);
}

function unref(ref) {
  return isRef(ref) ? ref.value : ref;
}

const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];

    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};

function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}

class CustomRefImpl {
  constructor(factory) {
    this.__v_isRef = true;
    const {
      get,
      set
    } = factory(() => track(this, "get"
    /* GET */
    , 'value'), () => trigger(this, "set"
    /* SET */
    , 'value'));
    this._get = get;
    this._set = set;
  }

  get value() {
    return this._get();
  }

  set value(newVal) {
    this._set(newVal);
  }

}

function customRef(factory) {
  return new CustomRefImpl(factory);
}

function toRefs(object) {
  if ( true && !isProxy(object)) {
    console.warn(`toRefs() expects a reactive object but received a plain one.`);
  }

  const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};

  for (const key in object) {
    ret[key] = toRef(object, key);
  }

  return ret;
}

class ObjectRefImpl {
  constructor(_object, _key) {
    this._object = _object;
    this._key = _key;
    this.__v_isRef = true;
  }

  get value() {
    return this._object[this._key];
  }

  set value(newVal) {
    this._object[this._key] = newVal;
  }

}

function toRef(object, key) {
  return isRef(object[key]) ? object[key] : new ObjectRefImpl(object, key);
}

class ComputedRefImpl {
  constructor(getter, _setter, isReadonly) {
    this._setter = _setter;
    this._dirty = true;
    this.__v_isRef = true;
    this.effect = effect(getter, {
      lazy: true,
      scheduler: () => {
        if (!this._dirty) {
          this._dirty = true;
          trigger(toRaw(this), "set"
          /* SET */
          , 'value');
        }
      }
    });
    this["__v_isReadonly"
    /* IS_READONLY */
    ] = isReadonly;
  }

  get value() {
    // the computed ref may get wrapped by other proxies e.g. readonly() #3376
    const self = toRaw(this);

    if (self._dirty) {
      self._value = this.effect();
      self._dirty = false;
    }

    track(self, "get"
    /* GET */
    , 'value');
    return self._value;
  }

  set value(newValue) {
    this._setter(newValue);
  }

}

function computed(getterOrOptions) {
  let getter;
  let setter;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions)) {
    getter = getterOrOptions;
    setter =  true ? () => {
      console.warn('Write operation failed: computed value is readonly');
    } : 0;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }

  return new ComputedRefImpl(getter, setter, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions) || !getterOrOptions.set);
}



/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey),
/* harmony export */   "BaseTransition": () => (/* binding */ BaseTransition),
/* harmony export */   "Comment": () => (/* binding */ Comment$1),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "KeepAlive": () => (/* binding */ KeepAlive),
/* harmony export */   "Static": () => (/* binding */ Static),
/* harmony export */   "Suspense": () => (/* binding */ Suspense),
/* harmony export */   "Teleport": () => (/* binding */ Teleport),
/* harmony export */   "Text": () => (/* binding */ Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* binding */ callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* binding */ callWithErrorHandling),
/* harmony export */   "cloneVNode": () => (/* binding */ cloneVNode),
/* harmony export */   "compatUtils": () => (/* binding */ compatUtils),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "createBlock": () => (/* binding */ createBlock),
/* harmony export */   "createCommentVNode": () => (/* binding */ createCommentVNode),
/* harmony export */   "createHydrationRenderer": () => (/* binding */ createHydrationRenderer),
/* harmony export */   "createRenderer": () => (/* binding */ createRenderer),
/* harmony export */   "createSlots": () => (/* binding */ createSlots),
/* harmony export */   "createStaticVNode": () => (/* binding */ createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* binding */ createTextVNode),
/* harmony export */   "createVNode": () => (/* binding */ createVNode),
/* harmony export */   "defineAsyncComponent": () => (/* binding */ defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* binding */ defineComponent),
/* harmony export */   "defineEmit": () => (/* binding */ defineEmit),
/* harmony export */   "defineEmits": () => (/* binding */ defineEmits),
/* harmony export */   "defineExpose": () => (/* binding */ defineExpose),
/* harmony export */   "defineProps": () => (/* binding */ defineProps),
/* harmony export */   "devtools": () => (/* binding */ devtools),
/* harmony export */   "getCurrentInstance": () => (/* binding */ getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* binding */ getTransitionRawChildren),
/* harmony export */   "h": () => (/* binding */ h),
/* harmony export */   "handleError": () => (/* binding */ handleError),
/* harmony export */   "initCustomFormatter": () => (/* binding */ initCustomFormatter),
/* harmony export */   "inject": () => (/* binding */ inject),
/* harmony export */   "isRuntimeOnly": () => (/* binding */ isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* binding */ isVNode),
/* harmony export */   "mergeDefaults": () => (/* binding */ mergeDefaults),
/* harmony export */   "mergeProps": () => (/* binding */ mergeProps),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "onActivated": () => (/* binding */ onActivated),
/* harmony export */   "onBeforeMount": () => (/* binding */ onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* binding */ onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* binding */ onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* binding */ onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* binding */ onErrorCaptured),
/* harmony export */   "onMounted": () => (/* binding */ onMounted),
/* harmony export */   "onRenderTracked": () => (/* binding */ onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* binding */ onRenderTriggered),
/* harmony export */   "onServerPrefetch": () => (/* binding */ onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* binding */ onUnmounted),
/* harmony export */   "onUpdated": () => (/* binding */ onUpdated),
/* harmony export */   "openBlock": () => (/* binding */ openBlock),
/* harmony export */   "popScopeId": () => (/* binding */ popScopeId),
/* harmony export */   "provide": () => (/* binding */ provide),
/* harmony export */   "pushScopeId": () => (/* binding */ pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* binding */ queuePostFlushCb),
/* harmony export */   "registerRuntimeCompiler": () => (/* binding */ registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* binding */ renderList),
/* harmony export */   "renderSlot": () => (/* binding */ renderSlot),
/* harmony export */   "resolveComponent": () => (/* binding */ resolveComponent),
/* harmony export */   "resolveDirective": () => (/* binding */ resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* binding */ resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* binding */ resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* binding */ resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* binding */ setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* binding */ setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* binding */ setTransitionHooks),
/* harmony export */   "ssrContextKey": () => (/* binding */ ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* binding */ ssrUtils),
/* harmony export */   "toHandlers": () => (/* binding */ toHandlers),
/* harmony export */   "transformVNodeArgs": () => (/* binding */ transformVNodeArgs),
/* harmony export */   "useAttrs": () => (/* binding */ useAttrs),
/* harmony export */   "useContext": () => (/* binding */ useContext),
/* harmony export */   "useSSRContext": () => (/* binding */ useSSRContext),
/* harmony export */   "useSlots": () => (/* binding */ useSlots),
/* harmony export */   "useTransitionState": () => (/* binding */ useTransitionState),
/* harmony export */   "version": () => (/* binding */ version),
/* harmony export */   "warn": () => (/* binding */ warn),
/* harmony export */   "watch": () => (/* binding */ watch),
/* harmony export */   "watchEffect": () => (/* binding */ watchEffect),
/* harmony export */   "withAsyncContext": () => (/* binding */ withAsyncContext),
/* harmony export */   "withCtx": () => (/* binding */ withCtx),
/* harmony export */   "withDefaults": () => (/* binding */ withDefaults),
/* harmony export */   "withDirectives": () => (/* binding */ withDirectives),
/* harmony export */   "withScopeId": () => (/* binding */ withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");




const stack = [];

function pushWarningContext(vnode) {
  stack.push(vnode);
}

function popWarningContext() {
  stack.pop();
}

function warn(msg, ...args) {
  // avoid props formatting or warn handler tracking deps that might be mutated
  // during patch, leading to infinite recursion.
  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();

  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11
    /* APP_WARN_HANDLER */
    , [msg + args.join(''), instance && instance.proxy, trace.map(({
      vnode
    }) => `at <${formatComponentName(instance, vnode.type)}>`).join('\n'), trace]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    /* istanbul ignore if */

    if (trace.length && // avoid spamming console during tests
    !false) {
      warnArgs.push(`\n`, ...formatTrace(trace));
    }

    console.warn(...warnArgs);
  }

  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
}

function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];

  if (!currentVNode) {
    return [];
  } // we can't just use the stack because it will be incomplete during updates
  // that did not start from the root. Re-construct the parent chain using
  // instance parent pointers.


  const normalizedStack = [];

  while (currentVNode) {
    const last = normalizedStack[0];

    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }

    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }

  return normalizedStack;
}
/* istanbul ignore next */


function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
  });
  return logs;
}

function formatTraceEntry({
  vnode,
  recurseCount
}) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
/* istanbul ignore next */


function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach(key => {
    res.push(...formatProp(key, props[key]));
  });

  if (keys.length > 3) {
    res.push(` ...`);
  }

  return res;
}
/* istanbul ignore next */


function formatProp(key, value, raw) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === 'number' || typeof value === 'boolean' || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
    value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);
    return raw ? value : [`${key}=`, value];
  }
}

const ErrorTypeStrings = {
  ["sp"
  /* SERVER_PREFETCH */
  ]: 'serverPrefetch hook',
  ["bc"
  /* BEFORE_CREATE */
  ]: 'beforeCreate hook',
  ["c"
  /* CREATED */
  ]: 'created hook',
  ["bm"
  /* BEFORE_MOUNT */
  ]: 'beforeMount hook',
  ["m"
  /* MOUNTED */
  ]: 'mounted hook',
  ["bu"
  /* BEFORE_UPDATE */
  ]: 'beforeUpdate hook',
  ["u"
  /* UPDATED */
  ]: 'updated',
  ["bum"
  /* BEFORE_UNMOUNT */
  ]: 'beforeUnmount hook',
  ["um"
  /* UNMOUNTED */
  ]: 'unmounted hook',
  ["a"
  /* ACTIVATED */
  ]: 'activated hook',
  ["da"
  /* DEACTIVATED */
  ]: 'deactivated hook',
  ["ec"
  /* ERROR_CAPTURED */
  ]: 'errorCaptured hook',
  ["rtc"
  /* RENDER_TRACKED */
  ]: 'renderTracked hook',
  ["rtg"
  /* RENDER_TRIGGERED */
  ]: 'renderTriggered hook',
  [0
  /* SETUP_FUNCTION */
  ]: 'setup function',
  [1
  /* RENDER_FUNCTION */
  ]: 'render function',
  [2
  /* WATCH_GETTER */
  ]: 'watcher getter',
  [3
  /* WATCH_CALLBACK */
  ]: 'watcher callback',
  [4
  /* WATCH_CLEANUP */
  ]: 'watcher cleanup function',
  [5
  /* NATIVE_EVENT_HANDLER */
  ]: 'native event handler',
  [6
  /* COMPONENT_EVENT_HANDLER */
  ]: 'component event handler',
  [7
  /* VNODE_HOOK */
  ]: 'vnode hook',
  [8
  /* DIRECTIVE_HOOK */
  ]: 'directive hook',
  [9
  /* TRANSITION_HOOK */
  ]: 'transition hook',
  [10
  /* APP_ERROR_HANDLER */
  ]: 'app errorHandler',
  [11
  /* APP_WARN_HANDLER */
  ]: 'app warnHandler',
  [12
  /* FUNCTION_REF */
  ]: 'ref function',
  [13
  /* ASYNC_COMPONENT_LOADER */
  ]: 'async component loader',
  [14
  /* SCHEDULER */
  ]: 'scheduler flush. This is likely a Vue internals bug. ' + 'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'
};

function callWithErrorHandling(fn, instance, type, args) {
  let res;

  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }

  return res;
}

function callWithAsyncErrorHandling(fn, instance, type, args) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);

    if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {
      res.catch(err => {
        handleError(err, instance, type);
      });
    }

    return res;
  }

  const values = [];

  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }

  return values;
}

function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;

  if (instance) {
    let cur = instance.parent; // the exposed instance is the render proxy to keep it consistent with 2.x

    const exposedInstance = instance.proxy; // in production the hook receives only the error code

    const errorInfo =  true ? ErrorTypeStrings[type] : 0;

    while (cur) {
      const errorCapturedHooks = cur.ec;

      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }

      cur = cur.parent;
    } // app-level handling


    const appErrorHandler = instance.appContext.config.errorHandler;

    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10
      /* APP_ERROR_HANDLER */
      , [err, exposedInstance, errorInfo]);
      return;
    }
  }

  logError(err, type, contextVNode, throwInDev);
}

function logError(err, type, contextVNode, throwInDev = true) {
  if (true) {
    const info = ErrorTypeStrings[type];

    if (contextVNode) {
      pushWarningContext(contextVNode);
    }

    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);

    if (contextVNode) {
      popWarningContext();
    } // crash in dev by default so it's more noticeable


    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else {}
}

let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
const RECURSION_LIMIT = 100;

function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
} // #2768
// Use binary-search to find a suitable position in the queue,
// so that the queue maintains the increasing order of job's id,
// which can prevent the job from being skipped and also can avoid repeated patching.


function findInsertionIndex(job) {
  // the start index should be `flushIndex + 1`
  let start = flushIndex + 1;
  let end = queue.length;
  const jobId = getId(job);

  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < jobId ? start = middle + 1 : end = middle;
  }

  return start;
}

function queueJob(job) {
  // the dedupe search uses the startIndex argument of Array.includes()
  // by default the search index includes the current job that is being run
  // so it cannot recursively trigger itself again.
  // if the job is a watch() callback, the search will start with a +1 index to
  // allow it recursively trigger itself - it is the user's responsibility to
  // ensure it doesn't end up in an infinite loop.
  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    const pos = findInsertionIndex(job);

    if (pos > -1) {
      queue.splice(pos, 0, job);
    } else {
      queue.push(job);
    }

    queueFlush();
  }
}

function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}

function invalidateJob(job) {
  const i = queue.indexOf(job);

  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}

function queueCb(cb, activeQueue, pendingQueue, index) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
      pendingQueue.push(cb);
    }
  } else {
    // if cb is an array, it is a component lifecycle hook which can only be
    // triggered by a job, which is already deduped in the main queue, so
    // we can skip duplicate check here to improve perf
    pendingQueue.push(...cb);
  }

  queueFlush();
}

function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}

function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}

function flushPreFlushCbs(seen, parentJob = null) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;

    if (true) {
      seen = seen || new Map();
    }

    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      if ( true && checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
        continue;
      }

      activePreFlushCbs[preFlushIndex]();
    }

    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null; // recursively flush until it drains

    flushPreFlushCbs(seen, parentJob);
  }
}

function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0; // #1947 already has active queue, nested flushPostFlushCbs call

    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }

    activePostFlushCbs = deduped;

    if (true) {
      seen = seen || new Map();
    }

    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));

    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if ( true && checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
        continue;
      }

      activePostFlushCbs[postFlushIndex]();
    }

    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}

const getId = job => job.id == null ? Infinity : job.id;

function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;

  if (true) {
    seen = seen || new Map();
  }

  flushPreFlushCbs(seen); // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child so its render effect will have smaller
  //    priority number)
  // 2. If a component is unmounted during a parent component's update,
  //    its update can be skipped.

  queue.sort((a, b) => getId(a) - getId(b));

  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];

      if (job && job.active !== false) {
        if ( true && checkRecursiveUpdates(seen, job)) {
          continue;
        }

        callWithErrorHandling(job, null, 14
        /* SCHEDULER */
        );
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null; // some postFlushCb queued jobs!
    // keep flushing until it drains.

    if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}

function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    const count = seen.get(fn);

    if (count > RECURSION_LIMIT) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` + `This means you have a reactive effect that is mutating its own ` + `dependencies and thus recursively triggering itself. Possible sources ` + `include component template, render function, updated hook or ` + `watcher source function.`);
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}
/* eslint-disable no-restricted-globals */


let isHmrUpdating = false;
const hmrDirtyComponents = new Set(); // Expose the HMR runtime on the global object
// This makes it entirely tree-shakable without polluting the exports and makes
// it easier to be used in toolings like vue-loader
// Note: for a component to be eligible for HMR it also needs the __hmrId option
// to be set so that its instances can be registered / removed.

if (true) {
  const globalObject = typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {};
  globalObject.__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}

const map = new Map();

function registerHMR(instance) {
  const id = instance.type.__hmrId;
  let record = map.get(id);

  if (!record) {
    createRecord(id, instance.type);
    record = map.get(id);
  }

  record.instances.add(instance);
}

function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances.delete(instance);
}

function createRecord(id, component) {
  if (!component) {
    warn(`HMR API usage is out of date.\n` + `Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant ` + `dependency that handles Vue SFC compilation.`);
    component = {};
  }

  if (map.has(id)) {
    return false;
  }

  map.set(id, {
    component: isClassComponent(component) ? component.__vccOpts : component,
    instances: new Set()
  });
  return true;
}

function rerender(id, newRender) {
  const record = map.get(id);
  if (!record) return;
  if (newRender) record.component.render = newRender; // Array.from creates a snapshot which avoids the set being mutated during
  // updates

  Array.from(record.instances).forEach(instance => {
    if (newRender) {
      instance.render = newRender;
    }

    instance.renderCache = []; // this flag forces child components with slot content to update

    isHmrUpdating = true;
    instance.update();
    isHmrUpdating = false;
  });
}

function reload(id, newComp) {
  const record = map.get(id);
  if (!record) return; // Array.from creates a snapshot which avoids the set being mutated during
  // updates

  const {
    component,
    instances
  } = record;

  if (!hmrDirtyComponents.has(component)) {
    // 1. Update existing comp definition to match new one
    newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(component, newComp);

    for (const key in component) {
      if (key !== '__file' && !(key in newComp)) {
        delete component[key];
      }
    } // 2. Mark component dirty. This forces the renderer to replace the component
    // on patch.


    hmrDirtyComponents.add(component); // 3. Make sure to unmark the component after the reload.

    queuePostFlushCb(() => {
      hmrDirtyComponents.delete(component);
    });
  }

  Array.from(instances).forEach(instance => {
    if (instance.parent) {
      // 4. Force the parent instance to re-render. This will cause all updated
      // components to be unmounted and re-mounted. Queue the update so that we
      // don't end up forcing the same parent to re-render multiple times.
      queueJob(instance.parent.update);
    } else if (instance.appContext.reload) {
      // root instance mounted via createApp() has a reload method
      instance.appContext.reload();
    } else if (typeof window !== 'undefined') {
      // root instance inside tree created via raw render(). Force reload.
      window.location.reload();
    } else {
      console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
    }
  });
}

function tryWrap(fn) {
  return (id, arg) => {
    try {
      return fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` + `Full reload required.`);
    }
  };
}

let devtools;

function setDevtoolsHook(hook) {
  devtools = hook;
}

function devtoolsInitApp(app, version) {
  // TODO queue if devtools is undefined
  if (!devtools) return;
  devtools.emit("app:init"
  /* APP_INIT */
  , app, version, {
    Fragment,
    Text,
    Comment: Comment$1,
    Static
  });
}

function devtoolsUnmountApp(app) {
  if (!devtools) return;
  devtools.emit("app:unmount"
  /* APP_UNMOUNT */
  , app);
}

const devtoolsComponentAdded = /*#__PURE__*/createDevtoolsComponentHook("component:added"
/* COMPONENT_ADDED */
);
const devtoolsComponentUpdated = /*#__PURE__*/createDevtoolsComponentHook("component:updated"
/* COMPONENT_UPDATED */
);
const devtoolsComponentRemoved = /*#__PURE__*/createDevtoolsComponentHook("component:removed"
/* COMPONENT_REMOVED */
);

function createDevtoolsComponentHook(hook) {
  return component => {
    if (!devtools) return;
    devtools.emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
  };
}

const devtoolsPerfStart = /*#__PURE__*/createDevtoolsPerformanceHook("perf:start"
/* PERFORMANCE_START */
);
const devtoolsPerfEnd = /*#__PURE__*/createDevtoolsPerformanceHook("perf:end"
/* PERFORMANCE_END */
);

function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    if (!devtools) return;
    devtools.emit(hook, component.appContext.app, component.uid, component, type, time);
  };
}

function devtoolsComponentEmit(component, event, params) {
  if (!devtools) return;
  devtools.emit("component:emit"
  /* COMPONENT_EMIT */
  , component.appContext.app, component, event, params);
}

const deprecationData = {
  ["GLOBAL_MOUNT"
  /* GLOBAL_MOUNT */
  ]: {
    message: `The global app bootstrapping API has changed: vm.$mount() and the "el" ` + `option have been removed. Use createApp(RootComponent).mount() instead.`,
    link: `https://v3.vuejs.org/guide/migration/global-api.html#mounting-app-instance`
  },
  ["GLOBAL_MOUNT_CONTAINER"
  /* GLOBAL_MOUNT_CONTAINER */
  ]: {
    message: `Vue detected directives on the mount container. ` + `In Vue 3, the container is no longer considered part of the template ` + `and will not be processed/replaced.`,
    link: `https://v3.vuejs.org/guide/migration/mount-changes.html`
  },
  ["GLOBAL_EXTEND"
  /* GLOBAL_EXTEND */
  ]: {
    message: `Vue.extend() has been removed in Vue 3. ` + `Use defineComponent() instead.`,
    link: `https://v3.vuejs.org/api/global-api.html#definecomponent`
  },
  ["GLOBAL_PROTOTYPE"
  /* GLOBAL_PROTOTYPE */
  ]: {
    message: `Vue.prototype is no longer available in Vue 3. ` + `Use app.config.globalProperties instead.`,
    link: `https://v3.vuejs.org/guide/migration/global-api.html#vue-prototype-replaced-by-config-globalproperties`
  },
  ["GLOBAL_SET"
  /* GLOBAL_SET */
  ]: {
    message: `Vue.set() has been removed as it is no longer needed in Vue 3. ` + `Simply use native JavaScript mutations.`
  },
  ["GLOBAL_DELETE"
  /* GLOBAL_DELETE */
  ]: {
    message: `Vue.delete() has been removed as it is no longer needed in Vue 3. ` + `Simply use native JavaScript mutations.`
  },
  ["GLOBAL_OBSERVABLE"
  /* GLOBAL_OBSERVABLE */
  ]: {
    message: `Vue.observable() has been removed. ` + `Use \`import { reactive } from "vue"\` from Composition API instead.`,
    link: `https://v3.vuejs.org/api/basic-reactivity.html`
  },
  ["GLOBAL_PRIVATE_UTIL"
  /* GLOBAL_PRIVATE_UTIL */
  ]: {
    message: `Vue.util has been removed. Please refactor to avoid its usage ` + `since it was an internal API even in Vue 2.`
  },
  ["CONFIG_SILENT"
  /* CONFIG_SILENT */
  ]: {
    message: `config.silent has been removed because it is not good practice to ` + `intentionally suppress warnings. You can use your browser console's ` + `filter features to focus on relevant messages.`
  },
  ["CONFIG_DEVTOOLS"
  /* CONFIG_DEVTOOLS */
  ]: {
    message: `config.devtools has been removed. To enable devtools for ` + `production, configure the __VUE_PROD_DEVTOOLS__ compile-time flag.`,
    link: `https://github.com/vuejs/vue-next/tree/master/packages/vue#bundler-build-feature-flags`
  },
  ["CONFIG_KEY_CODES"
  /* CONFIG_KEY_CODES */
  ]: {
    message: `config.keyCodes has been removed. ` + `In Vue 3, you can directly use the kebab-case key names as v-on modifiers.`,
    link: `https://v3.vuejs.org/guide/migration/keycode-modifiers.html`
  },
  ["CONFIG_PRODUCTION_TIP"
  /* CONFIG_PRODUCTION_TIP */
  ]: {
    message: `config.productionTip has been removed.`,
    link: `https://v3.vuejs.org/guide/migration/global-api.html#config-productiontip-removed`
  },
  ["CONFIG_IGNORED_ELEMENTS"
  /* CONFIG_IGNORED_ELEMENTS */
  ]: {
    message: () => {
      let msg = `config.ignoredElements has been removed.`;

      if (isRuntimeOnly()) {
        msg += ` Pass the "isCustomElement" option to @vue/compiler-dom instead.`;
      } else {
        msg += ` Use config.isCustomElement instead.`;
      }

      return msg;
    },
    link: `https://v3.vuejs.org/guide/migration/global-api.html#config-ignoredelements-is-now-config-iscustomelement`
  },
  ["CONFIG_WHITESPACE"
  /* CONFIG_WHITESPACE */
  ]: {
    // this warning is only relevant in the full build when using runtime
    // compilation, so it's put in the runtime compatConfig list.
    message: `Vue 3 compiler's whitespace option will default to "condense" instead of ` + `"preserve". To suppress this warning, provide an explicit value for ` + `\`config.compilerOptions.whitespace\`.`
  },
  ["CONFIG_OPTION_MERGE_STRATS"
  /* CONFIG_OPTION_MERGE_STRATS */
  ]: {
    message: `config.optionMergeStrategies no longer exposes internal strategies. ` + `Use custom merge functions instead.`
  },
  ["INSTANCE_SET"
  /* INSTANCE_SET */
  ]: {
    message: `vm.$set() has been removed as it is no longer needed in Vue 3. ` + `Simply use native JavaScript mutations.`
  },
  ["INSTANCE_DELETE"
  /* INSTANCE_DELETE */
  ]: {
    message: `vm.$delete() has been removed as it is no longer needed in Vue 3. ` + `Simply use native JavaScript mutations.`
  },
  ["INSTANCE_DESTROY"
  /* INSTANCE_DESTROY */
  ]: {
    message: `vm.$destroy() has been removed. Use app.unmount() instead.`,
    link: `https://v3.vuejs.org/api/application-api.html#unmount`
  },
  ["INSTANCE_EVENT_EMITTER"
  /* INSTANCE_EVENT_EMITTER */
  ]: {
    message: `vm.$on/$once/$off() have been removed. ` + `Use an external event emitter library instead.`,
    link: `https://v3.vuejs.org/guide/migration/events-api.html`
  },
  ["INSTANCE_EVENT_HOOKS"
  /* INSTANCE_EVENT_HOOKS */
  ]: {
    message: event => `"${event}" lifecycle events are no longer supported. From templates, ` + `use the "vnode" prefix instead of "hook:". For example, @${event} ` + `should be changed to @vnode-${event.slice(5)}. ` + `From JavaScript, use Composition API to dynamically register lifecycle ` + `hooks.`,
    link: `https://v3.vuejs.org/guide/migration/vnode-lifecycle-events.html`
  },
  ["INSTANCE_CHILDREN"
  /* INSTANCE_CHILDREN */
  ]: {
    message: `vm.$children has been removed. Consider refactoring your logic ` + `to avoid relying on direct access to child components.`,
    link: `https://v3.vuejs.org/guide/migration/children.html`
  },
  ["INSTANCE_LISTENERS"
  /* INSTANCE_LISTENERS */
  ]: {
    message: `vm.$listeners has been removed. In Vue 3, parent v-on listeners are ` + `included in vm.$attrs and it is no longer necessary to separately use ` + `v-on="$listeners" if you are already using v-bind="$attrs". ` + `(Note: the Vue 3 behavior only applies if this compat config is disabled)`,
    link: `https://v3.vuejs.org/guide/migration/listeners-removed.html`
  },
  ["INSTANCE_SCOPED_SLOTS"
  /* INSTANCE_SCOPED_SLOTS */
  ]: {
    message: `vm.$scopedSlots has been removed. Use vm.$slots instead.`,
    link: `https://v3.vuejs.org/guide/migration/slots-unification.html`
  },
  ["INSTANCE_ATTRS_CLASS_STYLE"
  /* INSTANCE_ATTRS_CLASS_STYLE */
  ]: {
    message: componentName => `Component <${componentName || 'Anonymous'}> has \`inheritAttrs: false\` but is ` + `relying on class/style fallthrough from parent. In Vue 3, class/style ` + `are now included in $attrs and will no longer fallthrough when ` + `inheritAttrs is false. If you are already using v-bind="$attrs" on ` + `component root it should render the same end result. ` + `If you are binding $attrs to a non-root element and expecting ` + `class/style to fallthrough on root, you will need to now manually bind ` + `them on root via :class="$attrs.class".`,
    link: `https://v3.vuejs.org/guide/migration/attrs-includes-class-style.html`
  },
  ["OPTIONS_DATA_FN"
  /* OPTIONS_DATA_FN */
  ]: {
    message: `The "data" option can no longer be a plain object. ` + `Always use a function.`,
    link: `https://v3.vuejs.org/guide/migration/data-option.html`
  },
  ["OPTIONS_DATA_MERGE"
  /* OPTIONS_DATA_MERGE */
  ]: {
    message: key => `Detected conflicting key "${key}" when merging data option values. ` + `In Vue 3, data keys are merged shallowly and will override one another.`,
    link: `https://v3.vuejs.org/guide/migration/data-option.html#mixin-merge-behavior-change`
  },
  ["OPTIONS_BEFORE_DESTROY"
  /* OPTIONS_BEFORE_DESTROY */
  ]: {
    message: `\`beforeDestroy\` has been renamed to \`beforeUnmount\`.`
  },
  ["OPTIONS_DESTROYED"
  /* OPTIONS_DESTROYED */
  ]: {
    message: `\`destroyed\` has been renamed to \`unmounted\`.`
  },
  ["WATCH_ARRAY"
  /* WATCH_ARRAY */
  ]: {
    message: `"watch" option or vm.$watch on an array value will no longer ` + `trigger on array mutation unless the "deep" option is specified. ` + `If current usage is intended, you can disable the compat behavior and ` + `suppress this warning with:` + `\n\n  configureCompat({ ${"WATCH_ARRAY"
    /* WATCH_ARRAY */
    }: false })\n`,
    link: `https://v3.vuejs.org/guide/migration/watch.html`
  },
  ["PROPS_DEFAULT_THIS"
  /* PROPS_DEFAULT_THIS */
  ]: {
    message: key => `props default value function no longer has access to "this". The compat ` + `build only offers access to this.$options.` + `(found in prop "${key}")`,
    link: `https://v3.vuejs.org/guide/migration/props-default-this.html`
  },
  ["CUSTOM_DIR"
  /* CUSTOM_DIR */
  ]: {
    message: (legacyHook, newHook) => `Custom directive hook "${legacyHook}" has been removed. ` + `Use "${newHook}" instead.`,
    link: `https://v3.vuejs.org/guide/migration/custom-directives.html`
  },
  ["V_FOR_REF"
  /* V_FOR_REF */
  ]: {
    message: `Ref usage on v-for no longer creates array ref values in Vue 3. ` + `Consider using function refs or refactor to avoid ref usage altogether.`,
    link: `https://v3.vuejs.org/guide/migration/array-refs.html`
  },
  ["V_ON_KEYCODE_MODIFIER"
  /* V_ON_KEYCODE_MODIFIER */
  ]: {
    message: `Using keyCode as v-on modifier is no longer supported. ` + `Use kebab-case key name modifiers instead.`,
    link: `https://v3.vuejs.org/guide/migration/keycode-modifiers.html`
  },
  ["ATTR_FALSE_VALUE"
  /* ATTR_FALSE_VALUE */
  ]: {
    message: name => `Attribute "${name}" with v-bind value \`false\` will render ` + `${name}="false" instead of removing it in Vue 3. To remove the attribute, ` + `use \`null\` or \`undefined\` instead. If the usage is intended, ` + `you can disable the compat behavior and suppress this warning with:` + `\n\n  configureCompat({ ${"ATTR_FALSE_VALUE"
    /* ATTR_FALSE_VALUE */
    }: false })\n`,
    link: `https://v3.vuejs.org/guide/migration/attribute-coercion.html`
  },
  ["ATTR_ENUMERATED_COERCION"
  /* ATTR_ENUMERATED_COERCION */
  ]: {
    message: (name, value, coerced) => `Enumerated attribute "${name}" with v-bind value \`${value}\` will ` + `${value === null ? `be removed` : `render the value as-is`} instead of coercing the value to "${coerced}" in Vue 3. ` + `Always use explicit "true" or "false" values for enumerated attributes. ` + `If the usage is intended, ` + `you can disable the compat behavior and suppress this warning with:` + `\n\n  configureCompat({ ${"ATTR_ENUMERATED_COERCION"
    /* ATTR_ENUMERATED_COERCION */
    }: false })\n`,
    link: `https://v3.vuejs.org/guide/migration/attribute-coercion.html`
  },
  ["TRANSITION_CLASSES"
  /* TRANSITION_CLASSES */
  ]: {
    message: `` // this feature cannot be runtime-detected

  },
  ["TRANSITION_GROUP_ROOT"
  /* TRANSITION_GROUP_ROOT */
  ]: {
    message: `<TransitionGroup> no longer renders a root <span> element by ` + `default if no "tag" prop is specified. If you do not rely on the span ` + `for styling, you can disable the compat behavior and suppress this ` + `warning with:` + `\n\n  configureCompat({ ${"TRANSITION_GROUP_ROOT"
    /* TRANSITION_GROUP_ROOT */
    }: false })\n`,
    link: `https://v3.vuejs.org/guide/migration/transition-group.html`
  },
  ["COMPONENT_ASYNC"
  /* COMPONENT_ASYNC */
  ]: {
    message: comp => {
      const name = getComponentName(comp);
      return `Async component${name ? ` <${name}>` : `s`} should be explicitly created via \`defineAsyncComponent()\` ` + `in Vue 3. Plain functions will be treated as functional components in ` + `non-compat build. If you have already migrated all async component ` + `usage and intend to use plain functions for functional components, ` + `you can disable the compat behavior and suppress this ` + `warning with:` + `\n\n  configureCompat({ ${"COMPONENT_ASYNC"
      /* COMPONENT_ASYNC */
      }: false })\n`;
    },
    link: `https://v3.vuejs.org/guide/migration/async-components.html`
  },
  ["COMPONENT_FUNCTIONAL"
  /* COMPONENT_FUNCTIONAL */
  ]: {
    message: comp => {
      const name = getComponentName(comp);
      return `Functional component${name ? ` <${name}>` : `s`} should be defined as a plain function in Vue 3. The "functional" ` + `option has been removed. NOTE: Before migrating to use plain ` + `functions for functional components, first make sure that all async ` + `components usage have been migrated and its compat behavior has ` + `been disabled.`;
    },
    link: `https://v3.vuejs.org/guide/migration/functional-components.html`
  },
  ["COMPONENT_V_MODEL"
  /* COMPONENT_V_MODEL */
  ]: {
    message: comp => {
      const configMsg = `opt-in to ` + `Vue 3 behavior on a per-component basis with \`compatConfig: { ${"COMPONENT_V_MODEL"
      /* COMPONENT_V_MODEL */
      }: false }\`.`;

      if (comp.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(comp.props) ? comp.props.includes('modelValue') : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(comp.props, 'modelValue')) {
        return `Component delcares "modelValue" prop, which is Vue 3 usage, but ` + `is running under Vue 2 compat v-model behavior. You can ${configMsg}`;
      }

      return `v-model usage on component has changed in Vue 3. Component that expects ` + `to work with v-model should now use the "modelValue" prop and emit the ` + `"update:modelValue" event. You can update the usage and then ${configMsg}`;
    },
    link: `https://v3.vuejs.org/guide/migration/v-model.html`
  },
  ["RENDER_FUNCTION"
  /* RENDER_FUNCTION */
  ]: {
    message: `Vue 3's render function API has changed. ` + `You can opt-in to the new API with:` + `\n\n  configureCompat({ ${"RENDER_FUNCTION"
    /* RENDER_FUNCTION */
    }: false })\n` + `\n  (This can also be done per-component via the "compatConfig" option.)`,
    link: `https://v3.vuejs.org/guide/migration/render-function-api.html`
  },
  ["FILTERS"
  /* FILTERS */
  ]: {
    message: `filters have been removed in Vue 3. ` + `The "|" symbol will be treated as native JavaScript bitwise OR operator. ` + `Use method calls or computed properties instead.`,
    link: `https://v3.vuejs.org/guide/migration/filters.html`
  },
  ["PRIVATE_APIS"
  /* PRIVATE_APIS */
  ]: {
    message: name => `"${name}" is a Vue 2 private API that no longer exists in Vue 3. ` + `If you are seeing this warning only due to a dependency, you can ` + `suppress this warning via { PRIVATE_APIS: 'supress-warning' }.`
  }
};
const instanceWarned = Object.create(null);
const warnCount = Object.create(null);

function warnDeprecation(key, instance, ...args) {
  if (false) {}

  instance = instance || getCurrentInstance(); // check user config

  const config = getCompatConfigForKey(key, instance);

  if (config === 'suppress-warning') {
    return;
  }

  const dupKey = key + args.join('');
  let compId = instance && formatComponentName(instance, instance.type);

  if (compId === 'Anonymous' && instance) {
    compId = instance.uid;
  } // skip if the same warning is emitted for the same component type


  const componentDupKey = dupKey + compId;

  if (componentDupKey in instanceWarned) {
    return;
  }

  instanceWarned[componentDupKey] = true; // same warning, but different component. skip the long message and just
  // log the key and count.

  if (dupKey in warnCount) {
    warn(`(deprecation ${key}) (${++warnCount[dupKey] + 1})`);
    return;
  }

  warnCount[dupKey] = 0;
  const {
    message,
    link
  } = deprecationData[key];
  warn(`(deprecation ${key}) ${typeof message === 'function' ? message(...args) : message}${link ? `\n  Details: ${link}` : ``}`);

  if (!isCompatEnabled(key, instance, true)) {
    console.error(`^ The above deprecation's compat behavior is disabled and will likely ` + `lead to runtime errors.`);
  }
}

const globalCompatConfig = {
  MODE: 2
};

function getCompatConfigForKey(key, instance) {
  const instanceConfig = instance && instance.type.compatConfig;

  if (instanceConfig && key in instanceConfig) {
    return instanceConfig[key];
  }

  return globalCompatConfig[key];
}

function isCompatEnabled(key, instance, enableForBuiltIn = false) {
  // skip compat for built-in components
  if (!enableForBuiltIn && instance && instance.type.__isBuiltIn) {
    return false;
  }

  const rawMode = getCompatConfigForKey('MODE', instance) || 2;
  const val = getCompatConfigForKey(key, instance);
  const mode = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(rawMode) ? rawMode(instance && instance.type) : rawMode;

  if (mode === 2) {
    return val !== false;
  } else {
    return val === true || val === 'suppress-warning';
  }
}

function emit(instance, event, ...rawArgs) {
  const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;

  if (true) {
    const {
      emitsOptions,
      propsOptions: [propsOptions]
    } = instance;

    if (emitsOptions) {
      if (!(event in emitsOptions) && !false) {
        if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event) in propsOptions)) {
          warn(`Component emitted event "${event}" but it is neither declared in ` + `the emits option nor as an "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)}" prop.`);
        }
      } else {
        const validator = emitsOptions[event];

        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {
          const isValid = validator(...rawArgs);

          if (!isValid) {
            warn(`Invalid event arguments: event validation failed for event "${event}".`);
          }
        }
      }
    }
  }

  let args = rawArgs;
  const isModelListener = event.startsWith('update:'); // for v-model update:xxx events, apply modifiers on args

  const modelArg = isModelListener && event.slice(7);

  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;
    const {
      number,
      trim
    } = props[modifiersKey] || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;

    if (trim) {
      args = rawArgs.map(a => a.trim());
    } else if (number) {
      args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber);
    }
  }

  if (true) {
    devtoolsComponentEmit(instance, event, args);
  }

  if (true) {
    const lowerCaseEvent = event.toLowerCase();

    if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {
      warn(`Event "${lowerCaseEvent}" is emitted in component ` + `${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". ` + `Note that HTML attributes are case-insensitive and you cannot use ` + `v-on to listen to camelCase events when using in-DOM templates. ` + `You should probably use "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)}" instead of "${event}".`);
    }
  }

  let handlerName;
  let handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)] || // also try camelCase event handler (#2249)
  props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event))]; // for v-model update:xxx events, also trigger kebab-case equivalent
  // for props passed via kebab-case

  if (!handler && isModelListener) {
    handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event))];
  }

  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6
    /* COMPONENT_EVENT_HANDLER */
    , args);
  }

  const onceHandler = props[handlerName + `Once`];

  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }

    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6
    /* COMPONENT_EVENT_HANDLER */
    , args);
  }
}

function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);

  if (cached !== undefined) {
    return cached;
  }

  const raw = comp.emits;
  let normalized = {}; // apply mixin/extends props

  let hasExtends = false;

  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
    const extendEmits = raw => {
      const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);

      if (normalizedFromExtend) {
        hasExtends = true;
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizedFromExtend);
      }
    };

    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }

    if (comp.extends) {
      extendEmits(comp.extends);
    }

    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }

  if (!raw && !hasExtends) {
    cache.set(comp, null);
    return null;
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    raw.forEach(key => normalized[key] = null);
  } else {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);
  }

  cache.set(comp, normalized);
  return normalized;
} // Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.


function isEmitListener(options, key) {
  if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
    return false;
  }

  key = key.slice(2).replace(/Once$/, '');
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key);
}
/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 */


let currentRenderingInstance = null;
let currentScopeId = null;
/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 */

function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
/**
 * Set scope id when creating hoisted vnodes.
 * @private compiler helper
 */


function pushScopeId(id) {
  currentScopeId = id;
}
/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * @private
 */


function popScopeId() {
  currentScopeId = null;
}
/**
 * Only for backwards compat
 * @private
 */


const withScopeId = _id => withCtx;
/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 */


function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only
) {
  if (!ctx) return fn; // already normalized

  if (fn._n) {
    return fn;
  }

  const renderFnWithContext = (...args) => {
    // If a user calls a compiled slot inside a template expression (#1745), it
    // can mess up block tracking, so by default we disable block tracking and
    // force bail out when invoking a compiled slot (indicated by the ._d flag).
    // This isn't necessary if rendering a compiled `<slot>`, so we flip the
    // ._d flag off when invoking the wrapped fn inside `renderSlot`.
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }

    const prevInstance = setCurrentRenderingInstance(ctx);
    const res = fn(...args);
    setCurrentRenderingInstance(prevInstance);

    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }

    if (true) {
      devtoolsComponentUpdated(ctx);
    }

    return res;
  }; // mark normalized to avoid duplicated wrapping


  renderFnWithContext._n = true; // mark this as compiled by default
  // this is used in vnode.ts -> normalizeChildren() to set the slot
  // rendering flag.

  renderFnWithContext._c = true; // disable block tracking by default

  renderFnWithContext._d = true;
  return renderFnWithContext;
}
/**
 * dev only flag to track whether $attrs was used during render.
 * If $attrs was used during render then the warning for failed attrs
 * fallthrough can be suppressed.
 */


let accessedAttrs = false;

function markAttrsAccessed() {
  accessedAttrs = true;
}

function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit,
    render,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  const prev = setCurrentRenderingInstance(instance);

  if (true) {
    accessedAttrs = false;
  }

  try {
    let fallthroughAttrs;

    if (vnode.shapeFlag & 4
    /* STATEFUL_COMPONENT */
    ) {
        // withProxy is a proxy with a different `has` trap only for
        // runtime-compiled render functions using `with` block.
        const proxyToUse = withProxy || proxy;
        result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
        fallthroughAttrs = attrs;
      } else {
      // functional
      const render = Component; // in dev, mark attrs accessed if optional props (attrs === props)

      if ( true && attrs === props) {
        markAttrsAccessed();
      }

      result = normalizeVNode(render.length > 1 ? render(props,  true ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },

        slots,
        emit
      } : 0) : render(props, null
      /* we know it doesn't need it */
      ));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    } // attr merging
    // in dev mode, comments are preserved, and it's possible for a template
    // to have comments along side the root element which makes it a fragment


    let root = result;
    let setRoot = undefined;

    if ( true && result.patchFlag > 0 && result.patchFlag & 2048
    /* DEV_ROOT_FRAGMENT */
    ) {
        ;
        [root, setRoot] = getChildRoot(result);
      }

    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys = Object.keys(fallthroughAttrs);
      const {
        shapeFlag
      } = root;

      if (keys.length) {
        if (shapeFlag & 1
        /* ELEMENT */
        || shapeFlag & 6
        /* COMPONENT */
        ) {
            if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {
              // If a v-model listener (onUpdate:xxx) has a corresponding declared
              // prop, it indicates this component expects to handle v-model and
              // it should not fallthrough.
              // related: #1543, #1643, #1989
              fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
            }

            root = cloneVNode(root, fallthroughAttrs);
          } else if ( true && !accessedAttrs && root.type !== Comment$1) {
          const allAttrs = Object.keys(attrs);
          const eventAttrs = [];
          const extraAttrs = [];

          for (let i = 0, l = allAttrs.length; i < l; i++) {
            const key = allAttrs[i];

            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
              // ignore v-model handlers when they fail to fallthrough
              if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
                // remove `on`, lowercase first letter to reflect event casing
                // accurately
                eventAttrs.push(key[2].toLowerCase() + key.slice(3));
              }
            } else {
              extraAttrs.push(key);
            }
          }

          if (extraAttrs.length) {
            warn(`Extraneous non-props attributes (` + `${extraAttrs.join(', ')}) ` + `were passed to component but could not be automatically inherited ` + `because component renders fragment or text root nodes.`);
          }

          if (eventAttrs.length) {
            warn(`Extraneous non-emits event listeners (` + `${eventAttrs.join(', ')}) ` + `were passed to component but could not be automatically inherited ` + `because component renders fragment or text root nodes. ` + `If the listener is intended to be a component custom event listener only, ` + `declare it using the "emits" option.`);
          }
        }
      }
    }

    if (false) {} // inherit directives

    if (vnode.dirs) {
      if ( true && !isElementRoot(root)) {
        warn(`Runtime directive used on component with non-element root node. ` + `The directives will not function as intended.`);
      }

      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    } // inherit transition data


    if (vnode.transition) {
      if ( true && !isElementRoot(root)) {
        warn(`Component inside <Transition> renders non-element root node ` + `that cannot be animated.`);
      }

      root.transition = vnode.transition;
    }

    if ( true && setRoot) {
      setRoot(root);
    } else {
      result = root;
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1
    /* RENDER_FUNCTION */
    );
    result = createVNode(Comment$1);
  }

  setCurrentRenderingInstance(prev);
  return result;
}
/**
 * dev only
 * In dev mode, template root level comments are rendered, which turns the
 * template into a fragment root, but we need to locate the single element
 * root for attrs and scope id processing.
 */


const getChildRoot = vnode => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren);

  if (!childRoot) {
    return [vnode, undefined];
  }

  const index = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;

  const setRoot = updatedRoot => {
    rawChildren[index] = updatedRoot;

    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  };

  return [normalizeVNode(childRoot), setRoot];
};

function filterSingleRoot(children) {
  let singleRoot;

  for (let i = 0; i < children.length; i++) {
    const child = children[i];

    if (isVNode(child)) {
      // ignore user comment
      if (child.type !== Comment$1 || child.children === 'v-if') {
        if (singleRoot) {
          // has more than 1 non-comment child, return now
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }

  return singleRoot;
}

const getFunctionalFallthrough = attrs => {
  let res;

  for (const key in attrs) {
    if (key === 'class' || key === 'style' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }

  return res;
};

const filterModelListeners = (attrs, props) => {
  const res = {};

  for (const key in attrs) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }

  return res;
};

const isElementRoot = vnode => {
  return vnode.shapeFlag & 6
  /* COMPONENT */
  || vnode.shapeFlag & 1
  /* ELEMENT */
  || vnode.type === Comment$1 // potential v-if branch switch
  ;
};

function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const {
    props: prevProps,
    children: prevChildren,
    component
  } = prevVNode;
  const {
    props: nextProps,
    children: nextChildren,
    patchFlag
  } = nextVNode;
  const emits = component.emitsOptions; // Parent component's render function was hot-updated. Since this may have
  // caused the child component's slots content to have changed, we need to
  // force the child to update as well.

  if ( true && (prevChildren || nextChildren) && isHmrUpdating) {
    return true;
  } // force child update for runtime directive or transition on component vnode.


  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }

  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024
    /* DYNAMIC_SLOTS */
    ) {
        // slot content that references values that might have changed,
        // e.g. in a v-for
        return true;
      }

    if (patchFlag & 16
    /* FULL_PROPS */
    ) {
        if (!prevProps) {
          return !!nextProps;
        } // presence of this flag indicates props are always non-null


        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8
    /* PROPS */
    ) {
        const dynamicProps = nextVNode.dynamicProps;

        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i];

          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
  } else {
    // this path is only taken by manually written render functions
    // so presence of any children leads to a forced update
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }

    if (prevProps === nextProps) {
      return false;
    }

    if (!prevProps) {
      return !!nextProps;
    }

    if (!nextProps) {
      return true;
    }

    return hasPropsChanged(prevProps, nextProps, emits);
  }

  return false;
}

function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);

  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }

  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];

    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }

  return false;
}

function updateHOCHostEl({
  vnode,
  parent
}, el // HostNode
) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}

const isSuspense = type => type.__isSuspense; // Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.


const SuspenseImpl = {
  name: 'Suspense',
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,

  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, // platform-specific impl passed from renderer
  rendererInternals) {
    if (n1 == null) {
      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
    } else {
      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    }
  },

  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
}; // Force-casted public typing for h and TSX props inference

const Suspense = SuspenseImpl;

function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(eventListener)) {
    eventListener();
  }
}

function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: {
      createElement
    }
  } = rendererInternals;
  const hiddenContainer = createElement('div');
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals); // start mounting the content subtree in an off-dom container

  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds); // now check if we have encountered any async deps

  if (suspense.deps > 0) {
    // has async
    // invoke @fallback event
    triggerEvent(vnode, 'onPending');
    triggerEvent(vnode, 'onFallback'); // mount the fallback tree

    patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
    isSVG, slotScopeIds);
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    // Suspense has no async deps. Just resolve.
    suspense.resolve();
  }
}

function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, {
  p: patch,
  um: unmount,
  o: {
    createElement
  }
}) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const {
    activeBranch,
    pendingBranch,
    isInFallback,
    isHydrating
  } = suspense;

  if (pendingBranch) {
    suspense.pendingBranch = newBranch;

    if (isSameVNodeType(newBranch, pendingBranch)) {
      // same root type but content may have changed.
      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newFallback);
      }
    } else {
      // toggled before pending tree is resolved
      suspense.pendingId++;

      if (isHydrating) {
        // if toggled before hydration is finished, the current DOM tree is
        // no longer valid. set it as the active branch so it will be unmounted
        // when resolved
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      } // increment pending ID. this is used to invalidate async callbacks
      // reset suspense state


      suspense.deps = 0; // discard effects from pending branch

      suspense.effects.length = 0; // discard previous container

      suspense.hiddenContainer = createElement('div');

      if (isInFallback) {
        // already in fallback state
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
          isSVG, slotScopeIds, optimized);
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        // toggled "back" to current active branch
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized); // force resolve

        suspense.resolve(true);
      } else {
        // switched to a 3rd branch
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      // root did not change, just normal patch
      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      setActiveBranch(suspense, newBranch);
    } else {
      // root node toggled
      // invoke @pending event
      triggerEvent(n2, 'onPending'); // mount pending branch in off-dom container

      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

      if (suspense.deps <= 0) {
        // incoming branch has no async deps, resolve now.
        suspense.resolve();
      } else {
        const {
          timeout,
          pendingId
        } = suspense;

        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}

let hasWarned = false;

function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  /* istanbul ignore if */
  if ( true && !hasWarned) {
    hasWarned = true; // @ts-ignore `console.info` cannot be null error

    console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);
  }

  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: {
      parentNode,
      remove
    }
  } = rendererInternals;
  const timeout = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props && vnode.props.timeout);
  const suspense = {
    vnode,
    parent,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === 'number' ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],

    resolve(resume = false) {
      if (true) {
        if (!resume && !suspense.pendingBranch) {
          throw new Error(`suspense.resolve() is called without a pending branch.`);
        }

        if (suspense.isUnmounted) {
          throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
        }
      }

      const {
        vnode,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent,
        container
      } = suspense;

      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === 'out-in';

        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container, anchor, 0
              /* ENTER */
              );
            }
          };
        } // this is initial anchor on mount


        let {
          anchor
        } = suspense; // unmount current active tree

        if (activeBranch) {
          // if the fallback tree was mounted, it may have been moved
          // as part of a parent suspense. get the latest anchor for insertion
          anchor = next(activeBranch);
          unmount(activeBranch, parentComponent, suspense, true);
        }

        if (!delayEnter) {
          // move content from off-dom container to actual container
          move(pendingBranch, container, anchor, 0
          /* ENTER */
          );
        }
      }

      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false; // flush buffered effects
      // check if there is a pending parent suspense

      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;

      while (parent) {
        if (parent.pendingBranch) {
          // found a pending parent suspense, merge buffered post jobs
          // into that parent
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }

        parent = parent.parent;
      } // no pending parent suspense, flush all jobs


      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }

      suspense.effects = []; // invoke @resolve event

      triggerEvent(vnode, 'onResolve');
    },

    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }

      const {
        vnode,
        activeBranch,
        parentComponent,
        container,
        isSVG
      } = suspense; // invoke @fallback event

      triggerEvent(vnode, 'onFallback');
      const anchor = next(activeBranch);

      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        } // mount the fallback tree


        patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, fallbackVNode);
      };

      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';

      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }

      suspense.isInFallback = true; // unmount current active branch

      unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now
      true // shouldRemove
      );

      if (!delayEnter) {
        mountFallback();
      }
    },

    move(container, anchor, type) {
      suspense.activeBranch && move(suspense.activeBranch, container, anchor, type);
      suspense.container = container;
    },

    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },

    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;

      if (isInPendingSuspense) {
        suspense.deps++;
      }

      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch(err => {
        handleError(err, instance, 0
        /* SETUP_FUNCTION */
        );
      }).then(asyncSetupResult => {
        // retry when the setup() promise resolves.
        // component may have been unmounted before resolve.
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        } // retry from this component


        instance.asyncResolved = true;
        const {
          vnode
        } = instance;

        if (true) {
          pushWarningContext(vnode);
        }

        handleSetupResult(instance, asyncSetupResult, false);

        if (hydratedEl) {
          // vnode may have been replaced if an update happened before the
          // async dep is resolved.
          vnode.el = hydratedEl;
        }

        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(instance, vnode, // component may have been moved before resolve.
        // if this is not a hydration, instance.subTree will be the comment
        // placeholder.
        parentNode(hydratedEl || instance.subTree.el), // anchor will not be used if this is hydration, so only need to
        // consider the comment placeholder case.
        hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);

        if (placeholder) {
          remove(placeholder);
        }

        updateHOCHostEl(instance, vnode.el);

        if (true) {
          popWarningContext();
        } // only decrease deps count if suspense is not already resolved


        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },

    unmount(parentSuspense, doRemove) {
      suspense.isUnmounted = true;

      if (suspense.activeBranch) {
        unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
      }

      if (suspense.pendingBranch) {
        unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
      }
    }

  };
  return suspense;
}

function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  /* eslint-disable no-restricted-globals */
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true
  /* hydrating */
  ); // there are two possible scenarios for server-rendered suspense:
  // - success: ssr content should be fully resolved
  // - failure: ssr content should be the fallback branch.
  // however, on the client we don't really know if it has failed or not
  // attempt to hydrate the DOM assuming it has succeeded, but we still
  // need to construct a suspense boundary first

  const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);

  if (suspense.deps === 0) {
    suspense.resolve();
  }

  return result;
  /* eslint-enable no-restricted-globals */
}

function normalizeSuspenseChildren(vnode) {
  const {
    shapeFlag,
    children
  } = vnode;
  const isSlotChildren = shapeFlag & 32
  /* SLOTS_CHILDREN */
  ;
  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}

function normalizeSuspenseSlot(s) {
  let block;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
    const isCompiledSlot = s._c;

    if (isCompiledSlot) {
      // disableTracking: false
      // allow block tracking for compiled slots
      // (see ./componentRenderContext.ts)
      s._d = false;
      openBlock();
    }

    s = s();

    if (isCompiledSlot) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {
    const singleChild = filterSingleRoot(s);

    if ( true && !singleChild) {
      warn(`<Suspense> slots expect a single root node.`);
    }

    s = singleChild;
  }

  s = normalizeVNode(s);

  if (block) {
    s.dynamicChildren = block.filter(c => c !== s);
  }

  return s;
}

function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}

function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const {
    vnode,
    parentComponent
  } = suspense;
  const el = vnode.el = branch.el; // in case suspense is the root node of a component,
  // recursively update the HOC el

  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}

function provide(key, value) {
  if (!currentInstance) {
    if (true) {
      warn(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides; // by default an instance inherits its parent's provides object
    // but when it needs to provide values of its own, it creates its
    // own provides object using parent provides object as prototype.
    // this way in `inject` we can simply look up injections from direct
    // parent and let the prototype chain do the work.

    const parentProvides = currentInstance.parent && currentInstance.parent.provides;

    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    } // TS doesn't allow symbol as index type


    provides[key] = value;
  }
}

function inject(key, defaultValue, treatDefaultAsFactory = false) {
  // fallback to `currentRenderingInstance` so that this can be called in
  // a functional component
  const instance = currentInstance || currentRenderingInstance;

  if (instance) {
    // #2400
    // to support `app.use` plugins,
    // fallback to appContext's `provides` if the intance is at root
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;

    if (provides && key in provides) {
      // TS doesn't allow symbol as index type
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else if (true) {
      warn(`injection "${String(key)}" not found.`);
    }
  } else if (true) {
    warn(`inject() can only be used inside setup() or functional components.`);
  }
} // Simple effect.


function watchEffect(effect, options) {
  return doWatch(effect, null, options);
} // initial value for watchers to trigger on undefined initial values


const INITIAL_WATCHER_VALUE = {}; // implementation

function watch(source, cb, options) {
  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {
    warn(`\`watch(fn, options?)\` signature has been moved to a separate API. ` + `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` + `supports \`watch(source, cb, options?) signature.`);
  }

  return doWatch(source, cb, options);
}

function doWatch(source, cb, {
  immediate,
  deep,
  flush,
  onTrack,
  onTrigger
} = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ, instance = currentInstance) {
  if ( true && !cb) {
    if (immediate !== undefined) {
      warn(`watch() "immediate" option is only respected when using the ` + `watch(source, callback, options?) signature.`);
    }

    if (deep !== undefined) {
      warn(`watch() "deep" option is only respected when using the ` + `watch(source, callback, options?) signature.`);
    }
  }

  const warnInvalidSource = s => {
    warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` + `a reactive object, or an array of these types.`);
  };

  let getter;
  let forceTrigger = false;
  let isMultiSource = false;

  if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(source)) {
    getter = () => source.value;

    forceTrigger = !!source._shallow;
  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source)) {
    getter = () => source;

    deep = true;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source)) {
    isMultiSource = true;
    forceTrigger = source.some(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive);

    getter = () => source.map(s => {
      if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(s)) {
        return s.value;
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s)) {
        return traverse(s);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
        return callWithErrorHandling(s, instance, 2
        /* WATCH_GETTER */
        );
      } else {
         true && warnInvalidSource(s);
      }
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
    if (cb) {
      // getter with cb
      getter = () => callWithErrorHandling(source, instance, 2
      /* WATCH_GETTER */
      );
    } else {
      // no cb -> simple effect
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }

        if (cleanup) {
          cleanup();
        }

        return callWithAsyncErrorHandling(source, instance, 3
        /* WATCH_CALLBACK */
        , [onInvalidate]);
      };
    }
  } else {
    getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
     true && warnInvalidSource(source);
  }

  if (cb && deep) {
    const baseGetter = getter;

    getter = () => traverse(baseGetter());
  }

  let cleanup;

  let onInvalidate = fn => {
    cleanup = runner.options.onStop = () => {
      callWithErrorHandling(fn, instance, 4
      /* WATCH_CLEANUP */
      );
    };
  };

  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;

  const job = () => {
    if (!runner.active) {
      return;
    }

    if (cb) {
      // watch(source, cb)
      const newValue = runner();

      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(v, oldValue[i])) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(newValue, oldValue)) || false) {
        // cleanup before running cb again
        if (cleanup) {
          cleanup();
        }

        callWithAsyncErrorHandling(cb, instance, 3
        /* WATCH_CALLBACK */
        , [newValue, // pass undefined as the old value when it's changed for the first time
        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue, onInvalidate]);
        oldValue = newValue;
      }
    } else {
      // watchEffect
      runner();
    }
  }; // important: mark the job as a watcher callback so that scheduler knows
  // it is allowed to self-trigger (#1727)


  job.allowRecurse = !!cb;
  let scheduler;

  if (flush === 'sync') {
    scheduler = job; // the scheduler function gets called directly
  } else if (flush === 'post') {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    // default: 'pre'
    scheduler = () => {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        // with 'pre' option, the first call must happen before
        // the component is mounted so it is called synchronously.
        job();
      }
    };
  }

  const runner = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect)(getter, {
    lazy: true,
    onTrack,
    onTrigger,
    scheduler
  });
  recordInstanceBoundEffect(runner, instance); // initial run

  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = runner();
    }
  } else if (flush === 'post') {
    queuePostRenderEffect(runner, instance && instance.suspense);
  } else {
    runner();
  }

  return () => {
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop)(runner);

    if (instance) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(instance.effects, runner);
    }
  };
} // this.$watch


function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source) ? source.includes('.') ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }

  return doWatch(getter, cb.bind(publicThis), options, this);
}

function createPathGetter(ctx, path) {
  const segments = path.split('.');
  return () => {
    let cur = ctx;

    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }

    return cur;
  };
}

function traverse(value, seen = new Set()) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) || seen.has(value) || value["__v_skip"
  /* SKIP */
  ]) {
    return value;
  }

  seen.add(value);

  if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
    traverse(value.value, seen);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(value)) {
    value.forEach(v => {
      traverse(v, seen);
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }

  return value;
}

function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}

const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },

  setup(props, {
    slots
  }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);

      if (!children || !children.length) {
        return;
      } // warn multiple elements


      if ( true && children.length > 1) {
        warn('<transition> can only be used on a single element or component. Use ' + '<transition-group> for lists.');
      } // there's no need to track reactivity for these props so use the raw
      // props for a bit better perf


      const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
      const {
        mode
      } = rawProps; // check mode

      if ( true && mode && !['in-out', 'out-in', 'default'].includes(mode)) {
        warn(`invalid <transition> mode: ${mode}`);
      } // at this point children has a guaranteed length of 1.


      const child = children[0];

      if (state.isLeaving) {
        return emptyPlaceholder(child);
      } // in the case of <transition><keep-alive/></transition>, we need to
      // compare the type of the kept-alive children.


      const innerChild = getKeepAliveChild(child);

      if (!innerChild) {
        return emptyPlaceholder(child);
      }

      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const {
        getTransitionKey
      } = innerChild.type;

      if (getTransitionKey) {
        const key = getTransitionKey();

        if (prevTransitionKey === undefined) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      } // handle mode


      if (oldInnerChild && oldInnerChild.type !== Comment$1 && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance); // update old tree's hooks in case of dynamic transition

        setTransitionHooks(oldInnerChild, leavingHooks); // switching between different views

        if (mode === 'out-in') {
          state.isLeaving = true; // return placeholder node and queue update when leave finishes

          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            instance.update();
          };

          return emptyPlaceholder(child);
        } else if (mode === 'in-out' && innerChild.type !== Comment$1) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild; // early removal callback

            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = undefined;
              delete enterHooks.delayedLeave;
            };

            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }

      return child;
    };
  }

}; // export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files

const BaseTransition = BaseTransitionImpl;

function getLeavingNodesForType(state, vnode) {
  const {
    leavingVNodes
  } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);

  if (!leavingVNodesCache) {
    leavingVNodesCache = Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }

  return leavingVNodesCache;
} // The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.


function resolveTransitionHooks(vnode, props, state, instance) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);

  const callHook = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9
    /* TRANSITION_HOOK */
    , args);
  };

  const hooks = {
    mode,
    persisted,

    beforeEnter(el) {
      let hook = onBeforeEnter;

      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      } // for same element (v-show)


      if (el._leaveCb) {
        el._leaveCb(true
        /* cancelled */
        );
      } // for toggled element with same key (v-if)


      const leavingVNode = leavingVNodesCache[key];

      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        // force early removal (not cancelled)
        leavingVNode.el._leaveCb();
      }

      callHook(hook, [el]);
    },

    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;

      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }

      let called = false;

      const done = el._enterCb = cancelled => {
        if (called) return;
        called = true;

        if (cancelled) {
          callHook(cancelHook, [el]);
        } else {
          callHook(afterHook, [el]);
        }

        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }

        el._enterCb = undefined;
      };

      if (hook) {
        hook(el, done);

        if (hook.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },

    leave(el, remove) {
      const key = String(vnode.key);

      if (el._enterCb) {
        el._enterCb(true
        /* cancelled */
        );
      }

      if (state.isUnmounting) {
        return remove();
      }

      callHook(onBeforeLeave, [el]);
      let called = false;

      const done = el._leaveCb = cancelled => {
        if (called) return;
        called = true;
        remove();

        if (cancelled) {
          callHook(onLeaveCancelled, [el]);
        } else {
          callHook(onAfterLeave, [el]);
        }

        el._leaveCb = undefined;

        if (leavingVNodesCache[key] === vnode) {
          delete leavingVNodesCache[key];
        }
      };

      leavingVNodesCache[key] = vnode;

      if (onLeave) {
        onLeave(el, done);

        if (onLeave.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },

    clone(vnode) {
      return resolveTransitionHooks(vnode, props, state, instance);
    }

  };
  return hooks;
} // the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.


function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}

function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : undefined : vnode;
}

function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6
  /* COMPONENT */
  && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128
  /* SUSPENSE */
  ) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
    vnode.transition = hooks;
  }
}

function getTransitionRawChildren(children, keepComment = false) {
  let ret = [];
  let keyedFragmentCount = 0;

  for (let i = 0; i < children.length; i++) {
    const child = children[i]; // handle fragment children case, e.g. v-for

    if (child.type === Fragment) {
      if (child.patchFlag & 128
      /* KEYED_FRAGMENT */
      ) keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
    } // comment placeholders should be skipped, e.g. v-if
    else if (keepComment || child.type !== Comment$1) {
        ret.push(child);
      }
  } // #1126 if a transition children list contains multiple sub fragments, these
  // fragments will be merged into a flat children array. Since each v-for
  // fragment may contain different static bindings inside, we need to de-op
  // these children to force full diffs to ensure correct behavior.


  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2
      /* BAIL */
      ;
    }
  }

  return ret;
} // implementation, close to no-op


function defineComponent(options) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ? {
    setup: options,
    name: options.name
  } : options;
}

const isAsyncWrapper = i => !!i.type.__asyncLoader;

function defineAsyncComponent(source) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
    source = {
      loader: source
    };
  }

  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;

  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };

  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch(err => {
      err = err instanceof Error ? err : new Error(String(err));

      if (userOnError) {
        return new Promise((resolve, reject) => {
          const userRetry = () => resolve(retry());

          const userFail = () => reject(err);

          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then(comp => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }

      if ( true && !comp) {
        warn(`Async component loader resolved to undefined. ` + `If you are using retry(), make sure to return its return value.`);
      } // interop module default


      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
        comp = comp.default;
      }

      if ( true && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        throw new Error(`Invalid async component load result: ${comp}`);
      }

      resolvedComp = comp;
      return comp;
    }));
  };

  return defineComponent({
    name: 'AsyncComponentWrapper',
    __asyncLoader: load,

    get __asyncResolved() {
      return resolvedComp;
    },

    setup() {
      const instance = currentInstance; // already resolved

      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }

      const onError = err => {
        pendingRequest = null;
        handleError(err, instance, 13
        /* ASYNC_COMPONENT_LOADER */
        , !errorComponent
        /* do not throw in dev if user provided error component */
        );
      }; // suspense-controlled or SSR.


      if (suspensible && instance.suspense || false) {
        return load().then(comp => {
          return () => createInnerComp(comp, instance);
        }).catch(err => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }

      const loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
      const error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
      const delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);

      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }

      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(`Async component timed out after ${timeout}ms.`);
            onError(err);
            error.value = err;
          }
        }, timeout);
      }

      load().then(() => {
        loaded.value = true;

        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          // parent is keep-alive, force update so the loaded component's
          // name is taken into account
          queueJob(instance.parent.update);
        }
      }).catch(err => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }

  });
}

function createInnerComp(comp, {
  vnode: {
    ref,
    props,
    children
  }
}) {
  const vnode = createVNode(comp, props, children); // ensure inner component inherits the async wrapper's ref owner

  vnode.ref = ref;
  return vnode;
}

const isKeepAlive = vnode => vnode.type.__isKeepAlive;

const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },

  setup(props, {
    slots
  }) {
    const instance = getCurrentInstance(); // KeepAlive communicates with the instantiated renderer via the
    // ctx where the renderer passes in its internals,
    // and the KeepAlive instance exposes activate/deactivate implementations.
    // The whole point of this is to avoid importing KeepAlive directly in the
    // renderer to facilitate tree-shaking.

    const sharedContext = instance.ctx; // if the internal renderer is not registered, it indicates that this is server-side rendering,
    // for KeepAlive, we just need to render its children

    if (!sharedContext.renderer) {
      return slots.default;
    }

    const cache = new Map();
    const keys = new Set();
    let current = null;

    if (true) {
      instance.__v_cache = cache;
    }

    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: {
          createElement
        }
      }
    } = sharedContext;
    const storageContainer = createElement('div');

    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
      const instance = vnode.component;
      move(vnode, container, anchor, 0
      /* ENTER */
      , parentSuspense); // in case props have changed

      patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
      queuePostRenderEffect(() => {
        instance.isDeactivated = false;

        if (instance.a) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.a);
        }

        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;

        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance.parent, vnode);
        }
      }, parentSuspense);

      if (true) {
        // Update components tree
        devtoolsComponentAdded(instance);
      }
    };

    sharedContext.deactivate = vnode => {
      const instance = vnode.component;
      move(vnode, storageContainer, null, 1
      /* LEAVE */
      , parentSuspense);
      queuePostRenderEffect(() => {
        if (instance.da) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.da);
        }

        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;

        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance.parent, vnode);
        }

        instance.isDeactivated = true;
      }, parentSuspense);

      if (true) {
        // Update components tree
        devtoolsComponentAdded(instance);
      }
    };

    function unmount(vnode) {
      // reset the shapeFlag so it can be properly unmounted
      resetShapeFlag(vnode);

      _unmount(vnode, instance, parentSuspense);
    }

    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);

        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key);
        }
      });
    }

    function pruneCacheEntry(key) {
      const cached = cache.get(key);

      if (!current || cached.type !== current.type) {
        unmount(cached);
      } else if (current) {
        // current active instance should no longer be kept-alive.
        // we can't unmount it now but it might be later, so reset its flag now.
        resetShapeFlag(current);
      }

      cache.delete(key);
      keys.delete(key);
    } // prune cache on include/exclude prop change


    watch(() => [props.include, props.exclude], ([include, exclude]) => {
      include && pruneCache(name => matches(include, name));
      exclude && pruneCache(name => !matches(exclude, name));
    }, // prune post-render after `current` has been updated
    {
      flush: 'post',
      deep: true
    }); // cache sub tree after render

    let pendingCacheKey = null;

    const cacheSubtree = () => {
      // fix #1621, the pendingCacheKey could be 0
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };

    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach(cached => {
        const {
          subTree,
          suspense
        } = instance;
        const vnode = getInnerChild(subTree);

        if (cached.type === vnode.type) {
          // current instance will be unmounted as part of keep-alive's unmount
          resetShapeFlag(vnode); // but invoke its deactivated hook here

          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }

        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;

      if (!slots.default) {
        return null;
      }

      const children = slots.default();
      const rawVNode = children[0];

      if (children.length > 1) {
        if (true) {
          warn(`KeepAlive should contain exactly one component child.`);
        }

        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4
      /* STATEFUL_COMPONENT */
      ) && !(rawVNode.shapeFlag & 128
      /* SUSPENSE */
      )) {
        current = null;
        return rawVNode;
      }

      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type; // for async components, name check should be based in its loaded
      // inner component if available

      const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
      const {
        include,
        exclude,
        max
      } = props;

      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }

      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key); // clone vnode if it's reused because we are going to mutate it

      if (vnode.el) {
        vnode = cloneVNode(vnode);

        if (rawVNode.shapeFlag & 128
        /* SUSPENSE */
        ) {
            rawVNode.ssContent = vnode;
          }
      } // #1513 it's possible for the returned vnode to be cloned due to attr
      // fallthrough or scopeId, so the vnode here may not be the final vnode
      // that is mounted. Instead of caching it directly, we store the pending
      // key and cache `instance.subTree` (the normalized vnode) in
      // beforeMount/beforeUpdate hooks.


      pendingCacheKey = key;

      if (cachedVNode) {
        // copy over mounted state
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;

        if (vnode.transition) {
          // recursively update transition hooks on subTree
          setTransitionHooks(vnode, vnode.transition);
        } // avoid vnode being mounted as fresh


        vnode.shapeFlag |= 512
        /* COMPONENT_KEPT_ALIVE */
        ; // make this key the freshest

        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key); // prune oldest entry

        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      } // avoid vnode being unmounted


      vnode.shapeFlag |= 256
      /* COMPONENT_SHOULD_KEEP_ALIVE */
      ;
      current = vnode;
      return rawVNode;
    };
  }

}; // export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files

const KeepAlive = KeepAliveImpl;

function matches(pattern, name) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {
    return pattern.some(p => matches(p, name));
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {
    return pattern.split(',').indexOf(name) > -1;
  } else if (pattern.test) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a"
  /* ACTIVATED */
  , target);
}

function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da"
  /* DEACTIVATED */
  , target);
}

function registerKeepAliveHook(hook, type, target = currentInstance) {
  // cache the deactivate branch check wrapper for injected hooks so the same
  // hook can be properly deduped by the scheduler. "__wdc" stands for "with
  // deactivation check".
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    // only fire the hook if the target instance is NOT in a deactivated branch.
    let current = target;

    while (current) {
      if (current.isDeactivated) {
        return;
      }

      current = current.parent;
    }

    hook();
  });

  injectHook(type, wrappedHook, target); // In addition to registering it on the target instance, we walk up the parent
  // chain and register it on all ancestor instances that are keep-alive roots.
  // This avoids the need to walk the entire component tree when invoking these
  // hooks, and more importantly, avoids the need to track child components in
  // arrays.

  if (target) {
    let current = target.parent;

    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }

      current = current.parent;
    }
  }
}

function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  // injectHook wraps the original for error handling, so make sure to remove
  // the wrapped version.
  const injected = injectHook(type, hook, keepAliveRoot, true
  /* prepend */
  );
  onUnmounted(() => {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);
  }, target);
}

function resetShapeFlag(vnode) {
  let shapeFlag = vnode.shapeFlag;

  if (shapeFlag & 256
  /* COMPONENT_SHOULD_KEEP_ALIVE */
  ) {
      shapeFlag -= 256
      /* COMPONENT_SHOULD_KEEP_ALIVE */
      ;
    }

  if (shapeFlag & 512
  /* COMPONENT_KEPT_ALIVE */
  ) {
      shapeFlag -= 512
      /* COMPONENT_KEPT_ALIVE */
      ;
    }

  vnode.shapeFlag = shapeFlag;
}

function getInnerChild(vnode) {
  return vnode.shapeFlag & 128
  /* SUSPENSE */
  ? vnode.ssContent : vnode;
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []); // cache the error handling wrapper for injected hooks so the same hook
    // can be properly deduped by the scheduler. "__weh" stands for "with error
    // handling".

    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      } // disable tracking inside all lifecycle hooks
      // since they can potentially be called inside effects.


      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)(); // Set currentInstance during hook invocation.
      // This assumes the hook does not synchronously trigger other hooks, which
      // can only be false when the user does something really funky.

      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      setCurrentInstance(null);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
      return res;
    });

    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }

    return wrappedHook;
  } else if (true) {
    const apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ''));
    warn(`${apiName} is called when there is no active component instance to be ` + `associated with. ` + `Lifecycle injection APIs can only be used during execution of setup().` + (` If you are using async setup(), make sure to register lifecycle ` + `hooks before the first await statement.`));
  }
}

const createHook = lifecycle => (hook, target = currentInstance) => // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
(!isInSSRComponentSetup || lifecycle === "sp"
/* SERVER_PREFETCH */
) && injectHook(lifecycle, hook, target);

const onBeforeMount = createHook("bm"
/* BEFORE_MOUNT */
);
const onMounted = createHook("m"
/* MOUNTED */
);
const onBeforeUpdate = createHook("bu"
/* BEFORE_UPDATE */
);
const onUpdated = createHook("u"
/* UPDATED */
);
const onBeforeUnmount = createHook("bum"
/* BEFORE_UNMOUNT */
);
const onUnmounted = createHook("um"
/* UNMOUNTED */
);
const onServerPrefetch = createHook("sp"
/* SERVER_PREFETCH */
);
const onRenderTriggered = createHook("rtg"
/* RENDER_TRIGGERED */
);
const onRenderTracked = createHook("rtc"
/* RENDER_TRACKED */
);

function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec"
  /* ERROR_CAPTURED */
  , hook, target);
}

function createDuplicateChecker() {
  const cache = Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}

let shouldCacheAccess = true;

function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx; // do not cache property access on public proxy during state initialization

  shouldCacheAccess = false; // call beforeCreate first before accessing other options since
  // the hook may mutate resolved options (#2791)

  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc"
    /* BEFORE_CREATE */
    );
  }

  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties =  true ? createDuplicateChecker() : 0;

  if (true) {
    const [propsOptions] = instance.propsOptions;

    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props"
        /* PROPS */
        , key);
      }
    }
  } // options initialization order (to be consistent with Vue 2):
  // - props (already done outside of this function)
  // - inject
  // - methods
  // - data (deferred since it relies on `this` access)
  // - computed
  // - watch (deferred since it relies on `this` access)


  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }

  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {
        // In dev mode, we use the `createRenderContext` function to define methods to the proxy target,
        // and those are read-only but reconfigurable, so it needs to be redefined here
        if (true) {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {}

        if (true) {
          checkDuplicateProperties("Methods"
          /* METHODS */
          , key);
        }
      } else if (true) {
        warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. ` + `Did you reference the function correctly?`);
      }
    }
  }

  if (dataOptions) {
    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataOptions)) {
      warn(`The data option must be a function. ` + `Plain object usage is no longer supported.`);
    }

    const data = dataOptions.call(publicThis, publicThis);

    if ( true && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {
      warn(`data() returned a Promise - note data() cannot be async; If you ` + `intend to perform data fetching before component renders, use ` + `async setup() + <Suspense>.`);
    }

    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {
       true && warn(`data() should return an object.`);
    } else {
      instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);

      if (true) {
        for (const key in data) {
          checkDuplicateProperties("Data"
          /* DATA */
          , key); // expose data on ctx during dev

          if (key[0] !== '$' && key[0] !== '_') {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data[key],
              set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
            });
          }
        }
      }
    }
  } // state initialization complete at this point - start caching access


  shouldCacheAccess = true;

  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;

      if ( true && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
        warn(`Computed property "${key}" has no getter.`);
      }

      const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set) ? opt.set.bind(publicThis) :  true ? () => {
        warn(`Write operation failed: computed property "${key}" is readonly.`);
      } : 0;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: v => c.value = v
      });

      if (true) {
        checkDuplicateProperties("Computed"
        /* COMPUTED */
        , key);
      }
    }
  }

  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }

  if (provideOptions) {
    const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach(key => {
      provide(key, provides[key]);
    });
  }

  if (created) {
    callHook(created, instance, "c"
    /* CREATED */
    );
  }

  function registerLifecycleHook(register, hook) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
      hook.forEach(_hook => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }

  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach(key => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: val => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  } // options that are handled when creating the instance but also need to be
  // applied from mixins


  if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
    instance.render = render;
  }

  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  } // asset options.


  if (components) instance.components = components;
  if (directives) instance.directives = directives;
}

function resolveInjections(injectOptions, ctx, checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }

  for (const key in injectOptions) {
    const opt = injectOptions[key];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {
      if ('default' in opt) {
        ctx[key] = inject(opt.from || key, opt.default, true
        /* treat default function as factory */
        );
      } else {
        ctx[key] = inject(opt.from || key);
      }
    } else {
      ctx[key] = inject(opt);
    }

    if (true) {
      checkDuplicateProperties("Inject"
      /* INJECT */
      , key);
    }
  }
}

function callHook(hook, instance, type) {
  callWithAsyncErrorHandling((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook) ? hook.map(h => h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}

function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes('.') ? createPathGetter(publicThis, key) : () => publicThis[key];

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {
    const handler = ctx[raw];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
      watch(getter, handler);
    } else if (true) {
      warn(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
      raw.forEach(r => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
        watch(getter, handler, raw);
      } else if (true) {
        warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else if (true) {
    warn(`Invalid watch option: "${key}"`, raw);
  }
}
/**
 * Resolve merged options and cache it on the component.
 * This is done only once per-component since the merging does not involve
 * instances.
 */


function resolveMergedOptions(instance) {
  const base = instance.type;
  const {
    mixins,
    extends: extendsOptions
  } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: {
      optionMergeStrategies
    }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;

  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};

    if (globalMixins.length) {
      globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));
    }

    mergeOptions(resolved, base, optionMergeStrategies);
  }

  cache.set(base, resolved);
  return resolved;
}

function mergeOptions(to, from, strats, asMixin = false) {
  const {
    mixins,
    extends: extendsOptions
  } = from;

  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }

  if (mixins) {
    mixins.forEach(m => mergeOptions(to, m, strats, true));
  }

  for (const key in from) {
    if (asMixin && key === 'expose') {
       true && warn(`"expose" option is ignored when declared in mixins or extends. ` + `It should only be declared in the base component itself.`);
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }

  return to;
}

const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  destroyed: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};

function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }

  if (!to) {
    return from;
  }

  return function mergedDataFn() {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to) ? to.call(this, this) : to, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from) ? from.call(this, this) : from);
  };
}

function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}

function normalizeInject(raw) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    const res = {};

    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }

    return res;
  }

  return raw;
}

function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}

function mergeObjectOptions(to, from) {
  return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to), from) : from;
}

function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to);

  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }

  return merged;
}

function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison
isSSR = false) {
  const props = {};
  const attrs = {};
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(attrs, InternalObjectKey, 1);
  instance.propsDefaults = Object.create(null);
  setFullProps(instance, rawProps, props, attrs); // ensure all declared prop keys are present

  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = undefined;
    }
  } // validation


  if (true) {
    validateProps(rawProps || {}, props, instance);
  }

  if (isStateful) {
    // stateful
    instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);
  } else {
    if (!instance.type.props) {
      // functional w/ optional props, props === attrs
      instance.props = attrs;
    } else {
      // functional w/ declared props
      instance.props = props;
    }
  }

  instance.attrs = attrs;
}

function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: {
      patchFlag
    }
  } = instance;
  const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;

  if ( // always force full diff in dev
  // - #1942 if hmr is enabled with sfc component
  // - vite#872 non-sfc component used by sfc component
  !( true && (instance.type.__hmrId || instance.parent && instance.parent.type.__hmrId)) && (optimized || patchFlag > 0) && !(patchFlag & 16
  /* FULL_PROPS */
  )) {
    if (patchFlag & 8
    /* PROPS */
    ) {
        // Compiler-generated props & no keys change, just set the updated
        // the props.
        const propsToUpdate = instance.vnode.dynamicProps;

        for (let i = 0; i < propsToUpdate.length; i++) {
          let key = propsToUpdate[i]; // PROPS flag guarantees rawProps to be non-null

          const value = rawProps[key];

          if (options) {
            // attr / props separation was done on init and will be consistent
            // in this code path, so just check if attrs have it.
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
              props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false
              /* isAbsent */
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
  } else {
    // full props update.
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    } // in case of dynamic props, check if we need to delete keys from
    // the props object


    let kebabKey;

    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && ( // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      (kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && ( // for camelCase
          rawPrevProps[key] !== undefined || // for kebab-case
          rawPrevProps[kebabKey] !== undefined)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true
            /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    } // in the case of functional component w/o props declaration, props and
    // attrs point to the same object so it should already have been updated.


    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key)) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  } // trigger updates for $attrs in case it's used in component slots


  if (hasAttrsChanged) {
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, "set"
    /* SET */
    , '$attrs');
  }

  if (true) {
    validateProps(rawProps || {}, props, instance);
  }
}

function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;

  if (rawProps) {
    for (let key in rawProps) {
      // key, ref are reserved and never passed down
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
        continue;
      }

      const value = rawProps[key]; // prop option names are camelized during normalization, so to support
      // kebab -> camel conversion here we need to camelize the key.

      let camelKey;

      if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }

  if (needCastKeys) {
    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;

    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(castValues, key));
    }
  }

  return hasAttrsChanged;
}

function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];

  if (opt != null) {
    const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, 'default'); // default values

    if (hasDefault && value === undefined) {
      const defaultValue = opt.default;

      if (opt.type !== Function && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {
        const {
          propsDefaults
        } = instance;

        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          setCurrentInstance(null);
        }
      } else {
        value = defaultValue;
      }
    } // boolean casting


    if (opt[0
    /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1
      /* shouldCastTrue */
      ] && (value === '' || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {
        value = true;
      }
    }
  }

  return value;
}

function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);

  if (cached) {
    return cached;
  }

  const raw = comp.props;
  const normalized = {};
  const needCastKeys = []; // apply mixin/extends props

  let hasExtends = false;

  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
    const extendProps = raw => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw, appContext, true);
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };

    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }

    if (comp.extends) {
      extendProps(comp.extends);
    }

    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }

  if (!raw && !hasExtends) {
    cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);
    return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {
        warn(`props must be strings when using array syntax.`, raw[i]);
      }

      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);

      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
      warn(`invalid props options`, raw);
    }

    for (const key in raw) {
      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);

      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? {
          type: opt
        } : opt;

        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0
          /* shouldCast */
          ] = booleanIndex > -1;
          prop[1
          /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex; // if the prop needs boolean casting or default value

          if (booleanIndex > -1 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, 'default')) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }

  const res = [normalized, needCastKeys];
  cache.set(comp, res);
  return res;
}

function validatePropName(key) {
  if (key[0] !== '$') {
    return true;
  } else if (true) {
    warn(`Invalid prop name: "${key}" is a reserved property.`);
  }

  return false;
} // use function string name to check type constructors
// so that it works across vms / iframes.


function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expectedTypes)) {
    return expectedTypes.findIndex(t => isSameType(t, type));
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  return -1;
}
/**
 * dev only
 */


function validateProps(rawProps, props, instance) {
  const resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
  const options = instance.propsOptions[0];

  for (const key in options) {
    let opt = options[key];
    if (opt == null) continue;
    validateProp(key, resolvedValues[key], opt, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)));
  }
}
/**
 * dev only
 */


function validateProp(name, value, prop, isAbsent) {
  const {
    type,
    required,
    validator
  } = prop; // required!

  if (required && isAbsent) {
    warn('Missing required prop: "' + name + '"');
    return;
  } // missing but optional


  if (value == null && !prop.required) {
    return;
  } // type check


  if (type != null && type !== true) {
    let isValid = false;
    const types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];
    const expectedTypes = []; // value is valid as long as one of the specified types match

    for (let i = 0; i < types.length && !isValid; i++) {
      const {
        valid,
        expectedType
      } = assertType(value, types[i]);
      expectedTypes.push(expectedType || '');
      isValid = valid;
    }

    if (!isValid) {
      warn(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  } // custom validator


  if (validator && !validator(value)) {
    warn('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}

const isSimpleType = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('String,Number,Boolean,Function,Symbol,BigInt');
/**
 * dev only
 */

function assertType(value, type) {
  let valid;
  const expectedType = getType(type);

  if (isSimpleType(expectedType)) {
    const t = typeof value;
    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);
  } else if (expectedType === 'Array') {
    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);
  } else {
    valid = value instanceof type;
  }

  return {
    valid,
    expectedType
  };
}
/**
 * dev only
 */


function getInvalidTypeMessage(name, value, expectedTypes) {
  let message = `Invalid prop: type check failed for prop "${name}".` + ` Expected ${expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(', ')}`;
  const expectedType = expectedTypes[0];
  const receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }

  message += `, got ${receivedType} `; // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }

  return message;
}
/**
 * dev only
 */


function styleValue(value, type) {
  if (type === 'String') {
    return `"${value}"`;
  } else if (type === 'Number') {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
/**
 * dev only
 */


function isExplicable(type) {
  const explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(elem => type.toLowerCase() === elem);
}
/**
 * dev only
 */


function isBoolean(...args) {
  return args.some(elem => elem.toLowerCase() === 'boolean');
}

const isInternalKey = key => key[0] === '_' || key === '$stable';

const normalizeSlotValue = value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];

const normalizeSlot = (key, rawSlot, ctx) => {
  const normalized = withCtx(props => {
    if ( true && currentInstance) {
      warn(`Slot "${key}" invoked outside of the render function: ` + `this will not track dependencies used in the slot. ` + `Invoke the slot function inside the render function instead.`);
    }

    return normalizeSlotValue(rawSlot(props));
  }, ctx);
  normalized._c = false;
  return normalized;
};

const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;

  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      if (true) {
        warn(`Non-function value encountered for slot "${key}". ` + `Prefer function slots for better performance.`);
      }

      const normalized = normalizeSlotValue(value);

      slots[key] = () => normalized;
    }
  }
};

const normalizeVNodeSlots = (instance, children) => {
  if ( true && !isKeepAlive(instance.vnode) && !false) {
    warn(`Non-function value encountered for default slot. ` + `Prefer function slots for better performance.`);
  }

  const normalized = normalizeSlotValue(children);

  instance.slots.default = () => normalized;
};

const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32
  /* SLOTS_CHILDREN */
  ) {
      const type = children._;

      if (type) {
        // users can get the shallow readonly version of the slots object through `this.$slots`,
        // we should avoid the proxy object polluting the slots of the internal instance
        instance.slots = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(children); // make compiler marker non-enumerable

        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(children, '_', type);
      } else {
        normalizeObjectSlots(children, instance.slots = {});
      }
    } else {
    instance.slots = {};

    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }

  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(instance.slots, InternalObjectKey, 1);
};

const updateSlots = (instance, children, optimized) => {
  const {
    vnode,
    slots
  } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;

  if (vnode.shapeFlag & 32
  /* SLOTS_CHILDREN */
  ) {
      const type = children._;

      if (type) {
        // compiled slots.
        if ( true && isHmrUpdating) {
          // Parent was HMR updated so slot content may have changed.
          // force update slots and mark instance for hmr as well
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
        } else if (optimized && type === 1
        /* STABLE */
        ) {
            // compiled AND stable.
            // no need to update, and skip stale slots removal.
            needDeletionCheck = false;
          } else {
          // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
          // normalization.
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children); // #2893
          // when rendering the optimized slots by manually written render function,
          // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
          // i.e. let the `renderSlot` create the bailed Fragment

          if (!optimized && type === 1
          /* STABLE */
          ) {
              delete slots._;
            }
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }

      deletionComparisonTarget = children;
    } else if (children) {
    // non slot object children (direct value) passed to a component
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = {
      default: 1
    };
  } // delete stale slots


  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/


const isBuiltInDirective = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text');

function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn('Do not use built-in directive ids as custom directive id: ' + name);
  }
}
/**
 * Adds directives to a VNode.
 */


function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;

  if (internalInstance === null) {
     true && warn(`withDirectives can only be used inside render functions.`);
    return vnode;
  }

  const instance = internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);

  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ] = directives[i];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }

    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers
    });
  }

  return vnode;
}

function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;

  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];

    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }

    let hook = binding.dir[name];

    if (hook) {
      // disable tracking inside all lifecycle hooks
      // since they can potentially be called inside effects.
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
      callWithAsyncErrorHandling(hook, instance, 8
      /* DIRECTIVE_HOOK */
      , [vnode.el, binding, vnode, prevVNode]);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    }
  }
}

function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: undefined,
      warnHandler: undefined,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap()
  };
}

let uid = 0;

function createAppAPI(render, hydrate) {
  return function createApp(rootComponent, rootProps = null) {
    if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {
       true && warn(`root props passed to app.mount() must be an object.`);
      rootProps = null;
    }

    const context = createAppContext();
    const installedPlugins = new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,

      get config() {
        return context.config;
      },

      set config(v) {
        if (true) {
          warn(`app.config cannot be replaced. Modify individual options instead.`);
        }
      },

      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) {
           true && warn(`Plugin has already been applied to target app.`);
        } else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else if (true) {
          warn(`A plugin must either be a function or an object with an "install" ` + `function.`);
        }

        return app;
      },

      mixin(mixin) {
        if (true) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (true) {
            warn('Mixin has already been applied to target app' + (mixin.name ? `: ${mixin.name}` : ''));
          }
        } else {}

        return app;
      },

      component(name, component) {
        if (true) {
          validateComponentName(name, context.config);
        }

        if (!component) {
          return context.components[name];
        }

        if ( true && context.components[name]) {
          warn(`Component "${name}" has already been registered in target app.`);
        }

        context.components[name] = component;
        return app;
      },

      directive(name, directive) {
        if (true) {
          validateDirectiveName(name);
        }

        if (!directive) {
          return context.directives[name];
        }

        if ( true && context.directives[name]) {
          warn(`Directive "${name}" has already been registered in target app.`);
        }

        context.directives[name] = directive;
        return app;
      },

      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps); // store app context on the root VNode.
          // this will be set on the root instance on initial mount.

          vnode.appContext = context; // HMR root reload

          if (true) {
            context.reload = () => {
              render(cloneVNode(vnode), rootContainer, isSVG);
            };
          }

          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }

          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;

          if (true) {
            app._instance = vnode.component;
            devtoolsInitApp(app, version);
          }

          return vnode.component.proxy;
        } else if (true) {
          warn(`App has already been mounted.\n` + `If you want to remount the same app, move your app creation logic ` + `into a factory function and create fresh app instances for each ` + `mount - e.g. \`const createMyApp = () => createApp(App)\``);
        }
      },

      unmount() {
        if (isMounted) {
          render(null, app._container);

          if (true) {
            app._instance = null;
            devtoolsUnmountApp(app);
          }

          delete app._container.__vue_app__;
        } else if (true) {
          warn(`Cannot unmount an app that is not mounted.`);
        }
      },

      provide(key, value) {
        if ( true && key in context.provides) {
          warn(`App already provides property with key "${String(key)}". ` + `It will be overwritten with the new value.`);
        } // TypeScript doesn't allow symbols as index type
        // https://github.com/Microsoft/TypeScript/issues/24587


        context.provides[key] = value;
        return app;
      }

    };
    return app;
  };
}

let hasMismatch = false;

const isSVGContainer = container => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';

const isComment = node => node.nodeType === 8
/* COMMENT */
; // Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.


function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp,
      nextSibling,
      parentNode,
      remove,
      insert,
      createComment
    }
  } = rendererInternals;

  const hydrate = (vnode, container) => {
    if (!container.hasChildNodes()) {
       true && warn(`Attempting to hydrate existing markup but container is empty. ` + `Performing full mount instead.`);
      patch(null, vnode, container);
      flushPostFlushCbs();
      return;
    }

    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();

    if (hasMismatch && !false) {
      // this error should show up in production
      console.error(`Hydration completed but contains mismatches.`);
    }
  };

  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    const isFragmentStart = isComment(node) && node.data === '[';

    const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);

    const {
      type,
      ref,
      shapeFlag
    } = vnode;
    const domType = node.nodeType;
    vnode.el = node;
    let nextNode = null;

    switch (type) {
      case Text:
        if (domType !== 3
        /* TEXT */
        ) {
            nextNode = onMismatch();
          } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
             true && warn(`Hydration text mismatch:` + `\n- Client: ${JSON.stringify(node.data)}` + `\n- Server: ${JSON.stringify(vnode.children)}`);
            node.data = vnode.children;
          }

          nextNode = nextSibling(node);
        }

        break;

      case Comment$1:
        if (domType !== 8
        /* COMMENT */
        || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }

        break;

      case Static:
        if (domType !== 1
        /* ELEMENT */
        ) {
            nextNode = onMismatch();
          } else {
          // determine anchor, adopt content
          nextNode = node; // if the static vnode has its content stripped during build,
          // adopt it from the server-rendered HTML.

          const needToAdoptContent = !vnode.children.length;

          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent) vnode.children += nextNode.outerHTML;

            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }

            nextNode = nextSibling(nextNode);
          }

          return nextNode;
        }

        break;

      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
        }

        break;

      default:
        if (shapeFlag & 1
        /* ELEMENT */
        ) {
            if (domType !== 1
            /* ELEMENT */
            || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
              nextNode = onMismatch();
            } else {
              nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
          } else if (shapeFlag & 6
        /* COMPONENT */
        ) {
            // when setting up the render effect, if the initial vnode already
            // has .el set, the component will perform hydration instead of mount
            // on its sub-tree.
            vnode.slotScopeIds = slotScopeIds;
            const container = parentNode(node);
            mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized); // component may be async, so in the case of fragments we cannot rely
            // on component's rendered output to determine the end of the fragment
            // instead, we do a lookahead to find the end anchor node.

            nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node); // #3787
            // if component is async, it may get moved / unmounted before its
            // inner component is loaded, so we need to give it a placeholder
            // vnode that matches its adopted DOM.

            if (isAsyncWrapper(vnode)) {
              let subTree;

              if (isFragmentStart) {
                subTree = createVNode(Fragment);
                subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
              } else {
                subTree = node.nodeType === 3 ? createTextVNode('') : createVNode('div');
              }

              subTree.el = node;
              vnode.component.subTree = subTree;
            }
          } else if (shapeFlag & 64
        /* TELEPORT */
        ) {
            if (domType !== 8
            /* COMMENT */
            ) {
                nextNode = onMismatch();
              } else {
              nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
            }
          } else if (shapeFlag & 128
        /* SUSPENSE */
        ) {
            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
          } else if (true) {
          warn('Invalid HostVNode type:', type, `(${typeof type})`);
        }

    }

    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode);
    }

    return nextNode;
  };

  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const {
      type,
      props,
      patchFlag,
      shapeFlag,
      dirs
    } = vnode; // #4006 for form elements with non-string v-model value bindings
    // e.g. <option :value="obj">, <input type="checkbox" :true-value="1">

    const forcePatchValue = type === 'input' && dirs || type === 'option'; // skip props & children if this is hoisted static nodes

    if (forcePatchValue || patchFlag !== -1
    /* HOISTED */
    ) {
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, 'created');
        } // props


        if (props) {
          if (forcePatchValue || !optimized || patchFlag & 16
          /* FULL_PROPS */
          || patchFlag & 32
          /* HYDRATE_EVENTS */
          ) {
            for (const key in props) {
              if (forcePatchValue && key.endsWith('value') || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
                patchProp(el, key, null, props[key]);
              }
            }
          } else if (props.onClick) {
            // Fast path for click listeners (which is most often) to avoid
            // iterating through props.
            patchProp(el, 'onClick', null, props.onClick);
          }
        } // vnode / directive hooks


        let vnodeHooks;

        if (vnodeHooks = props && props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHooks, parentComponent, vnode);
        }

        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
        }

        if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
          queueEffectWithSuspense(() => {
            vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
          }, parentSuspense);
        } // children


        if (shapeFlag & 16
        /* ARRAY_CHILDREN */
        && // skip if element has innerHTML / textContent
        !(props && (props.innerHTML || props.textContent))) {
          let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
          let hasWarned = false;

          while (next) {
            hasMismatch = true;

            if ( true && !hasWarned) {
              warn(`Hydration children mismatch in <${vnode.type}>: ` + `server rendered element contains more child nodes than client vdom.`);
              hasWarned = true;
            } // The SSRed DOM contains more nodes than it should. Remove them.


            const cur = next;
            next = next.nextSibling;
            remove(cur);
          }
        } else if (shapeFlag & 8
        /* TEXT_CHILDREN */
        ) {
            if (el.textContent !== vnode.children) {
              hasMismatch = true;
               true && warn(`Hydration text content mismatch in <${vnode.type}>:\n` + `- Client: ${el.textContent}\n` + `- Server: ${vnode.children}`);
              el.textContent = vnode.children;
            }
          }
      }

    return el.nextSibling;
  };

  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    let hasWarned = false;

    for (let i = 0; i < l; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);

      if (node) {
        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;

        if ( true && !hasWarned) {
          warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` + `server rendered element contains fewer child nodes than client vdom.`);
          hasWarned = true;
        } // the SSRed DOM didn't contain enough nodes. Mount the missing ones.


        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
      }
    }

    return node;
  };

  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const {
      slotScopeIds: fragmentSlotScopeIds
    } = vnode;

    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }

    const container = parentNode(node);
    const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);

    if (next && isComment(next) && next.data === ']') {
      return nextSibling(vnode.anchor = next);
    } else {
      // fragment didn't hydrate successfully, since we didn't get a end anchor
      // back. This should have led to node/children mismatch warnings.
      hasMismatch = true; // since the anchor is missing, we need to create one and insert it

      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };

  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    hasMismatch = true;
     true && warn(`Hydration node mismatch:\n- Client vnode:`, vnode.type, `\n- Server rendered DOM:`, node, node.nodeType === 3
    /* TEXT */
    ? `(text)` : isComment(node) && node.data === '[' ? `(start of fragment)` : ``);
    vnode.el = null;

    if (isFragment) {
      // remove excessive fragment nodes
      const end = locateClosingAsyncAnchor(node);

      while (true) {
        const next = nextSibling(node);

        if (next && next !== end) {
          remove(next);
        } else {
          break;
        }
      }
    }

    const next = nextSibling(node);
    const container = parentNode(node);
    remove(node);
    patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
    return next;
  };

  const locateClosingAsyncAnchor = node => {
    let match = 0;

    while (node) {
      node = nextSibling(node);

      if (node && isComment(node)) {
        if (node.data === '[') match++;

        if (node.data === ']') {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }

    return node;
  };

  return [hydrate, hydrateNode];
}

let supported;
let perf;

function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark(`vue-${type}-${instance.uid}`);
  }

  if (true) {
    devtoolsPerfStart(instance, type, supported ? perf.now() : Date.now());
  }
}

function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf.mark(endTag);
    perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }

  if (true) {
    devtoolsPerfEnd(instance, type, supported ? perf.now() : Date.now());
  }
}

function isSupported() {
  if (supported !== undefined) {
    return supported;
  }
  /* eslint-disable no-restricted-globals */


  if (typeof window !== 'undefined' && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  /* eslint-enable no-restricted-globals */


  return supported;
}
/**
 * This is only called in esm-bundler builds.
 * It is called when a renderer is created, in `baseCreateRenderer` so that
 * importing runtime-core is side-effects free.
 *
 * istanbul-ignore-next
 */


function initFeatureFlags() {
  let needWarn = false;

  if (false) {}

  if (false) {}

  if ( true && needWarn) {
    console.warn(`You are running the esm-bundler build of Vue. It is recommended to ` + `configure your bundler to explicitly replace feature flag globals ` + `with boolean literals to get proper tree-shaking in the final bundle. ` + `See http://link.vuejs.org/feature-flags for more details.`);
  }
}

const prodEffectOptions = {
  scheduler: queueJob,
  // #1801, #2043 component render effects should allow recursive updates
  allowRecurse: true
};

function createDevEffectOptions(instance) {
  return {
    scheduler: queueJob,
    allowRecurse: true,
    onTrack: instance.rtc ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e) : void 0,
    onTrigger: instance.rtg ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e) : void 0
  };
}

const queuePostRenderEffect = queueEffectWithSuspense;

const setRef = (rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) => {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {
    rawRef.forEach((r, i) => setRef(r, oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }

  if (isAsyncWrapper(vnode) && !isUnmount) {
    // when mounting async components, nothing needs to be done,
    // because the template ref is forwarded to inner component
    return;
  }

  const refValue = vnode.shapeFlag & 4
  /* STATEFUL_COMPONENT */
  ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const {
    i: owner,
    r: ref
  } = rawRef;

  if ( true && !owner) {
    warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` + `A vnode with ref must be created inside the render function.`);
    return;
  }

  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState; // dynamic ref changed. unset old ref

  if (oldRef != null && oldRef !== ref) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {
      refs[oldRef] = null;

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {
      oldRef.value = null;
    }
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref)) {
    const doSet = () => {
      {
        refs[ref] = value;
      }

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {
        setupState[ref] = value;
      }
    }; // #1789: for non-null values, set them after render
    // null values means this is unmount and it should not overwrite another
    // ref with the same key


    if (value) {
      doSet.id = -1;
      queuePostRenderEffect(doSet, parentSuspense);
    } else {
      doSet();
    }
  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref)) {
    const doSet = () => {
      ref.value = value;
    };

    if (value) {
      doSet.id = -1;
      queuePostRenderEffect(doSet, parentSuspense);
    } else {
      doSet();
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {
    callWithErrorHandling(ref, owner, 12
    /* FUNCTION_REF */
    , [value, refs]);
  } else if (true) {
    warn('Invalid template ref type:', value, `(${typeof value})`);
  }
};
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */


function createRenderer(options) {
  return baseCreateRenderer(options);
} // Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.


function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
} // implementation


function baseCreateRenderer(options, createHydrationFns) {
  // compile-time feature flags check
  {
    initFeatureFlags();
  }

  if (true) {
    const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
    target.__VUE__ = true;
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__);
  }

  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    forcePatchProp: hostForcePatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP,
    cloneNode: hostCloneNode,
    insertStaticContent: hostInsertStaticContent
  } = options; // Note: functions inside this closure should use `const xxx = () => {}`
  // style in order to prevent being inlined by minifiers.

  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = false) => {
    // patching & not same type, unmount old tree
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }

    if (n2.patchFlag === -2
    /* BAIL */
    ) {
        optimized = false;
        n2.dynamicChildren = null;
      }

    const {
      type,
      ref,
      shapeFlag
    } = n2;

    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;

      case Comment$1:
        processCommentNode(n1, n2, container, anchor);
        break;

      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        } else if (true) {
          patchStaticNode(n1, n2, container, isSVG);
        }

        break;

      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;

      default:
        if (shapeFlag & 1
        /* ELEMENT */
        ) {
            processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 6
        /* COMPONENT */
        ) {
            processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 64
        /* TELEPORT */
        ) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (shapeFlag & 128
        /* SUSPENSE */
        ) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (true) {
          warn('Invalid VNode type:', type, `(${typeof type})`);
        }

    } // set ref


    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };

  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;

      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };

  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ''), container, anchor);
    } else {
      // there's no support for dynamic comments
      n2.el = n1.el;
    }
  };

  const mountStaticNode = (n2, container, anchor, isSVG) => {
    // static nodes are only present when used with compiler-dom/runtime-dom
    // which guarantees presence of hostInsertStaticContent.
    const nodes = hostInsertStaticContent(n2.children, container, anchor, isSVG, // pass cached nodes if the static node is being mounted multiple times
    // so that runtime-dom can simply cloneNode() instead of inserting new
    // HTML
    n2.staticCache); // first mount - this is the orignal hoisted vnode. cache nodes.

    if (!n2.el) {
      n2.staticCache = nodes;
    }

    n2.el = nodes[0];
    n2.anchor = nodes[nodes.length - 1];
  };
  /**
   * Dev / HMR only
   */


  const patchStaticNode = (n1, n2, container, isSVG) => {
    // static nodes are only patched during dev for HMR
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor); // remove existing

      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };

  const moveStaticNode = ({
    el,
    anchor
  }, container, nextSibling) => {
    let next;

    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }

    hostInsert(anchor, container, nextSibling);
  };

  const removeStaticNode = ({
    el,
    anchor
  }) => {
    let next;

    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }

    hostRemove(anchor);
  };

  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === 'svg';

    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };

  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const {
      type,
      props,
      shapeFlag,
      transition,
      patchFlag,
      dirs
    } = vnode;

    if (false
    /* HOISTED */
    ) {} else {
      el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props); // mount children first, since some props may rely on child content
      // being already rendered, e.g. `<select value>`

      if (shapeFlag & 8
      /* TEXT_CHILDREN */
      ) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
          mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized || !!vnode.dynamicChildren);
        }

      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, 'created');
      } // props


      if (props) {
        for (const key in props) {
          if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
            hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }

        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      } // scopeId


      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }

    if (true) {
      Object.defineProperty(el, '__vnode', {
        value: vnode,
        enumerable: false
      });
      Object.defineProperty(el, '__vueParentComponent', {
        value: parentComponent,
        enumerable: false
      });
    }

    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
    } // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
    // #1689 For inside suspense + suspense resolved case, just call it


    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;

    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }

    hostInsert(el, container, anchor);

    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
      }, parentSuspense);
    }
  };

  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }

    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }

    if (parentComponent) {
      let subTree = parentComponent.subTree;

      if ( true && subTree.patchFlag > 0 && subTree.patchFlag & 2048
      /* DEV_ROOT_FRAGMENT */
      ) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }

      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };

  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };

  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let {
      patchFlag,
      dynamicChildren,
      dirs
    } = n2; // #1426 take the old vnode's patch flag into account since user may clone a
    // compiler-generated vnode, which de-opts to FULL_PROPS

    patchFlag |= n1.patchFlag & 16
    /* FULL_PROPS */
    ;
    const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    let vnodeHook;

    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }

    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
    }

    if ( true && isHmrUpdating) {
      // HMR updated, force full diff
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }

    if (patchFlag > 0) {
      // the presence of a patchFlag means this element's render code was
      // generated by the compiler and can take the fast path.
      // in this path old node and new node are guaranteed to have the same shape
      // (i.e. at the exact same position in the source template)
      if (patchFlag & 16
      /* FULL_PROPS */
      ) {
          // element props contain dynamic keys, full diff needed
          patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        } else {
        // class
        // this flag is matched when the element has dynamic class bindings.
        if (patchFlag & 2
        /* CLASS */
        ) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, 'class', null, newProps.class, isSVG);
            }
          } // style
        // this flag is matched when the element has dynamic style bindings


        if (patchFlag & 4
        /* STYLE */
        ) {
            hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
          } // props
        // This flag is matched when the element has dynamic prop/attr bindings
        // other than class and style. The keys of dynamic prop/attrs are saved for
        // faster iteration.
        // Note dynamic keys like :[foo]="bar" will cause this optimization to
        // bail out and go through a full diff because we need to unset the old key


        if (patchFlag & 8
        /* PROPS */
        ) {
            // if the flag is present then dynamicProps must be non-null
            const propsToUpdate = n2.dynamicProps;

            for (let i = 0; i < propsToUpdate.length; i++) {
              const key = propsToUpdate[i];
              const prev = oldProps[key];
              const next = newProps[key];

              if (next !== prev || hostForcePatchProp && hostForcePatchProp(el, key)) {
                hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
              }
            }
          }
      } // text
      // This flag is matched when the element has only dynamic text children.


      if (patchFlag & 1
      /* TEXT */
      ) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
    } else if (!optimized && dynamicChildren == null) {
      // unoptimized, full diff
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }

    const areChildrenSVG = isSVG && n2.type !== 'foreignObject';

    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);

      if ( true && parentComponent && parentComponent.type.__hmrId) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      // full diff
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }

    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
      }, parentSuspense);
    }
  }; // The fast path for blocks.


  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i]; // Determine the container (parent element) for the patch.

      const container = // oldVNode may be an errored async setup() component inside Suspense
      // which will not have a mounted element
      oldVNode.el && ( // - In the case of a Fragment, we need to provide the actual parent
      // of the Fragment itself so it can move its children.
      oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
      // which also requires the correct parent container
      !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
      oldVNode.shapeFlag & 6
      /* COMPONENT */
      || oldVNode.shapeFlag & 64
      /* TELEPORT */
      ) ? hostParentNode(oldVNode.el) : // In other cases, the parent container is not actually used so we
      // just pass the block element here to avoid a DOM parentNode call.
      fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };

  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      for (const key in newProps) {
        // empty string is not valid prop
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];

        if (next !== prev || hostForcePatchProp && hostForcePatchProp(el, key)) {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }

      if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
    }
  };

  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText('');
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText('');
    let {
      patchFlag,
      dynamicChildren,
      slotScopeIds: fragmentSlotScopeIds
    } = n2;

    if (dynamicChildren) {
      optimized = true;
    } // check if this is a slot fragment with :slotted scope ids


    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }

    if ( true && isHmrUpdating) {
      // HMR updated, force full diff
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }

    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor); // a fragment can only have array children
      // since they are either generated by the compiler, or implicitly created
      // from arrays.

      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64
      /* STABLE_FRAGMENT */
      && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        // a stable fragment (template root or <template v-for>) doesn't need to
        // patch children order, but it may contain dynamicChildren.
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);

        if ( true && parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n2);
        } else if ( // #2080 if the stable fragment has a key, it's a <template v-for> that may
        //  get moved around. Make sure all root level vnodes inherit el.
        // #2134 or if it's a component root, it may also get moved around
        // as the component is being moved.
        n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true
          /* shallow */
          );
        }
      } else {
        // keyed / unkeyed, or manual fragments.
        // for keyed & unkeyed, since they are compiler generated from v-for,
        // each child is guaranteed to be a block so the fragment will never
        // have dynamicChildren.
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };

  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;

    if (n1 == null) {
      if (n2.shapeFlag & 512
      /* COMPONENT_KEPT_ALIVE */
      ) {
          parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
        } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };

  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);

    if ( true && instance.type.__hmrId) {
      registerHMR(instance);
    }

    if (true) {
      pushWarningContext(initialVNode);
      startMeasure(instance, `mount`);
    } // inject renderer internals for keepAlive


    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    } // resolve props and slots for setup context


    {
      if (true) {
        startMeasure(instance, `init`);
      }

      setupComponent(instance);

      if (true) {
        endMeasure(instance, `init`);
      }
    } // setup() is async. This component relies on async logic to be resolved
    // before proceeding

    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect); // Give it a placeholder if this is not hydration
      // TODO handle self-defined fallback

      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment$1);
        processCommentNode(null, placeholder, container, anchor);
      }

      return;
    }

    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);

    if (true) {
      popWarningContext();
      endMeasure(instance, `mount`);
    }
  };

  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;

    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        // async & still pending - just update props and slots
        // since the component's reactive effect for render isn't set-up yet
        if (true) {
          pushWarningContext(n2);
        }

        updateComponentPreRender(instance, n2, optimized);

        if (true) {
          popWarningContext();
        }

        return;
      } else {
        // normal update
        instance.next = n2; // in case the child component is also queued, remove it to avoid
        // double updating the same child component in the same flush.

        invalidateJob(instance.update); // instance.update is the reactive effect runner.

        instance.update();
      }
    } else {
      // no update needed. just copy over properties
      n2.component = n1.component;
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };

  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    // create reactive effect for rendering
    instance.update = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect)(function componentEffect() {
      if (!instance.isMounted) {
        let vnodeHook;
        const {
          el,
          props
        } = initialVNode;
        const {
          bm,
          m,
          parent
        } = instance; // beforeMount hook

        if (bm) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);
        } // onVnodeBeforeMount


        if (vnodeHook = props && props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }

        if (el && hydrateNode) {
          // vnode has adopted host node - perform hydration instead of mount.
          const hydrateSubTree = () => {
            if (true) {
              startMeasure(instance, `render`);
            }

            instance.subTree = renderComponentRoot(instance);

            if (true) {
              endMeasure(instance, `render`);
            }

            if (true) {
              startMeasure(instance, `hydrate`);
            }

            hydrateNode(el, instance.subTree, instance, parentSuspense, null);

            if (true) {
              endMeasure(instance, `hydrate`);
            }
          };

          if (isAsyncWrapper(initialVNode)) {
            initialVNode.type.__asyncLoader().then( // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !instance.isUnmounted && hydrateSubTree());
          } else {
            hydrateSubTree();
          }
        } else {
          if (true) {
            startMeasure(instance, `render`);
          }

          const subTree = instance.subTree = renderComponentRoot(instance);

          if (true) {
            endMeasure(instance, `render`);
          }

          if (true) {
            startMeasure(instance, `patch`);
          }

          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);

          if (true) {
            endMeasure(instance, `patch`);
          }

          initialVNode.el = subTree.el;
        } // mounted hook


        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        } // onVnodeMounted


        if (vnodeHook = props && props.onVnodeMounted) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        } // activated hook for keep-alive roots.
        // #1742 activated hook must be accessed after first render
        // since the hook may be injected by a child keep-alive


        if (initialVNode.shapeFlag & 256
        /* COMPONENT_SHOULD_KEEP_ALIVE */
        ) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }

        instance.isMounted = true;

        if (true) {
          devtoolsComponentAdded(instance);
        } // #2458: deference mount-only object parameters to prevent memleaks


        initialVNode = container = anchor = null;
      } else {
        // updateComponent
        // This is triggered by mutation of component's own state (next: null)
        // OR parent calling processComponent (next: VNode)
        let {
          next,
          bu,
          u,
          parent,
          vnode
        } = instance;
        let originNext = next;
        let vnodeHook;

        if (true) {
          pushWarningContext(next || instance.vnode);
        }

        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        } // beforeUpdate hook


        if (bu) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);
        } // onVnodeBeforeUpdate


        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        } // render


        if (true) {
          startMeasure(instance, `render`);
        }

        const nextTree = renderComponentRoot(instance);

        if (true) {
          endMeasure(instance, `render`);
        }

        const prevTree = instance.subTree;
        instance.subTree = nextTree;

        if (true) {
          startMeasure(instance, `patch`);
        }

        patch(prevTree, nextTree, // parent may have changed if it's in a teleport
        hostParentNode(prevTree.el), // anchor may have changed if it's in a fragment
        getNextHostNode(prevTree), instance, parentSuspense, isSVG);

        if (true) {
          endMeasure(instance, `patch`);
        }

        next.el = nextTree.el;

        if (originNext === null) {
          // self-triggered update. In case of HOC, update parent component
          // vnode el. HOC is indicated by parent instance's subTree pointing
          // to child component's vnode
          updateHOCHostEl(instance, nextTree.el);
        } // updated hook


        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        } // onVnodeUpdated


        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }

        if (true) {
          devtoolsComponentUpdated(instance);
        }

        if (true) {
          popWarningContext();
        }
      }
    },  true ? createDevEffectOptions(instance) : 0);

    if (true) {
      // @ts-ignore
      instance.update.ownerInstance = instance;
    }
  };

  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)(); // props update may have triggered pre-flush watchers.
    // flush them before the render update.

    flushPreFlushCbs(undefined, instance.update);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
  };

  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const {
      patchFlag,
      shapeFlag
    } = n2; // fast path

    if (patchFlag > 0) {
      if (patchFlag & 128
      /* KEYED_FRAGMENT */
      ) {
          // this could be either fully-keyed or mixed (some keyed some not)
          // presence of patchFlag means children are guaranteed to be arrays
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        } else if (patchFlag & 256
      /* UNKEYED_FRAGMENT */
      ) {
          // unkeyed
          patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        }
    } // children has 3 possibilities: text, array or no children.


    if (shapeFlag & 8
    /* TEXT_CHILDREN */
    ) {
        // text children fast path
        if (prevShapeFlag & 16
        /* ARRAY_CHILDREN */
        ) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }

        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
      if (prevShapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
          // prev children was array
          if (shapeFlag & 16
          /* ARRAY_CHILDREN */
          ) {
              // two arrays, cannot assume anything, do full diff
              patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else {
            // no new children, just unmount old
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
        // prev children was text OR null
        // new children is array OR null
        if (prevShapeFlag & 8
        /* TEXT_CHILDREN */
        ) {
            hostSetElementText(container, '');
          } // mount new if array


        if (shapeFlag & 16
        /* ARRAY_CHILDREN */
        ) {
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
      }
    }
  };

  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;

    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }

    if (oldLength > newLength) {
      // remove old
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      // mount new
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  }; // can be all-keyed or mixed


  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1; // prev ending index

    let e2 = l2 - 1; // next ending index
    // 1. sync from start
    // (a b) c
    // (a b) d e

    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);

      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }

      i++;
    } // 2. sync from end
    // a (b c)
    // d e (b c)


    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);

      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }

      e1--;
      e2--;
    } // 3. common sequence + mount
    // (a b)
    // (a b) c
    // i = 2, e1 = 1, e2 = 2
    // (a b)
    // c (a b)
    // i = 0, e1 = -1, e2 = 0


    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;

        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } // 4. common sequence + unmount
    // (a b) c
    // (a b)
    // i = 2, e1 = 2, e2 = 1
    // a (b c)
    // (b c)
    // i = 0, e1 = 0, e2 = -1
    else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } // 5. unknown sequence
      // [i ... e1 + 1]: a b [c d e] f g
      // [i ... e2 + 1]: a b [e d c h] f g
      // i = 2, e1 = 4, e2 = 5
      else {
          const s1 = i; // prev starting index

          const s2 = i; // next starting index
          // 5.1 build key:index map for newChildren

          const keyToNewIndexMap = new Map();

          for (i = s2; i <= e2; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);

            if (nextChild.key != null) {
              if ( true && keyToNewIndexMap.has(nextChild.key)) {
                warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
              }

              keyToNewIndexMap.set(nextChild.key, i);
            }
          } // 5.2 loop through old children left to be patched and try to patch
          // matching nodes & remove nodes that are no longer present


          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false; // used to track whether any node has moved

          let maxNewIndexSoFar = 0; // works as Map<newIndex, oldIndex>
          // Note that oldIndex is offset by +1
          // and oldIndex = 0 is a special value indicating the new node has
          // no corresponding old node.
          // used for determining longest stable subsequence

          const newIndexToOldIndexMap = new Array(toBePatched);

          for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;

          for (i = s1; i <= e1; i++) {
            const prevChild = c1[i];

            if (patched >= toBePatched) {
              // all new children have been patched so this can only be a removal
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }

            let newIndex;

            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              // key-less node, try to locate a key-less node of the same type
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }

            if (newIndex === undefined) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;

              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }

              patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              patched++;
            }
          } // 5.3 move and mount
          // generate longest stable subsequence only when nodes have moved


          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1; // looping backwards so that we can use last patched node as anchor

          for (i = toBePatched - 1; i >= 0; i--) {
            const nextIndex = s2 + i;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;

            if (newIndexToOldIndexMap[i] === 0) {
              // mount new
              patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else if (moved) {
              // move if:
              // There is no stable subsequence (e.g. a reverse)
              // OR current node is not among the stable sequence
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2
                /* REORDER */
                );
              } else {
                j--;
              }
            }
          }
        }
  };

  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const {
      el,
      type,
      transition,
      children,
      shapeFlag
    } = vnode;

    if (shapeFlag & 6
    /* COMPONENT */
    ) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }

    if (shapeFlag & 128
    /* SUSPENSE */
    ) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }

    if (shapeFlag & 64
    /* TELEPORT */
    ) {
        type.move(vnode, container, anchor, internals);
        return;
      }

    if (type === Fragment) {
      hostInsert(el, container, anchor);

      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }

      hostInsert(vnode.anchor, container, anchor);
      return;
    }

    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    } // single nodes


    const needTransition = moveType !== 2
    /* REORDER */
    && shapeFlag & 1
    /* ELEMENT */
    && transition;

    if (needTransition) {
      if (moveType === 0
      /* ENTER */
      ) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
        const {
          leave,
          delayLeave,
          afterLeave
        } = transition;

        const remove = () => hostInsert(el, container, anchor);

        const performLeave = () => {
          leave(el, () => {
            remove();
            afterLeave && afterLeave();
          });
        };

        if (delayLeave) {
          delayLeave(el, remove, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };

  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode; // unset ref

    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode, true);
    }

    if (shapeFlag & 256
    /* COMPONENT_SHOULD_KEEP_ALIVE */
    ) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }

    const shouldInvokeDirs = shapeFlag & 1
    /* ELEMENT */
    && dirs;
    let vnodeHook;

    if (vnodeHook = props && props.onVnodeBeforeUnmount) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }

    if (shapeFlag & 6
    /* COMPONENT */
    ) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
      if (shapeFlag & 128
      /* SUSPENSE */
      ) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }

      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
      }

      if (shapeFlag & 64
      /* TELEPORT */
      ) {
          vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
        } else if (dynamicChildren && ( // #1153: fast path should not be taken for non-stable (v-for) fragments
      type !== Fragment || patchFlag > 0 && patchFlag & 64
      /* STABLE_FRAGMENT */
      )) {
        // fast path for block nodes: only need to unmount dynamic children.
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && (patchFlag & 128
      /* KEYED_FRAGMENT */
      || patchFlag & 256
      /* UNKEYED_FRAGMENT */
      ) || !optimized && shapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
        unmountChildren(children, parentComponent, parentSuspense);
      }

      if (doRemove) {
        remove(vnode);
      }
    }

    if ((vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
      }, parentSuspense);
    }
  };

  const remove = vnode => {
    const {
      type,
      el,
      anchor,
      transition
    } = vnode;

    if (type === Fragment) {
      removeFragment(el, anchor);
      return;
    }

    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }

    const performRemove = () => {
      hostRemove(el);

      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };

    if (vnode.shapeFlag & 1
    /* ELEMENT */
    && transition && !transition.persisted) {
      const {
        leave,
        delayLeave
      } = transition;

      const performLeave = () => leave(el, performRemove);

      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };

  const removeFragment = (cur, end) => {
    // For fragments, directly remove all contained DOM nodes.
    // (fragment child nodes cannot have transition)
    let next;

    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }

    hostRemove(end);
  };

  const unmountComponent = (instance, parentSuspense, doRemove) => {
    if ( true && instance.type.__hmrId) {
      unregisterHMR(instance);
    }

    const {
      bum,
      effects,
      update,
      subTree,
      um
    } = instance; // beforeUnmount hook

    if (bum) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);
    }

    if (effects) {
      for (let i = 0; i < effects.length; i++) {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop)(effects[i]);
      }
    } // update may be null if a component is unmounted before its async
    // setup has resolved.


    if (update) {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop)(update);
      unmount(subTree, instance, parentSuspense, doRemove);
    } // unmounted hook


    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }

    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense); // A component with async dep inside a pending suspense is unmounted before
    // its async dep resolves. This should remove the dep from the suspense, and
    // cause the suspense to resolve immediately if that was the last dep.

    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;

      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }

    if (true) {
      devtoolsComponentRemoved(instance);
    }
  };

  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };

  const getNextHostNode = vnode => {
    if (vnode.shapeFlag & 6
    /* COMPONENT */
    ) {
        return getNextHostNode(vnode.component.subTree);
      }

    if (vnode.shapeFlag & 128
    /* SUSPENSE */
    ) {
        return vnode.suspense.next();
      }

    return hostNextSibling(vnode.anchor || vnode.el);
  };

  const render = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }

    flushPostFlushCbs();
    container._vnode = vnode;
  };

  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;

  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }

  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}

function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7
  /* VNODE_HOOK */
  , [vnode, prevVNode]);
}
/**
 * #1156
 * When a component is HMR-enabled, we need to make sure that all static nodes
 * inside a block also inherit the DOM element from the previous tree so that
 * HMR updates (which are full updates) can retrieve the element for patching.
 *
 * #2080
 * Inside keyed `template` fragment static children, if a fragment is moved,
 * the children will always moved so that need inherit el form previous nodes
 * to ensure correct moved position.
 */


function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      // this is only called in the optimized path so array children are
      // guaranteed to be vnodes
      const c1 = ch1[i];
      let c2 = ch2[i];

      if (c2.shapeFlag & 1
      /* ELEMENT */
      && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32
        /* HYDRATE_EVENTS */
        ) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }

        if (!shallow) traverseStaticChildren(c1, c2);
      } // also inherit for comment nodes, but not placeholders (e.g. v-if which
      // would have received .el during block patch)


      if ( true && c2.type === Comment$1 && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
} // https://en.wikipedia.org/wiki/Longest_increasing_subsequence


function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;

  for (i = 0; i < len; i++) {
    const arrI = arr[i];

    if (arrI !== 0) {
      j = result[result.length - 1];

      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }

      u = 0;
      v = result.length - 1;

      while (u < v) {
        c = (u + v) / 2 | 0;

        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }

      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }

        result[u] = i;
      }
    }
  }

  u = result.length;
  v = result[u - 1];

  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }

  return result;
}

const isTeleport = type => type.__isTeleport;

const isTeleportDisabled = props => props && (props.disabled || props.disabled === '');

const isTargetSVG = target => typeof SVGElement !== 'undefined' && target instanceof SVGElement;

const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {
    if (!select) {
       true && warn(`Current renderer does not support string target for Teleports. ` + `(missing querySelector renderer option)`);
      return null;
    } else {
      const target = select(targetSelector);

      if (!target) {
         true && warn(`Failed to locate Teleport target with selector "${targetSelector}". ` + `Note the target element must exist before the component is mounted - ` + `i.e. the target cannot be rendered by the component itself, and ` + `ideally should be outside of the entire Vue component tree.`);
      }

      return target;
    }
  } else {
    if ( true && !targetSelector && !isTeleportDisabled(props)) {
      warn(`Invalid Teleport target: ${targetSelector}`);
    }

    return targetSelector;
  }
};

const TeleportImpl = {
  __isTeleport: true,

  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: {
        insert,
        querySelector,
        createText,
        createComment
      }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let {
      shapeFlag,
      children,
      dynamicChildren
    } = n2; // #3302
    // HMR updated, force full diff

    if ( true && isHmrUpdating) {
      optimized = false;
      dynamicChildren = null;
    }

    if (n1 == null) {
      // insert anchors in the main view
      const placeholder = n2.el =  true ? createComment('teleport start') : 0;
      const mainAnchor = n2.anchor =  true ? createComment('teleport end') : 0;
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText('');

      if (target) {
        insert(targetAnchor, target); // #2652 we could be teleporting from a non-SVG tree into an SVG tree

        isSVG = isSVG || isTargetSVG(target);
      } else if ( true && !disabled) {
        warn('Invalid Teleport target on mount:', target, `(${typeof target})`);
      }

      const mount = (container, anchor) => {
        // Teleport *always* has Array children. This is enforced in both the
        // compiler and vnode children normalization.
        if (shapeFlag & 16
        /* ARRAY_CHILDREN */
        ) {
            mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
      };

      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      // update content
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);

      if (dynamicChildren) {
        // fast path when the teleport happens to be a block root
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds); // even in block tree mode we need to make sure all root-level nodes
        // in the teleport inherit previous DOM references so that they can
        // be moved in future patches.

        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }

      if (disabled) {
        if (!wasDisabled) {
          // enabled -> disabled
          // move into main container
          moveTeleport(n2, container, mainAnchor, internals, 1
          /* TOGGLE */
          );
        }
      } else {
        // target changed
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);

          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0
            /* TARGET_CHANGE */
            );
          } else if (true) {
            warn('Invalid Teleport target on update:', target, `(${typeof target})`);
          }
        } else if (wasDisabled) {
          // disabled -> enabled
          // move into teleport target
          moveTeleport(n2, target, targetAnchor, internals, 1
          /* TOGGLE */
          );
        }
      }
    }
  },

  remove(vnode, parentComponent, parentSuspense, optimized, {
    um: unmount,
    o: {
      remove: hostRemove
    }
  }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetAnchor,
      target,
      props
    } = vnode;

    if (target) {
      hostRemove(targetAnchor);
    } // an unmounted teleport should always remove its children if not disabled


    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);

      if (shapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
          }
        }
    }
  },

  move: moveTeleport,
  hydrate: hydrateTeleport
};

function moveTeleport(vnode, container, parentAnchor, {
  o: {
    insert
  },
  m: move
}, moveType = 2
/* REORDER */
) {
  // move target anchor if this is a target change.
  if (moveType === 0
  /* TARGET_CHANGE */
  ) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }

  const {
    el,
    anchor,
    shapeFlag,
    children,
    props
  } = vnode;
  const isReorder = moveType === 2
  /* REORDER */
  ; // move main view anchor if this is a re-order.

  if (isReorder) {
    insert(el, container, parentAnchor);
  } // if this is a re-order and teleport is enabled (content is in target)
  // do not move children. So the opposite is: only move children if this
  // is not a reorder, or the teleport is disabled


  if (!isReorder || isTeleportDisabled(props)) {
    // Teleport has either Array children or no children.
    if (shapeFlag & 16
    /* ARRAY_CHILDREN */
    ) {
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, parentAnchor, 2
          /* REORDER */
          );
        }
      }
  } // move main view anchor if this is a re-order.


  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}

function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: {
    nextSibling,
    parentNode,
    querySelector
  }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(vnode.props, querySelector);

  if (target) {
    // if multiple teleports rendered to the same target element, we need to
    // pick up from where the last teleport finished instead of the first node
    const targetNode = target._lpa || target.firstChild;

    if (vnode.shapeFlag & 16
    /* ARRAY_CHILDREN */
    ) {
        if (isTeleportDisabled(vnode.props)) {
          vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
          vnode.targetAnchor = targetNode;
        } else {
          vnode.anchor = nextSibling(node);
          vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
        }

        target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
      }
  }

  return vnode.anchor && nextSibling(vnode.anchor);
} // Force-casted public typing for h and TSX props inference


const Teleport = TeleportImpl;
const COMPONENTS = 'components';
const DIRECTIVES = 'directives';
/**
 * @private
 */

function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}

const NULL_DYNAMIC_COMPONENT = Symbol();
/**
 * @private
 */

function resolveDynamicComponent(component) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    // invalid types will fallthrough to createVNode and raise warning
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
/**
 * @private
 */


function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
} // implementation


function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;

  if (instance) {
    const Component = instance.type; // explicit self name has highest priority

    if (type === COMPONENTS) {
      const selfName = getComponentName(Component);

      if (selfName && (selfName === name || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {
        return Component;
      }
    }

    const res = // local registration
    // check instance[type] first which is resolved for options API
    resolve(instance[type] || Component[type], name) || // global registration
    resolve(instance.appContext[type], name);

    if (!res && maybeSelfReference) {
      // fallback to implicit self-reference
      return Component;
    }

    if ( true && warnMissing && !res) {
      warn(`Failed to resolve ${type.slice(0, -1)}: ${name}`);
    }

    return res;
  } else if (true) {
    warn(`resolve${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1))} ` + `can only be used in render() or setup().`);
  }
}

function resolve(registry, name) {
  return registry && (registry[name] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]);
}

const Fragment = Symbol( true ? 'Fragment' : 0);
const Text = Symbol( true ? 'Text' : 0);
const Comment$1 = Symbol( true ? 'Comment' : 0);
const Static = Symbol( true ? 'Static' : 0); // Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).

const blockStack = [];
let currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @private
 */

function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}

function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
} // Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)


let isBlockTreeEnabled = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */

function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */


function createBlock(type, props, children, patchFlag, dynamicProps) {
  const vnode = createVNode(type, props, children, patchFlag, dynamicProps, true
  /* isBlock: prevent a block from tracking itself */
  ); // save current block children on the block vnode

  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR : null; // close block

  closeBlock(); // a block is always going to be patched, so track it as a child of its
  // parent block

  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }

  return vnode;
}

function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}

function isSameVNodeType(n1, n2) {
  if ( true && n2.shapeFlag & 6
  /* COMPONENT */
  && hmrDirtyComponents.has(n2.type)) {
    // HMR only: if the component has been hot-updated, force a reload.
    return false;
  }

  return n1.type === n2.type && n1.key === n2.key;
}

let vnodeArgsTransformer;
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */

function transformVNodeArgs(transformer) {
  vnodeArgsTransformer = transformer;
}

const createVNodeWithArgsTransform = (...args) => {
  return _createVNode(...(vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args));
};

const InternalObjectKey = `__vInternal`;

const normalizeKey = ({
  key
}) => key != null ? key : null;

const normalizeRef = ({
  ref
}) => {
  return ref != null ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref) ? {
    i: currentRenderingInstance,
    r: ref
  } : ref : null;
};

const createVNode =  true ? createVNodeWithArgsTransform : 0;

function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if ( true && !type) {
      warn(`Invalid vnode type when creating vnode: ${type}.`);
    }

    type = Comment$1;
  }

  if (isVNode(type)) {
    // createVNode receiving an existing vnode. This happens in cases like
    // <component :is="vnode"/>
    // #2078 make sure to merge refs during the clone instead of overwriting it
    const cloned = cloneVNode(type, props, true
    /* mergeRef: true */
    );

    if (children) {
      normalizeChildren(cloned, children);
    }

    return cloned;
  } // class component normalization.


  if (isClassComponent(type)) {
    type = type.__vccOpts;
  } // class & style normalization.


  if (props) {
    // for reactive or proxy objects, we need to clone it to enable mutation.
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || InternalObjectKey in props) {
      props = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props);
    }

    let {
      class: klass,
      style
    } = props;

    if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {
      props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);
    }

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {
      // reactive state objects need to be cloned since they are likely to be
      // mutated
      if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {
        style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);
      }

      props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);
    }
  } // encode the vnode type information into a bitmap


  const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type) ? 1
  /* ELEMENT */
  : isSuspense(type) ? 128
  /* SUSPENSE */
  : isTeleport(type) ? 64
  /* TELEPORT */
  : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type) ? 4
  /* STATEFUL_COMPONENT */
  : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type) ? 2
  /* FUNCTIONAL_COMPONENT */
  : 0;

  if ( true && shapeFlag & 4
  /* STATEFUL_COMPONENT */
  && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {
    type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);
    warn(`Vue received a Component which was made a reactive object. This can ` + `lead to unnecessary performance overhead, and should be avoided by ` + `marking the component with \`markRaw\` or using \`shallowRef\` ` + `instead of \`ref\`.`, `\nComponent that was made reactive: `, type);
  }

  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children: null,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null
  }; // validate key

  if ( true && vnode.key !== vnode.key) {
    warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }

  normalizeChildren(vnode, children); // normalize suspense children

  if (shapeFlag & 128
  /* SUSPENSE */
  ) {
      type.normalize(vnode);
    }

  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && ( // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  patchFlag > 0 || shapeFlag & 6
  /* COMPONENT */
  ) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  patchFlag !== 32
  /* HYDRATE_EVENTS */
  ) {
      currentBlock.push(vnode);
    }

  return vnode;
}

function cloneVNode(vnode, extraProps, mergeRef = false) {
  // This is intentionally NOT using spread or extend to avoid the runtime
  // key enumeration cost.
  const {
    props,
    ref,
    patchFlag,
    children
  } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? // #2078 in the case of <component :is="vnode" ref="extra"/>
    // if the vnode itself already has a ref, cloneVNode will need to merge
    // the refs so the single vnode can be set on multiple refs
    mergeRef && ref ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children:  true && patchFlag === -1
    /* HOISTED */
    && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children) ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    staticCache: vnode.staticCache,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: perserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 // hoisted node
    ? 16
    /* FULL_PROPS */
    : patchFlag | 16
    /* FULL_PROPS */
    : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
/**
 * Dev only, for HMR of hoisted vnodes reused in v-for
 * https://github.com/vitejs/vite/issues/2022
 */


function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }

  return cloned;
}
/**
 * @private
 */


function createTextVNode(text = ' ', flag = 0) {
  return createVNode(Text, null, text, flag);
}
/**
 * @private
 */


function createStaticVNode(content, numberOfNodes) {
  // A static vnode can contain multiple stringified elements, and the number
  // of elements is necessary for hydration.
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
/**
 * @private
 */


function createCommentVNode(text = '', // when used as the v-else branch, the comment node must be created as a
// block to ensure correct updates.
asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment$1, null, text)) : createVNode(Comment$1, null, text);
}

function normalizeVNode(child) {
  if (child == null || typeof child === 'boolean') {
    // empty placeholder
    return createVNode(Comment$1);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {
    // fragment
    return createVNode(Fragment, null, // #3666, avoid reference pollution when reusing vnode
    child.slice());
  } else if (typeof child === 'object') {
    // already vnode, this should be the most common since compiled templates
    // always produce all-vnode children arrays
    return cloneIfMounted(child);
  } else {
    // strings and numbers
    return createVNode(Text, null, String(child));
  }
} // optimized normalization for template-compiled render fns


function cloneIfMounted(child) {
  return child.el === null ? child : cloneVNode(child);
}

function normalizeChildren(vnode, children) {
  let type = 0;
  const {
    shapeFlag
  } = vnode;

  if (children == null) {
    children = null;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {
    type = 16
    /* ARRAY_CHILDREN */
    ;
  } else if (typeof children === 'object') {
    if (shapeFlag & 1
    /* ELEMENT */
    || shapeFlag & 64
    /* TELEPORT */
    ) {
        // Normalize slot to plain children for plain element and Teleport
        const slot = children.default;

        if (slot) {
          // _c marker is added by withCtx() indicating this is a compiled slot
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }

        return;
      } else {
      type = 32
      /* SLOTS_CHILDREN */
      ;
      const slotFlag = children._;

      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3
      /* FORWARDED */
      && currentRenderingInstance) {
        // a child component receives forwarded slots from the parent.
        // its slot type is determined by its parent's slot type.
        if (currentRenderingInstance.slots._ === 1
        /* STABLE */
        ) {
            children._ = 1
            /* STABLE */
            ;
          } else {
          children._ = 2
          /* DYNAMIC */
          ;
          vnode.patchFlag |= 1024
          /* DYNAMIC_SLOTS */
          ;
        }
      }
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {
    children = {
      default: children,
      _ctx: currentRenderingInstance
    };
    type = 32
    /* SLOTS_CHILDREN */
    ;
  } else {
    children = String(children); // force teleport children to array so it can be moved around

    if (shapeFlag & 64
    /* TELEPORT */
    ) {
        type = 16
        /* ARRAY_CHILDREN */
        ;
        children = [createTextVNode(children)];
      } else {
      type = 8
      /* TEXT_CHILDREN */
      ;
    }
  }

  vnode.children = children;
  vnode.shapeFlag |= type;
}

function mergeProps(...args) {
  const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, args[0]);

  for (let i = 1; i < args.length; i++) {
    const toMerge = args[i];

    for (const key in toMerge) {
      if (key === 'class') {
        if (ret.class !== toMerge.class) {
          ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret.class, toMerge.class]);
        }
      } else if (key === 'style') {
        ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];

        if (existing !== incoming) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== '') {
        ret[key] = toMerge[key];
      }
    }
  }

  return ret;
}
/**
 * Actual implementation
 */


function renderList(source, renderItem) {
  let ret;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {
    ret = new Array(source.length);

    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i);
    }
  } else if (typeof source === 'number') {
    if ( true && !Number.isInteger(source)) {
      warn(`The v-for range expect an integer value but got ${source}.`);
      return [];
    }

    ret = new Array(source);

    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, renderItem);
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);

      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i);
      }
    }
  } else {
    ret = [];
  }

  return ret;
}
/**
 * Compiler runtime helper for creating dynamic slots object
 * @private
 */


function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i]; // array of dynamic slot generated by <template v-for="..." #[...]>

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      // conditional single slot generated by <template v-if="..." #foo>
      slots[slot.name] = slot.fn;
    }
  }

  return slots;
}
/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */


function renderSlot(slots, name, props = {}, // this is not a user-facing function, so the fallback is always generated by
// the compiler and guaranteed to be a function returning an array
fallback, noSlotted) {
  let slot = slots[name];

  if ( true && slot && slot.length > 1) {
    warn(`SSR-optimized slot function detected in a non-SSR-optimized render ` + `function. You need to mark this component with $dynamic-slots in the ` + `parent template.`);

    slot = () => [];
  } // a compiled slot disables block tracking by default to avoid manual
  // invocation interfering with template-based block tracking, but in
  // `renderSlot` we can be sure that it's template-based so we can force
  // enable it.


  if (slot && slot._c) {
    slot._d = false;
  }

  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment, {
    key: props.key || `_${name}`
  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1
  /* STABLE */
  ? 64
  /* STABLE_FRAGMENT */
  : -2
  /* BAIL */
  );

  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + '-s'];
  }

  if (slot && slot._c) {
    slot._d = true;
  }

  return rendered;
}

function ensureValidVNode(vnodes) {
  return vnodes.some(child => {
    if (!isVNode(child)) return true;
    if (child.type === Comment$1) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
    return true;
  }) ? vnodes : null;
}
/**
 * For prefixing keys in v-on="obj" with "on"
 * @private
 */


function toHandlers(obj) {
  const ret = {};

  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
    warn(`v-on with no argument expects an object value.`);
    return ret;
  }

  for (const key in obj) {
    ret[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];
  }

  return ret;
}
/**
 * #2437 In Vue 3, functional components do not have a public instance proxy but
 * they exist in the internal parent chain. For code that relies on traversing
 * public $parent chains, skip functional ones and go to the parent instead.
 */


const getPublicInstance = i => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};

const publicPropertiesMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), {
  $: i => i,
  $el: i => i.vnode.el,
  $data: i => i.data,
  $props: i =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0,
  $attrs: i =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0,
  $slots: i =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0,
  $refs: i =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0,
  $parent: i => getPublicInstance(i.parent),
  $root: i => getPublicInstance(i.root),
  $emit: i => i.emit,
  $options: i =>  true ? resolveMergedOptions(i) : 0,
  $forceUpdate: i => () => queueJob(i.update),
  $nextTick: i => nextTick.bind(i.proxy),
  $watch: i =>  true ? instanceWatch.bind(i) : 0
});
const PublicInstanceProxyHandlers = {
  get({
    _: instance
  }, key) {
    const {
      ctx,
      setupState,
      data,
      props,
      accessCache,
      type,
      appContext
    } = instance; // for internal formatters to know that this is a Vue instance

    if ( true && key === '__isVue') {
      return true;
    } // prioritize <script setup> bindings during dev.
    // this allows even properties that start with _ or $ to be used - so that
    // it aligns with the production behavior where the render fn is inlined and
    // indeed has access to all declared variables.


    if ( true && setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && setupState.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
      return setupState[key];
    } // data / props / ctx
    // This getter gets called for every property access on the render context
    // during render and is a major hotspot. The most expensive part of this
    // is the multiple hasOwn() calls. It's much faster to do a simple property
    // access on a plain object, so we use an accessCache object (with null
    // prototype) to memoize what access type a key corresponds to.


    let normalizedProps;

    if (key[0] !== '$') {
      const n = accessCache[key];

      if (n !== undefined) {
        switch (n) {
          case 0
          /* SETUP */
          :
            return setupState[key];

          case 1
          /* DATA */
          :
            return data[key];

          case 3
          /* CONTEXT */
          :
            return ctx[key];

          case 2
          /* PROPS */
          :
            return props[key];
          // default: just fallthrough
        }
      } else if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
        accessCache[key] = 0
        /* SETUP */
        ;
        return setupState[key];
      } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
        accessCache[key] = 1
        /* DATA */
        ;
        return data[key];
      } else if ( // only cache other properties when instance has declared (thus stable)
      // props
      (normalizedProps = instance.propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) {
        accessCache[key] = 2
        /* PROPS */
        ;
        return props[key];
      } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
        accessCache[key] = 3
        /* CONTEXT */
        ;
        return ctx[key];
      } else if ( false || shouldCacheAccess) {
        accessCache[key] = 4
        /* OTHER */
        ;
      }
    }

    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties; // public $xxx properties

    if (publicGetter) {
      if (key === '$attrs') {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get"
        /* GET */
        , key);
         true && markAttrsAccessed();
      }

      return publicGetter(instance);
    } else if ( // css module (injected by vue-loader)
    (cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
      // user may set custom properties to `this` that start with `$`
      accessCache[key] = 3
      /* CONTEXT */
      ;
      return ctx[key];
    } else if ( // global properties
    globalProperties = appContext.config.globalProperties, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else if ( true && currentRenderingInstance && (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    key.indexOf('__v') !== 0)) {
      if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (key[0] === '$' || key[0] === '_') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
        warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` + `character ("$" or "_") and is not proxied on the render context.`);
      } else if (instance === currentRenderingInstance) {
        warn(`Property ${JSON.stringify(key)} was accessed during render ` + `but is not defined on instance.`);
      }
    }
  },

  set({
    _: instance
  }, key, value) {
    const {
      data,
      setupState,
      ctx
    } = instance;

    if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
      setupState[key] = value;
    } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
      data[key] = value;
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {
       true && warn(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
      return false;
    }

    if (key[0] === '$' && key.slice(1) in instance) {
       true && warn(`Attempting to mutate public property "${key}". ` + `Properties starting with $ are reserved and readonly.`, instance);
      return false;
    } else {
      if ( true && key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }

    return true;
  },

  has({
    _: {
      data,
      setupState,
      accessCache,
      ctx,
      appContext,
      propsOptions
    }
  }, key) {
    let normalizedProps;
    return accessCache[key] !== undefined || data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key) || setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key) || (normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key);
  }

};

if (true) {
  PublicInstanceProxyHandlers.ownKeys = target => {
    warn(`Avoid app logic that relies on enumerating keys on a component instance. ` + `The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
  };
}

const RuntimeCompiledPublicInstanceProxyHandlers = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    // fast path for unscopables when using `with` block
    if (key === Symbol.unscopables) {
      return;
    }

    return PublicInstanceProxyHandlers.get(target, key, target);
  },

  has(_, key) {
    const has = key[0] !== '_' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyWhitelisted)(key);

    if ( true && !has && PublicInstanceProxyHandlers.has(_, key)) {
      warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
    }

    return has;
  }

}); // In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.

function createRenderContext(instance) {
  const target = {}; // expose internal instance for proxy handlers

  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  }); // expose public properties

  Object.keys(publicPropertiesMap).forEach(key => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
    });
  });
  return target;
} // dev only


function exposePropsOnRenderContext(instance) {
  const {
    ctx,
    propsOptions: [propsOptions]
  } = instance;

  if (propsOptions) {
    Object.keys(propsOptions).forEach(key => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
      });
    });
  }
} // dev only


function exposeSetupStateOnRenderContext(instance) {
  const {
    ctx,
    setupState
  } = instance;
  Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach(key => {
    if (!setupState.__isScriptSetup && (key[0] === '$' || key[0] === '_')) {
      warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` + `which are reserved prefixes for Vue internals.`);
      return;
    }

    Object.defineProperty(ctx, key, {
      enumerable: true,
      configurable: true,
      get: () => setupState[key],
      set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
    });
  });
}

const emptyAppContext = createAppContext();
let uid$1 = 0;

function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type; // inherit parent app context - or - if root, adopt from root vnode

  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    update: null,
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    effects: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resovled assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    emitted: null,
    // props default value
    propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };

  if (true) {
    instance.ctx = createRenderContext(instance);
  } else {}

  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  return instance;
}

let currentInstance = null;

const getCurrentInstance = () => currentInstance || currentRenderingInstance;

const setCurrentInstance = instance => {
  currentInstance = instance;
};

const isBuiltInTag = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('slot,component');

function validateComponentName(name, config) {
  const appIsNativeTag = config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO;

  if (isBuiltInTag(name) || appIsNativeTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component id: ' + name);
  }
}

function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4
  /* STATEFUL_COMPONENT */
  ;
}

let isInSSRComponentSetup = false;

function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const {
    props,
    children
  } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : undefined;
  isInSSRComponentSetup = false;
  return setupResult;
}

function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;

  if (true) {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }

    if (Component.components) {
      const names = Object.keys(Component.components);

      for (let i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }

    if (Component.directives) {
      const names = Object.keys(Component.directives);

      for (let i = 0; i < names.length; i++) {
        validateDirectiveName(names[i]);
      }
    }

    if (Component.compilerOptions && isRuntimeOnly()) {
      warn(`"compilerOptions" is only supported when using a build of Vue that ` + `includes the runtime compiler. Since you are using a runtime-only ` + `build, the options should be passed via your build tool config instead.`);
    }
  } // 0. create render proxy property access cache


  instance.accessCache = Object.create(null); // 1. create public instance / render proxy
  // also mark it raw so it's never observed

  instance.proxy = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));

  if (true) {
    exposePropsOnRenderContext(instance);
  } // 2. call setup()


  const {
    setup
  } = Component;

  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    currentInstance = instance;
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    const setupResult = callWithErrorHandling(setup, instance, 0
    /* SETUP_FUNCTION */
    , [ true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0, setupContext]);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    currentInstance = null;

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult)) {
      const unsetInstance = () => {
        currentInstance = null;
      };

      setupResult.then(unsetInstance, unsetInstance);

      if (isSSR) {
        // return the promise so server-renderer can wait on it
        return setupResult.then(resolvedResult => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch(e => {
          handleError(e, instance, 0
          /* SETUP_FUNCTION */
          );
        });
      } else {
        // async setup returned Promise.
        // bail here and wait for re-entry.
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}

function handleSetupResult(instance, setupResult, isSSR) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {
    // setup returned an inline render function
    {
      instance.render = setupResult;
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {
    if ( true && isVNode(setupResult)) {
      warn(`setup() should not return VNodes directly - ` + `return a render function instead.`);
    } // setup returned bindings.
    // assuming a render function compiled from template is present.


    if (true) {
      instance.devtoolsRawSetupState = setupResult;
    }

    instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);

    if (true) {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if ( true && setupResult !== undefined) {
    warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);
  }

  finishComponentSetup(instance, isSSR);
}

let compile; // dev only

const isRuntimeOnly = () => !compile;
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */


function registerRuntimeCompiler(_compile) {
  compile = _compile;
}

function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type; // template / render function normalization

  if (!instance.render) {
    // could be set from setup()
    if (compile && !Component.render) {
      const template = Component.template;

      if (template) {
        if (true) {
          startMeasure(instance, `compile`);
        }

        const {
          isCustomElement,
          compilerOptions
        } = instance.appContext.config;
        const {
          delimiters,
          compilerOptions: componentCompilerOptions
        } = Component;
        const finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);

        if (true) {
          endMeasure(instance, `compile`);
        }
      }
    }

    instance.render = Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP; // for runtime-compiled render functions using `with` blocks, the render
    // proxy used needs a different `has` handler which is more performant and
    // also only allows a whitelist of globals to fallthrough.

    if (instance.render._rc) {
      instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  } // support for 2.x options


  if (true) {
    currentInstance = instance;
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    applyOptions(instance);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    currentInstance = null;
  } // warn missing template/render
  // the runtime compilation of template in SSR is done by server-render


  if ( true && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP && !isSSR) {
    /* istanbul ignore if */
    if (!compile && Component.template) {
      warn(`Component provided template option but ` + `runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
      /* should not happen */
      );
    } else {
      warn(`Component is missing template or render function.`);
    }
  }
}

const attrDevProxyHandlers = {
  get: (target, key) => {
    markAttrsAccessed();
    return target[key];
  },
  set: () => {
    warn(`setupContext.attrs is readonly.`);
    return false;
  },
  deleteProperty: () => {
    warn(`setupContext.attrs is readonly.`);
    return false;
  }
};

function createSetupContext(instance) {
  const expose = exposed => {
    if ( true && instance.exposed) {
      warn(`expose() should be called only once per setup().`);
    }

    instance.exposed = exposed || {};
  };

  if (true) {
    let attrs; // We use getters in dev in case libs like test-utils overwrite instance
    // properties (overwrites should not be done in prod)

    return Object.freeze({
      get attrs() {
        return attrs || (attrs = new Proxy(instance.attrs, attrDevProxyHandlers));
      },

      get slots() {
        return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.slots);
      },

      get emit() {
        return (event, ...args) => instance.emit(event, ...args);
      },

      expose
    });
  } else {}
}

function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      }

    }));
  }
} // record effects created during a component's setup() so that they can be
// stopped when the component unmounts


function recordInstanceBoundEffect(effect, instance = currentInstance) {
  if (instance) {
    (instance.effects || (instance.effects = [])).push(effect);
  }
}

const classifyRE = /(?:^|[-_])(\w)/g;

const classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');

function getComponentName(Component) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component) ? Component.displayName || Component.name : Component.name;
}
/* istanbul ignore next */


function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);

  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);

    if (match) {
      name = match[1];
    }
  }

  if (!name && instance && instance.parent) {
    // try to infer the name based on reverse resolution
    const inferFromRegistry = registry => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };

    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }

  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}

function isClassComponent(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && '__vccOpts' in value;
}

function computed(getterOrOptions) {
  const c = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions);
  recordInstanceBoundEffect(c.effect);
  return c;
}

 true ? Object.freeze({}) : 0;
 true ? Object.freeze([]) : 0;

const isFunction = val => typeof val === 'function';

const isObject = val => val !== null && typeof val === 'object';

const isPromise = val => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
}; // dev only


const warnRuntimeUsage = method => warn(`${method}() is a compiler-hint helper that is only usable inside ` + `<script setup> of a single file component. Its arguments should be ` + `compiled away and passing it at runtime has no effect.`); // implementation


function defineProps() {
  if (true) {
    warnRuntimeUsage(`defineProps`);
  }

  return null;
} // implementation


function defineEmits() {
  if (true) {
    warnRuntimeUsage(`defineEmits`);
  }

  return null;
}
/**
 * @deprecated use `defineEmits` instead.
 */


const defineEmit = defineEmits;
/**
 * Vue `<script setup>` compiler macro for declaring a component's exposed
 * instance properties when it is accessed by a parent component via template
 * refs.
 *
 * `<script setup>` components are closed by default - i.e. varaibles inside
 * the `<script setup>` scope is not exposed to parent unless explicitly exposed
 * via `defineExpose`.
 *
 * This is only usable inside `<script setup>`, is compiled away in the
 * output and should **not** be actually called at runtime.
 */

function defineExpose(exposed) {
  if (true) {
    warnRuntimeUsage(`defineExpose`);
  }
}
/**
 * Vue `<script setup>` compiler macro for providing props default values when
 * using type-based `defineProps` decalration.
 *
 * Example usage:
 * ```ts
 * withDefaults(defineProps<{
 *   size?: number
 *   labels?: string[]
 * }>(), {
 *   size: 3,
 *   labels: () => ['default label']
 * })
 * ```
 *
 * This is only usable inside `<script setup>`, is compiled away in the output
 * and should **not** be actually called at runtime.
 */


function withDefaults(props, defaults) {
  if (true) {
    warnRuntimeUsage(`withDefaults`);
  }

  return null;
}
/**
 * @deprecated use `useSlots` and `useAttrs` instead.
 */


function useContext() {
  if (true) {
    warn(`\`useContext()\` has been deprecated and will be removed in the ` + `next minor release. Use \`useSlots()\` and \`useAttrs()\` instead.`);
  }

  return getContext();
}

function useSlots() {
  return getContext().slots;
}

function useAttrs() {
  return getContext().attrs;
}

function getContext() {
  const i = getCurrentInstance();

  if ( true && !i) {
    warn(`useContext() called without active instance.`);
  }

  return i.setupContext || (i.setupContext = createSetupContext(i));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */


function mergeDefaults( // the base props is compiler-generated and guaranteed to be in this shape.
props, defaults) {
  for (const key in defaults) {
    const val = props[key];

    if (val) {
      val.default = defaults[key];
    } else if (val === null) {
      props[key] = {
        default: defaults[key]
      };
    } else if (true) {
      warn(`props default key "${key}" has no corresponding declaration.`);
    }
  }

  return props;
}
/**
 * Runtime helper for storing and resuming current instance context in
 * async setup().
 */


function withAsyncContext(awaitable) {
  const ctx = getCurrentInstance();
  setCurrentInstance(null); // unset after storing instance

  if ( true && !ctx) {
    warn(`withAsyncContext() called when there is no active context instance.`);
  }

  return isPromise(awaitable) ? awaitable.then(res => {
    setCurrentInstance(ctx);
    return res;
  }, err => {
    setCurrentInstance(ctx);
    throw err;
  }) : awaitable;
} // Actual implementation


function h(type, propsOrChildren, children) {
  const l = arguments.length;

  if (l === 2) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {
      // single vnode without props
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      } // props without children


      return createVNode(type, propsOrChildren);
    } else {
      // omit props
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }

    return createVNode(type, propsOrChildren, children);
  }
}

const ssrContextKey = Symbol( true ? `ssrContext` : 0);

const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);

    if (!ctx) {
      warn(`Server rendering context not provided. Make sure to only call ` + `useSSRContext() conditionally in the server build.`);
    }

    return ctx;
  }
};

function initCustomFormatter() {
  /* eslint-disable no-restricted-globals */
  if ( false || typeof window === 'undefined') {
    return;
  }

  const vueStyle = {
    style: 'color:#3ba776'
  };
  const numberStyle = {
    style: 'color:#0b1bc9'
  };
  const stringStyle = {
    style: 'color:#b62e24'
  };
  const keywordStyle = {
    style: 'color:#9d288c'
  }; // custom formatter for Chrome
  // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html

  const formatter = {
    header(obj) {
      // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
        return null;
      }

      if (obj.__isVue) {
        return ['div', vueStyle, `VueInstance`];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {
        return ['div', {}, ['span', vueStyle, genRefFlag(obj)], '<', formatValue(obj.value), `>`];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {
        return ['div', {}, ['span', vueStyle, 'Reactive'], '<', formatValue(obj), `>${(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? ` (readonly)` : ``}`];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {
        return ['div', {}, ['span', vueStyle, 'Readonly'], '<', formatValue(obj), '>'];
      }

      return null;
    },

    hasBody(obj) {
      return obj && obj.__isVue;
    },

    body(obj) {
      if (obj && obj.__isVue) {
        return ['div', {}, ...formatInstance(obj.$)];
      }
    }

  };

  function formatInstance(instance) {
    const blocks = [];

    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock('props', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));
    }

    if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      blocks.push(createInstanceBlock('setup', instance.setupState));
    }

    if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      blocks.push(createInstanceBlock('data', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));
    }

    const computed = extractKeys(instance, 'computed');

    if (computed) {
      blocks.push(createInstanceBlock('computed', computed));
    }

    const injected = extractKeys(instance, 'inject');

    if (injected) {
      blocks.push(createInstanceBlock('injected', injected));
    }

    blocks.push(['div', {}, ['span', {
      style: keywordStyle.style + ';opacity:0.66'
    }, '$ (internal): '], ['object', {
      object: instance
    }]]);
    return blocks;
  }

  function createInstanceBlock(type, target) {
    target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);

    if (!Object.keys(target).length) {
      return ['span', {}];
    }

    return ['div', {
      style: 'line-height:1.25em;margin-bottom:0.6em'
    }, ['div', {
      style: 'color:#476582'
    }, type], ['div', {
      style: 'padding-left:1.25em'
    }, ...Object.keys(target).map(key => {
      return ['div', {}, ['span', keywordStyle, key + ': '], formatValue(target[key], false)];
    })]];
  }

  function formatValue(v, asRaw = true) {
    if (typeof v === 'number') {
      return ['span', numberStyle, v];
    } else if (typeof v === 'string') {
      return ['span', stringStyle, JSON.stringify(v)];
    } else if (typeof v === 'boolean') {
      return ['span', keywordStyle, v];
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {
      return ['object', {
        object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v
      }];
    } else {
      return ['span', stringStyle, String(v)];
    }
  }

  function extractKeys(instance, type) {
    const Comp = instance.type;

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {
      return;
    }

    const extracted = {};

    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }

    return extracted;
  }

  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts) {
      return true;
    }

    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }

    if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {
      return true;
    }
  }

  function genRefFlag(v) {
    if (v._shallow) {
      return `ShallowRef`;
    }

    if (v.effect) {
      return `ComputedRef`;
    }

    return `Ref`;
  }

  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
} // Core API ------------------------------------------------------------------


const version = "3.1.4";
/**
 * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
 * @internal
 */

const ssrUtils = null;
/**
 * @internal only exposed in compat builds
 */

const resolveFilter = null;
/**
 * @internal only exposed in compat builds.
 */

const compatUtils = null;


/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineEmit": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmit),
/* harmony export */   "defineEmits": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   "defineExpose": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   "useContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useContext),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useSlots": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "withAsyncContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDefaults": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "Transition": () => (/* binding */ Transition),
/* harmony export */   "TransitionGroup": () => (/* binding */ TransitionGroup),
/* harmony export */   "createApp": () => (/* binding */ createApp),
/* harmony export */   "createSSRApp": () => (/* binding */ createSSRApp),
/* harmony export */   "hydrate": () => (/* binding */ hydrate),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "useCssModule": () => (/* binding */ useCssModule),
/* harmony export */   "useCssVars": () => (/* binding */ useCssVars),
/* harmony export */   "vModelCheckbox": () => (/* binding */ vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* binding */ vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* binding */ vModelRadio),
/* harmony export */   "vModelSelect": () => (/* binding */ vModelSelect),
/* harmony export */   "vModelText": () => (/* binding */ vModelText),
/* harmony export */   "vShow": () => (/* binding */ vShow),
/* harmony export */   "withKeys": () => (/* binding */ withKeys),
/* harmony export */   "withModifiers": () => (/* binding */ withModifiers)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");



const svgNS = 'http://www.w3.org/2000/svg';
const doc = typeof document !== 'undefined' ? document : null;
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: child => {
    const parent = child.parentNode;

    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? {
      is
    } : undefined);

    if (tag === 'select' && props && props.multiple != null) {
      el.setAttribute('multiple', props.multiple);
    }

    return el;
  },
  createText: text => doc.createTextNode(text),
  createComment: text => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: node => node.parentNode,
  nextSibling: node => node.nextSibling,
  querySelector: selector => doc.querySelector(selector),

  setScopeId(el, id) {
    el.setAttribute(id, '');
  },

  cloneNode(el) {
    const cloned = el.cloneNode(true); // #3072
    // - in `patchDOMProp`, we store the actual value in the `el._value` property.
    // - normally, elements using `:value` bindings will not be hoisted, but if
    //   the bound value is a constant, e.g. `:value="true"` - they do get
    //   hoisted.
    // - in production, hoisted nodes are cloned when subsequent inserts, but
    //   cloneNode() does not copy the custom property we attached.
    // - This may need to account for other custom DOM properties we attach to
    //   elements in addition to `_value` in the future.

    if (`_value` in el) {
      cloned._value = el._value;
    }

    return cloned;
  },

  // __UNSAFE__
  // Reason: insertAdjacentHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, cached) {
    if (cached) {
      let first;
      let last;
      let i = 0;
      let l = cached.length;

      for (; i < l; i++) {
        const node = cached[i].cloneNode(true);
        if (i === 0) first = node;
        if (i === l - 1) last = node;
        parent.insertBefore(node, anchor);
      }

      return [first, last];
    } // <parent> before | first ... last | anchor </parent>


    const before = anchor ? anchor.previousSibling : parent.lastChild;

    if (anchor) {
      let insertionPoint;
      let usingTempInsertionPoint = false;

      if (anchor instanceof Element) {
        insertionPoint = anchor;
      } else {
        // insertAdjacentHTML only works for elements but the anchor is not an
        // element...
        usingTempInsertionPoint = true;
        insertionPoint = isSVG ? doc.createElementNS(svgNS, 'g') : doc.createElement('div');
        parent.insertBefore(insertionPoint, anchor);
      }

      insertionPoint.insertAdjacentHTML('beforebegin', content);

      if (usingTempInsertionPoint) {
        parent.removeChild(insertionPoint);
      }
    } else {
      parent.insertAdjacentHTML('beforeend', content);
    }

    let first = before ? before.nextSibling : parent.firstChild;
    const last = anchor ? anchor.previousSibling : parent.lastChild;
    const ret = [];

    while (first) {
      ret.push(first);
      if (first === last) break;
      first = first.nextSibling;
    }

    return ret;
  }

}; // compiler should normalize class + :class bindings on the same element
// into a single binding ['staticClass', dynamic]

function patchClass(el, value, isSVG) {
  if (value == null) {
    value = '';
  }

  if (isSVG) {
    el.setAttribute('class', value);
  } else {
    // directly setting className should be faster than setAttribute in theory
    // if this is an element during a transition, take the temporary transition
    // classes into account.
    const transitionClasses = el._vtc;

    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');
    }

    el.className = value;
  }
}

function patchStyle(el, prev, next) {
  const style = el.style;

  if (!next) {
    el.removeAttribute('style');
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next)) {
    if (prev !== next) {
      const current = style.display;
      style.cssText = next; // indicates that the `display` of the element is controlled by `v-show`,
      // so we always keep the current `display` value regardless of the `style` value,
      // thus handing over control to `v-show`.

      if ('_vod' in el) {
        style.display = current;
      }
    }
  } else {
    for (const key in next) {
      setStyle(style, key, next[key]);
    }

    if (prev && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, '');
        }
      }
    }
  }
}

const importantRE = /\s*!important$/;

function setStyle(style, name, val) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {
    val.forEach(v => setStyle(style, name, v));
  } else {
    if (name.startsWith('--')) {
      // custom property definition
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);

      if (importantRE.test(val)) {
        // !important
        style.setProperty((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(prefixed), val.replace(importantRE, ''), 'important');
      } else {
        style[prefixed] = val;
      }
    }
  }
}

const prefixes = ['Webkit', 'Moz', 'ms'];
const prefixCache = {};

function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];

  if (cached) {
    return cached;
  }

  let name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(rawName);

  if (name !== 'filter' && name in style) {
    return prefixCache[rawName] = name;
  }

  name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);

  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;

    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }

  return rawName;
}

const xlinkNS = 'http://www.w3.org/1999/xlink';

function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith('xlink:')) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    // note we are only checking boolean attributes that don't have a
    // corresponding dom prop of the same name here.
    const isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key);

    if (value == null || isBoolean && value === false) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? '' : value);
    }
  }
} // __UNSAFE__
// functions. The user is responsible for using them with only trusted content.


function patchDOMProp(el, key, value, // the following args are passed only due to potential innerHTML/textContent
// overriding existing VNodes, in which case the old tree must be properly
// unmounted.
prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === 'innerHTML' || key === 'textContent') {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }

    el[key] = value == null ? '' : value;
    return;
  }

  if (key === 'value' && el.tagName !== 'PROGRESS') {
    // store value as _value as well since
    // non-string values will be stringified.
    el._value = value;
    const newValue = value == null ? '' : value;

    if (el.value !== newValue) {
      el.value = newValue;
    }

    if (value == null) {
      el.removeAttribute(key);
    }

    return;
  }

  if (value === '' || value == null) {
    const type = typeof el[key];

    if (value === '' && type === 'boolean') {
      // e.g. <select multiple> compiles to { multiple: '' }
      el[key] = true;
      return;
    } else if (value == null && type === 'string') {
      // e.g. <div :id="null">
      el[key] = '';
      el.removeAttribute(key);
      return;
    } else if (type === 'number') {
      // e.g. <img :width="null">
      el[key] = 0;
      el.removeAttribute(key);
      return;
    }
  } // some properties perform value validation and throw


  try {
    el[key] = value;
  } catch (e) {
    if (true) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: ` + `value ${value} is invalid.`, e);
    }
  }
} // Async edge case fix requires storing an event listener's attach timestamp.


let _getNow = Date.now;
let skipTimestampCheck = false;

if (typeof window !== 'undefined') {
  // Determine what event timestamp the browser is using. Annoyingly, the
  // timestamp can either be hi-res (relative to page load) or low-res
  // (relative to UNIX epoch), so in order to compare time we have to use the
  // same timestamp type when saving the flush timestamp.
  if (_getNow() > document.createEvent('Event').timeStamp) {
    // if the low-res timestamp which is bigger than the event timestamp
    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listeners as well.
    _getNow = () => performance.now();
  } // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation
  // and does not fire microtasks in between event propagation, so safe to exclude.


  const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
  skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
} // To avoid the overhead of repeatedly calling performance.now(), we cache
// and use the same timestamp for all event listeners attached in the same tick.


let cachedNow = 0;
const p = Promise.resolve();

const reset = () => {
  cachedNow = 0;
};

const getNow = () => cachedNow || (p.then(reset), cachedNow = _getNow());

function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}

function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}

function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  // vei = vue event invokers
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];

  if (nextValue && existingInvoker) {
    // patch
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);

    if (nextValue) {
      // add
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      // remove
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = undefined;
    }
  }
}

const optionsModifierRE = /(?:Once|Passive|Capture)$/;

function parseName(name) {
  let options;

  if (optionsModifierRE.test(name)) {
    options = {};
    let m;

    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }

  return [(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name.slice(2)), options];
}

function createInvoker(initialValue, instance) {
  const invoker = e => {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    const timeStamp = e.timeStamp || _getNow();

    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5
      /* NATIVE_EVENT_HANDLER */
      , [e]);
    }
  };

  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}

function patchStopImmediatePropagation(e, value) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    const originalStop = e.stopImmediatePropagation;

    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };

    return value.map(fn => e => !e._stopped && fn(e));
  } else {
    return value;
  }
}

const nativeOnRE = /^on[a-z]/;

const forcePatchProp = (_, key) => key === 'value';

const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  switch (key) {
    // special
    case 'class':
      patchClass(el, nextValue, isSVG);
      break;

    case 'style':
      patchStyle(el, prevValue, nextValue);
      break;

    default:
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        // ignore v-model listeners
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
      } else {
        // special case for <input v-model type="checkbox"> with
        // :true-value & :false-value
        // store value as dom properties since non-string values will be
        // stringified.
        if (key === 'true-value') {
          el._trueValue = nextValue;
        } else if (key === 'false-value') {
          el._falseValue = nextValue;
        }

        patchAttr(el, key, nextValue, isSVG);
      }

      break;
  }
};

function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    // most keys must be set as attribute on svg elements to work
    // ...except innerHTML
    if (key === 'innerHTML') {
      return true;
    } // or native onclick with function values


    if (key in el && nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
      return true;
    }

    return false;
  } // spellcheck and draggable are numerated attrs, however their
  // corresponding DOM properties are actually booleans - this leads to
  // setting it with a string "false" value leading it to be coerced to
  // `true`, so we need to always treat them as attributes.
  // Note that `contentEditable` doesn't have this problem: its DOM
  // property is also enumerated string values.


  if (key === 'spellcheck' || key === 'draggable') {
    return false;
  } // #1787, #2840 form property on form elements is readonly and must be set as
  // attribute.


  if (key === 'form') {
    return false;
  } // #1526 <input list> must be set as attribute


  if (key === 'list' && el.tagName === 'INPUT') {
    return false;
  } // #2766 <textarea type> must be set as attribute


  if (key === 'type' && el.tagName === 'TEXTAREA') {
    return false;
  } // native onclick with string value, must be set as attribute


  if (nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
    return false;
  }

  return key in el;
}

function useCssModule(name = '$style') {
  /* istanbul ignore else */
  {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();

    if (!instance) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssModule must be called inside setup()`);
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }

    const modules = instance.type.__cssModules;

    if (!modules) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS modules injected.`);
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }

    const mod = modules[name];

    if (!mod) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS module named "${name}".`);
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }

    return mod;
  }
}
/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */


function useCssVars(getter) {
  const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
  /* istanbul ignore next */

  if (!instance) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssVars is called without current active component instance.`);
    return;
  }

  const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));

  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect)(setVars, {
    flush: 'post'
  }));
  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(setVars);
}

function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128
  /* SUSPENSE */
  ) {
      const suspense = vnode.suspense;
      vnode = suspense.activeBranch;

      if (suspense.pendingBranch && !suspense.isHydrating) {
        suspense.effects.push(() => {
          setVarsOnVNode(suspense.activeBranch, vars);
        });
      }
    } // drill down HOCs until it's a non-component vnode


  while (vnode.component) {
    vnode = vnode.component.subTree;
  }

  if (vnode.shapeFlag & 1
  /* ELEMENT */
  && vnode.el) {
    const style = vnode.el.style;

    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
    }
  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
    vnode.children.forEach(c => setVarsOnVNode(c, vars));
  }
}

const TRANSITION = 'transition';
const ANIMATION = 'animation'; // DOM Transition is a higher-order-component based on the platform-agnostic
// base Transition component, with DOM-specific logic.

const Transition = (props, {
  slots
}) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots);

Transition.displayName = 'Transition';
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition.props, DOMTransitionPropsValidators);
/**
 * #3227 Incoming hooks may be merged into arrays when wrapping Transition
 * with custom HOCs.
 */

const callHook = (hook, args = []) => {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
    hook.forEach(h => h(...args));
  } else if (hook) {
    hook(...args);
  }
};
/**
 * Check if a hook expects a callback (2nd arg), which means the user
 * intends to explicitly control the end of the transition.
 */


const hasExplicitCallback = hook => {
  return hook ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook) ? hook.some(h => h.length > 1) : hook.length > 1 : false;
};

function resolveTransitionProps(rawProps) {
  const baseProps = {};

  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }

  if (rawProps.css === false) {
    return baseProps;
  }

  const {
    name = 'v',
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;

  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };

  const finishLeave = (el, done) => {
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };

  const makeEnterHook = isAppear => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;

      const resolve = () => finishEnter(el, isAppear, done);

      callHook(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);

        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };

  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },

    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },

    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),

    onLeave(el, done) {
      const resolve = () => finishLeave(el, done);

      addTransitionClass(el, leaveFromClass); // force reflow so *-leave-from classes immediately take effect (#2593)

      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);

        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(onLeave, [el, resolve]);
    },

    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },

    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },

    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }

  });
}

function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}

function NumberOf(val) {
  const res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(val);
  if (true) validateDuration(res);
  return res;
}

function validateDuration(val) {
  if (typeof val !== 'number') {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is not a valid number - ` + `got ${JSON.stringify(val)}.`);
  } else if (isNaN(val)) {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is NaN - ` + 'the duration expression might be incorrect.');
  }
}

function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach(c => c && el.classList.add(c));
  (el._vtc || (el._vtc = new Set())).add(cls);
}

function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach(c => c && el.classList.remove(c));
  const {
    _vtc
  } = el;

  if (_vtc) {
    _vtc.delete(cls);

    if (!_vtc.size) {
      el._vtc = undefined;
    }
  }
}

function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}

let endId = 0;

function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id = el._endId = ++endId;

  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve();
    }
  };

  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }

  const {
    type,
    timeout,
    propCount
  } = getTransitionInfo(el, expectedType);

  if (!type) {
    return resolve();
  }

  const endEvent = type + 'end';
  let ended = 0;

  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };

  const onEnd = e => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };

  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}

function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  const getStyleProperties = key => (styles[key] || '').split(', ');

  const transitionDelays = getStyleProperties(TRANSITION + 'Delay');
  const transitionDurations = getStyleProperties(TRANSITION + 'Duration');
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(ANIMATION + 'Delay');
  const animationDurations = getStyleProperties(ANIMATION + 'Duration');
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}

function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer
// numbers in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down
// (i.e. acting as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
} // synchronously force layout to put elements into a certain state


function forceReflow() {
  return document.body.offsetHeight;
}

const positionMap = new WeakMap();
const newPositionMap = new WeakMap();
const TransitionGroupImpl = {
  name: 'TransitionGroup',
  props: /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),

  setup(props, {
    slots
  }) {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();
    let prevChildren;
    let children;
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {
      // children is guaranteed to exist after initial render
      if (!prevChildren.length) {
        return;
      }

      const moveClass = props.moveClass || `${props.name || 'v'}-move`;

      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      } // we divide the work into three loops to avoid mixing DOM reads and writes
      // in each iteration - which helps prevent layout thrashing.


      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation); // force reflow to put everything in position

      forceReflow();
      movedChildren.forEach(c => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = '';

        const cb = el._moveCb = e => {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener('transitionend', cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };

        el.addEventListener('transitionend', cb);
      });
    });
    return () => {
      const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toRaw)(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;
      prevChildren = children;
      children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots.default()) : [];

      for (let i = 0; i < children.length; i++) {
        const child = children[i];

        if (child.key != null) {
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
        } else if (true) {
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<TransitionGroup> children must be keyed.`);
        }
      }

      if (prevChildren) {
        for (let i = 0; i < prevChildren.length; i++) {
          const child = prevChildren[i];
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }

      return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);
    };
  }

};
const TransitionGroup = TransitionGroupImpl;

function callPendingCbs(c) {
  const el = c.el;

  if (el._moveCb) {
    el._moveCb();
  }

  if (el._enterCb) {
    el._enterCb();
  }
}

function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}

function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;

  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = '0s';
    return c;
  }
}

function hasCSSTransform(el, root, moveClass) {
  // Detect whether an element with the move class applied has
  // CSS transitions. Since the element may be inside an entering
  // transition at this very moment, we make a clone of it and remove
  // all other transition classes applied to ensure only the move class
  // is applied.
  const clone = el.cloneNode();

  if (el._vtc) {
    el._vtc.forEach(cls => {
      cls.split(/\s+/).forEach(c => c && clone.classList.remove(c));
    });
  }

  moveClass.split(/\s+/).forEach(c => c && clone.classList.add(c));
  clone.style.display = 'none';
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const {
    hasTransform
  } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}

const getModelAssigner = vnode => {
  const fn = vnode.props['onUpdate:modelValue'];
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn) ? value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(fn, value) : fn;
};

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  const target = e.target;

  if (target.composing) {
    target.composing = false;
    trigger(target, 'input');
  }
}

function trigger(el, type) {
  const e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
} // We are exporting the v-model runtime directly as vnode hooks so that it can
// be tree-shaken in case v-model is never used.


const vModelText = {
  created(el, {
    modifiers: {
      lazy,
      trim,
      number
    }
  }, vnode) {
    el._assign = getModelAssigner(vnode);
    const castToNumber = number || el.type === 'number';
    addEventListener(el, lazy ? 'change' : 'input', e => {
      if (e.target.composing) return;
      let domValue = el.value;

      if (trim) {
        domValue = domValue.trim();
      } else if (castToNumber) {
        domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(domValue);
      }

      el._assign(domValue);
    });

    if (trim) {
      addEventListener(el, 'change', () => {
        el.value = el.value.trim();
      });
    }

    if (!lazy) {
      addEventListener(el, 'compositionstart', onCompositionStart);
      addEventListener(el, 'compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
      // switching focus before confirming composition choice
      // this also fixes the issue where some browsers e.g. iOS Chrome
      // fires "change" instead of "input" on autocomplete.

      addEventListener(el, 'change', onCompositionEnd);
    }
  },

  // set value on mounted so it's after min/max for type="range"
  mounted(el, {
    value
  }) {
    el.value = value == null ? '' : value;
  },

  beforeUpdate(el, {
    value,
    modifiers: {
      trim,
      number
    }
  }, vnode) {
    el._assign = getModelAssigner(vnode); // avoid clearing unresolved text. #2302

    if (el.composing) return;

    if (document.activeElement === el) {
      if (trim && el.value.trim() === value) {
        return;
      }

      if ((number || el.type === 'number') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(el.value) === value) {
        return;
      }
    }

    const newValue = value == null ? '' : value;

    if (el.value !== newValue) {
      el.value = newValue;
    }
  }

};
const vModelCheckbox = {
  created(el, _, vnode) {
    el._assign = getModelAssigner(vnode);
    addEventListener(el, 'change', () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el._assign;

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(modelValue)) {
        const index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(modelValue, elementValue);
        const found = index !== -1;

        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)) {
        const cloned = new Set(modelValue);

        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }

        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },

  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,

  beforeUpdate(el, binding, vnode) {
    el._assign = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }

};

function setChecked(el, {
  value,
  oldValue
}, vnode) {
  el._modelValue = value;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, getCheckboxValue(el, true));
  }
}

const vModelRadio = {
  created(el, {
    value
  }, vnode) {
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
    el._assign = getModelAssigner(vnode);
    addEventListener(el, 'change', () => {
      el._assign(getValue(el));
    });
  },

  beforeUpdate(el, {
    value,
    oldValue
  }, vnode) {
    el._assign = getModelAssigner(vnode);

    if (value !== oldValue) {
      el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
    }
  }

};
const vModelSelect = {
  created(el, {
    value,
    modifiers: {
      number
    }
  }, vnode) {
    const isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);
    addEventListener(el, 'change', () => {
      const selectedVal = Array.prototype.filter.call(el.options, o => o.selected).map(o => number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(getValue(o)) : getValue(o));

      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el._assign = getModelAssigner(vnode);
  },

  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, {
    value
  }) {
    setSelected(el, value);
  },

  beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },

  updated(el, {
    value
  }) {
    setSelected(el, value);
  }

};

function setSelected(el, value) {
  const isMultiple = el.multiple;

  if (isMultiple && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<select multiple v-model> expects an Array or Set value for its binding, ` + `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
    return;
  }

  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);

    if (isMultiple) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(getValue(option), value)) {
        if (el.selectedIndex !== i) el.selectedIndex = i;
        return;
      }
    }
  }

  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
} // retrieve raw value set via :value bindings


function getValue(el) {
  return '_value' in el ? el._value : el.value;
} // retrieve raw value for true-value and false-value set via :true-value or :false-value bindings


function getCheckboxValue(el, checked) {
  const key = checked ? '_trueValue' : '_falseValue';
  return key in el ? el[key] : checked;
}

const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, 'created');
  },

  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, 'mounted');
  },

  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
  },

  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, 'updated');
  }

};

function callModelHook(el, binding, vnode, prevVNode, hook) {
  let modelToUse;

  switch (el.tagName) {
    case 'SELECT':
      modelToUse = vModelSelect;
      break;

    case 'TEXTAREA':
      modelToUse = vModelText;
      break;

    default:
      switch (vnode.props && vnode.props.type) {
        case 'checkbox':
          modelToUse = vModelCheckbox;
          break;

        case 'radio':
          modelToUse = vModelRadio;
          break;

        default:
          modelToUse = vModelText;
      }

  }

  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}

const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
const modifierGuards = {
  stop: e => e.stopPropagation(),
  prevent: e => e.preventDefault(),
  self: e => e.target !== e.currentTarget,
  ctrl: e => !e.ctrlKey,
  shift: e => !e.shiftKey,
  alt: e => !e.altKey,
  meta: e => !e.metaKey,
  left: e => 'button' in e && e.button !== 0,
  middle: e => 'button' in e && e.button !== 1,
  right: e => 'button' in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
};
/**
 * @private
 */

const withModifiers = (fn, modifiers) => {
  return (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }

    return fn(event, ...args);
  };
}; // Kept for 2.x compat.
// Note: IE11 compat for `spacebar` and `del` is removed for now.


const keyNames = {
  esc: 'escape',
  space: ' ',
  up: 'arrow-up',
  left: 'arrow-left',
  right: 'arrow-right',
  down: 'arrow-down',
  delete: 'backspace'
};
/**
 * @private
 */

const withKeys = (fn, modifiers) => {
  return event => {
    if (!('key' in event)) {
      return;
    }

    const eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);

    if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {
      return fn(event);
    }
  };
};

const vShow = {
  beforeMount(el, {
    value
  }, {
    transition
  }) {
    el._vod = el.style.display === 'none' ? '' : el.style.display;

    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },

  mounted(el, {
    value
  }, {
    transition
  }) {
    if (transition && value) {
      transition.enter(el);
    }
  },

  updated(el, {
    value,
    oldValue
  }, {
    transition
  }) {
    if (!value === !oldValue) return;

    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },

  beforeUnmount(el, {
    value
  }) {
    setDisplay(el, value);
  }

};

function setDisplay(el, value) {
  el.style.display = value ? el._vod : 'none';
}

const rendererOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
  patchProp,
  forcePatchProp
}, nodeOps); // lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.

let renderer;
let enabledHydration = false;

function ensureRenderer() {
  return renderer || (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions));
}

function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);
  enabledHydration = true;
  return renderer;
} // use explicit type casts here to avoid import() calls in rolled-up d.ts


const render = (...args) => {
  ensureRenderer().render(...args);
};

const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};

const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);

  if (true) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }

  const {
    mount
  } = app;

  app.mount = containerOrSelector => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app._component;

    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(component) && !component.render && !component.template) {
      // __UNSAFE__
      // Reason: potential execution of JS expressions in in-DOM template.
      // The user must make sure the in-DOM template is trusted. If it's
      // rendered by the server, the template should not contain any user data.
      component.template = container.innerHTML;
    } // clear content before mounting


    container.innerHTML = '';
    const proxy = mount(container, false, container instanceof SVGElement);

    if (container instanceof Element) {
      container.removeAttribute('v-cloak');
      container.setAttribute('data-v-app', '');
    }

    return proxy;
  };

  return app;
};

const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);

  if (true) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }

  const {
    mount
  } = app;

  app.mount = containerOrSelector => {
    const container = normalizeContainer(containerOrSelector);

    if (container) {
      return mount(container, true, container instanceof SVGElement);
    }
  };

  return app;
};

function injectNativeTagCheck(app) {
  // Inject `isNativeTag`
  // this is used for component name validation (dev only)
  Object.defineProperty(app.config, 'isNativeTag', {
    value: tag => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),
    writable: false
  });
} // dev only


function injectCompilerOptionsCheck(app) {
  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {
    const isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, 'isCustomElement', {
      get() {
        return isCustomElement;
      },

      set() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`The \`isCustomElement\` config option is deprecated. Use ` + `\`compilerOptions.isCustomElement\` instead.`);
      }

    });
    const compilerOptions = app.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using ` + `a build of Vue.js that includes the runtime compiler (aka "full build"). ` + `Since you are using the runtime-only build, \`compilerOptions\` ` + `must be passed to \`@vue/compiler-dom\` in the build setup instead.\n` + `- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.\n` + `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n` + `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
    Object.defineProperty(app.config, 'compilerOptions', {
      get() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
        return compilerOptions;
      },

      set() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
      }

    });
  }
}

function normalizeContainer(container) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {
    const res = document.querySelector(container);

    if ( true && !res) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed to mount app: mount target selector "${container}" returned null.`);
    }

    return res;
  }

  if ( true && container instanceof window.ShadowRoot && container.mode === 'closed') {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
  }

  return container;
}



/***/ }),

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY_ARR": () => (/* binding */ EMPTY_ARR),
/* harmony export */   "EMPTY_OBJ": () => (/* binding */ EMPTY_OBJ),
/* harmony export */   "NO": () => (/* binding */ NO),
/* harmony export */   "NOOP": () => (/* binding */ NOOP),
/* harmony export */   "PatchFlagNames": () => (/* binding */ PatchFlagNames),
/* harmony export */   "babelParserDefaultPlugins": () => (/* binding */ babelParserDefaultPlugins),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "def": () => (/* binding */ def),
/* harmony export */   "escapeHtml": () => (/* binding */ escapeHtml),
/* harmony export */   "escapeHtmlComment": () => (/* binding */ escapeHtmlComment),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "generateCodeFrame": () => (/* binding */ generateCodeFrame),
/* harmony export */   "getGlobalThis": () => (/* binding */ getGlobalThis),
/* harmony export */   "hasChanged": () => (/* binding */ hasChanged),
/* harmony export */   "hasOwn": () => (/* binding */ hasOwn),
/* harmony export */   "hyphenate": () => (/* binding */ hyphenate),
/* harmony export */   "invokeArrayFns": () => (/* binding */ invokeArrayFns),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBooleanAttr": () => (/* binding */ isBooleanAttr),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isGloballyWhitelisted": () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   "isHTMLTag": () => (/* binding */ isHTMLTag),
/* harmony export */   "isIntegerKey": () => (/* binding */ isIntegerKey),
/* harmony export */   "isKnownAttr": () => (/* binding */ isKnownAttr),
/* harmony export */   "isMap": () => (/* binding */ isMap),
/* harmony export */   "isModelListener": () => (/* binding */ isModelListener),
/* harmony export */   "isNoUnitNumericStyleProp": () => (/* binding */ isNoUnitNumericStyleProp),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isOn": () => (/* binding */ isOn),
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isReservedProp": () => (/* binding */ isReservedProp),
/* harmony export */   "isSSRSafeAttrName": () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   "isSVGTag": () => (/* binding */ isSVGTag),
/* harmony export */   "isSet": () => (/* binding */ isSet),
/* harmony export */   "isSpecialBooleanAttr": () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isSymbol": () => (/* binding */ isSymbol),
/* harmony export */   "isVoidTag": () => (/* binding */ isVoidTag),
/* harmony export */   "looseEqual": () => (/* binding */ looseEqual),
/* harmony export */   "looseIndexOf": () => (/* binding */ looseIndexOf),
/* harmony export */   "makeMap": () => (/* binding */ makeMap),
/* harmony export */   "normalizeClass": () => (/* binding */ normalizeClass),
/* harmony export */   "normalizeStyle": () => (/* binding */ normalizeStyle),
/* harmony export */   "objectToString": () => (/* binding */ objectToString),
/* harmony export */   "parseStringStyle": () => (/* binding */ parseStringStyle),
/* harmony export */   "propsToAttrMap": () => (/* binding */ propsToAttrMap),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "slotFlagsText": () => (/* binding */ slotFlagsText),
/* harmony export */   "stringifyStyle": () => (/* binding */ stringifyStyle),
/* harmony export */   "toDisplayString": () => (/* binding */ toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* binding */ toHandlerKey),
/* harmony export */   "toNumber": () => (/* binding */ toNumber),
/* harmony export */   "toRawType": () => (/* binding */ toRawType),
/* harmony export */   "toTypeString": () => (/* binding */ toTypeString)
/* harmony export */ });
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
  const map = Object.create(null);
  const list = str.split(',');

  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}
/**
 * dev only flag -> name mapping
 */


const PatchFlagNames = {
  [1
  /* TEXT */
  ]: `TEXT`,
  [2
  /* CLASS */
  ]: `CLASS`,
  [4
  /* STYLE */
  ]: `STYLE`,
  [8
  /* PROPS */
  ]: `PROPS`,
  [16
  /* FULL_PROPS */
  ]: `FULL_PROPS`,
  [32
  /* HYDRATE_EVENTS */
  ]: `HYDRATE_EVENTS`,
  [64
  /* STABLE_FRAGMENT */
  ]: `STABLE_FRAGMENT`,
  [128
  /* KEYED_FRAGMENT */
  ]: `KEYED_FRAGMENT`,
  [256
  /* UNKEYED_FRAGMENT */
  ]: `UNKEYED_FRAGMENT`,
  [512
  /* NEED_PATCH */
  ]: `NEED_PATCH`,
  [1024
  /* DYNAMIC_SLOTS */
  ]: `DYNAMIC_SLOTS`,
  [2048
  /* DEV_ROOT_FRAGMENT */
  ]: `DEV_ROOT_FRAGMENT`,
  [-1
  /* HOISTED */
  ]: `HOISTED`,
  [-2
  /* BAIL */
  ]: `BAIL`
};
/**
 * Dev only
 */

const slotFlagsText = {
  [1
  /* STABLE */
  ]: 'STABLE',
  [2
  /* DYNAMIC */
  ]: 'DYNAMIC',
  [3
  /* FORWARDED */
  ]: 'FORWARDED'
};
const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' + 'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' + 'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
const isGloballyWhitelisted = /*#__PURE__*/makeMap(GLOBALS_WHITE_LISTED);
const range = 2;

function generateCodeFrame(source, start = 0, end = source.length) {
  const lines = source.split(/\r?\n/);
  let count = 0;
  const res = [];

  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;

    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
        const lineLength = lines[j].length;

        if (j === i) {
          // push underline
          const pad = start - (count - lineLength) + 1;
          const length = Math.max(1, end > count ? lineLength - pad : end - start);
          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + '^'.repeat(length));
          }

          count += lineLength + 1;
        }
      }

      break;
    }
  }

  return res.join('\n');
}
/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */


const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */

const isBooleanAttr = /*#__PURE__*/makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` + `loop,open,required,reversed,scoped,seamless,` + `checked,muted,multiple,selected`);
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};

function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }

  const isUnsafe = unsafeAttrCharRE.test(name);

  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }

  return attrValidationCache[name] = !isUnsafe;
}

const propsToAttrMap = {
  acceptCharset: 'accept-charset',
  className: 'class',
  htmlFor: 'for',
  httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */

const isNoUnitNumericStyleProp = /*#__PURE__*/makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` + `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` + `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` + `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` + `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` + `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` + // SVG
`fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` + `stroke-miterlimit,stroke-opacity,stroke-width`);
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */

const isKnownAttr = /*#__PURE__*/makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` + `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` + `border,buffered,capture,challenge,charset,checked,cite,class,code,` + `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` + `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` + `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` + `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` + `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` + `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` + `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` + `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` + `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` + `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` + `start,step,style,summary,tabindex,target,title,translate,type,usemap,` + `value,width,wrap`);

function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};

    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);

      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }

    return res;
  } else if (isObject(value)) {
    return value;
  }
}

const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;

function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach(item => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}

function stringifyStyle(styles) {
  let ret = '';

  if (!styles) {
    return ret;
  }

  for (const key in styles) {
    const value = styles[key];
    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);

    if (isString(value) || typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey)) {
      // only render valid values
      ret += `${normalizedKey}:${value};`;
    }
  }

  return ret;
}

function normalizeClass(value) {
  let res = '';

  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);

      if (normalized) {
        res += normalized + ' ';
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + ' ';
      }
    }
  }

  return res.trim();
} // These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element


const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' + 'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' + 'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' + 'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' + 'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' + 'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' + 'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' + 'option,output,progress,select,textarea,details,dialog,menu,' + 'summary,template,blockquote,iframe,tfoot'; // https://developer.mozilla.org/en-US/docs/Web/SVG/Element

const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' + 'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' + 'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' + 'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' + 'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' + 'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' + 'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' + 'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' + 'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' + 'text,textPath,title,tspan,unknown,use,view';
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
const isHTMLTag = /*#__PURE__*/makeMap(HTML_TAGS);
const isSVGTag = /*#__PURE__*/makeMap(SVG_TAGS);
const isVoidTag = /*#__PURE__*/makeMap(VOID_TAGS);
const escapeRE = /["'&<>]/;

function escapeHtml(string) {
  const str = '' + string;
  const match = escapeRE.exec(str);

  if (!match) {
    return str;
  }

  let html = '';
  let escaped;
  let index;
  let lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escaped = '&quot;';
        break;

      case 38:
        // &
        escaped = '&amp;';
        break;

      case 39:
        // '
        escaped = '&#39;';
        break;

      case 60:
        // <
        escaped = '&lt;';
        break;

      case 62:
        // >
        escaped = '&gt;';
        break;

      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escaped;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
} // https://www.w3.org/TR/html52/syntax.html#comments


const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;

function escapeHtmlComment(src) {
  return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;

  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }

  return equal;
}

function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);

  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }

  aValidType = isArray(a);
  bValidType = isArray(b);

  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }

  aValidType = isObject(a);
  bValidType = isObject(b);

  if (aValidType || bValidType) {
    /* istanbul ignore if: this if will probably never be called */
    if (!aValidType || !bValidType) {
      return false;
    }

    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;

    if (aKeysCount !== bKeysCount) {
      return false;
    }

    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);

      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }

  return String(a) === String(b);
}

function looseIndexOf(arr, val) {
  return arr.findIndex(item => looseEqual(item, val));
}
/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */


const toDisplayString = val => {
  return val == null ? '' : isObject(val) ? JSON.stringify(val, replacer, 2) : String(val);
};

const replacer = (_key, val) => {
  if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
        entries[`${key} =>`] = val;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }

  return val;
};
/**
 * List of @babel/parser plugins that are used for template expression
 * transforms and SFC script transforms. By default we enable proposals slated
 * for ES2020. This will need to be updated as the spec moves forward.
 * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins
 */


const babelParserDefaultPlugins = ['bigInt', 'optionalChaining', 'nullishCoalescingOperator'];
const EMPTY_OBJ =  true ? Object.freeze({}) : 0;
const EMPTY_ARR =  true ? Object.freeze([]) : 0;

const NOOP = () => {};
/**
 * Always return false.
 */


const NO = () => false;

const onRE = /^on[^a-z]/;

const isOn = key => onRE.test(key);

const isModelListener = key => key.startsWith('onUpdate:');

const extend = Object.assign;

const remove = (arr, el) => {
  const i = arr.indexOf(el);

  if (i > -1) {
    arr.splice(i, 1);
  }
};

const hasOwnProperty = Object.prototype.hasOwnProperty;

const hasOwn = (val, key) => hasOwnProperty.call(val, key);

const isArray = Array.isArray;

const isMap = val => toTypeString(val) === '[object Map]';

const isSet = val => toTypeString(val) === '[object Set]';

const isDate = val => val instanceof Date;

const isFunction = val => typeof val === 'function';

const isString = val => typeof val === 'string';

const isSymbol = val => typeof val === 'symbol';

const isObject = val => val !== null && typeof val === 'object';

const isPromise = val => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};

const objectToString = Object.prototype.toString;

const toTypeString = value => objectToString.call(value);

const toRawType = value => {
  // extract "RawType" from strings like "[object RawType]"
  return toTypeString(value).slice(8, -1);
};

const isPlainObject = val => toTypeString(val) === '[object Object]';

const isIntegerKey = key => isString(key) && key !== 'NaN' && key[0] !== '-' && '' + parseInt(key, 10) === key;

const isReservedProp = /*#__PURE__*/makeMap( // the leading comma is intentional so empty string "" is also included
',key,ref,' + 'onVnodeBeforeMount,onVnodeMounted,' + 'onVnodeBeforeUpdate,onVnodeUpdated,' + 'onVnodeBeforeUnmount,onVnodeUnmounted');

const cacheStringFunction = fn => {
  const cache = Object.create(null);
  return str => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};

const camelizeRE = /-(\w)/g;
/**
 * @private
 */

const camelize = cacheStringFunction(str => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : '');
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */

const hyphenate = cacheStringFunction(str => str.replace(hyphenateRE, '-$1').toLowerCase());
/**
 * @private
 */

const capitalize = cacheStringFunction(str => str.charAt(0).toUpperCase() + str.slice(1));
/**
 * @private
 */

const toHandlerKey = cacheStringFunction(str => str ? `on${capitalize(str)}` : ``); // compare whether a value has changed, accounting for NaN.

const hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);

const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};

const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};

const toNumber = val => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};

let _globalThis;

const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : {});
};



/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");

var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");

var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");

var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");

var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");

var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");

var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest(); // HTTP basic authentication

    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout; // Listen for ready state

    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      } // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request


      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      } // Prepare the response


      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      settle(resolve, reject, response); // Clean up request

      request = null;
    }; // Handle browser request cancellation (as opposed to a manual cancellation)


    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }

      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    } // Add headers to the request


    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    } // Add withCredentials to request if needed


    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    } // Add responseType to request if needed


    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel); // Clean up request

        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    } // Send the request


    request.send(requestData);
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");

var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");

var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */


function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance

  utils.extend(instance, Axios.prototype, context); // Copy context to instance

  utils.extend(instance, context);
  return instance;
} // Create the default instance to be exported


var axios = createInstance(defaults); // Expose Axios class to allow class inheritance

axios.Axios = Axios; // Factory for creating new instances

axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
}; // Expose Cancel & CancelToken


axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js"); // Expose all/spread

axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js"); // Expose isAxiosError

axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");
module.exports = axios; // Allow use of default import syntax in TypeScript

module.exports.default = axios;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */


function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */


CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");

var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");

var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");

var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */


function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */


Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config); // Set config.method

  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  } // Hook up interceptors middleware


  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
}; // Provide aliases for supported request methods


utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});
module.exports = Axios;

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */


InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */


InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */


InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");

var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */


module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }

  return requestedURL;
};

/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */


module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");

var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */


module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config); // Ensure headers exist

  config.headers = config.headers || {}; // Transform request data

  config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config); // Transform response data

    response.data = transformData(response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config); // Transform response data

      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;

  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };

  return error;
};

/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */


module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};
  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = ['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress', 'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }

    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });
  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils.forEach(otherKeys, mergeDeepProperties);
  return config;
};

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */


module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;

  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */


module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });
  return data;
};

/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");

var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;

  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }

  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }

    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }

    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }

    return data;
  }],
  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        /* Ignore */
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    return fn.apply(thisArg, args);
  };
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */


module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;

  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }

        parts.push(encode(key) + '=' + encode(v));
      });
    });
    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */

module.exports = function isAxiosError(payload) {
  return typeof payload === 'object' && payload.isAxiosError === true;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;
  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */

  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);
  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */

  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js"); // Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers


var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */

module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }

      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });
  return parsed;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
/*global toString:true*/
// utils is a library of generic helper functions non-specific to axios


var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */

function isArray(val) {
  return toString.call(val) === '[object Array]';
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */


function isUndefined(val) {
  return typeof val === 'undefined';
}
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */


function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */


function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */


function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */


function isArrayBufferView(val) {
  var result;

  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }

  return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */


function isString(val) {
  return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */


function isNumber(val) {
  return typeof val === 'number';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */


function isObject(val) {
  return val !== null && typeof val === 'object';
}
/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */


function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */


function isDate(val) {
  return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */


function isFile(val) {
  return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */


function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */


function isFunction(val) {
  return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */


function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */


function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */


function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */


function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */


function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  } // Force an array if not already something iterable


  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function merge()
/* obj1, obj2, obj3, ... */
{
  var result = {};

  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */


function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */


function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }

  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names

module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join("");
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === "string") {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, ""]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";


function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = function cssWithMappingToString(item) {
  var _item = _slicedToArray(item, 4),
      content = _item[1],
      cssMapping = _item[3];

  if (typeof btoa === "function") {
    // eslint-disable-next-line no-undef
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=script&lang=js":
/*!*******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=script&lang=js ***!
  \*******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
const metricsUrl = 'http://planogram.stevensoncompany.com/api/metrics/store';

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  async beforeCreate() {
    let results;

    try {
      ({
        data: {
          data: results
        }
      } = await axios__WEBPACK_IMPORTED_MODULE_0___default()(metricsUrl));
    } catch {}

    this.results = parseMetrics(results);
  },

  methods: {
    PascalSpaceCase,
    upperAbbreviateMonth
  },
  data: () => ({
    results: [],
    resultType: 'count'
  })
});

function parseMetrics(results) {
  for (const result of results) {
    Object.assign(result, {
      counts: [result.best_buy_202103, result.best_buy_202104, result.best_buy_202105, result.home_depot_202103, result.home_depot_202104, result.home_depot_202105, result.lowes_202103, result.lowes_202104, result.lowes_202105],
      percents: [result.best_buy_202103_percent, result.best_buy_202104_percent, result.best_buy_202105_percent, result.home_depot_202103_percent, result.home_depot_202104_percent, result.home_depot_202105_percent, result.lowes_202103_percent, result.lowes_202104_percent, result.lowes_202105_percent]
    });
  }

  return results;
}

function PascalSpaceCase(str) {
  const camelSpaceCased = str?.replaceAll?.(/[A-Z]/g, ' $&');
  return capitalize(camelSpaceCased);
}

function upperAbbreviateMonth(month) {
  const abbreviated = month?.substr?.(0, 3);
  return capitalize(abbreviated);
}

function capitalize(str) {
  return `${str?.charAt?.(0).toLocaleUpperCase()}${str?.slice?.(1)}`;
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/pug-plain-loader/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=template&id=1384d825&scoped=true&lang=pug":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/pug-plain-loader/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=template&id=1384d825&scoped=true&lang=pug ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");


const _withId = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.withScopeId)("data-v-1384d825");

(0,vue__WEBPACK_IMPORTED_MODULE_0__.pushScopeId)("data-v-1384d825");

const _hoisted_1 = {
  class: "summary"
};

const _hoisted_2 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", {
  class: "summary-title"
}, "Store Summary", -1
/* HOISTED */
);

const _hoisted_3 = {
  class: "summary-btns"
};
const _hoisted_4 = {
  class: "results"
};
const _hoisted_5 = {
  class: "result"
};

const _hoisted_6 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", {
  class: "result-title"
}, "Brand", -1
/* HOISTED */
);

const _hoisted_7 = {
  class: "result-store"
};
const _hoisted_8 = {
  class: "result-store-title"
};
const _hoisted_9 = {
  class: "result-months"
};
const _hoisted_10 = {
  class: "result-month"
};
const _hoisted_11 = {
  class: "result-month"
};
const _hoisted_12 = {
  class: "result-month"
};
const _hoisted_13 = {
  class: "result-store"
};
const _hoisted_14 = {
  class: "result-store-title"
};
const _hoisted_15 = {
  class: "result-months"
};
const _hoisted_16 = {
  class: "result-month"
};
const _hoisted_17 = {
  class: "result-month"
};
const _hoisted_18 = {
  class: "result-month"
};
const _hoisted_19 = {
  class: "result-store"
};
const _hoisted_20 = {
  class: "result-store-title"
};
const _hoisted_21 = {
  class: "result-months"
};
const _hoisted_22 = {
  class: "result-month"
};
const _hoisted_23 = {
  class: "result-month"
};
const _hoisted_24 = {
  class: "result-month"
};

const _hoisted_25 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", {
  class: "result-total result-header-total"
}, "Grand Total", -1
/* HOISTED */
);

const _hoisted_26 = {
  class: "result"
};
const _hoisted_27 = {
  class: "result-title"
};
const _hoisted_28 = {
  class: "result-count"
};
const _hoisted_29 = {
  class: "result-total"
};

(0,vue__WEBPACK_IMPORTED_MODULE_0__.popScopeId)();

const render = /*#__PURE__*/_withId((_ctx, _cache, $props, $setup, $data, $options) => {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_1, [_hoisted_2, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_3, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", (0,vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps)({
    class: "btn summary-btn"
  }, {
    class: _ctx.resultType === 'count' && 'active' || ''
  }, {
    onClick: _cache[1] || (_cache[1] = $event => _ctx.resultType = 'count')
  }), "COUNT", 16
  /* FULL_PROPS */
  ), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", (0,vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps)({
    class: "btn summary-btn"
  }, {
    class: _ctx.resultType === 'percent' && 'active' || ''
  }, {
    onClick: _cache[2] || (_cache[2] = $event => _ctx.resultType = 'percent')
  }), "PERCENT", 16
  /* FULL_PROPS */
  )])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_4, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("header", _hoisted_5, [_hoisted_6, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_7, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_8, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($options.PascalSpaceCase('bestBuy')), 1
  /* TEXT */
  ), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_9, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_10, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($options.upperAbbreviateMonth('january')), 1
  /* TEXT */
  ), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_11, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($options.upperAbbreviateMonth('february')), 1
  /* TEXT */
  ), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_12, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($options.upperAbbreviateMonth('march')), 1
  /* TEXT */
  )])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_13, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_14, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($options.PascalSpaceCase('homeDepot')), 1
  /* TEXT */
  ), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_15, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_16, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($options.upperAbbreviateMonth('january')), 1
  /* TEXT */
  ), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_17, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($options.upperAbbreviateMonth('february')), 1
  /* TEXT */
  ), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_18, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($options.upperAbbreviateMonth('march')), 1
  /* TEXT */
  )])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_19, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_20, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($options.PascalSpaceCase('lowes')), 1
  /* TEXT */
  ), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_21, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_22, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($options.upperAbbreviateMonth('january')), 1
  /* TEXT */
  ), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_23, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($options.upperAbbreviateMonth('february')), 1
  /* TEXT */
  ), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_24, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($options.upperAbbreviateMonth('march')), 1
  /* TEXT */
  )])]), _hoisted_25]), ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(_ctx.results, result => {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)("div", _hoisted_26, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_27, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(result.brand), 1
    /* TEXT */
    ), ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(result[`${_ctx.resultType}s`], count => {
      return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)("div", _hoisted_28, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(`${count}${_ctx.resultType === 'percent' && '%' || ''}`), 1
      /* TEXT */
      );
    }), 256
    /* UNKEYED_FRAGMENT */
    )), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_29, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(_ctx.resultType === 'percent' ? `${result.total_percent}%` : result.total), 1
    /* TEXT */
    )]);
  }), 256
  /* UNKEYED_FRAGMENT */
  ))])], 64
  /* STABLE_FRAGMENT */
  );
});

/***/ }),

/***/ "./node_modules/vue/dist/vue.runtime.esm-bundler.js":
/*!**********************************************************!*\
  !*** ./node_modules/vue/dist/vue.runtime.esm-bundler.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "Transition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   "TransitionGroup": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSSRApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineEmit": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmit),
/* harmony export */   "defineEmits": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   "defineExpose": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "hydrate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "render": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   "useContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useContext),
/* harmony export */   "useCssModule": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule),
/* harmony export */   "useCssVars": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "vModelCheckbox": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),
/* harmony export */   "vModelSelect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),
/* harmony export */   "vModelText": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText),
/* harmony export */   "vShow": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "withAsyncContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDefaults": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withKeys": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys),
/* harmony export */   "withModifiers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "compile": () => (/* binding */ compile)
/* harmony export */ });
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js");



function initDev() {
  {
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.initCustomFormatter)();
  }
} // This entry exports the runtime only, and is built as


if (true) {
  initDev();
}

const compile = () => {
  if (true) {
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(`Runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
    /* should not happen */
    );
  }
};



/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/stylus-loader/dist/cjs.js!./app.styl":
/*!*************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/stylus-loader/dist/cjs.js!./app.styl ***!
  \*************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "body {\n  background-color: #e5edf1;\n  font-family: Arial;\n  margin: 0;\n}\n", "",{"version":3,"sources":["webpack://./app.styl"],"names":[],"mappings":"AAAA;EACE,yBAAiB;EACjB,kBAAY;EACZ,SAAO;AACT","sourcesContent":["body\n  background-color #e5edf1\n  font-family Arial\n  margin 0\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=0&id=1384d825&lang=stylus":
/*!*************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=0&id=1384d825&lang=stylus ***!
  \*************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".metrics {\n  padding-inline: 8px;\n  padding-top: 20px;\n  padding-bottom: 5px;\n}\n", "",{"version":3,"sources":["webpack://./metrics.vue"],"names":[],"mappings":"AACA;EACE,mBAAe;EACf,iBAAY;EACZ,mBAAe;AAAjB","sourcesContent":["<template lang=\"pug\">\n- const stores = ['bestBuy', 'homeDepot', 'lowes']\n- const months = ['january', 'february', 'march']\n\n.summary\n  .summary-title Store Summary\n  .summary-btns\n    .btn.summary-btn(v-bind='{ class: resultType === \\'count\\' && \\'active\\' || \\'\\' }', @click='resultType = \\'count\\'') COUNT\n    .btn.summary-btn(v-bind='{ class: resultType === \\'percent\\' && \\'active\\' || \\'\\' }', @click='resultType = \\'percent\\'') PERCENT\n\n.results\n  header.result\n    .result-title Brand\n\n    each store in stores\n      .result-store\n        .result-store-title= `{{ PascalSpaceCase('${store}') }}`\n\n        .result-months\n          each month in months\n            .result-month= `{{ upperAbbreviateMonth('${month}') }}`\n\n    .result-total.result-header-total Grand Total\n\n  .result(v-for='result in results')\n    .result-title {{ result.brand }}\n\n    .result-count(v-for='count in result[`${resultType}s`]') {{ `${count}${resultType === 'percent' && '%' || ''}` }}\n\n    .result-total {{ resultType === 'percent' ? `${result.total_percent}%` : result.total }}\n</template>\n\n<script>\nconst metricsUrl = 'http://planogram.stevensoncompany.com/api/metrics/store';\n\nimport axios from 'axios';\n\nexport default {\n  async beforeCreate() {\n    let results;\n    try {\n      ({data: {data: results}} = await axios(metricsUrl));\n    } catch {}\n\n    this.results = parseMetrics(results);\n  },\n\n  methods: {\n    PascalSpaceCase,\n    upperAbbreviateMonth,\n  },\n\n  data: () => ({results: [], resultType: 'count'}),\n};\n\nfunction parseMetrics(results) {\n  for(const result of results) {\n    Object.assign(result, {\n      counts: [\n        result.best_buy_202103,\n        result.best_buy_202104,\n        result.best_buy_202105,\n        result.home_depot_202103,\n        result.home_depot_202104,\n        result.home_depot_202105,\n        result.lowes_202103,\n        result.lowes_202104,\n        result.lowes_202105,\n      ],\n\n      percents: [\n        result.best_buy_202103_percent,\n        result.best_buy_202104_percent,\n        result.best_buy_202105_percent,\n        result.home_depot_202103_percent,\n        result.home_depot_202104_percent,\n        result.home_depot_202105_percent,\n        result.lowes_202103_percent,\n        result.lowes_202104_percent,\n        result.lowes_202105_percent,\n      ],\n    });\n  }\n\n  return results;\n}\n\nfunction PascalSpaceCase(str) {\n  const camelSpaceCased = str?.replaceAll?.(/[A-Z]/g, ' $&');\n\n  return capitalize(camelSpaceCased);\n}\n\nfunction upperAbbreviateMonth(month) {\n  const abbreviated = month?.substr?.(0, 3);\n\n  return capitalize(abbreviated);\n}\n\nfunction capitalize(str) {\n  return `${str?.charAt?.(0).toLocaleUpperCase()}${str?.slice?.(1)}`;\n}\n</script>\n\n<style lang=\"stylus\">\n.metrics\n  padding-inline 8px\n  padding-top 20px\n  padding-bottom 5px\n</style>\n\n<style lang=\"stylus\" scoped>\n.btn\n  background-color white\n  color #4386ab\n  cursor pointer\n  padding-inline 12px\n  height 34px\n  display flex\n  justify-content center\n  align-items center\n\n  &.active\n    background-color #4386ab\n    color white\n\n.summary\n  margin-bottom 20px\n  display flex\n\n.summary-title\n  font-weight bold\n  margin-right 40px\n  display flex\n  align-items center\n\n.summary-btns\n  display flex\n\n.summary-btn\n  width 100px\n\n  &:first-child\n   border-top-left-radius 5px\n   border-bottom-left-radius 5px\n\n  &:last-child\n   border-top-right-radius 5px\n   border-bottom-right-radius 5px\n\n.results\n  & header\n    color #7a8f9f\n    font-weight bold\n    margin-bottom 10px\n    height 100px\n\n.result\n  background-color white\n  margin-bottom 5px\n  border-radius 5px\n  height 50px\n  display flex\n  align-items center\n\n  &:last-child\n    margin-bottom 0\n\n.result-count\n  flex-grow 1\n  width: 0\n  display flex\n  align-items center\n  justify-content center\n\n.result-title\n  padding-left 15px\n  width 200px\n  display flex\n  align-items center\n\n.result-store\n  flex-grow 1\n  align-self stretch\n  border-left 1px solid #e6eef1\n  display flex\n  flex-direction column\n\n.result-store-title\n  flex-grow 1\n  border-bottom 1px solid #e6eef1\n  display flex\n  justify-content center\n  align-items center\n\n.result-months\n  flex-grow 1\n  display flex\n\n.result-month\n  flex-grow 1\n  display flex\n  justify-content center\n  align-items center\n\n.result-total\n  text-align center\n  align-self stretch\n  margin-right 15px\n  width 150px\n  display flex\n  justify-content flex-end\n  align-items center\n\n.result-header-total\n  margin-left 0\n  border-left 1px solid #e6eef1\n  justify-content center\n</style>\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=1&id=1384d825&lang=stylus&scoped=true":
/*!*************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=1&id=1384d825&lang=stylus&scoped=true ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".btn[data-v-1384d825] {\n  background-color: #fff;\n  color: #4386ab;\n  cursor: pointer;\n  padding-inline: 12px;\n  height: 34px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.btn.active[data-v-1384d825] {\n  background-color: #4386ab;\n  color: #fff;\n}\n.summary[data-v-1384d825] {\n  margin-bottom: 20px;\n  display: flex;\n}\n.summary-title[data-v-1384d825] {\n  font-weight: bold;\n  margin-right: 40px;\n  display: flex;\n  align-items: center;\n}\n.summary-btns[data-v-1384d825] {\n  display: flex;\n}\n.summary-btn[data-v-1384d825] {\n  width: 100px;\n}\n.summary-btn[data-v-1384d825]:first-child {\n  border-top-left-radius: 5px;\n  border-bottom-left-radius: 5px;\n}\n.summary-btn[data-v-1384d825]:last-child {\n  border-top-right-radius: 5px;\n  border-bottom-right-radius: 5px;\n}\n.results header[data-v-1384d825] {\n  color: #7a8f9f;\n  font-weight: bold;\n  margin-bottom: 10px;\n  height: 100px;\n}\n.result[data-v-1384d825] {\n  background-color: #fff;\n  margin-bottom: 5px;\n  border-radius: 5px;\n  height: 50px;\n  display: flex;\n  align-items: center;\n}\n.result[data-v-1384d825]:last-child {\n  margin-bottom: 0;\n}\n.result-count[data-v-1384d825] {\n  flex-grow: 1;\n  width: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.result-title[data-v-1384d825] {\n  padding-left: 15px;\n  width: 200px;\n  display: flex;\n  align-items: center;\n}\n.result-store[data-v-1384d825] {\n  flex-grow: 1;\n  align-self: stretch;\n  border-left: 1px solid #e6eef1;\n  display: flex;\n  flex-direction: column;\n}\n.result-store-title[data-v-1384d825] {\n  flex-grow: 1;\n  border-bottom: 1px solid #e6eef1;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.result-months[data-v-1384d825] {\n  flex-grow: 1;\n  display: flex;\n}\n.result-month[data-v-1384d825] {\n  flex-grow: 1;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.result-total[data-v-1384d825] {\n  text-align: center;\n  align-self: stretch;\n  margin-right: 15px;\n  width: 150px;\n  display: flex;\n  justify-content: flex-end;\n  align-items: center;\n}\n.result-header-total[data-v-1384d825] {\n  margin-left: 0;\n  border-left: 1px solid #e6eef1;\n  justify-content: center;\n}\n", "",{"version":3,"sources":["webpack://./metrics.vue"],"names":[],"mappings":"AACA;EACE,sBAAiB;EACjB,cAAM;EACN,eAAO;EACP,oBAAe;EACf,YAAO;EACP,aAAQ;EACR,uBAAgB;EAChB,mBAAY;AAAd;AAEE;EACE,yBAAiB;EACjB,WAAM;AAAV;AAEA;EACE,mBAAc;EACd,aAAQ;AAAV;AAEA;EACE,iBAAY;EACZ,kBAAa;EACb,aAAQ;EACR,mBAAY;AAAd;AAEA;EACE,aAAQ;AAAV;AAEA;EACE,YAAM;AAAR;AAEE;EACC,2BAAuB;EACvB,8BAA0B;AAA7B;AAEE;EACC,4BAAwB;EACxB,+BAA2B;AAA9B;AAGE;EACE,cAAM;EACN,iBAAY;EACZ,mBAAc;EACd,aAAO;AADX;AAGA;EACE,sBAAiB;EACjB,kBAAc;EACd,kBAAc;EACd,YAAO;EACP,aAAQ;EACR,mBAAY;AADd;AAGE;EACE,gBAAc;AADlB;AAGA;EACE,YAAU;EACV,QAAO;EACP,aAAQ;EACR,mBAAY;EACZ,uBAAgB;AADlB;AAGA;EACE,kBAAa;EACb,YAAM;EACN,aAAQ;EACR,mBAAY;AADd;AAGA;EACE,YAAU;EACV,mBAAW;EACX,8BAAY;EACZ,aAAQ;EACR,sBAAe;AADjB;AAGA;EACE,YAAU;EACV,gCAAc;EACd,aAAQ;EACR,uBAAgB;EAChB,mBAAY;AADd;AAGA;EACE,YAAU;EACV,aAAQ;AADV;AAGA;EACE,YAAU;EACV,aAAQ;EACR,uBAAgB;EAChB,mBAAY;AADd;AAGA;EACE,kBAAW;EACX,mBAAW;EACX,kBAAa;EACb,YAAM;EACN,aAAQ;EACR,yBAAgB;EAChB,mBAAY;AADd;AAGA;EACE,cAAY;EACZ,8BAAY;EACZ,uBAAgB;AADlB","sourcesContent":["<template lang=\"pug\">\n- const stores = ['bestBuy', 'homeDepot', 'lowes']\n- const months = ['january', 'february', 'march']\n\n.summary\n  .summary-title Store Summary\n  .summary-btns\n    .btn.summary-btn(v-bind='{ class: resultType === \\'count\\' && \\'active\\' || \\'\\' }', @click='resultType = \\'count\\'') COUNT\n    .btn.summary-btn(v-bind='{ class: resultType === \\'percent\\' && \\'active\\' || \\'\\' }', @click='resultType = \\'percent\\'') PERCENT\n\n.results\n  header.result\n    .result-title Brand\n\n    each store in stores\n      .result-store\n        .result-store-title= `{{ PascalSpaceCase('${store}') }}`\n\n        .result-months\n          each month in months\n            .result-month= `{{ upperAbbreviateMonth('${month}') }}`\n\n    .result-total.result-header-total Grand Total\n\n  .result(v-for='result in results')\n    .result-title {{ result.brand }}\n\n    .result-count(v-for='count in result[`${resultType}s`]') {{ `${count}${resultType === 'percent' && '%' || ''}` }}\n\n    .result-total {{ resultType === 'percent' ? `${result.total_percent}%` : result.total }}\n</template>\n\n<script>\nconst metricsUrl = 'http://planogram.stevensoncompany.com/api/metrics/store';\n\nimport axios from 'axios';\n\nexport default {\n  async beforeCreate() {\n    let results;\n    try {\n      ({data: {data: results}} = await axios(metricsUrl));\n    } catch {}\n\n    this.results = parseMetrics(results);\n  },\n\n  methods: {\n    PascalSpaceCase,\n    upperAbbreviateMonth,\n  },\n\n  data: () => ({results: [], resultType: 'count'}),\n};\n\nfunction parseMetrics(results) {\n  for(const result of results) {\n    Object.assign(result, {\n      counts: [\n        result.best_buy_202103,\n        result.best_buy_202104,\n        result.best_buy_202105,\n        result.home_depot_202103,\n        result.home_depot_202104,\n        result.home_depot_202105,\n        result.lowes_202103,\n        result.lowes_202104,\n        result.lowes_202105,\n      ],\n\n      percents: [\n        result.best_buy_202103_percent,\n        result.best_buy_202104_percent,\n        result.best_buy_202105_percent,\n        result.home_depot_202103_percent,\n        result.home_depot_202104_percent,\n        result.home_depot_202105_percent,\n        result.lowes_202103_percent,\n        result.lowes_202104_percent,\n        result.lowes_202105_percent,\n      ],\n    });\n  }\n\n  return results;\n}\n\nfunction PascalSpaceCase(str) {\n  const camelSpaceCased = str?.replaceAll?.(/[A-Z]/g, ' $&');\n\n  return capitalize(camelSpaceCased);\n}\n\nfunction upperAbbreviateMonth(month) {\n  const abbreviated = month?.substr?.(0, 3);\n\n  return capitalize(abbreviated);\n}\n\nfunction capitalize(str) {\n  return `${str?.charAt?.(0).toLocaleUpperCase()}${str?.slice?.(1)}`;\n}\n</script>\n\n<style lang=\"stylus\">\n.metrics\n  padding-inline 8px\n  padding-top 20px\n  padding-bottom 5px\n</style>\n\n<style lang=\"stylus\" scoped>\n.btn\n  background-color white\n  color #4386ab\n  cursor pointer\n  padding-inline 12px\n  height 34px\n  display flex\n  justify-content center\n  align-items center\n\n  &.active\n    background-color #4386ab\n    color white\n\n.summary\n  margin-bottom 20px\n  display flex\n\n.summary-title\n  font-weight bold\n  margin-right 40px\n  display flex\n  align-items center\n\n.summary-btns\n  display flex\n\n.summary-btn\n  width 100px\n\n  &:first-child\n   border-top-left-radius 5px\n   border-bottom-left-radius 5px\n\n  &:last-child\n   border-top-right-radius 5px\n   border-bottom-right-radius 5px\n\n.results\n  & header\n    color #7a8f9f\n    font-weight bold\n    margin-bottom 10px\n    height 100px\n\n.result\n  background-color white\n  margin-bottom 5px\n  border-radius 5px\n  height 50px\n  display flex\n  align-items center\n\n  &:last-child\n    margin-bottom 0\n\n.result-count\n  flex-grow 1\n  width: 0\n  display flex\n  align-items center\n  justify-content center\n\n.result-title\n  padding-left 15px\n  width 200px\n  display flex\n  align-items center\n\n.result-store\n  flex-grow 1\n  align-self stretch\n  border-left 1px solid #e6eef1\n  display flex\n  flex-direction column\n\n.result-store-title\n  flex-grow 1\n  border-bottom 1px solid #e6eef1\n  display flex\n  justify-content center\n  align-items center\n\n.result-months\n  flex-grow 1\n  display flex\n\n.result-month\n  flex-grow 1\n  display flex\n  justify-content center\n  align-items center\n\n.result-total\n  text-align center\n  align-self stretch\n  margin-right 15px\n  width 150px\n  display flex\n  justify-content flex-end\n  align-items center\n\n.result-header-total\n  margin-left 0\n  border-left 1px solid #e6eef1\n  justify-content center\n</style>\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./app.styl":
/*!******************!*\
  !*** ./app.styl ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/getTarget.js */ "./node_modules/style-loader/dist/runtime/getTarget.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_app_styl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !!./node_modules/css-loader/dist/cjs.js!./node_modules/stylus-loader/dist/cjs.js!./app.styl */ "./node_modules/css-loader/dist/cjs.js!./node_modules/stylus-loader/dist/cjs.js!./app.styl");

      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = function(css, style){
      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
      while (style.firstChild) {
        style.removeChild(style.firstChild);
      }

      style.appendChild(document.createTextNode(css));
    }
  };
options.setAttributes = function(style) {
        var nonce =
           true ? __webpack_require__.nc : 0;

        if (nonce) {
          style.setAttribute("nonce", nonce);
        }
      };
options.insert = function(style){
    var target = _node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2___default()("head");

    if (!target) {
      throw new Error(
        "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
      );
    }

    target.appendChild(style);
  };
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_app_styl__WEBPACK_IMPORTED_MODULE_4__.default, options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_app_styl__WEBPACK_IMPORTED_MODULE_4__.default && _node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_app_styl__WEBPACK_IMPORTED_MODULE_4__.default.locals ? _node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_app_styl__WEBPACK_IMPORTED_MODULE_4__.default.locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=0&id=1384d825&lang=stylus":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=0&id=1384d825&lang=stylus ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/getTarget.js */ "./node_modules/style-loader/dist/runtime/getTarget.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_stylus_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_style_index_0_id_1384d825_lang_stylus__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=0&id=1384d825&lang=stylus */ "./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=0&id=1384d825&lang=stylus");

      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = function(css, style){
      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
      while (style.firstChild) {
        style.removeChild(style.firstChild);
      }

      style.appendChild(document.createTextNode(css));
    }
  };
options.setAttributes = function(style) {
        var nonce =
           true ? __webpack_require__.nc : 0;

        if (nonce) {
          style.setAttribute("nonce", nonce);
        }
      };
options.insert = function(style){
    var target = _node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2___default()("head");

    if (!target) {
      throw new Error(
        "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
      );
    }

    target.appendChild(style);
  };
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_stylus_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_style_index_0_id_1384d825_lang_stylus__WEBPACK_IMPORTED_MODULE_4__.default, options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_stylus_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_style_index_0_id_1384d825_lang_stylus__WEBPACK_IMPORTED_MODULE_4__.default && _node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_stylus_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_style_index_0_id_1384d825_lang_stylus__WEBPACK_IMPORTED_MODULE_4__.default.locals ? _node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_stylus_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_style_index_0_id_1384d825_lang_stylus__WEBPACK_IMPORTED_MODULE_4__.default.locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=1&id=1384d825&lang=stylus&scoped=true":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=1&id=1384d825&lang=stylus&scoped=true ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/getTarget.js */ "./node_modules/style-loader/dist/runtime/getTarget.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_stylus_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_style_index_1_id_1384d825_lang_stylus_scoped_true__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=1&id=1384d825&lang=stylus&scoped=true */ "./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=1&id=1384d825&lang=stylus&scoped=true");

      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = function(css, style){
      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
      while (style.firstChild) {
        style.removeChild(style.firstChild);
      }

      style.appendChild(document.createTextNode(css));
    }
  };
options.setAttributes = function(style) {
        var nonce =
           true ? __webpack_require__.nc : 0;

        if (nonce) {
          style.setAttribute("nonce", nonce);
        }
      };
options.insert = function(style){
    var target = _node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2___default()("head");

    if (!target) {
      throw new Error(
        "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
      );
    }

    target.appendChild(style);
  };
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_stylus_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_style_index_1_id_1384d825_lang_stylus_scoped_true__WEBPACK_IMPORTED_MODULE_4__.default, options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_stylus_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_style_index_1_id_1384d825_lang_stylus_scoped_true__WEBPACK_IMPORTED_MODULE_4__.default && _node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_stylus_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_style_index_1_id_1384d825_lang_stylus_scoped_true__WEBPACK_IMPORTED_MODULE_4__.default.locals ? _node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_stylus_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_style_index_1_id_1384d825_lang_stylus_scoped_true__WEBPACK_IMPORTED_MODULE_4__.default.locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/getTarget.js":
/*!*************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/getTarget.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}

module.exports = getTarget;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var style = document.createElement("style");
  options.setAttributes(style, options.attributes);
  options.insert(style);
  return style;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute("media", media);
  } else {
    style.removeAttribute("media");
  }

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, style);
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


function domAPI(options) {
  var style = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(style, options, obj);
    },
    remove: function remove() {
      removeStyleElement(style);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./metrics.vue":
/*!*********************!*\
  !*** ./metrics.vue ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _metrics_vue_vue_type_template_id_1384d825_scoped_true_lang_pug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./metrics.vue?vue&type=template&id=1384d825&scoped=true&lang=pug */ "./metrics.vue?vue&type=template&id=1384d825&scoped=true&lang=pug");
/* harmony import */ var _metrics_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metrics.vue?vue&type=script&lang=js */ "./metrics.vue?vue&type=script&lang=js");
/* harmony import */ var _metrics_vue_vue_type_style_index_0_id_1384d825_lang_stylus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metrics.vue?vue&type=style&index=0&id=1384d825&lang=stylus */ "./metrics.vue?vue&type=style&index=0&id=1384d825&lang=stylus");
/* harmony import */ var _metrics_vue_vue_type_style_index_1_id_1384d825_lang_stylus_scoped_true__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./metrics.vue?vue&type=style&index=1&id=1384d825&lang=stylus&scoped=true */ "./metrics.vue?vue&type=style&index=1&id=1384d825&lang=stylus&scoped=true");




;

_metrics_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__.default.render = _metrics_vue_vue_type_template_id_1384d825_scoped_true_lang_pug__WEBPACK_IMPORTED_MODULE_0__.render
_metrics_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__.default.__scopeId = "data-v-1384d825"
/* hot reload */
if (false) {}

_metrics_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__.default.__file = "metrics.vue"

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_metrics_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__.default);

/***/ }),

/***/ "./metrics.vue?vue&type=script&lang=js":
/*!*********************************************!*\
  !*** ./metrics.vue?vue&type=script&lang=js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__.default)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./metrics.vue?vue&type=template&id=1384d825&scoped=true&lang=pug":
/*!************************************************************************!*\
  !*** ./metrics.vue?vue&type=template&id=1384d825&scoped=true&lang=pug ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_pug_plain_loader_index_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_template_id_1384d825_scoped_true_lang_pug__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_pug_plain_loader_index_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_template_id_1384d825_scoped_true_lang_pug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/pug-plain-loader/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=template&id=1384d825&scoped=true&lang=pug */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/pug-plain-loader/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=template&id=1384d825&scoped=true&lang=pug");


/***/ }),

/***/ "./metrics.vue?vue&type=style&index=0&id=1384d825&lang=stylus":
/*!********************************************************************!*\
  !*** ./metrics.vue?vue&type=style&index=0&id=1384d825&lang=stylus ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_stylus_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_style_index_0_id_1384d825_lang_stylus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=0&id=1384d825&lang=stylus */ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=0&id=1384d825&lang=stylus");


/***/ }),

/***/ "./metrics.vue?vue&type=style&index=1&id=1384d825&lang=stylus&scoped=true":
/*!********************************************************************************!*\
  !*** ./metrics.vue?vue&type=style&index=1&id=1384d825&lang=stylus&scoped=true ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_stylus_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_7_use_0_metrics_vue_vue_type_style_index_1_id_1384d825_lang_stylus_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=1&id=1384d825&lang=stylus&scoped=true */ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/stylus-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[7].use[0]!./metrics.vue?vue&type=style&index=1&id=1384d825&lang=stylus&scoped=true");


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!****************!*\
  !*** ./app.js ***!
  \****************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _app_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app.styl */ "./app.styl");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");
/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metrics */ "./metrics.vue");



(0,vue__WEBPACK_IMPORTED_MODULE_1__.createApp)(_metrics__WEBPACK_IMPORTED_MODULE_2__.default).mount('main');
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL25vZGVfbW9kdWxlcy9AdnVlL3JlYWN0aXZpdHkvZGlzdC9yZWFjdGl2aXR5LmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1jb3JlL2Rpc3QvcnVudGltZS1jb3JlLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1kb20vZGlzdC9ydW50aW1lLWRvbS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vc3RldmVuc29uLW1ldHJpY3MvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJ3ZWJwYWNrOi8vc3RldmVuc29uLW1ldHJpY3MvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCJ3ZWJwYWNrOi8vc3RldmVuc29uLW1ldHJpY3MvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vc3RldmVuc29uLW1ldHJpY3MvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcyIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJ3ZWJwYWNrOi8vc3RldmVuc29uLW1ldHJpY3MvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vc3RldmVuc29uLW1ldHJpY3MvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJ3ZWJwYWNrOi8vc3RldmVuc29uLW1ldHJpY3MvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vc3RldmVuc29uLW1ldHJpY3MvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbWV0cmljcy52dWUiLCJ3ZWJwYWNrOi8vc3RldmVuc29uLW1ldHJpY3MvLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vc3RldmVuc29uLW1ldHJpY3MvLi9hcHAuc3R5bCIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL21ldHJpY3MudnVlPzI1MjkiLCJ3ZWJwYWNrOi8vc3RldmVuc29uLW1ldHJpY3MvLi9tZXRyaWNzLnZ1ZT83NTQ0Iiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vYXBwLnN0eWw/ZjZiZSIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy8uL21ldHJpY3MudnVlPzAyNjQiLCJ3ZWJwYWNrOi8vc3RldmVuc29uLW1ldHJpY3MvLi9tZXRyaWNzLnZ1ZT9hZTgyIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VGFyZ2V0LmpzIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanMiLCJ3ZWJwYWNrOi8vc3RldmVuc29uLW1ldHJpY3MvLi9tZXRyaWNzLnZ1ZT80MTI3Iiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzLy4vbWV0cmljcy52dWU/YWFlZiIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vc3RldmVuc29uLW1ldHJpY3Mvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9zdGV2ZW5zb24tbWV0cmljcy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3N0ZXZlbnNvbi1tZXRyaWNzL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vc3RldmVuc29uLW1ldHJpY3MvLi9hcHAuanMiXSwibmFtZXMiOlsidGFyZ2V0TWFwIiwiV2Vha01hcCIsImVmZmVjdFN0YWNrIiwiYWN0aXZlRWZmZWN0IiwiSVRFUkFURV9LRVkiLCJTeW1ib2wiLCJwcm9jZXNzIiwiTUFQX0tFWV9JVEVSQVRFX0tFWSIsImlzRWZmZWN0IiwiZm4iLCJfaXNFZmZlY3QiLCJlZmZlY3QiLCJvcHRpb25zIiwiRU1QVFlfT0JKIiwicmF3IiwiY3JlYXRlUmVhY3RpdmVFZmZlY3QiLCJsYXp5Iiwic3RvcCIsImFjdGl2ZSIsImNsZWFudXAiLCJvblN0b3AiLCJ1aWQiLCJyZWFjdGl2ZUVmZmVjdCIsImluY2x1ZGVzIiwiZW5hYmxlVHJhY2tpbmciLCJwdXNoIiwicG9wIiwicmVzZXRUcmFja2luZyIsImxlbmd0aCIsImlkIiwiYWxsb3dSZWN1cnNlIiwiZGVwcyIsImkiLCJkZWxldGUiLCJzaG91bGRUcmFjayIsInRyYWNrU3RhY2siLCJwYXVzZVRyYWNraW5nIiwibGFzdCIsInVuZGVmaW5lZCIsInRyYWNrIiwidGFyZ2V0IiwidHlwZSIsImtleSIsImRlcHNNYXAiLCJnZXQiLCJzZXQiLCJNYXAiLCJkZXAiLCJTZXQiLCJoYXMiLCJhZGQiLCJvblRyYWNrIiwidHJpZ2dlciIsIm5ld1ZhbHVlIiwib2xkVmFsdWUiLCJvbGRUYXJnZXQiLCJlZmZlY3RzIiwiZWZmZWN0c1RvQWRkIiwiZm9yRWFjaCIsImlzQXJyYXkiLCJpc01hcCIsImlzSW50ZWdlcktleSIsInJ1biIsIm9uVHJpZ2dlciIsInNjaGVkdWxlciIsImlzTm9uVHJhY2thYmxlS2V5cyIsIm1ha2VNYXAiLCJidWlsdEluU3ltYm9scyIsIk9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJtYXAiLCJmaWx0ZXIiLCJpc1N5bWJvbCIsImNyZWF0ZUdldHRlciIsInNoYWxsb3dHZXQiLCJyZWFkb25seUdldCIsInNoYWxsb3dSZWFkb25seUdldCIsImFycmF5SW5zdHJ1bWVudGF0aW9ucyIsImNyZWF0ZUFycmF5SW5zdHJ1bWVudGF0aW9ucyIsImluc3RydW1lbnRhdGlvbnMiLCJtZXRob2QiLCJBcnJheSIsInByb3RvdHlwZSIsImFyZ3MiLCJhcnIiLCJ0b1JhdyIsImwiLCJyZXMiLCJhcHBseSIsImlzUmVhZG9ubHkiLCJzaGFsbG93IiwicmVjZWl2ZXIiLCJzaGFsbG93UmVhZG9ubHlNYXAiLCJyZWFkb25seU1hcCIsInNoYWxsb3dSZWFjdGl2ZU1hcCIsInJlYWN0aXZlTWFwIiwidGFyZ2V0SXNBcnJheSIsImhhc093biIsIlJlZmxlY3QiLCJpc1JlZiIsInNob3VsZFVud3JhcCIsInZhbHVlIiwiaXNPYmplY3QiLCJyZWFkb25seSIsInJlYWN0aXZlIiwiY3JlYXRlU2V0dGVyIiwic2hhbGxvd1NldCIsImhhZEtleSIsIk51bWJlciIsInJlc3VsdCIsImhhc0NoYW5nZWQiLCJkZWxldGVQcm9wZXJ0eSIsIm93bktleXMiLCJtdXRhYmxlSGFuZGxlcnMiLCJyZWFkb25seUhhbmRsZXJzIiwiY29uc29sZSIsIndhcm4iLCJTdHJpbmciLCJzaGFsbG93UmVhY3RpdmVIYW5kbGVycyIsImV4dGVuZCIsInNoYWxsb3dSZWFkb25seUhhbmRsZXJzIiwidG9SZWFjdGl2ZSIsInRvUmVhZG9ubHkiLCJ0b1NoYWxsb3ciLCJnZXRQcm90byIsInYiLCJnZXRQcm90b3R5cGVPZiIsImdldCQxIiwiaXNTaGFsbG93IiwicmF3VGFyZ2V0IiwicmF3S2V5Iiwid3JhcCIsImNhbGwiLCJoYXMkMSIsInNpemUiLCJwcm90byIsInNldCQxIiwiY2hlY2tJZGVudGl0eUtleXMiLCJkZWxldGVFbnRyeSIsImNsZWFyIiwiaGFkSXRlbXMiLCJjcmVhdGVGb3JFYWNoIiwiY2FsbGJhY2siLCJ0aGlzQXJnIiwib2JzZXJ2ZWQiLCJjcmVhdGVJdGVyYWJsZU1ldGhvZCIsInRhcmdldElzTWFwIiwiaXNQYWlyIiwiaXRlcmF0b3IiLCJpc0tleU9ubHkiLCJpbm5lckl0ZXJhdG9yIiwibmV4dCIsImRvbmUiLCJjcmVhdGVSZWFkb25seU1ldGhvZCIsImNhcGl0YWxpemUiLCJjcmVhdGVJbnN0cnVtZW50YXRpb25zIiwibXV0YWJsZUluc3RydW1lbnRhdGlvbnMiLCJzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyIsInJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyIsInNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMiLCJpdGVyYXRvck1ldGhvZHMiLCJjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIiLCJtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzIiwic2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyIsInJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzIiwic2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzIiwidG9SYXdUeXBlIiwidGFyZ2V0VHlwZU1hcCIsInJhd1R5cGUiLCJnZXRUYXJnZXRUeXBlIiwiaXNFeHRlbnNpYmxlIiwiY3JlYXRlUmVhY3RpdmVPYmplY3QiLCJzaGFsbG93UmVhY3RpdmUiLCJzaGFsbG93UmVhZG9ubHkiLCJiYXNlSGFuZGxlcnMiLCJjb2xsZWN0aW9uSGFuZGxlcnMiLCJwcm94eU1hcCIsImV4aXN0aW5nUHJveHkiLCJ0YXJnZXRUeXBlIiwicHJveHkiLCJQcm94eSIsImlzUmVhY3RpdmUiLCJpc1Byb3h5IiwibWFya1JhdyIsImRlZiIsImNvbnZlcnQiLCJ2YWwiLCJyIiwiQm9vbGVhbiIsIl9fdl9pc1JlZiIsInJlZiIsImNyZWF0ZVJlZiIsInNoYWxsb3dSZWYiLCJSZWZJbXBsIiwiY29uc3RydWN0b3IiLCJfcmF3VmFsdWUiLCJfc2hhbGxvdyIsIl92YWx1ZSIsIm5ld1ZhbCIsInJhd1ZhbHVlIiwidHJpZ2dlclJlZiIsInVucmVmIiwic2hhbGxvd1Vud3JhcEhhbmRsZXJzIiwicHJveHlSZWZzIiwib2JqZWN0V2l0aFJlZnMiLCJDdXN0b21SZWZJbXBsIiwiZmFjdG9yeSIsIl9nZXQiLCJfc2V0IiwiY3VzdG9tUmVmIiwidG9SZWZzIiwib2JqZWN0IiwicmV0IiwidG9SZWYiLCJPYmplY3RSZWZJbXBsIiwiX29iamVjdCIsIl9rZXkiLCJDb21wdXRlZFJlZkltcGwiLCJnZXR0ZXIiLCJfc2V0dGVyIiwiX2RpcnR5Iiwic2VsZiIsImNvbXB1dGVkIiwiZ2V0dGVyT3JPcHRpb25zIiwic2V0dGVyIiwiaXNGdW5jdGlvbiIsIk5PT1AiLCJzdGFjayIsInB1c2hXYXJuaW5nQ29udGV4dCIsInZub2RlIiwicG9wV2FybmluZ0NvbnRleHQiLCJtc2ciLCJpbnN0YW5jZSIsImNvbXBvbmVudCIsImFwcFdhcm5IYW5kbGVyIiwiYXBwQ29udGV4dCIsImNvbmZpZyIsIndhcm5IYW5kbGVyIiwidHJhY2UiLCJnZXRDb21wb25lbnRUcmFjZSIsImNhbGxXaXRoRXJyb3JIYW5kbGluZyIsImpvaW4iLCJmb3JtYXRDb21wb25lbnROYW1lIiwid2FybkFyZ3MiLCJmb3JtYXRUcmFjZSIsImN1cnJlbnRWTm9kZSIsIm5vcm1hbGl6ZWRTdGFjayIsInJlY3Vyc2VDb3VudCIsInBhcmVudEluc3RhbmNlIiwicGFyZW50IiwibG9ncyIsImVudHJ5IiwiZm9ybWF0VHJhY2VFbnRyeSIsInBvc3RmaXgiLCJpc1Jvb3QiLCJvcGVuIiwiY2xvc2UiLCJwcm9wcyIsImZvcm1hdFByb3BzIiwia2V5cyIsInNsaWNlIiwiZm9ybWF0UHJvcCIsImlzU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsImlzRnVuY3Rpb24kMSIsIm5hbWUiLCJFcnJvclR5cGVTdHJpbmdzIiwiZXJyIiwiaGFuZGxlRXJyb3IiLCJjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyIsImlzUHJvbWlzZSQxIiwiY2F0Y2giLCJ2YWx1ZXMiLCJ0aHJvd0luRGV2IiwiY29udGV4dFZOb2RlIiwiY3VyIiwiZXhwb3NlZEluc3RhbmNlIiwiZXJyb3JJbmZvIiwiZXJyb3JDYXB0dXJlZEhvb2tzIiwiZWMiLCJhcHBFcnJvckhhbmRsZXIiLCJlcnJvckhhbmRsZXIiLCJsb2dFcnJvciIsImluZm8iLCJlcnJvciIsImlzRmx1c2hpbmciLCJpc0ZsdXNoUGVuZGluZyIsInF1ZXVlIiwiZmx1c2hJbmRleCIsInBlbmRpbmdQcmVGbHVzaENicyIsImFjdGl2ZVByZUZsdXNoQ2JzIiwicHJlRmx1c2hJbmRleCIsInBlbmRpbmdQb3N0Rmx1c2hDYnMiLCJhY3RpdmVQb3N0Rmx1c2hDYnMiLCJwb3N0Rmx1c2hJbmRleCIsInJlc29sdmVkUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY3VycmVudEZsdXNoUHJvbWlzZSIsImN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYiIsIlJFQ1VSU0lPTl9MSU1JVCIsIm5leHRUaWNrIiwicCIsInRoZW4iLCJiaW5kIiwiZmluZEluc2VydGlvbkluZGV4Iiwiam9iIiwic3RhcnQiLCJlbmQiLCJqb2JJZCIsImdldElkIiwibWlkZGxlIiwibWlkZGxlSm9iSWQiLCJxdWV1ZUpvYiIsInBvcyIsInNwbGljZSIsInF1ZXVlRmx1c2giLCJmbHVzaEpvYnMiLCJpbnZhbGlkYXRlSm9iIiwiaW5kZXhPZiIsInF1ZXVlQ2IiLCJjYiIsImFjdGl2ZVF1ZXVlIiwicGVuZGluZ1F1ZXVlIiwiaW5kZXgiLCJxdWV1ZVByZUZsdXNoQ2IiLCJxdWV1ZVBvc3RGbHVzaENiIiwiZmx1c2hQcmVGbHVzaENicyIsInNlZW4iLCJwYXJlbnRKb2IiLCJjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMiLCJmbHVzaFBvc3RGbHVzaENicyIsImRlZHVwZWQiLCJzb3J0IiwiYSIsImIiLCJJbmZpbml0eSIsImNvdW50Iiwib3duZXJJbnN0YW5jZSIsImNvbXBvbmVudE5hbWUiLCJnZXRDb21wb25lbnROYW1lIiwiaXNIbXJVcGRhdGluZyIsImhtckRpcnR5Q29tcG9uZW50cyIsImdsb2JhbE9iamVjdCIsImdsb2JhbCIsIndpbmRvdyIsIl9fVlVFX0hNUl9SVU5USU1FX18iLCJjcmVhdGVSZWNvcmQiLCJ0cnlXcmFwIiwicmVyZW5kZXIiLCJyZWxvYWQiLCJyZWdpc3RlckhNUiIsIl9faG1ySWQiLCJyZWNvcmQiLCJpbnN0YW5jZXMiLCJ1bnJlZ2lzdGVySE1SIiwiaXNDbGFzc0NvbXBvbmVudCIsIl9fdmNjT3B0cyIsIm5ld1JlbmRlciIsInJlbmRlciIsImZyb20iLCJyZW5kZXJDYWNoZSIsInVwZGF0ZSIsIm5ld0NvbXAiLCJsb2NhdGlvbiIsImFyZyIsImUiLCJkZXZ0b29scyIsInNldERldnRvb2xzSG9vayIsImhvb2siLCJkZXZ0b29sc0luaXRBcHAiLCJhcHAiLCJ2ZXJzaW9uIiwiZW1pdCIsIkZyYWdtZW50IiwiVGV4dCIsIkNvbW1lbnQiLCJDb21tZW50JDEiLCJTdGF0aWMiLCJkZXZ0b29sc1VubW91bnRBcHAiLCJkZXZ0b29sc0NvbXBvbmVudEFkZGVkIiwiY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rIiwiZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkIiwiZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkIiwiZGV2dG9vbHNQZXJmU3RhcnQiLCJjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayIsImRldnRvb2xzUGVyZkVuZCIsInRpbWUiLCJkZXZ0b29sc0NvbXBvbmVudEVtaXQiLCJldmVudCIsInBhcmFtcyIsImRlcHJlY2F0aW9uRGF0YSIsIm1lc3NhZ2UiLCJsaW5rIiwiaXNSdW50aW1lT25seSIsImxlZ2FjeUhvb2siLCJuZXdIb29rIiwiY29lcmNlZCIsImNvbXAiLCJjb25maWdNc2ciLCJpbnN0YW5jZVdhcm5lZCIsImNyZWF0ZSIsIndhcm5Db3VudCIsIndhcm5EZXByZWNhdGlvbiIsImdldEN1cnJlbnRJbnN0YW5jZSIsImdldENvbXBhdENvbmZpZ0ZvcktleSIsImR1cEtleSIsImNvbXBJZCIsImNvbXBvbmVudER1cEtleSIsImlzQ29tcGF0RW5hYmxlZCIsImdsb2JhbENvbXBhdENvbmZpZyIsIk1PREUiLCJpbnN0YW5jZUNvbmZpZyIsImNvbXBhdENvbmZpZyIsImVuYWJsZUZvckJ1aWx0SW4iLCJfX2lzQnVpbHRJbiIsInJhd01vZGUiLCJtb2RlIiwicmF3QXJncyIsImVtaXRzT3B0aW9ucyIsInByb3BzT3B0aW9ucyIsInRvSGFuZGxlcktleSIsInZhbGlkYXRvciIsImlzVmFsaWQiLCJpc01vZGVsTGlzdGVuZXIiLCJzdGFydHNXaXRoIiwibW9kZWxBcmciLCJtb2RpZmllcnNLZXkiLCJudW1iZXIiLCJ0cmltIiwidG9OdW1iZXIiLCJsb3dlckNhc2VFdmVudCIsInRvTG93ZXJDYXNlIiwiaHlwaGVuYXRlIiwiaGFuZGxlck5hbWUiLCJoYW5kbGVyIiwiY2FtZWxpemUiLCJvbmNlSGFuZGxlciIsImVtaXR0ZWQiLCJub3JtYWxpemVFbWl0c09wdGlvbnMiLCJhc01peGluIiwiY2FjaGUiLCJlbWl0c0NhY2hlIiwiY2FjaGVkIiwiZW1pdHMiLCJub3JtYWxpemVkIiwiaGFzRXh0ZW5kcyIsIl9fVlVFX09QVElPTlNfQVBJX18iLCJleHRlbmRFbWl0cyIsIm5vcm1hbGl6ZWRGcm9tRXh0ZW5kIiwibWl4aW5zIiwiZXh0ZW5kcyIsImlzRW1pdExpc3RlbmVyIiwiaXNPbiIsInJlcGxhY2UiLCJjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UiLCJjdXJyZW50U2NvcGVJZCIsInNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSIsInByZXYiLCJfX3Njb3BlSWQiLCJwdXNoU2NvcGVJZCIsInBvcFNjb3BlSWQiLCJ3aXRoU2NvcGVJZCIsIl9pZCIsIndpdGhDdHgiLCJjdHgiLCJpc05vblNjb3BlZFNsb3QiLCJfbiIsInJlbmRlckZuV2l0aENvbnRleHQiLCJfZCIsInNldEJsb2NrVHJhY2tpbmciLCJwcmV2SW5zdGFuY2UiLCJfYyIsImFjY2Vzc2VkQXR0cnMiLCJtYXJrQXR0cnNBY2Nlc3NlZCIsInJlbmRlckNvbXBvbmVudFJvb3QiLCJDb21wb25lbnQiLCJ3aXRoUHJveHkiLCJzbG90cyIsImF0dHJzIiwiZGF0YSIsInNldHVwU3RhdGUiLCJpbmhlcml0QXR0cnMiLCJmYWxsdGhyb3VnaEF0dHJzIiwic2hhcGVGbGFnIiwicHJveHlUb1VzZSIsIm5vcm1hbGl6ZVZOb2RlIiwiZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoIiwicm9vdCIsInNldFJvb3QiLCJwYXRjaEZsYWciLCJnZXRDaGlsZFJvb3QiLCJzb21lIiwiZmlsdGVyTW9kZWxMaXN0ZW5lcnMiLCJjbG9uZVZOb2RlIiwiYWxsQXR0cnMiLCJldmVudEF0dHJzIiwiZXh0cmFBdHRycyIsImRpcnMiLCJpc0VsZW1lbnRSb290IiwiY29uY2F0IiwidHJhbnNpdGlvbiIsImJsb2NrU3RhY2siLCJjcmVhdGVWTm9kZSIsInJhd0NoaWxkcmVuIiwiY2hpbGRyZW4iLCJkeW5hbWljQ2hpbGRyZW4iLCJjaGlsZFJvb3QiLCJmaWx0ZXJTaW5nbGVSb290IiwiZHluYW1pY0luZGV4IiwidXBkYXRlZFJvb3QiLCJzaW5nbGVSb290IiwiY2hpbGQiLCJpc1ZOb2RlIiwic2hvdWxkVXBkYXRlQ29tcG9uZW50IiwicHJldlZOb2RlIiwibmV4dFZOb2RlIiwib3B0aW1pemVkIiwicHJldlByb3BzIiwicHJldkNoaWxkcmVuIiwibmV4dFByb3BzIiwibmV4dENoaWxkcmVuIiwiaGFzUHJvcHNDaGFuZ2VkIiwiZHluYW1pY1Byb3BzIiwiJHN0YWJsZSIsIm5leHRLZXlzIiwidXBkYXRlSE9DSG9zdEVsIiwiZWwiLCJzdWJUcmVlIiwiaXNTdXNwZW5zZSIsIl9faXNTdXNwZW5zZSIsIlN1c3BlbnNlSW1wbCIsIm4xIiwibjIiLCJjb250YWluZXIiLCJhbmNob3IiLCJwYXJlbnRDb21wb25lbnQiLCJwYXJlbnRTdXNwZW5zZSIsImlzU1ZHIiwic2xvdFNjb3BlSWRzIiwicmVuZGVyZXJJbnRlcm5hbHMiLCJtb3VudFN1c3BlbnNlIiwicGF0Y2hTdXNwZW5zZSIsImh5ZHJhdGUiLCJoeWRyYXRlU3VzcGVuc2UiLCJjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5Iiwibm9ybWFsaXplIiwibm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbiIsIlN1c3BlbnNlIiwidHJpZ2dlckV2ZW50IiwiZXZlbnRMaXN0ZW5lciIsInBhdGNoIiwibyIsImNyZWF0ZUVsZW1lbnQiLCJoaWRkZW5Db250YWluZXIiLCJzdXNwZW5zZSIsInBlbmRpbmdCcmFuY2giLCJzc0NvbnRlbnQiLCJzc0ZhbGxiYWNrIiwic2V0QWN0aXZlQnJhbmNoIiwidW0iLCJ1bm1vdW50IiwibmV3QnJhbmNoIiwibmV3RmFsbGJhY2siLCJhY3RpdmVCcmFuY2giLCJpc0luRmFsbGJhY2siLCJpc0h5ZHJhdGluZyIsImlzU2FtZVZOb2RlVHlwZSIsInBlbmRpbmdJZCIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZmFsbGJhY2siLCJoYXNXYXJuZWQiLCJtIiwibW92ZSIsIm4iLCJwYXJlbnROb2RlIiwicmVtb3ZlIiwiaXNVbm1vdW50ZWQiLCJyZXN1bWUiLCJFcnJvciIsImRlbGF5RW50ZXIiLCJhZnRlckxlYXZlIiwiaGFzVW5yZXNvbHZlZEFuY2VzdG9yIiwiZmFsbGJhY2tWTm9kZSIsIm1vdW50RmFsbGJhY2siLCJyZWdpc3RlckRlcCIsInNldHVwUmVuZGVyRWZmZWN0IiwiaXNJblBlbmRpbmdTdXNwZW5zZSIsImh5ZHJhdGVkRWwiLCJhc3luY0RlcCIsImFzeW5jU2V0dXBSZXN1bHQiLCJzdXNwZW5zZUlkIiwiYXN5bmNSZXNvbHZlZCIsImhhbmRsZVNldHVwUmVzdWx0IiwicGxhY2Vob2xkZXIiLCJkb1JlbW92ZSIsIm5vZGUiLCJoeWRyYXRlTm9kZSIsImRvY3VtZW50IiwiaXNTbG90Q2hpbGRyZW4iLCJub3JtYWxpemVTdXNwZW5zZVNsb3QiLCJkZWZhdWx0IiwicyIsImJsb2NrIiwiaXNDb21waWxlZFNsb3QiLCJvcGVuQmxvY2siLCJjdXJyZW50QmxvY2siLCJjbG9zZUJsb2NrIiwic2luZ2xlQ2hpbGQiLCJjIiwicXVldWVFZmZlY3RXaXRoU3VzcGVuc2UiLCJicmFuY2giLCJwcm92aWRlIiwiY3VycmVudEluc3RhbmNlIiwicHJvdmlkZXMiLCJwYXJlbnRQcm92aWRlcyIsImluamVjdCIsImRlZmF1bHRWYWx1ZSIsInRyZWF0RGVmYXVsdEFzRmFjdG9yeSIsImFyZ3VtZW50cyIsIndhdGNoRWZmZWN0IiwiZG9XYXRjaCIsIklOSVRJQUxfV0FUQ0hFUl9WQUxVRSIsIndhdGNoIiwic291cmNlIiwiaW1tZWRpYXRlIiwiZGVlcCIsImZsdXNoIiwid2FybkludmFsaWRTb3VyY2UiLCJmb3JjZVRyaWdnZXIiLCJpc011bHRpU291cmNlIiwidHJhdmVyc2UiLCJvbkludmFsaWRhdGUiLCJiYXNlR2V0dGVyIiwicnVubmVyIiwicXVldWVQb3N0UmVuZGVyRWZmZWN0IiwiaXNNb3VudGVkIiwicmVjb3JkSW5zdGFuY2VCb3VuZEVmZmVjdCIsImluc3RhbmNlV2F0Y2giLCJwdWJsaWNUaGlzIiwiY3JlYXRlUGF0aEdldHRlciIsInBhdGgiLCJzZWdtZW50cyIsInNwbGl0IiwiaXNPYmplY3QkMSIsImlzU2V0IiwiaXNQbGFpbk9iamVjdCIsInVzZVRyYW5zaXRpb25TdGF0ZSIsInN0YXRlIiwiaXNMZWF2aW5nIiwiaXNVbm1vdW50aW5nIiwibGVhdmluZ1ZOb2RlcyIsIm9uTW91bnRlZCIsIm9uQmVmb3JlVW5tb3VudCIsIlRyYW5zaXRpb25Ib29rVmFsaWRhdG9yIiwiRnVuY3Rpb24iLCJCYXNlVHJhbnNpdGlvbkltcGwiLCJhcHBlYXIiLCJwZXJzaXN0ZWQiLCJvbkJlZm9yZUVudGVyIiwib25FbnRlciIsIm9uQWZ0ZXJFbnRlciIsIm9uRW50ZXJDYW5jZWxsZWQiLCJvbkJlZm9yZUxlYXZlIiwib25MZWF2ZSIsIm9uQWZ0ZXJMZWF2ZSIsIm9uTGVhdmVDYW5jZWxsZWQiLCJvbkJlZm9yZUFwcGVhciIsIm9uQXBwZWFyIiwib25BZnRlckFwcGVhciIsIm9uQXBwZWFyQ2FuY2VsbGVkIiwic2V0dXAiLCJwcmV2VHJhbnNpdGlvbktleSIsImdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiIsInJhd1Byb3BzIiwiZW1wdHlQbGFjZWhvbGRlciIsImlubmVyQ2hpbGQiLCJnZXRLZWVwQWxpdmVDaGlsZCIsImVudGVySG9va3MiLCJyZXNvbHZlVHJhbnNpdGlvbkhvb2tzIiwic2V0VHJhbnNpdGlvbkhvb2tzIiwib2xkQ2hpbGQiLCJvbGRJbm5lckNoaWxkIiwidHJhbnNpdGlvbktleUNoYW5nZWQiLCJnZXRUcmFuc2l0aW9uS2V5IiwibGVhdmluZ0hvb2tzIiwiZGVsYXlMZWF2ZSIsImVhcmx5UmVtb3ZlIiwiZGVsYXllZExlYXZlIiwibGVhdmluZ1ZOb2Rlc0NhY2hlIiwiZ2V0TGVhdmluZ05vZGVzRm9yVHlwZSIsIl9sZWF2ZUNiIiwiQmFzZVRyYW5zaXRpb24iLCJjYWxsSG9vayIsImhvb2tzIiwiYmVmb3JlRW50ZXIiLCJsZWF2aW5nVk5vZGUiLCJlbnRlciIsImFmdGVySG9vayIsImNhbmNlbEhvb2siLCJjYWxsZWQiLCJfZW50ZXJDYiIsImNhbmNlbGxlZCIsImxlYXZlIiwiY2xvbmUiLCJpc0tlZXBBbGl2ZSIsImtlZXBDb21tZW50Iiwia2V5ZWRGcmFnbWVudENvdW50IiwiZGVmaW5lQ29tcG9uZW50IiwiaXNBc3luY1dyYXBwZXIiLCJfX2FzeW5jTG9hZGVyIiwiZGVmaW5lQXN5bmNDb21wb25lbnQiLCJsb2FkZXIiLCJsb2FkaW5nQ29tcG9uZW50IiwiZXJyb3JDb21wb25lbnQiLCJkZWxheSIsInN1c3BlbnNpYmxlIiwib25FcnJvciIsInVzZXJPbkVycm9yIiwicGVuZGluZ1JlcXVlc3QiLCJyZXNvbHZlZENvbXAiLCJyZXRyaWVzIiwicmV0cnkiLCJsb2FkIiwidGhpc1JlcXVlc3QiLCJyZWplY3QiLCJ1c2VyUmV0cnkiLCJ1c2VyRmFpbCIsIl9fZXNNb2R1bGUiLCJ0b1N0cmluZ1RhZyIsIl9fYXN5bmNSZXNvbHZlZCIsImNyZWF0ZUlubmVyQ29tcCIsImxvYWRlZCIsImRlbGF5ZWQiLCJfX2lzS2VlcEFsaXZlIiwiS2VlcEFsaXZlSW1wbCIsImluY2x1ZGUiLCJSZWdFeHAiLCJleGNsdWRlIiwibWF4Iiwic2hhcmVkQ29udGV4dCIsInJlbmRlcmVyIiwiY3VycmVudCIsIl9fdl9jYWNoZSIsIl91bm1vdW50Iiwic3RvcmFnZUNvbnRhaW5lciIsImFjdGl2YXRlIiwiaXNEZWFjdGl2YXRlZCIsImludm9rZUFycmF5Rm5zIiwidm5vZGVIb29rIiwib25Wbm9kZU1vdW50ZWQiLCJpbnZva2VWTm9kZUhvb2siLCJkZWFjdGl2YXRlIiwiZGEiLCJvblZub2RlVW5tb3VudGVkIiwicmVzZXRTaGFwZUZsYWciLCJwcnVuZUNhY2hlIiwicHJ1bmVDYWNoZUVudHJ5IiwibWF0Y2hlcyIsInBlbmRpbmdDYWNoZUtleSIsImNhY2hlU3VidHJlZSIsImdldElubmVyQ2hpbGQiLCJvblVwZGF0ZWQiLCJyYXdWTm9kZSIsImNhY2hlZFZOb2RlIiwicGFyc2VJbnQiLCJLZWVwQWxpdmUiLCJwYXR0ZXJuIiwidGVzdCIsIm9uQWN0aXZhdGVkIiwicmVnaXN0ZXJLZWVwQWxpdmVIb29rIiwib25EZWFjdGl2YXRlZCIsIndyYXBwZWRIb29rIiwiX193ZGMiLCJpbmplY3RIb29rIiwiaW5qZWN0VG9LZWVwQWxpdmVSb290Iiwia2VlcEFsaXZlUm9vdCIsImluamVjdGVkIiwib25Vbm1vdW50ZWQiLCJwcmVwZW5kIiwiX193ZWgiLCJzZXRDdXJyZW50SW5zdGFuY2UiLCJ1bnNoaWZ0IiwiYXBpTmFtZSIsImNyZWF0ZUhvb2siLCJsaWZlY3ljbGUiLCJpc0luU1NSQ29tcG9uZW50U2V0dXAiLCJvbkJlZm9yZU1vdW50Iiwib25CZWZvcmVVcGRhdGUiLCJvblNlcnZlclByZWZldGNoIiwib25SZW5kZXJUcmlnZ2VyZWQiLCJvblJlbmRlclRyYWNrZWQiLCJvbkVycm9yQ2FwdHVyZWQiLCJjcmVhdGVEdXBsaWNhdGVDaGVja2VyIiwic2hvdWxkQ2FjaGVBY2Nlc3MiLCJhcHBseU9wdGlvbnMiLCJyZXNvbHZlTWVyZ2VkT3B0aW9ucyIsImJlZm9yZUNyZWF0ZSIsImRhdGFPcHRpb25zIiwiY29tcHV0ZWRPcHRpb25zIiwibWV0aG9kcyIsIndhdGNoT3B0aW9ucyIsInByb3ZpZGVPcHRpb25zIiwiaW5qZWN0T3B0aW9ucyIsImNyZWF0ZWQiLCJiZWZvcmVNb3VudCIsIm1vdW50ZWQiLCJiZWZvcmVVcGRhdGUiLCJ1cGRhdGVkIiwiYWN0aXZhdGVkIiwiZGVhY3RpdmF0ZWQiLCJiZWZvcmVEZXN0cm95IiwiYmVmb3JlVW5tb3VudCIsImRlc3Ryb3llZCIsInVubW91bnRlZCIsInJlbmRlclRyYWNrZWQiLCJyZW5kZXJUcmlnZ2VyZWQiLCJlcnJvckNhcHR1cmVkIiwic2VydmVyUHJlZmV0Y2giLCJleHBvc2UiLCJjb21wb25lbnRzIiwiZGlyZWN0aXZlcyIsImZpbHRlcnMiLCJjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMiLCJyZXNvbHZlSW5qZWN0aW9ucyIsIm1ldGhvZEhhbmRsZXIiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsIm9wdCIsImNyZWF0ZVdhdGNoZXIiLCJyZWdpc3RlckxpZmVjeWNsZUhvb2siLCJyZWdpc3RlciIsIl9ob29rIiwiZXhwb3NlZCIsIm5vcm1hbGl6ZUluamVjdCIsImgiLCJiYXNlIiwiZXh0ZW5kc09wdGlvbnMiLCJnbG9iYWxNaXhpbnMiLCJvcHRpb25zQ2FjaGUiLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJyZXNvbHZlZCIsIm1lcmdlT3B0aW9ucyIsInRvIiwic3RyYXRzIiwic3RyYXQiLCJpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzIiwibWVyZ2VEYXRhRm4iLCJtZXJnZU9iamVjdE9wdGlvbnMiLCJtZXJnZUFzQXJyYXkiLCJtZXJnZVdhdGNoT3B0aW9ucyIsIm1lcmdlSW5qZWN0IiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkIiwiaW5pdFByb3BzIiwiaXNTdGF0ZWZ1bCIsImlzU1NSIiwiSW50ZXJuYWxPYmplY3RLZXkiLCJwcm9wc0RlZmF1bHRzIiwic2V0RnVsbFByb3BzIiwidmFsaWRhdGVQcm9wcyIsInVwZGF0ZVByb3BzIiwicmF3UHJldlByb3BzIiwicmF3Q3VycmVudFByb3BzIiwiaGFzQXR0cnNDaGFuZ2VkIiwicHJvcHNUb1VwZGF0ZSIsImNhbWVsaXplZEtleSIsInJlc29sdmVQcm9wVmFsdWUiLCJrZWJhYktleSIsIm5lZWRDYXN0S2V5cyIsInJhd0Nhc3RWYWx1ZXMiLCJpc1Jlc2VydmVkUHJvcCIsImNhbWVsS2V5IiwiY2FzdFZhbHVlcyIsImlzQWJzZW50IiwiaGFzRGVmYXVsdCIsIm5vcm1hbGl6ZVByb3BzT3B0aW9ucyIsInByb3BzQ2FjaGUiLCJleHRlbmRQcm9wcyIsIkVNUFRZX0FSUiIsIm5vcm1hbGl6ZWRLZXkiLCJ2YWxpZGF0ZVByb3BOYW1lIiwicHJvcCIsImJvb2xlYW5JbmRleCIsImdldFR5cGVJbmRleCIsInN0cmluZ0luZGV4IiwiZ2V0VHlwZSIsImN0b3IiLCJtYXRjaCIsInRvU3RyaW5nIiwiaXNTYW1lVHlwZSIsImV4cGVjdGVkVHlwZXMiLCJmaW5kSW5kZXgiLCJ0IiwicmVzb2x2ZWRWYWx1ZXMiLCJ2YWxpZGF0ZVByb3AiLCJyZXF1aXJlZCIsInR5cGVzIiwidmFsaWQiLCJleHBlY3RlZFR5cGUiLCJhc3NlcnRUeXBlIiwiZ2V0SW52YWxpZFR5cGVNZXNzYWdlIiwiaXNTaW1wbGVUeXBlIiwicmVjZWl2ZWRUeXBlIiwiZXhwZWN0ZWRWYWx1ZSIsInN0eWxlVmFsdWUiLCJyZWNlaXZlZFZhbHVlIiwiaXNFeHBsaWNhYmxlIiwiaXNCb29sZWFuIiwiZXhwbGljaXRUeXBlcyIsImVsZW0iLCJpc0ludGVybmFsS2V5Iiwibm9ybWFsaXplU2xvdFZhbHVlIiwibm9ybWFsaXplU2xvdCIsInJhd1Nsb3QiLCJub3JtYWxpemVPYmplY3RTbG90cyIsInJhd1Nsb3RzIiwiX2N0eCIsIm5vcm1hbGl6ZVZOb2RlU2xvdHMiLCJpbml0U2xvdHMiLCJfIiwidXBkYXRlU2xvdHMiLCJuZWVkRGVsZXRpb25DaGVjayIsImRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCIsImlzQnVpbHRJbkRpcmVjdGl2ZSIsInZhbGlkYXRlRGlyZWN0aXZlTmFtZSIsIndpdGhEaXJlY3RpdmVzIiwiaW50ZXJuYWxJbnN0YW5jZSIsImJpbmRpbmdzIiwiZGlyIiwibW9kaWZpZXJzIiwiaW52b2tlRGlyZWN0aXZlSG9vayIsIm9sZEJpbmRpbmdzIiwiYmluZGluZyIsImNyZWF0ZUFwcENvbnRleHQiLCJpc05hdGl2ZVRhZyIsIk5PIiwicGVyZm9ybWFuY2UiLCJnbG9iYWxQcm9wZXJ0aWVzIiwiY29tcGlsZXJPcHRpb25zIiwiY3JlYXRlQXBwQVBJIiwiY3JlYXRlQXBwIiwicm9vdENvbXBvbmVudCIsInJvb3RQcm9wcyIsImNvbnRleHQiLCJpbnN0YWxsZWRQbHVnaW5zIiwiX3VpZCIsIl9jb21wb25lbnQiLCJfcHJvcHMiLCJfY29udGFpbmVyIiwiX2NvbnRleHQiLCJfaW5zdGFuY2UiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsIiwibWl4aW4iLCJ2YWxpZGF0ZUNvbXBvbmVudE5hbWUiLCJkaXJlY3RpdmUiLCJtb3VudCIsInJvb3RDb250YWluZXIiLCJpc0h5ZHJhdGUiLCJfX3Z1ZV9hcHBfXyIsImhhc01pc21hdGNoIiwiaXNTVkdDb250YWluZXIiLCJuYW1lc3BhY2VVUkkiLCJ0YWdOYW1lIiwiaXNDb21tZW50Iiwibm9kZVR5cGUiLCJjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMiLCJtdCIsIm1vdW50Q29tcG9uZW50IiwicGF0Y2hQcm9wIiwibmV4dFNpYmxpbmciLCJpbnNlcnQiLCJjcmVhdGVDb21tZW50IiwiaGFzQ2hpbGROb2RlcyIsImZpcnN0Q2hpbGQiLCJpc0ZyYWdtZW50U3RhcnQiLCJvbk1pc21hdGNoIiwiaGFuZGxlTWlzbWF0Y2giLCJkb21UeXBlIiwibmV4dE5vZGUiLCJuZWVkVG9BZG9wdENvbnRlbnQiLCJzdGF0aWNDb3VudCIsIm91dGVySFRNTCIsImh5ZHJhdGVGcmFnbWVudCIsImh5ZHJhdGVFbGVtZW50IiwibG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yIiwicHJldmlvdXNTaWJsaW5nIiwibGFzdENoaWxkIiwiY3JlYXRlVGV4dFZOb2RlIiwiaHlkcmF0ZUNoaWxkcmVuIiwic2V0UmVmIiwiZm9yY2VQYXRjaFZhbHVlIiwiZW5kc1dpdGgiLCJvbkNsaWNrIiwidm5vZGVIb29rcyIsIm9uVm5vZGVCZWZvcmVNb3VudCIsImlubmVySFRNTCIsInRleHRDb250ZW50IiwicGFyZW50Vk5vZGUiLCJmcmFnbWVudFNsb3RTY29wZUlkcyIsImlzRnJhZ21lbnQiLCJzdXBwb3J0ZWQiLCJwZXJmIiwic3RhcnRNZWFzdXJlIiwiaXNTdXBwb3J0ZWQiLCJtYXJrIiwibm93IiwiRGF0ZSIsImVuZE1lYXN1cmUiLCJzdGFydFRhZyIsImVuZFRhZyIsIm1lYXN1cmUiLCJjbGVhck1hcmtzIiwiaW5pdEZlYXR1cmVGbGFncyIsIm5lZWRXYXJuIiwicHJvZEVmZmVjdE9wdGlvbnMiLCJjcmVhdGVEZXZFZmZlY3RPcHRpb25zIiwicnRjIiwicnRnIiwicmF3UmVmIiwib2xkUmF3UmVmIiwiaXNVbm1vdW50IiwicmVmVmFsdWUiLCJnZXRFeHBvc2VQcm94eSIsIm93bmVyIiwib2xkUmVmIiwicmVmcyIsImRvU2V0IiwiY3JlYXRlUmVuZGVyZXIiLCJiYXNlQ3JlYXRlUmVuZGVyZXIiLCJjcmVhdGVIeWRyYXRpb25SZW5kZXJlciIsImNyZWF0ZUh5ZHJhdGlvbkZucyIsImdldEdsb2JhbFRoaXMiLCJfX1ZVRV9fIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImhvc3RJbnNlcnQiLCJob3N0UmVtb3ZlIiwiaG9zdFBhdGNoUHJvcCIsImZvcmNlUGF0Y2hQcm9wIiwiaG9zdEZvcmNlUGF0Y2hQcm9wIiwiaG9zdENyZWF0ZUVsZW1lbnQiLCJjcmVhdGVUZXh0IiwiaG9zdENyZWF0ZVRleHQiLCJob3N0Q3JlYXRlQ29tbWVudCIsInNldFRleHQiLCJob3N0U2V0VGV4dCIsInNldEVsZW1lbnRUZXh0IiwiaG9zdFNldEVsZW1lbnRUZXh0IiwiaG9zdFBhcmVudE5vZGUiLCJob3N0TmV4dFNpYmxpbmciLCJzZXRTY29wZUlkIiwiaG9zdFNldFNjb3BlSWQiLCJjbG9uZU5vZGUiLCJob3N0Q2xvbmVOb2RlIiwiaW5zZXJ0U3RhdGljQ29udGVudCIsImhvc3RJbnNlcnRTdGF0aWNDb250ZW50IiwiZ2V0TmV4dEhvc3ROb2RlIiwicHJvY2Vzc1RleHQiLCJwcm9jZXNzQ29tbWVudE5vZGUiLCJtb3VudFN0YXRpY05vZGUiLCJwYXRjaFN0YXRpY05vZGUiLCJwcm9jZXNzRnJhZ21lbnQiLCJwcm9jZXNzRWxlbWVudCIsInByb2Nlc3NDb21wb25lbnQiLCJpbnRlcm5hbHMiLCJub2RlcyIsInN0YXRpY0NhY2hlIiwicmVtb3ZlU3RhdGljTm9kZSIsIm1vdmVTdGF0aWNOb2RlIiwibW91bnRFbGVtZW50IiwicGF0Y2hFbGVtZW50IiwiaXMiLCJtb3VudENoaWxkcmVuIiwidW5tb3VudENoaWxkcmVuIiwic2NvcGVJZCIsIm5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzIiwiY2xvbmVJZk1vdW50ZWQiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwib25Wbm9kZUJlZm9yZVVwZGF0ZSIsInBhdGNoUHJvcHMiLCJjbGFzcyIsInN0eWxlIiwiYXJlQ2hpbGRyZW5TVkciLCJwYXRjaEJsb2NrQ2hpbGRyZW4iLCJ0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuIiwicGF0Y2hDaGlsZHJlbiIsIm9uVm5vZGVVcGRhdGVkIiwib2xkQ2hpbGRyZW4iLCJuZXdDaGlsZHJlbiIsImZhbGxiYWNrQ29udGFpbmVyIiwib2xkVk5vZGUiLCJuZXdWTm9kZSIsImZyYWdtZW50U3RhcnRBbmNob3IiLCJmcmFnbWVudEVuZEFuY2hvciIsInVwZGF0ZUNvbXBvbmVudCIsImluaXRpYWxWTm9kZSIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlIiwic2V0dXBDb21wb25lbnQiLCJ1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIiLCJjb21wb25lbnRFZmZlY3QiLCJibSIsImh5ZHJhdGVTdWJUcmVlIiwic2NvcGVkSW5pdGlhbFZOb2RlIiwiYnUiLCJ1Iiwib3JpZ2luTmV4dCIsIm5leHRUcmVlIiwicHJldlRyZWUiLCJjMSIsInByZXZTaGFwZUZsYWciLCJjMiIsInBhdGNoS2V5ZWRDaGlsZHJlbiIsInBhdGNoVW5rZXllZENoaWxkcmVuIiwib2xkTGVuZ3RoIiwibmV3TGVuZ3RoIiwiY29tbW9uTGVuZ3RoIiwiTWF0aCIsIm1pbiIsIm5leHRDaGlsZCIsInBhcmVudEFuY2hvciIsImwyIiwiZTEiLCJlMiIsIm5leHRQb3MiLCJzMSIsInMyIiwia2V5VG9OZXdJbmRleE1hcCIsImoiLCJwYXRjaGVkIiwidG9CZVBhdGNoZWQiLCJtb3ZlZCIsIm1heE5ld0luZGV4U29GYXIiLCJuZXdJbmRleFRvT2xkSW5kZXhNYXAiLCJwcmV2Q2hpbGQiLCJuZXdJbmRleCIsImluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlIiwiZ2V0U2VxdWVuY2UiLCJuZXh0SW5kZXgiLCJtb3ZlVHlwZSIsIm5lZWRUcmFuc2l0aW9uIiwicGVyZm9ybUxlYXZlIiwic2hvdWxkSW52b2tlRGlycyIsIm9uVm5vZGVCZWZvcmVVbm1vdW50IiwidW5tb3VudENvbXBvbmVudCIsInJlbW92ZUZyYWdtZW50IiwicGVyZm9ybVJlbW92ZSIsImJ1bSIsIl92bm9kZSIsIm1jIiwicGMiLCJwYmMiLCJjaDEiLCJjaDIiLCJsZW4iLCJhcnJJIiwiaXNUZWxlcG9ydCIsIl9faXNUZWxlcG9ydCIsImlzVGVsZXBvcnREaXNhYmxlZCIsImRpc2FibGVkIiwiaXNUYXJnZXRTVkciLCJTVkdFbGVtZW50IiwicmVzb2x2ZVRhcmdldCIsInNlbGVjdCIsInRhcmdldFNlbGVjdG9yIiwiVGVsZXBvcnRJbXBsIiwicXVlcnlTZWxlY3RvciIsIm1haW5BbmNob3IiLCJ0YXJnZXRBbmNob3IiLCJ3YXNEaXNhYmxlZCIsImN1cnJlbnRDb250YWluZXIiLCJjdXJyZW50QW5jaG9yIiwibW92ZVRlbGVwb3J0IiwibmV4dFRhcmdldCIsImh5ZHJhdGVUZWxlcG9ydCIsImlzUmVvcmRlciIsInRhcmdldE5vZGUiLCJfbHBhIiwiVGVsZXBvcnQiLCJDT01QT05FTlRTIiwiRElSRUNUSVZFUyIsInJlc29sdmVDb21wb25lbnQiLCJtYXliZVNlbGZSZWZlcmVuY2UiLCJyZXNvbHZlQXNzZXQiLCJOVUxMX0RZTkFNSUNfQ09NUE9ORU5UIiwicmVzb2x2ZUR5bmFtaWNDb21wb25lbnQiLCJyZXNvbHZlRGlyZWN0aXZlIiwid2Fybk1pc3NpbmciLCJzZWxmTmFtZSIsInJlZ2lzdHJ5IiwiZGlzYWJsZVRyYWNraW5nIiwiaXNCbG9ja1RyZWVFbmFibGVkIiwiY3JlYXRlQmxvY2siLCJfX3ZfaXNWTm9kZSIsInZub2RlQXJnc1RyYW5zZm9ybWVyIiwidHJhbnNmb3JtVk5vZGVBcmdzIiwidHJhbnNmb3JtZXIiLCJjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtIiwiX2NyZWF0ZVZOb2RlIiwibm9ybWFsaXplS2V5Iiwibm9ybWFsaXplUmVmIiwiaXNCbG9ja05vZGUiLCJjbG9uZWQiLCJub3JtYWxpemVDaGlsZHJlbiIsImtsYXNzIiwibm9ybWFsaXplQ2xhc3MiLCJub3JtYWxpemVTdHlsZSIsIl9fdl9za2lwIiwiZXh0cmFQcm9wcyIsIm1lcmdlUmVmIiwibWVyZ2VkUHJvcHMiLCJtZXJnZVByb3BzIiwiZGVlcENsb25lVk5vZGUiLCJ0ZXh0IiwiZmxhZyIsImNyZWF0ZVN0YXRpY1ZOb2RlIiwiY29udGVudCIsIm51bWJlck9mTm9kZXMiLCJjcmVhdGVDb21tZW50Vk5vZGUiLCJhc0Jsb2NrIiwic2xvdCIsInNsb3RGbGFnIiwidG9NZXJnZSIsImV4aXN0aW5nIiwiaW5jb21pbmciLCJyZW5kZXJMaXN0IiwicmVuZGVySXRlbSIsImlzSW50ZWdlciIsImNyZWF0ZVNsb3RzIiwiZHluYW1pY1Nsb3RzIiwicmVuZGVyU2xvdCIsIm5vU2xvdHRlZCIsInZhbGlkU2xvdENvbnRlbnQiLCJlbnN1cmVWYWxpZFZOb2RlIiwicmVuZGVyZWQiLCJ2bm9kZXMiLCJ0b0hhbmRsZXJzIiwib2JqIiwiZ2V0UHVibGljSW5zdGFuY2UiLCJpc1N0YXRlZnVsQ29tcG9uZW50IiwicHVibGljUHJvcGVydGllc01hcCIsIiQiLCIkZWwiLCIkZGF0YSIsIiRwcm9wcyIsIiRhdHRycyIsIiRzbG90cyIsIiRyZWZzIiwiJHBhcmVudCIsIiRyb290IiwiJGVtaXQiLCIkb3B0aW9ucyIsIiRmb3JjZVVwZGF0ZSIsIiRuZXh0VGljayIsIiR3YXRjaCIsIlB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyIsImFjY2Vzc0NhY2hlIiwiX19pc1NjcmlwdFNldHVwIiwibm9ybWFsaXplZFByb3BzIiwicHVibGljR2V0dGVyIiwiY3NzTW9kdWxlIiwiX19jc3NNb2R1bGVzIiwiUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzIiwidW5zY29wYWJsZXMiLCJpc0dsb2JhbGx5V2hpdGVsaXN0ZWQiLCJjcmVhdGVSZW5kZXJDb250ZXh0IiwiZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQiLCJleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0IiwiZW1wdHlBcHBDb250ZXh0IiwidWlkJDEiLCJleHBvc2VQcm94eSIsInNldHVwQ29udGV4dCIsImJjIiwic3AiLCJpc0J1aWx0SW5UYWciLCJhcHBJc05hdGl2ZVRhZyIsInNldHVwUmVzdWx0Iiwic2V0dXBTdGF0ZWZ1bENvbXBvbmVudCIsIm5hbWVzIiwiY3JlYXRlU2V0dXBDb250ZXh0IiwidW5zZXRJbnN0YW5jZSIsInJlc29sdmVkUmVzdWx0IiwiZmluaXNoQ29tcG9uZW50U2V0dXAiLCJkZXZ0b29sc1Jhd1NldHVwU3RhdGUiLCJjb21waWxlIiwicmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIiLCJfY29tcGlsZSIsInNraXBPcHRpb25zIiwidGVtcGxhdGUiLCJpc0N1c3RvbUVsZW1lbnQiLCJkZWxpbWl0ZXJzIiwiY29tcG9uZW50Q29tcGlsZXJPcHRpb25zIiwiZmluYWxDb21waWxlck9wdGlvbnMiLCJfcmMiLCJhdHRyRGV2UHJveHlIYW5kbGVycyIsImZyZWV6ZSIsImNsYXNzaWZ5UkUiLCJjbGFzc2lmeSIsInN0ciIsInRvVXBwZXJDYXNlIiwiZGlzcGxheU5hbWUiLCJfX2ZpbGUiLCJpbmZlckZyb21SZWdpc3RyeSIsImNvbXB1dGVkJDEiLCJpc1Byb21pc2UiLCJ3YXJuUnVudGltZVVzYWdlIiwiZGVmaW5lUHJvcHMiLCJkZWZpbmVFbWl0cyIsImRlZmluZUVtaXQiLCJkZWZpbmVFeHBvc2UiLCJ3aXRoRGVmYXVsdHMiLCJkZWZhdWx0cyIsInVzZUNvbnRleHQiLCJnZXRDb250ZXh0IiwidXNlU2xvdHMiLCJ1c2VBdHRycyIsIm1lcmdlRGVmYXVsdHMiLCJ3aXRoQXN5bmNDb250ZXh0IiwiYXdhaXRhYmxlIiwicHJvcHNPckNoaWxkcmVuIiwic3NyQ29udGV4dEtleSIsInVzZVNTUkNvbnRleHQiLCJpbml0Q3VzdG9tRm9ybWF0dGVyIiwidnVlU3R5bGUiLCJudW1iZXJTdHlsZSIsInN0cmluZ1N0eWxlIiwia2V5d29yZFN0eWxlIiwiZm9ybWF0dGVyIiwiaGVhZGVyIiwiX19pc1Z1ZSIsImdlblJlZkZsYWciLCJmb3JtYXRWYWx1ZSIsImhhc0JvZHkiLCJib2R5IiwiZm9ybWF0SW5zdGFuY2UiLCJibG9ja3MiLCJjcmVhdGVJbnN0YW5jZUJsb2NrIiwiZXh0cmFjdEtleXMiLCJhc1JhdyIsIkNvbXAiLCJleHRyYWN0ZWQiLCJpc0tleU9mVHlwZSIsIm9wdHMiLCJkZXZ0b29sc0Zvcm1hdHRlcnMiLCJzc3JVdGlscyIsInJlc29sdmVGaWx0ZXIiLCJjb21wYXRVdGlscyIsInN2Z05TIiwiZG9jIiwibm9kZU9wcyIsImluc2VydEJlZm9yZSIsInJlbW92ZUNoaWxkIiwidGFnIiwiY3JlYXRlRWxlbWVudE5TIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVUZXh0Tm9kZSIsIm5vZGVWYWx1ZSIsInNlbGVjdG9yIiwiZmlyc3QiLCJiZWZvcmUiLCJpbnNlcnRpb25Qb2ludCIsInVzaW5nVGVtcEluc2VydGlvblBvaW50IiwiRWxlbWVudCIsImluc2VydEFkamFjZW50SFRNTCIsInBhdGNoQ2xhc3MiLCJ0cmFuc2l0aW9uQ2xhc3NlcyIsIl92dGMiLCJjbGFzc05hbWUiLCJwYXRjaFN0eWxlIiwicmVtb3ZlQXR0cmlidXRlIiwiZGlzcGxheSIsImNzc1RleHQiLCJzZXRTdHlsZSIsImltcG9ydGFudFJFIiwic2V0UHJvcGVydHkiLCJwcmVmaXhlZCIsImF1dG9QcmVmaXgiLCJwcmVmaXhlcyIsInByZWZpeENhY2hlIiwicmF3TmFtZSIsInhsaW5rTlMiLCJwYXRjaEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInNldEF0dHJpYnV0ZU5TIiwiaXNTcGVjaWFsQm9vbGVhbkF0dHIiLCJwYXRjaERPTVByb3AiLCJfZ2V0Tm93Iiwic2tpcFRpbWVzdGFtcENoZWNrIiwiY3JlYXRlRXZlbnQiLCJ0aW1lU3RhbXAiLCJmZk1hdGNoIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiY2FjaGVkTm93IiwicmVzZXQiLCJnZXROb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInBhdGNoRXZlbnQiLCJwcmV2VmFsdWUiLCJuZXh0VmFsdWUiLCJpbnZva2VycyIsIl92ZWkiLCJleGlzdGluZ0ludm9rZXIiLCJwYXJzZU5hbWUiLCJpbnZva2VyIiwiY3JlYXRlSW52b2tlciIsIm9wdGlvbnNNb2RpZmllclJFIiwiaW5pdGlhbFZhbHVlIiwiYXR0YWNoZWQiLCJwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIm9yaWdpbmFsU3RvcCIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIl9zdG9wcGVkIiwibmF0aXZlT25SRSIsInNob3VsZFNldEFzUHJvcCIsIl90cnVlVmFsdWUiLCJfZmFsc2VWYWx1ZSIsInVzZUNzc01vZHVsZSIsIm1vZHVsZXMiLCJtb2QiLCJ1c2VDc3NWYXJzIiwic2V0VmFycyIsInNldFZhcnNPblZOb2RlIiwidmFycyIsIlRSQU5TSVRJT04iLCJBTklNQVRJT04iLCJUcmFuc2l0aW9uIiwicmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyIsIkRPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMiLCJjc3MiLCJkdXJhdGlvbiIsImVudGVyRnJvbUNsYXNzIiwiZW50ZXJBY3RpdmVDbGFzcyIsImVudGVyVG9DbGFzcyIsImFwcGVhckZyb21DbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImxlYXZlRnJvbUNsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsIlRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMiLCJoYXNFeHBsaWNpdENhbGxiYWNrIiwiYmFzZVByb3BzIiwiZHVyYXRpb25zIiwibm9ybWFsaXplRHVyYXRpb24iLCJlbnRlckR1cmF0aW9uIiwibGVhdmVEdXJhdGlvbiIsImZpbmlzaEVudGVyIiwiaXNBcHBlYXIiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJmaW5pc2hMZWF2ZSIsIm1ha2VFbnRlckhvb2siLCJuZXh0RnJhbWUiLCJhZGRUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJmb3JjZVJlZmxvdyIsIk51bWJlck9mIiwidmFsaWRhdGVEdXJhdGlvbiIsImlzTmFOIiwiY2xzIiwiY2xhc3NMaXN0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZW5kSWQiLCJleHBsaWNpdFRpbWVvdXQiLCJfZW5kSWQiLCJyZXNvbHZlSWZOb3RTdGFsZSIsInByb3BDb3VudCIsImdldFRyYW5zaXRpb25JbmZvIiwiZW5kRXZlbnQiLCJlbmRlZCIsIm9uRW5kIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFN0eWxlUHJvcGVydGllcyIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImQiLCJ0b01zIiwib2Zmc2V0SGVpZ2h0IiwicG9zaXRpb25NYXAiLCJuZXdQb3NpdGlvbk1hcCIsIlRyYW5zaXRpb25Hcm91cEltcGwiLCJtb3ZlQ2xhc3MiLCJoYXNDU1NUcmFuc2Zvcm0iLCJjYWxsUGVuZGluZ0NicyIsInJlY29yZFBvc2l0aW9uIiwibW92ZWRDaGlsZHJlbiIsImFwcGx5VHJhbnNsYXRpb24iLCJ0cmFuc2Zvcm0iLCJ3ZWJraXRUcmFuc2Zvcm0iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJfbW92ZUNiIiwicHJvcGVydHlOYW1lIiwiY3NzVHJhbnNpdGlvblByb3BzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiVHJhbnNpdGlvbkdyb3VwIiwib2xkUG9zIiwibmV3UG9zIiwiZHgiLCJsZWZ0IiwiZHkiLCJ0b3AiLCJhcHBlbmRDaGlsZCIsImdldE1vZGVsQXNzaWduZXIiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJjb21wb3NpbmciLCJvbkNvbXBvc2l0aW9uRW5kIiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInZNb2RlbFRleHQiLCJfYXNzaWduIiwiY2FzdFRvTnVtYmVyIiwiZG9tVmFsdWUiLCJhY3RpdmVFbGVtZW50Iiwidk1vZGVsQ2hlY2tib3giLCJtb2RlbFZhbHVlIiwiX21vZGVsVmFsdWUiLCJlbGVtZW50VmFsdWUiLCJnZXRWYWx1ZSIsImNoZWNrZWQiLCJhc3NpZ24iLCJsb29zZUluZGV4T2YiLCJmb3VuZCIsImZpbHRlcmVkIiwiZ2V0Q2hlY2tib3hWYWx1ZSIsInNldENoZWNrZWQiLCJsb29zZUVxdWFsIiwidk1vZGVsUmFkaW8iLCJ2TW9kZWxTZWxlY3QiLCJpc1NldE1vZGVsIiwic2VsZWN0ZWRWYWwiLCJzZWxlY3RlZCIsInNldFNlbGVjdGVkIiwiX2JpbmRpbmciLCJpc011bHRpcGxlIiwib3B0aW9uIiwib3B0aW9uVmFsdWUiLCJzZWxlY3RlZEluZGV4Iiwidk1vZGVsRHluYW1pYyIsImNhbGxNb2RlbEhvb2siLCJtb2RlbFRvVXNlIiwic3lzdGVtTW9kaWZpZXJzIiwibW9kaWZpZXJHdWFyZHMiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50IiwicHJldmVudERlZmF1bHQiLCJjdXJyZW50VGFyZ2V0IiwiY3RybCIsImN0cmxLZXkiLCJzaGlmdCIsInNoaWZ0S2V5IiwiYWx0IiwiYWx0S2V5IiwibWV0YSIsIm1ldGFLZXkiLCJidXR0b24iLCJyaWdodCIsImV4YWN0Iiwid2l0aE1vZGlmaWVycyIsImd1YXJkIiwia2V5TmFtZXMiLCJlc2MiLCJzcGFjZSIsInVwIiwiZG93biIsIndpdGhLZXlzIiwiZXZlbnRLZXkiLCJrIiwidlNob3ciLCJfdm9kIiwic2V0RGlzcGxheSIsInJlbmRlcmVyT3B0aW9ucyIsImVuYWJsZWRIeWRyYXRpb24iLCJlbnN1cmVSZW5kZXJlciIsImVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyIiwiaW5qZWN0TmF0aXZlVGFnQ2hlY2siLCJpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayIsImNvbnRhaW5lck9yU2VsZWN0b3IiLCJub3JtYWxpemVDb250YWluZXIiLCJjcmVhdGVTU1JBcHAiLCJpc0hUTUxUYWciLCJpc1NWR1RhZyIsIlNoYWRvd1Jvb3QiLCJleHBlY3RzTG93ZXJDYXNlIiwibGlzdCIsIlBhdGNoRmxhZ05hbWVzIiwic2xvdEZsYWdzVGV4dCIsIkdMT0JBTFNfV0hJVEVfTElTVEVEIiwicmFuZ2UiLCJnZW5lcmF0ZUNvZGVGcmFtZSIsImxpbmVzIiwibGluZSIsInJlcGVhdCIsImxpbmVMZW5ndGgiLCJwYWQiLCJzcGVjaWFsQm9vbGVhbkF0dHJzIiwiaXNCb29sZWFuQXR0ciIsInVuc2FmZUF0dHJDaGFyUkUiLCJhdHRyVmFsaWRhdGlvbkNhY2hlIiwiaXNTU1JTYWZlQXR0ck5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsImlzVW5zYWZlIiwicHJvcHNUb0F0dHJNYXAiLCJhY2NlcHRDaGFyc2V0IiwiaHRtbEZvciIsImh0dHBFcXVpdiIsImlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcCIsImlzS25vd25BdHRyIiwiaXRlbSIsInBhcnNlU3RyaW5nU3R5bGUiLCJsaXN0RGVsaW1pdGVyUkUiLCJwcm9wZXJ0eURlbGltaXRlclJFIiwidG1wIiwic3RyaW5naWZ5U3R5bGUiLCJIVE1MX1RBR1MiLCJTVkdfVEFHUyIsIlZPSURfVEFHUyIsImlzVm9pZFRhZyIsImVzY2FwZVJFIiwiZXNjYXBlSHRtbCIsInN0cmluZyIsImV4ZWMiLCJodG1sIiwiZXNjYXBlZCIsImxhc3RJbmRleCIsImNoYXJDb2RlQXQiLCJzdWJzdHJpbmciLCJjb21tZW50U3RyaXBSRSIsImVzY2FwZUh0bWxDb21tZW50Iiwic3JjIiwibG9vc2VDb21wYXJlQXJyYXlzIiwiZXF1YWwiLCJhVmFsaWRUeXBlIiwiaXNEYXRlIiwiYlZhbGlkVHlwZSIsImdldFRpbWUiLCJhS2V5c0NvdW50IiwiYktleXNDb3VudCIsImFIYXNLZXkiLCJiSGFzS2V5IiwidG9EaXNwbGF5U3RyaW5nIiwicmVwbGFjZXIiLCJlbnRyaWVzIiwicmVkdWNlIiwiYmFiZWxQYXJzZXJEZWZhdWx0UGx1Z2lucyIsIm9uUkUiLCJ0b1R5cGVTdHJpbmciLCJvYmplY3RUb1N0cmluZyIsImNhY2hlU3RyaW5nRnVuY3Rpb24iLCJoaXQiLCJjYW1lbGl6ZVJFIiwiaHlwaGVuYXRlUkUiLCJjaGFyQXQiLCJmbnMiLCJwYXJzZUZsb2F0IiwiX2dsb2JhbFRoaXMiLCJnbG9iYWxUaGlzIiwibW9kdWxlIiwidXRpbHMiLCJyZXF1aXJlIiwic2V0dGxlIiwiY29va2llcyIsImJ1aWxkVVJMIiwiYnVpbGRGdWxsUGF0aCIsInBhcnNlSGVhZGVycyIsImlzVVJMU2FtZU9yaWdpbiIsImNyZWF0ZUVycm9yIiwiZXhwb3J0cyIsInhockFkYXB0ZXIiLCJkaXNwYXRjaFhoclJlcXVlc3QiLCJyZXF1ZXN0RGF0YSIsInJlcXVlc3RIZWFkZXJzIiwiaGVhZGVycyIsImlzRm9ybURhdGEiLCJyZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3QiLCJhdXRoIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiQXV0aG9yaXphdGlvbiIsImJ0b2EiLCJmdWxsUGF0aCIsImJhc2VVUkwiLCJ1cmwiLCJwYXJhbXNTZXJpYWxpemVyIiwib25yZWFkeXN0YXRlY2hhbmdlIiwiaGFuZGxlTG9hZCIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJyZXNwb25zZVVSTCIsInJlc3BvbnNlSGVhZGVycyIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlRGF0YSIsInJlc3BvbnNlVHlwZSIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlIiwic3RhdHVzVGV4dCIsIm9uYWJvcnQiLCJoYW5kbGVBYm9ydCIsIm9uZXJyb3IiLCJvbnRpbWVvdXQiLCJoYW5kbGVUaW1lb3V0IiwidGltZW91dEVycm9yTWVzc2FnZSIsImlzU3RhbmRhcmRCcm93c2VyRW52IiwieHNyZlZhbHVlIiwid2l0aENyZWRlbnRpYWxzIiwieHNyZkNvb2tpZU5hbWUiLCJyZWFkIiwieHNyZkhlYWRlck5hbWUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwiaXNVbmRlZmluZWQiLCJvbkRvd25sb2FkUHJvZ3Jlc3MiLCJvblVwbG9hZFByb2dyZXNzIiwidXBsb2FkIiwiY2FuY2VsVG9rZW4iLCJwcm9taXNlIiwib25DYW5jZWxlZCIsImNhbmNlbCIsImFib3J0Iiwic2VuZCIsIkF4aW9zIiwibWVyZ2VDb25maWciLCJjcmVhdGVJbnN0YW5jZSIsImRlZmF1bHRDb25maWciLCJheGlvcyIsIkNhbmNlbCIsIkNhbmNlbFRva2VuIiwiaXNDYW5jZWwiLCJhbGwiLCJwcm9taXNlcyIsInNwcmVhZCIsImlzQXhpb3NFcnJvciIsIl9fQ0FOQ0VMX18iLCJleGVjdXRvciIsIlR5cGVFcnJvciIsInJlc29sdmVQcm9taXNlIiwicHJvbWlzZUV4ZWN1dG9yIiwidG9rZW4iLCJyZWFzb24iLCJ0aHJvd0lmUmVxdWVzdGVkIiwiSW50ZXJjZXB0b3JNYW5hZ2VyIiwiZGlzcGF0Y2hSZXF1ZXN0IiwiaW50ZXJjZXB0b3JzIiwiY2hhaW4iLCJ1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyIsImludGVyY2VwdG9yIiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMiLCJnZXRVcmkiLCJmb3JFYWNoTWV0aG9kTm9EYXRhIiwiZm9yRWFjaE1ldGhvZFdpdGhEYXRhIiwiaGFuZGxlcnMiLCJlamVjdCIsImZvckVhY2hIYW5kbGVyIiwiaXNBYnNvbHV0ZVVSTCIsImNvbWJpbmVVUkxzIiwicmVxdWVzdGVkVVJMIiwiZW5oYW5jZUVycm9yIiwiY29kZSIsInRyYW5zZm9ybURhdGEiLCJ0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwidHJhbnNmb3JtUmVxdWVzdCIsIm1lcmdlIiwiY29tbW9uIiwiY2xlYW5IZWFkZXJDb25maWciLCJhZGFwdGVyIiwib25BZGFwdGVyUmVzb2x1dGlvbiIsInRyYW5zZm9ybVJlc3BvbnNlIiwib25BZGFwdGVyUmVqZWN0aW9uIiwidG9KU09OIiwiZGVzY3JpcHRpb24iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJjb2x1bW5OdW1iZXIiLCJjb25maWcxIiwiY29uZmlnMiIsInZhbHVlRnJvbUNvbmZpZzJLZXlzIiwibWVyZ2VEZWVwUHJvcGVydGllc0tleXMiLCJkZWZhdWx0VG9Db25maWcyS2V5cyIsImRpcmVjdE1lcmdlS2V5cyIsImdldE1lcmdlZFZhbHVlIiwibWVyZ2VEZWVwUHJvcGVydGllcyIsInZhbHVlRnJvbUNvbmZpZzIiLCJkZWZhdWx0VG9Db25maWcyIiwiYXhpb3NLZXlzIiwib3RoZXJLZXlzIiwiZmlsdGVyQXhpb3NLZXlzIiwidmFsaWRhdGVTdGF0dXMiLCJub3JtYWxpemVIZWFkZXJOYW1lIiwiREVGQVVMVF9DT05URU5UX1RZUEUiLCJzZXRDb250ZW50VHlwZUlmVW5zZXQiLCJnZXREZWZhdWx0QWRhcHRlciIsImlzQXJyYXlCdWZmZXIiLCJpc0J1ZmZlciIsImlzU3RyZWFtIiwiaXNGaWxlIiwiaXNCbG9iIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJidWZmZXIiLCJpc1VSTFNlYXJjaFBhcmFtcyIsInBhcnNlIiwibWF4Q29udGVudExlbmd0aCIsIm1heEJvZHlMZW5ndGgiLCJlbmNvZGUiLCJzZXJpYWxpemVkUGFyYW1zIiwicGFydHMiLCJzZXJpYWxpemUiLCJwYXJzZVZhbHVlIiwidG9JU09TdHJpbmciLCJoYXNobWFya0luZGV4IiwicmVsYXRpdmVVUkwiLCJzdGFuZGFyZEJyb3dzZXJFbnYiLCJ3cml0ZSIsImV4cGlyZXMiLCJkb21haW4iLCJzZWN1cmUiLCJjb29raWUiLCJpc051bWJlciIsInRvR01UU3RyaW5nIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwibm9uU3RhbmRhcmRCcm93c2VyRW52IiwicGF5bG9hZCIsIm1zaWUiLCJ1cmxQYXJzaW5nTm9kZSIsIm9yaWdpblVSTCIsInJlc29sdmVVUkwiLCJocmVmIiwicHJvdG9jb2wiLCJob3N0Iiwic2VhcmNoIiwiaGFzaCIsImhvc3RuYW1lIiwicG9ydCIsInBhdGhuYW1lIiwicmVxdWVzdFVSTCIsInBhcnNlZCIsIm5vcm1hbGl6ZWROYW1lIiwicHJvY2Vzc0hlYWRlciIsImlnbm9yZUR1cGxpY2F0ZU9mIiwicGFyc2VyIiwic3Vic3RyIiwiRm9ybURhdGEiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsInBpcGUiLCJVUkxTZWFyY2hQYXJhbXMiLCJwcm9kdWN0IiwiYXNzaWduVmFsdWUiLCJzdHJpcEJPTSIsImNzc1dpdGhNYXBwaW5nVG9TdHJpbmciLCJtZWRpYVF1ZXJ5IiwiZGVkdXBlIiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsIl9pIiwiX3NsaWNlZFRvQXJyYXkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJhcnIyIiwiX2FyciIsIl9zIiwiX2UiLCJfaXRlbSIsImNzc01hcHBpbmciLCJiYXNlNjQiLCJzb3VyY2VNYXBwaW5nIiwic291cmNlVVJMcyIsInNvdXJjZXMiLCJzb3VyY2VSb290IiwicmVzdWx0VHlwZSIsInJlc3VsdHMiLCJpbml0RGV2IiwiTWV0cmljcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUVBLE1BQU1BLFNBQVMsR0FBRyxJQUFJQyxPQUFKLEVBQWxCO0FBQ0EsTUFBTUMsV0FBVyxHQUFHLEVBQXBCO0FBQ0EsSUFBSUMsWUFBSjtBQUNBLE1BQU1DLFdBQVcsR0FBR0MsTUFBTSxDQUFFQyxLQUFELEdBQTBDLFNBQTFDLEdBQXNELENBQXZELENBQTFCO0FBQ0EsTUFBTUMsbUJBQW1CLEdBQUdGLE1BQU0sQ0FBRUMsS0FBRCxHQUEwQyxpQkFBMUMsR0FBOEQsQ0FBL0QsQ0FBbEM7O0FBQ0EsU0FBU0UsUUFBVCxDQUFrQkMsRUFBbEIsRUFBc0I7QUFDbEIsU0FBT0EsRUFBRSxJQUFJQSxFQUFFLENBQUNDLFNBQUgsS0FBaUIsSUFBOUI7QUFDSDs7QUFDRCxTQUFTQyxNQUFULENBQWdCRixFQUFoQixFQUFvQkcsT0FBTyxHQUFHQyxrREFBOUIsRUFBeUM7QUFDckMsTUFBSUwsUUFBUSxDQUFDQyxFQUFELENBQVosRUFBa0I7QUFDZEEsTUFBRSxHQUFHQSxFQUFFLENBQUNLLEdBQVI7QUFDSDs7QUFDRCxRQUFNSCxNQUFNLEdBQUdJLG9CQUFvQixDQUFDTixFQUFELEVBQUtHLE9BQUwsQ0FBbkM7O0FBQ0EsTUFBSSxDQUFDQSxPQUFPLENBQUNJLElBQWIsRUFBbUI7QUFDZkwsVUFBTTtBQUNUOztBQUNELFNBQU9BLE1BQVA7QUFDSDs7QUFDRCxTQUFTTSxJQUFULENBQWNOLE1BQWQsRUFBc0I7QUFDbEIsTUFBSUEsTUFBTSxDQUFDTyxNQUFYLEVBQW1CO0FBQ2ZDLFdBQU8sQ0FBQ1IsTUFBRCxDQUFQOztBQUNBLFFBQUlBLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlUSxNQUFuQixFQUEyQjtBQUN2QlQsWUFBTSxDQUFDQyxPQUFQLENBQWVRLE1BQWY7QUFDSDs7QUFDRFQsVUFBTSxDQUFDTyxNQUFQLEdBQWdCLEtBQWhCO0FBQ0g7QUFDSjs7QUFDRCxJQUFJRyxHQUFHLEdBQUcsQ0FBVjs7QUFDQSxTQUFTTixvQkFBVCxDQUE4Qk4sRUFBOUIsRUFBa0NHLE9BQWxDLEVBQTJDO0FBQ3ZDLFFBQU1ELE1BQU0sR0FBRyxTQUFTVyxjQUFULEdBQTBCO0FBQ3JDLFFBQUksQ0FBQ1gsTUFBTSxDQUFDTyxNQUFaLEVBQW9CO0FBQ2hCLGFBQU9ULEVBQUUsRUFBVDtBQUNIOztBQUNELFFBQUksQ0FBQ1AsV0FBVyxDQUFDcUIsUUFBWixDQUFxQlosTUFBckIsQ0FBTCxFQUFtQztBQUMvQlEsYUFBTyxDQUFDUixNQUFELENBQVA7O0FBQ0EsVUFBSTtBQUNBYSxzQkFBYztBQUNkdEIsbUJBQVcsQ0FBQ3VCLElBQVosQ0FBaUJkLE1BQWpCO0FBQ0FSLG9CQUFZLEdBQUdRLE1BQWY7QUFDQSxlQUFPRixFQUFFLEVBQVQ7QUFDSCxPQUxELFNBTVE7QUFDSlAsbUJBQVcsQ0FBQ3dCLEdBQVo7QUFDQUMscUJBQWE7QUFDYnhCLG9CQUFZLEdBQUdELFdBQVcsQ0FBQ0EsV0FBVyxDQUFDMEIsTUFBWixHQUFxQixDQUF0QixDQUExQjtBQUNIO0FBQ0o7QUFDSixHQWxCRDs7QUFtQkFqQixRQUFNLENBQUNrQixFQUFQLEdBQVlSLEdBQUcsRUFBZjtBQUNBVixRQUFNLENBQUNtQixZQUFQLEdBQXNCLENBQUMsQ0FBQ2xCLE9BQU8sQ0FBQ2tCLFlBQWhDO0FBQ0FuQixRQUFNLENBQUNELFNBQVAsR0FBbUIsSUFBbkI7QUFDQUMsUUFBTSxDQUFDTyxNQUFQLEdBQWdCLElBQWhCO0FBQ0FQLFFBQU0sQ0FBQ0csR0FBUCxHQUFhTCxFQUFiO0FBQ0FFLFFBQU0sQ0FBQ29CLElBQVAsR0FBYyxFQUFkO0FBQ0FwQixRQUFNLENBQUNDLE9BQVAsR0FBaUJBLE9BQWpCO0FBQ0EsU0FBT0QsTUFBUDtBQUNIOztBQUNELFNBQVNRLE9BQVQsQ0FBaUJSLE1BQWpCLEVBQXlCO0FBQ3JCLFFBQU07QUFBRW9CO0FBQUYsTUFBV3BCLE1BQWpCOztBQUNBLE1BQUlvQixJQUFJLENBQUNILE1BQVQsRUFBaUI7QUFDYixTQUFLLElBQUlJLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdELElBQUksQ0FBQ0gsTUFBekIsRUFBaUNJLENBQUMsRUFBbEMsRUFBc0M7QUFDbENELFVBQUksQ0FBQ0MsQ0FBRCxDQUFKLENBQVFDLE1BQVIsQ0FBZXRCLE1BQWY7QUFDSDs7QUFDRG9CLFFBQUksQ0FBQ0gsTUFBTCxHQUFjLENBQWQ7QUFDSDtBQUNKOztBQUNELElBQUlNLFdBQVcsR0FBRyxJQUFsQjtBQUNBLE1BQU1DLFVBQVUsR0FBRyxFQUFuQjs7QUFDQSxTQUFTQyxhQUFULEdBQXlCO0FBQ3JCRCxZQUFVLENBQUNWLElBQVgsQ0FBZ0JTLFdBQWhCO0FBQ0FBLGFBQVcsR0FBRyxLQUFkO0FBQ0g7O0FBQ0QsU0FBU1YsY0FBVCxHQUEwQjtBQUN0QlcsWUFBVSxDQUFDVixJQUFYLENBQWdCUyxXQUFoQjtBQUNBQSxhQUFXLEdBQUcsSUFBZDtBQUNIOztBQUNELFNBQVNQLGFBQVQsR0FBeUI7QUFDckIsUUFBTVUsSUFBSSxHQUFHRixVQUFVLENBQUNULEdBQVgsRUFBYjtBQUNBUSxhQUFXLEdBQUdHLElBQUksS0FBS0MsU0FBVCxHQUFxQixJQUFyQixHQUE0QkQsSUFBMUM7QUFDSDs7QUFDRCxTQUFTRSxLQUFULENBQWVDLE1BQWYsRUFBdUJDLElBQXZCLEVBQTZCQyxHQUE3QixFQUFrQztBQUM5QixNQUFJLENBQUNSLFdBQUQsSUFBZ0IvQixZQUFZLEtBQUttQyxTQUFyQyxFQUFnRDtBQUM1QztBQUNIOztBQUNELE1BQUlLLE9BQU8sR0FBRzNDLFNBQVMsQ0FBQzRDLEdBQVYsQ0FBY0osTUFBZCxDQUFkOztBQUNBLE1BQUksQ0FBQ0csT0FBTCxFQUFjO0FBQ1YzQyxhQUFTLENBQUM2QyxHQUFWLENBQWNMLE1BQWQsRUFBdUJHLE9BQU8sR0FBRyxJQUFJRyxHQUFKLEVBQWpDO0FBQ0g7O0FBQ0QsTUFBSUMsR0FBRyxHQUFHSixPQUFPLENBQUNDLEdBQVIsQ0FBWUYsR0FBWixDQUFWOztBQUNBLE1BQUksQ0FBQ0ssR0FBTCxFQUFVO0FBQ05KLFdBQU8sQ0FBQ0UsR0FBUixDQUFZSCxHQUFaLEVBQWtCSyxHQUFHLEdBQUcsSUFBSUMsR0FBSixFQUF4QjtBQUNIOztBQUNELE1BQUksQ0FBQ0QsR0FBRyxDQUFDRSxHQUFKLENBQVE5QyxZQUFSLENBQUwsRUFBNEI7QUFDeEI0QyxPQUFHLENBQUNHLEdBQUosQ0FBUS9DLFlBQVI7QUFDQUEsZ0JBQVksQ0FBQzRCLElBQWIsQ0FBa0JOLElBQWxCLENBQXVCc0IsR0FBdkI7O0FBQ0EsUUFBS3pDLEtBQUQsSUFBMkNILFlBQVksQ0FBQ1MsT0FBYixDQUFxQnVDLE9BQXBFLEVBQTZFO0FBQ3pFaEQsa0JBQVksQ0FBQ1MsT0FBYixDQUFxQnVDLE9BQXJCLENBQTZCO0FBQ3pCeEMsY0FBTSxFQUFFUixZQURpQjtBQUV6QnFDLGNBRnlCO0FBR3pCQyxZQUh5QjtBQUl6QkM7QUFKeUIsT0FBN0I7QUFNSDtBQUNKO0FBQ0o7O0FBQ0QsU0FBU1UsT0FBVCxDQUFpQlosTUFBakIsRUFBeUJDLElBQXpCLEVBQStCQyxHQUEvQixFQUFvQ1csUUFBcEMsRUFBOENDLFFBQTlDLEVBQXdEQyxTQUF4RCxFQUFtRTtBQUMvRCxRQUFNWixPQUFPLEdBQUczQyxTQUFTLENBQUM0QyxHQUFWLENBQWNKLE1BQWQsQ0FBaEI7O0FBQ0EsTUFBSSxDQUFDRyxPQUFMLEVBQWM7QUFDVjtBQUNBO0FBQ0g7O0FBQ0QsUUFBTWEsT0FBTyxHQUFHLElBQUlSLEdBQUosRUFBaEI7O0FBQ0EsUUFBTUUsR0FBRyxHQUFJTyxZQUFELElBQWtCO0FBQzFCLFFBQUlBLFlBQUosRUFBa0I7QUFDZEEsa0JBQVksQ0FBQ0MsT0FBYixDQUFxQi9DLE1BQU0sSUFBSTtBQUMzQixZQUFJQSxNQUFNLEtBQUtSLFlBQVgsSUFBMkJRLE1BQU0sQ0FBQ21CLFlBQXRDLEVBQW9EO0FBQ2hEMEIsaUJBQU8sQ0FBQ04sR0FBUixDQUFZdkMsTUFBWjtBQUNIO0FBQ0osT0FKRDtBQUtIO0FBQ0osR0FSRDs7QUFTQSxNQUFJOEIsSUFBSSxLQUFLO0FBQVE7QUFBckIsSUFBa0M7QUFDOUI7QUFDQTtBQUNBRSxhQUFPLENBQUNlLE9BQVIsQ0FBZ0JSLEdBQWhCO0FBQ0gsS0FKRCxNQUtLLElBQUlSLEdBQUcsS0FBSyxRQUFSLElBQW9CaUIsb0RBQU8sQ0FBQ25CLE1BQUQsQ0FBL0IsRUFBeUM7QUFDMUNHLFdBQU8sQ0FBQ2UsT0FBUixDQUFnQixDQUFDWCxHQUFELEVBQU1MLEdBQU4sS0FBYztBQUMxQixVQUFJQSxHQUFHLEtBQUssUUFBUixJQUFvQkEsR0FBRyxJQUFJVyxRQUEvQixFQUF5QztBQUNyQ0gsV0FBRyxDQUFDSCxHQUFELENBQUg7QUFDSDtBQUNKLEtBSkQ7QUFLSCxHQU5JLE1BT0E7QUFDRDtBQUNBLFFBQUlMLEdBQUcsS0FBSyxLQUFLLENBQWpCLEVBQW9CO0FBQ2hCUSxTQUFHLENBQUNQLE9BQU8sQ0FBQ0MsR0FBUixDQUFZRixHQUFaLENBQUQsQ0FBSDtBQUNILEtBSkEsQ0FLRDs7O0FBQ0EsWUFBUUQsSUFBUjtBQUNJLFdBQUs7QUFBTTtBQUFYO0FBQ0ksWUFBSSxDQUFDa0Isb0RBQU8sQ0FBQ25CLE1BQUQsQ0FBWixFQUFzQjtBQUNsQlUsYUFBRyxDQUFDUCxPQUFPLENBQUNDLEdBQVIsQ0FBWXhDLFdBQVosQ0FBRCxDQUFIOztBQUNBLGNBQUl3RCxrREFBSyxDQUFDcEIsTUFBRCxDQUFULEVBQW1CO0FBQ2ZVLGVBQUcsQ0FBQ1AsT0FBTyxDQUFDQyxHQUFSLENBQVlyQyxtQkFBWixDQUFELENBQUg7QUFDSDtBQUNKLFNBTEQsTUFNSyxJQUFJc0QseURBQVksQ0FBQ25CLEdBQUQsQ0FBaEIsRUFBdUI7QUFDeEI7QUFDQVEsYUFBRyxDQUFDUCxPQUFPLENBQUNDLEdBQVIsQ0FBWSxRQUFaLENBQUQsQ0FBSDtBQUNIOztBQUNEOztBQUNKLFdBQUs7QUFBUztBQUFkO0FBQ0ksWUFBSSxDQUFDZSxvREFBTyxDQUFDbkIsTUFBRCxDQUFaLEVBQXNCO0FBQ2xCVSxhQUFHLENBQUNQLE9BQU8sQ0FBQ0MsR0FBUixDQUFZeEMsV0FBWixDQUFELENBQUg7O0FBQ0EsY0FBSXdELGtEQUFLLENBQUNwQixNQUFELENBQVQsRUFBbUI7QUFDZlUsZUFBRyxDQUFDUCxPQUFPLENBQUNDLEdBQVIsQ0FBWXJDLG1CQUFaLENBQUQsQ0FBSDtBQUNIO0FBQ0o7O0FBQ0Q7O0FBQ0osV0FBSztBQUFNO0FBQVg7QUFDSSxZQUFJcUQsa0RBQUssQ0FBQ3BCLE1BQUQsQ0FBVCxFQUFtQjtBQUNmVSxhQUFHLENBQUNQLE9BQU8sQ0FBQ0MsR0FBUixDQUFZeEMsV0FBWixDQUFELENBQUg7QUFDSDs7QUFDRDtBQXpCUjtBQTJCSDs7QUFDRCxRQUFNMEQsR0FBRyxHQUFJbkQsTUFBRCxJQUFZO0FBQ3BCLFFBQUtMLEtBQUQsSUFBMkNLLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlbUQsU0FBOUQsRUFBeUU7QUFDckVwRCxZQUFNLENBQUNDLE9BQVAsQ0FBZW1ELFNBQWYsQ0FBeUI7QUFDckJwRCxjQURxQjtBQUVyQjZCLGNBRnFCO0FBR3JCRSxXQUhxQjtBQUlyQkQsWUFKcUI7QUFLckJZLGdCQUxxQjtBQU1yQkMsZ0JBTnFCO0FBT3JCQztBQVBxQixPQUF6QjtBQVNIOztBQUNELFFBQUk1QyxNQUFNLENBQUNDLE9BQVAsQ0FBZW9ELFNBQW5CLEVBQThCO0FBQzFCckQsWUFBTSxDQUFDQyxPQUFQLENBQWVvRCxTQUFmLENBQXlCckQsTUFBekI7QUFDSCxLQUZELE1BR0s7QUFDREEsWUFBTTtBQUNUO0FBQ0osR0FsQkQ7O0FBbUJBNkMsU0FBTyxDQUFDRSxPQUFSLENBQWdCSSxHQUFoQjtBQUNIOztBQUVELE1BQU1HLGtCQUFrQixHQUFHLGFBQWNDLG9EQUFPLENBQUUsNkJBQUYsQ0FBaEQ7QUFDQSxNQUFNQyxjQUFjLEdBQUcsSUFBSW5CLEdBQUosQ0FBUW9CLE1BQU0sQ0FBQ0MsbUJBQVAsQ0FBMkJoRSxNQUEzQixFQUMxQmlFLEdBRDBCLENBQ3RCNUIsR0FBRyxJQUFJckMsTUFBTSxDQUFDcUMsR0FBRCxDQURTLEVBRTFCNkIsTUFGMEIsQ0FFbkJDLGlEQUZtQixDQUFSLENBQXZCO0FBR0EsTUFBTTVCLEdBQUcsR0FBRyxhQUFjNkIsWUFBWSxFQUF0QztBQUNBLE1BQU1DLFVBQVUsR0FBRyxhQUFjRCxZQUFZLENBQUMsS0FBRCxFQUFRLElBQVIsQ0FBN0M7QUFDQSxNQUFNRSxXQUFXLEdBQUcsYUFBY0YsWUFBWSxDQUFDLElBQUQsQ0FBOUM7QUFDQSxNQUFNRyxrQkFBa0IsR0FBRyxhQUFjSCxZQUFZLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FBckQ7QUFDQSxNQUFNSSxxQkFBcUIsR0FBRyxhQUFjQywyQkFBMkIsRUFBdkU7O0FBQ0EsU0FBU0EsMkJBQVQsR0FBdUM7QUFDbkMsUUFBTUMsZ0JBQWdCLEdBQUcsRUFBekI7QUFDQSxHQUFDLFVBQUQsRUFBYSxTQUFiLEVBQXdCLGFBQXhCLEVBQXVDckIsT0FBdkMsQ0FBK0NoQixHQUFHLElBQUk7QUFDbEQsVUFBTXNDLE1BQU0sR0FBR0MsS0FBSyxDQUFDQyxTQUFOLENBQWdCeEMsR0FBaEIsQ0FBZjs7QUFDQXFDLG9CQUFnQixDQUFDckMsR0FBRCxDQUFoQixHQUF3QixVQUFVLEdBQUd5QyxJQUFiLEVBQW1CO0FBQ3ZDLFlBQU1DLEdBQUcsR0FBR0MsS0FBSyxDQUFDLElBQUQsQ0FBakI7O0FBQ0EsV0FBSyxJQUFJckQsQ0FBQyxHQUFHLENBQVIsRUFBV3NELENBQUMsR0FBRyxLQUFLMUQsTUFBekIsRUFBaUNJLENBQUMsR0FBR3NELENBQXJDLEVBQXdDdEQsQ0FBQyxFQUF6QyxFQUE2QztBQUN6Q08sYUFBSyxDQUFDNkMsR0FBRCxFQUFNO0FBQU07QUFBWixVQUF1QnBELENBQUMsR0FBRyxFQUEzQixDQUFMO0FBQ0gsT0FKc0MsQ0FLdkM7OztBQUNBLFlBQU11RCxHQUFHLEdBQUdQLE1BQU0sQ0FBQ1EsS0FBUCxDQUFhSixHQUFiLEVBQWtCRCxJQUFsQixDQUFaOztBQUNBLFVBQUlJLEdBQUcsS0FBSyxDQUFDLENBQVQsSUFBY0EsR0FBRyxLQUFLLEtBQTFCLEVBQWlDO0FBQzdCO0FBQ0EsZUFBT1AsTUFBTSxDQUFDUSxLQUFQLENBQWFKLEdBQWIsRUFBa0JELElBQUksQ0FBQ2IsR0FBTCxDQUFTZSxLQUFULENBQWxCLENBQVA7QUFDSCxPQUhELE1BSUs7QUFDRCxlQUFPRSxHQUFQO0FBQ0g7QUFDSixLQWREO0FBZUgsR0FqQkQ7QUFrQkEsR0FBQyxNQUFELEVBQVMsS0FBVCxFQUFnQixPQUFoQixFQUF5QixTQUF6QixFQUFvQyxRQUFwQyxFQUE4QzdCLE9BQTlDLENBQXNEaEIsR0FBRyxJQUFJO0FBQ3pELFVBQU1zQyxNQUFNLEdBQUdDLEtBQUssQ0FBQ0MsU0FBTixDQUFnQnhDLEdBQWhCLENBQWY7O0FBQ0FxQyxvQkFBZ0IsQ0FBQ3JDLEdBQUQsQ0FBaEIsR0FBd0IsVUFBVSxHQUFHeUMsSUFBYixFQUFtQjtBQUN2Qy9DLG1CQUFhO0FBQ2IsWUFBTW1ELEdBQUcsR0FBR1AsTUFBTSxDQUFDUSxLQUFQLENBQWEsSUFBYixFQUFtQkwsSUFBbkIsQ0FBWjtBQUNBeEQsbUJBQWE7QUFDYixhQUFPNEQsR0FBUDtBQUNILEtBTEQ7QUFNSCxHQVJEO0FBU0EsU0FBT1IsZ0JBQVA7QUFDSDs7QUFDRCxTQUFTTixZQUFULENBQXNCZ0IsVUFBVSxHQUFHLEtBQW5DLEVBQTBDQyxPQUFPLEdBQUcsS0FBcEQsRUFBMkQ7QUFDdkQsU0FBTyxTQUFTOUMsR0FBVCxDQUFhSixNQUFiLEVBQXFCRSxHQUFyQixFQUEwQmlELFFBQTFCLEVBQW9DO0FBQ3ZDLFFBQUlqRCxHQUFHLEtBQUs7QUFBaUI7QUFBN0IsTUFBZ0Q7QUFDNUMsZUFBTyxDQUFDK0MsVUFBUjtBQUNILE9BRkQsTUFHSyxJQUFJL0MsR0FBRyxLQUFLO0FBQWlCO0FBQTdCLE1BQWdEO0FBQ2pELGVBQU8rQyxVQUFQO0FBQ0gsT0FGSSxNQUdBLElBQUkvQyxHQUFHLEtBQUs7QUFBVTtBQUFsQixPQUNMaUQsUUFBUSxLQUNKLENBQUNGLFVBQVUsR0FDTEMsT0FBTyxHQUNIRSxrQkFERyxHQUVIQyxXQUhDLEdBSUxILE9BQU8sR0FDSEksa0JBREcsR0FFSEMsV0FOVixFQU11Qm5ELEdBTnZCLENBTTJCSixNQU4zQixDQUZILEVBUXVDO0FBQ3hDLGFBQU9BLE1BQVA7QUFDSDs7QUFDRCxVQUFNd0QsYUFBYSxHQUFHckMsb0RBQU8sQ0FBQ25CLE1BQUQsQ0FBN0I7O0FBQ0EsUUFBSSxDQUFDaUQsVUFBRCxJQUFlTyxhQUFmLElBQWdDQyxtREFBTSxDQUFDcEIscUJBQUQsRUFBd0JuQyxHQUF4QixDQUExQyxFQUF3RTtBQUNwRSxhQUFPd0QsT0FBTyxDQUFDdEQsR0FBUixDQUFZaUMscUJBQVosRUFBbUNuQyxHQUFuQyxFQUF3Q2lELFFBQXhDLENBQVA7QUFDSDs7QUFDRCxVQUFNSixHQUFHLEdBQUdXLE9BQU8sQ0FBQ3RELEdBQVIsQ0FBWUosTUFBWixFQUFvQkUsR0FBcEIsRUFBeUJpRCxRQUF6QixDQUFaOztBQUNBLFFBQUluQixxREFBUSxDQUFDOUIsR0FBRCxDQUFSLEdBQWdCeUIsY0FBYyxDQUFDbEIsR0FBZixDQUFtQlAsR0FBbkIsQ0FBaEIsR0FBMEN1QixrQkFBa0IsQ0FBQ3ZCLEdBQUQsQ0FBaEUsRUFBdUU7QUFDbkUsYUFBTzZDLEdBQVA7QUFDSDs7QUFDRCxRQUFJLENBQUNFLFVBQUwsRUFBaUI7QUFDYmxELFdBQUssQ0FBQ0MsTUFBRCxFQUFTO0FBQU07QUFBZixRQUEwQkUsR0FBMUIsQ0FBTDtBQUNIOztBQUNELFFBQUlnRCxPQUFKLEVBQWE7QUFDVCxhQUFPSCxHQUFQO0FBQ0g7O0FBQ0QsUUFBSVksS0FBSyxDQUFDWixHQUFELENBQVQsRUFBZ0I7QUFDWjtBQUNBLFlBQU1hLFlBQVksR0FBRyxDQUFDSixhQUFELElBQWtCLENBQUNuQyx5REFBWSxDQUFDbkIsR0FBRCxDQUFwRDtBQUNBLGFBQU8wRCxZQUFZLEdBQUdiLEdBQUcsQ0FBQ2MsS0FBUCxHQUFlZCxHQUFsQztBQUNIOztBQUNELFFBQUllLHFEQUFRLENBQUNmLEdBQUQsQ0FBWixFQUFtQjtBQUNmO0FBQ0E7QUFDQTtBQUNBLGFBQU9FLFVBQVUsR0FBR2MsUUFBUSxDQUFDaEIsR0FBRCxDQUFYLEdBQW1CaUIsUUFBUSxDQUFDakIsR0FBRCxDQUE1QztBQUNIOztBQUNELFdBQU9BLEdBQVA7QUFDSCxHQTVDRDtBQTZDSDs7QUFDRCxNQUFNMUMsR0FBRyxHQUFHLGFBQWM0RCxZQUFZLEVBQXRDO0FBQ0EsTUFBTUMsVUFBVSxHQUFHLGFBQWNELFlBQVksQ0FBQyxJQUFELENBQTdDOztBQUNBLFNBQVNBLFlBQVQsQ0FBc0JmLE9BQU8sR0FBRyxLQUFoQyxFQUF1QztBQUNuQyxTQUFPLFNBQVM3QyxHQUFULENBQWFMLE1BQWIsRUFBcUJFLEdBQXJCLEVBQTBCMkQsS0FBMUIsRUFBaUNWLFFBQWpDLEVBQTJDO0FBQzlDLFFBQUlyQyxRQUFRLEdBQUdkLE1BQU0sQ0FBQ0UsR0FBRCxDQUFyQjs7QUFDQSxRQUFJLENBQUNnRCxPQUFMLEVBQWM7QUFDVlcsV0FBSyxHQUFHaEIsS0FBSyxDQUFDZ0IsS0FBRCxDQUFiO0FBQ0EvQyxjQUFRLEdBQUcrQixLQUFLLENBQUMvQixRQUFELENBQWhCOztBQUNBLFVBQUksQ0FBQ0ssb0RBQU8sQ0FBQ25CLE1BQUQsQ0FBUixJQUFvQjJELEtBQUssQ0FBQzdDLFFBQUQsQ0FBekIsSUFBdUMsQ0FBQzZDLEtBQUssQ0FBQ0UsS0FBRCxDQUFqRCxFQUEwRDtBQUN0RC9DLGdCQUFRLENBQUMrQyxLQUFULEdBQWlCQSxLQUFqQjtBQUNBLGVBQU8sSUFBUDtBQUNIO0FBQ0o7O0FBQ0QsVUFBTU0sTUFBTSxHQUFHaEQsb0RBQU8sQ0FBQ25CLE1BQUQsQ0FBUCxJQUFtQnFCLHlEQUFZLENBQUNuQixHQUFELENBQS9CLEdBQ1RrRSxNQUFNLENBQUNsRSxHQUFELENBQU4sR0FBY0YsTUFBTSxDQUFDWixNQURaLEdBRVRxRSxtREFBTSxDQUFDekQsTUFBRCxFQUFTRSxHQUFULENBRlo7QUFHQSxVQUFNbUUsTUFBTSxHQUFHWCxPQUFPLENBQUNyRCxHQUFSLENBQVlMLE1BQVosRUFBb0JFLEdBQXBCLEVBQXlCMkQsS0FBekIsRUFBZ0NWLFFBQWhDLENBQWYsQ0FiOEMsQ0FjOUM7O0FBQ0EsUUFBSW5ELE1BQU0sS0FBSzZDLEtBQUssQ0FBQ00sUUFBRCxDQUFwQixFQUFnQztBQUM1QixVQUFJLENBQUNnQixNQUFMLEVBQWE7QUFDVHZELGVBQU8sQ0FBQ1osTUFBRCxFQUFTO0FBQU07QUFBZixVQUEwQkUsR0FBMUIsRUFBK0IyRCxLQUEvQixDQUFQO0FBQ0gsT0FGRCxNQUdLLElBQUlTLHVEQUFVLENBQUNULEtBQUQsRUFBUS9DLFFBQVIsQ0FBZCxFQUFpQztBQUNsQ0YsZUFBTyxDQUFDWixNQUFELEVBQVM7QUFBTTtBQUFmLFVBQTBCRSxHQUExQixFQUErQjJELEtBQS9CLEVBQXNDL0MsUUFBdEMsQ0FBUDtBQUNIO0FBQ0o7O0FBQ0QsV0FBT3VELE1BQVA7QUFDSCxHQXhCRDtBQXlCSDs7QUFDRCxTQUFTRSxjQUFULENBQXdCdkUsTUFBeEIsRUFBZ0NFLEdBQWhDLEVBQXFDO0FBQ2pDLFFBQU1pRSxNQUFNLEdBQUdWLG1EQUFNLENBQUN6RCxNQUFELEVBQVNFLEdBQVQsQ0FBckI7QUFDQSxRQUFNWSxRQUFRLEdBQUdkLE1BQU0sQ0FBQ0UsR0FBRCxDQUF2QjtBQUNBLFFBQU1tRSxNQUFNLEdBQUdYLE9BQU8sQ0FBQ2EsY0FBUixDQUF1QnZFLE1BQXZCLEVBQStCRSxHQUEvQixDQUFmOztBQUNBLE1BQUltRSxNQUFNLElBQUlGLE1BQWQsRUFBc0I7QUFDbEJ2RCxXQUFPLENBQUNaLE1BQUQsRUFBUztBQUFTO0FBQWxCLE1BQWdDRSxHQUFoQyxFQUFxQ0osU0FBckMsRUFBZ0RnQixRQUFoRCxDQUFQO0FBQ0g7O0FBQ0QsU0FBT3VELE1BQVA7QUFDSDs7QUFDRCxTQUFTNUQsR0FBVCxDQUFhVCxNQUFiLEVBQXFCRSxHQUFyQixFQUEwQjtBQUN0QixRQUFNbUUsTUFBTSxHQUFHWCxPQUFPLENBQUNqRCxHQUFSLENBQVlULE1BQVosRUFBb0JFLEdBQXBCLENBQWY7O0FBQ0EsTUFBSSxDQUFDOEIscURBQVEsQ0FBQzlCLEdBQUQsQ0FBVCxJQUFrQixDQUFDeUIsY0FBYyxDQUFDbEIsR0FBZixDQUFtQlAsR0FBbkIsQ0FBdkIsRUFBZ0Q7QUFDNUNILFNBQUssQ0FBQ0MsTUFBRCxFQUFTO0FBQU07QUFBZixNQUEwQkUsR0FBMUIsQ0FBTDtBQUNIOztBQUNELFNBQU9tRSxNQUFQO0FBQ0g7O0FBQ0QsU0FBU0csT0FBVCxDQUFpQnhFLE1BQWpCLEVBQXlCO0FBQ3JCRCxPQUFLLENBQUNDLE1BQUQsRUFBUztBQUFVO0FBQW5CLElBQWtDbUIsb0RBQU8sQ0FBQ25CLE1BQUQsQ0FBUCxHQUFrQixRQUFsQixHQUE2QnBDLFdBQS9ELENBQUw7QUFDQSxTQUFPOEYsT0FBTyxDQUFDYyxPQUFSLENBQWdCeEUsTUFBaEIsQ0FBUDtBQUNIOztBQUNELE1BQU15RSxlQUFlLEdBQUc7QUFDcEJyRSxLQURvQjtBQUVwQkMsS0FGb0I7QUFHcEJrRSxnQkFIb0I7QUFJcEI5RCxLQUpvQjtBQUtwQitEO0FBTG9CLENBQXhCO0FBT0EsTUFBTUUsZ0JBQWdCLEdBQUc7QUFDckJ0RSxLQUFHLEVBQUUrQixXQURnQjs7QUFFckI5QixLQUFHLENBQUNMLE1BQUQsRUFBU0UsR0FBVCxFQUFjO0FBQ2IsUUFBS3BDLElBQUwsRUFBNkM7QUFDekM2RyxhQUFPLENBQUNDLElBQVIsQ0FBYyx5QkFBd0JDLE1BQU0sQ0FBQzNFLEdBQUQsQ0FBTSwrQkFBbEQsRUFBa0ZGLE1BQWxGO0FBQ0g7O0FBQ0QsV0FBTyxJQUFQO0FBQ0gsR0FQb0I7O0FBUXJCdUUsZ0JBQWMsQ0FBQ3ZFLE1BQUQsRUFBU0UsR0FBVCxFQUFjO0FBQ3hCLFFBQUtwQyxJQUFMLEVBQTZDO0FBQ3pDNkcsYUFBTyxDQUFDQyxJQUFSLENBQWMsNEJBQTJCQyxNQUFNLENBQUMzRSxHQUFELENBQU0sK0JBQXJELEVBQXFGRixNQUFyRjtBQUNIOztBQUNELFdBQU8sSUFBUDtBQUNIOztBQWJvQixDQUF6QjtBQWVBLE1BQU04RSx1QkFBdUIsR0FBRyxhQUFjQyxtREFBTSxDQUFDLEVBQUQsRUFBS04sZUFBTCxFQUFzQjtBQUN0RXJFLEtBQUcsRUFBRThCLFVBRGlFO0FBRXRFN0IsS0FBRyxFQUFFNkQ7QUFGaUUsQ0FBdEIsQ0FBcEQsQyxDQUlBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNYyx1QkFBdUIsR0FBRyxhQUFjRCxtREFBTSxDQUFDLEVBQUQsRUFBS0wsZ0JBQUwsRUFBdUI7QUFDdkV0RSxLQUFHLEVBQUVnQztBQURrRSxDQUF2QixDQUFwRDs7QUFJQSxNQUFNNkMsVUFBVSxHQUFJcEIsS0FBRCxJQUFXQyxxREFBUSxDQUFDRCxLQUFELENBQVIsR0FBa0JHLFFBQVEsQ0FBQ0gsS0FBRCxDQUExQixHQUFvQ0EsS0FBbEU7O0FBQ0EsTUFBTXFCLFVBQVUsR0FBSXJCLEtBQUQsSUFBV0MscURBQVEsQ0FBQ0QsS0FBRCxDQUFSLEdBQWtCRSxRQUFRLENBQUNGLEtBQUQsQ0FBMUIsR0FBb0NBLEtBQWxFOztBQUNBLE1BQU1zQixTQUFTLEdBQUl0QixLQUFELElBQVdBLEtBQTdCOztBQUNBLE1BQU11QixRQUFRLEdBQUlDLENBQUQsSUFBTzNCLE9BQU8sQ0FBQzRCLGNBQVIsQ0FBdUJELENBQXZCLENBQXhCOztBQUNBLFNBQVNFLEtBQVQsQ0FBZXZGLE1BQWYsRUFBdUJFLEdBQXZCLEVBQTRCK0MsVUFBVSxHQUFHLEtBQXpDLEVBQWdEdUMsU0FBUyxHQUFHLEtBQTVELEVBQW1FO0FBQy9EO0FBQ0E7QUFDQXhGLFFBQU0sR0FBR0EsTUFBTSxDQUFDO0FBQVU7QUFBWCxHQUFmO0FBQ0EsUUFBTXlGLFNBQVMsR0FBRzVDLEtBQUssQ0FBQzdDLE1BQUQsQ0FBdkI7QUFDQSxRQUFNMEYsTUFBTSxHQUFHN0MsS0FBSyxDQUFDM0MsR0FBRCxDQUFwQjs7QUFDQSxNQUFJQSxHQUFHLEtBQUt3RixNQUFaLEVBQW9CO0FBQ2hCLEtBQUN6QyxVQUFELElBQWVsRCxLQUFLLENBQUMwRixTQUFELEVBQVk7QUFBTTtBQUFsQixNQUE2QnZGLEdBQTdCLENBQXBCO0FBQ0g7O0FBQ0QsR0FBQytDLFVBQUQsSUFBZWxELEtBQUssQ0FBQzBGLFNBQUQsRUFBWTtBQUFNO0FBQWxCLElBQTZCQyxNQUE3QixDQUFwQjtBQUNBLFFBQU07QUFBRWpGO0FBQUYsTUFBVTJFLFFBQVEsQ0FBQ0ssU0FBRCxDQUF4QjtBQUNBLFFBQU1FLElBQUksR0FBR0gsU0FBUyxHQUFHTCxTQUFILEdBQWVsQyxVQUFVLEdBQUdpQyxVQUFILEdBQWdCRCxVQUEvRDs7QUFDQSxNQUFJeEUsR0FBRyxDQUFDbUYsSUFBSixDQUFTSCxTQUFULEVBQW9CdkYsR0FBcEIsQ0FBSixFQUE4QjtBQUMxQixXQUFPeUYsSUFBSSxDQUFDM0YsTUFBTSxDQUFDSSxHQUFQLENBQVdGLEdBQVgsQ0FBRCxDQUFYO0FBQ0gsR0FGRCxNQUdLLElBQUlPLEdBQUcsQ0FBQ21GLElBQUosQ0FBU0gsU0FBVCxFQUFvQkMsTUFBcEIsQ0FBSixFQUFpQztBQUNsQyxXQUFPQyxJQUFJLENBQUMzRixNQUFNLENBQUNJLEdBQVAsQ0FBV3NGLE1BQVgsQ0FBRCxDQUFYO0FBQ0gsR0FGSSxNQUdBLElBQUkxRixNQUFNLEtBQUt5RixTQUFmLEVBQTBCO0FBQzNCO0FBQ0E7QUFDQXpGLFVBQU0sQ0FBQ0ksR0FBUCxDQUFXRixHQUFYO0FBQ0g7QUFDSjs7QUFDRCxTQUFTMkYsS0FBVCxDQUFlM0YsR0FBZixFQUFvQitDLFVBQVUsR0FBRyxLQUFqQyxFQUF3QztBQUNwQyxRQUFNakQsTUFBTSxHQUFHLEtBQUs7QUFBVTtBQUFmLEdBQWY7QUFDQSxRQUFNeUYsU0FBUyxHQUFHNUMsS0FBSyxDQUFDN0MsTUFBRCxDQUF2QjtBQUNBLFFBQU0wRixNQUFNLEdBQUc3QyxLQUFLLENBQUMzQyxHQUFELENBQXBCOztBQUNBLE1BQUlBLEdBQUcsS0FBS3dGLE1BQVosRUFBb0I7QUFDaEIsS0FBQ3pDLFVBQUQsSUFBZWxELEtBQUssQ0FBQzBGLFNBQUQsRUFBWTtBQUFNO0FBQWxCLE1BQTZCdkYsR0FBN0IsQ0FBcEI7QUFDSDs7QUFDRCxHQUFDK0MsVUFBRCxJQUFlbEQsS0FBSyxDQUFDMEYsU0FBRCxFQUFZO0FBQU07QUFBbEIsSUFBNkJDLE1BQTdCLENBQXBCO0FBQ0EsU0FBT3hGLEdBQUcsS0FBS3dGLE1BQVIsR0FDRDFGLE1BQU0sQ0FBQ1MsR0FBUCxDQUFXUCxHQUFYLENBREMsR0FFREYsTUFBTSxDQUFDUyxHQUFQLENBQVdQLEdBQVgsS0FBbUJGLE1BQU0sQ0FBQ1MsR0FBUCxDQUFXaUYsTUFBWCxDQUZ6QjtBQUdIOztBQUNELFNBQVNJLElBQVQsQ0FBYzlGLE1BQWQsRUFBc0JpRCxVQUFVLEdBQUcsS0FBbkMsRUFBMEM7QUFDdENqRCxRQUFNLEdBQUdBLE1BQU0sQ0FBQztBQUFVO0FBQVgsR0FBZjtBQUNBLEdBQUNpRCxVQUFELElBQWVsRCxLQUFLLENBQUM4QyxLQUFLLENBQUM3QyxNQUFELENBQU4sRUFBZ0I7QUFBVTtBQUExQixJQUF5Q3BDLFdBQXpDLENBQXBCO0FBQ0EsU0FBTzhGLE9BQU8sQ0FBQ3RELEdBQVIsQ0FBWUosTUFBWixFQUFvQixNQUFwQixFQUE0QkEsTUFBNUIsQ0FBUDtBQUNIOztBQUNELFNBQVNVLEdBQVQsQ0FBYW1ELEtBQWIsRUFBb0I7QUFDaEJBLE9BQUssR0FBR2hCLEtBQUssQ0FBQ2dCLEtBQUQsQ0FBYjtBQUNBLFFBQU03RCxNQUFNLEdBQUc2QyxLQUFLLENBQUMsSUFBRCxDQUFwQjtBQUNBLFFBQU1rRCxLQUFLLEdBQUdYLFFBQVEsQ0FBQ3BGLE1BQUQsQ0FBdEI7QUFDQSxRQUFNbUUsTUFBTSxHQUFHNEIsS0FBSyxDQUFDdEYsR0FBTixDQUFVbUYsSUFBVixDQUFlNUYsTUFBZixFQUF1QjZELEtBQXZCLENBQWY7O0FBQ0EsTUFBSSxDQUFDTSxNQUFMLEVBQWE7QUFDVG5FLFVBQU0sQ0FBQ1UsR0FBUCxDQUFXbUQsS0FBWDtBQUNBakQsV0FBTyxDQUFDWixNQUFELEVBQVM7QUFBTTtBQUFmLE1BQTBCNkQsS0FBMUIsRUFBaUNBLEtBQWpDLENBQVA7QUFDSDs7QUFDRCxTQUFPLElBQVA7QUFDSDs7QUFDRCxTQUFTbUMsS0FBVCxDQUFlOUYsR0FBZixFQUFvQjJELEtBQXBCLEVBQTJCO0FBQ3ZCQSxPQUFLLEdBQUdoQixLQUFLLENBQUNnQixLQUFELENBQWI7QUFDQSxRQUFNN0QsTUFBTSxHQUFHNkMsS0FBSyxDQUFDLElBQUQsQ0FBcEI7QUFDQSxRQUFNO0FBQUVwQyxPQUFGO0FBQU9MO0FBQVAsTUFBZWdGLFFBQVEsQ0FBQ3BGLE1BQUQsQ0FBN0I7QUFDQSxNQUFJbUUsTUFBTSxHQUFHMUQsR0FBRyxDQUFDbUYsSUFBSixDQUFTNUYsTUFBVCxFQUFpQkUsR0FBakIsQ0FBYjs7QUFDQSxNQUFJLENBQUNpRSxNQUFMLEVBQWE7QUFDVGpFLE9BQUcsR0FBRzJDLEtBQUssQ0FBQzNDLEdBQUQsQ0FBWDtBQUNBaUUsVUFBTSxHQUFHMUQsR0FBRyxDQUFDbUYsSUFBSixDQUFTNUYsTUFBVCxFQUFpQkUsR0FBakIsQ0FBVDtBQUNILEdBSEQsTUFJSyxJQUFLcEMsSUFBTCxFQUE2QztBQUM5Q21JLHFCQUFpQixDQUFDakcsTUFBRCxFQUFTUyxHQUFULEVBQWNQLEdBQWQsQ0FBakI7QUFDSDs7QUFDRCxRQUFNWSxRQUFRLEdBQUdWLEdBQUcsQ0FBQ3dGLElBQUosQ0FBUzVGLE1BQVQsRUFBaUJFLEdBQWpCLENBQWpCO0FBQ0FGLFFBQU0sQ0FBQ0ssR0FBUCxDQUFXSCxHQUFYLEVBQWdCMkQsS0FBaEI7O0FBQ0EsTUFBSSxDQUFDTSxNQUFMLEVBQWE7QUFDVHZELFdBQU8sQ0FBQ1osTUFBRCxFQUFTO0FBQU07QUFBZixNQUEwQkUsR0FBMUIsRUFBK0IyRCxLQUEvQixDQUFQO0FBQ0gsR0FGRCxNQUdLLElBQUlTLHVEQUFVLENBQUNULEtBQUQsRUFBUS9DLFFBQVIsQ0FBZCxFQUFpQztBQUNsQ0YsV0FBTyxDQUFDWixNQUFELEVBQVM7QUFBTTtBQUFmLE1BQTBCRSxHQUExQixFQUErQjJELEtBQS9CLEVBQXNDL0MsUUFBdEMsQ0FBUDtBQUNIOztBQUNELFNBQU8sSUFBUDtBQUNIOztBQUNELFNBQVNvRixXQUFULENBQXFCaEcsR0FBckIsRUFBMEI7QUFDdEIsUUFBTUYsTUFBTSxHQUFHNkMsS0FBSyxDQUFDLElBQUQsQ0FBcEI7QUFDQSxRQUFNO0FBQUVwQyxPQUFGO0FBQU9MO0FBQVAsTUFBZWdGLFFBQVEsQ0FBQ3BGLE1BQUQsQ0FBN0I7QUFDQSxNQUFJbUUsTUFBTSxHQUFHMUQsR0FBRyxDQUFDbUYsSUFBSixDQUFTNUYsTUFBVCxFQUFpQkUsR0FBakIsQ0FBYjs7QUFDQSxNQUFJLENBQUNpRSxNQUFMLEVBQWE7QUFDVGpFLE9BQUcsR0FBRzJDLEtBQUssQ0FBQzNDLEdBQUQsQ0FBWDtBQUNBaUUsVUFBTSxHQUFHMUQsR0FBRyxDQUFDbUYsSUFBSixDQUFTNUYsTUFBVCxFQUFpQkUsR0FBakIsQ0FBVDtBQUNILEdBSEQsTUFJSyxJQUFLcEMsSUFBTCxFQUE2QztBQUM5Q21JLHFCQUFpQixDQUFDakcsTUFBRCxFQUFTUyxHQUFULEVBQWNQLEdBQWQsQ0FBakI7QUFDSDs7QUFDRCxRQUFNWSxRQUFRLEdBQUdWLEdBQUcsR0FBR0EsR0FBRyxDQUFDd0YsSUFBSixDQUFTNUYsTUFBVCxFQUFpQkUsR0FBakIsQ0FBSCxHQUEyQkosU0FBL0MsQ0FYc0IsQ0FZdEI7O0FBQ0EsUUFBTXVFLE1BQU0sR0FBR3JFLE1BQU0sQ0FBQ1AsTUFBUCxDQUFjUyxHQUFkLENBQWY7O0FBQ0EsTUFBSWlFLE1BQUosRUFBWTtBQUNSdkQsV0FBTyxDQUFDWixNQUFELEVBQVM7QUFBUztBQUFsQixNQUFnQ0UsR0FBaEMsRUFBcUNKLFNBQXJDLEVBQWdEZ0IsUUFBaEQsQ0FBUDtBQUNIOztBQUNELFNBQU91RCxNQUFQO0FBQ0g7O0FBQ0QsU0FBUzhCLEtBQVQsR0FBaUI7QUFDYixRQUFNbkcsTUFBTSxHQUFHNkMsS0FBSyxDQUFDLElBQUQsQ0FBcEI7QUFDQSxRQUFNdUQsUUFBUSxHQUFHcEcsTUFBTSxDQUFDOEYsSUFBUCxLQUFnQixDQUFqQztBQUNBLFFBQU0vRSxTQUFTLEdBQUlqRCxLQUFELEdBQ1pzRCxrREFBSyxDQUFDcEIsTUFBRCxDQUFMLEdBQ0ksSUFBSU0sR0FBSixDQUFRTixNQUFSLENBREosR0FFSSxJQUFJUSxHQUFKLENBQVFSLE1BQVIsQ0FIUSxHQUlaRixDQUpOLENBSGEsQ0FRYjs7QUFDQSxRQUFNdUUsTUFBTSxHQUFHckUsTUFBTSxDQUFDbUcsS0FBUCxFQUFmOztBQUNBLE1BQUlDLFFBQUosRUFBYztBQUNWeEYsV0FBTyxDQUFDWixNQUFELEVBQVM7QUFBUTtBQUFqQixNQUE4QkYsU0FBOUIsRUFBeUNBLFNBQXpDLEVBQW9EaUIsU0FBcEQsQ0FBUDtBQUNIOztBQUNELFNBQU9zRCxNQUFQO0FBQ0g7O0FBQ0QsU0FBU2dDLGFBQVQsQ0FBdUJwRCxVQUF2QixFQUFtQ3VDLFNBQW5DLEVBQThDO0FBQzFDLFNBQU8sU0FBU3RFLE9BQVQsQ0FBaUJvRixRQUFqQixFQUEyQkMsT0FBM0IsRUFBb0M7QUFDdkMsVUFBTUMsUUFBUSxHQUFHLElBQWpCO0FBQ0EsVUFBTXhHLE1BQU0sR0FBR3dHLFFBQVEsQ0FBQztBQUFVO0FBQVgsS0FBdkI7QUFDQSxVQUFNZixTQUFTLEdBQUc1QyxLQUFLLENBQUM3QyxNQUFELENBQXZCO0FBQ0EsVUFBTTJGLElBQUksR0FBR0gsU0FBUyxHQUFHTCxTQUFILEdBQWVsQyxVQUFVLEdBQUdpQyxVQUFILEdBQWdCRCxVQUEvRDtBQUNBLEtBQUNoQyxVQUFELElBQWVsRCxLQUFLLENBQUMwRixTQUFELEVBQVk7QUFBVTtBQUF0QixNQUFxQzdILFdBQXJDLENBQXBCO0FBQ0EsV0FBT29DLE1BQU0sQ0FBQ2tCLE9BQVAsQ0FBZSxDQUFDMkMsS0FBRCxFQUFRM0QsR0FBUixLQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxhQUFPb0csUUFBUSxDQUFDVixJQUFULENBQWNXLE9BQWQsRUFBdUJaLElBQUksQ0FBQzlCLEtBQUQsQ0FBM0IsRUFBb0M4QixJQUFJLENBQUN6RixHQUFELENBQXhDLEVBQStDc0csUUFBL0MsQ0FBUDtBQUNILEtBTE0sQ0FBUDtBQU1ILEdBWkQ7QUFhSDs7QUFDRCxTQUFTQyxvQkFBVCxDQUE4QmpFLE1BQTlCLEVBQXNDUyxVQUF0QyxFQUFrRHVDLFNBQWxELEVBQTZEO0FBQ3pELFNBQU8sVUFBVSxHQUFHN0MsSUFBYixFQUFtQjtBQUN0QixVQUFNM0MsTUFBTSxHQUFHLEtBQUs7QUFBVTtBQUFmLEtBQWY7QUFDQSxVQUFNeUYsU0FBUyxHQUFHNUMsS0FBSyxDQUFDN0MsTUFBRCxDQUF2QjtBQUNBLFVBQU0wRyxXQUFXLEdBQUd0RixrREFBSyxDQUFDcUUsU0FBRCxDQUF6QjtBQUNBLFVBQU1rQixNQUFNLEdBQUduRSxNQUFNLEtBQUssU0FBWCxJQUF5QkEsTUFBTSxLQUFLM0UsTUFBTSxDQUFDK0ksUUFBbEIsSUFBOEJGLFdBQXRFO0FBQ0EsVUFBTUcsU0FBUyxHQUFHckUsTUFBTSxLQUFLLE1BQVgsSUFBcUJrRSxXQUF2QztBQUNBLFVBQU1JLGFBQWEsR0FBRzlHLE1BQU0sQ0FBQ3dDLE1BQUQsQ0FBTixDQUFlLEdBQUdHLElBQWxCLENBQXRCO0FBQ0EsVUFBTWdELElBQUksR0FBR0gsU0FBUyxHQUFHTCxTQUFILEdBQWVsQyxVQUFVLEdBQUdpQyxVQUFILEdBQWdCRCxVQUEvRDtBQUNBLEtBQUNoQyxVQUFELElBQ0lsRCxLQUFLLENBQUMwRixTQUFELEVBQVk7QUFBVTtBQUF0QixNQUFxQ29CLFNBQVMsR0FBRzlJLG1CQUFILEdBQXlCSCxXQUF2RSxDQURULENBUnNCLENBVXRCO0FBQ0E7O0FBQ0EsV0FBTztBQUNIO0FBQ0FtSixVQUFJLEdBQUc7QUFDSCxjQUFNO0FBQUVsRCxlQUFGO0FBQVNtRDtBQUFULFlBQWtCRixhQUFhLENBQUNDLElBQWQsRUFBeEI7QUFDQSxlQUFPQyxJQUFJLEdBQ0w7QUFBRW5ELGVBQUY7QUFBU21EO0FBQVQsU0FESyxHQUVMO0FBQ0VuRCxlQUFLLEVBQUU4QyxNQUFNLEdBQUcsQ0FBQ2hCLElBQUksQ0FBQzlCLEtBQUssQ0FBQyxDQUFELENBQU4sQ0FBTCxFQUFpQjhCLElBQUksQ0FBQzlCLEtBQUssQ0FBQyxDQUFELENBQU4sQ0FBckIsQ0FBSCxHQUFzQzhCLElBQUksQ0FBQzlCLEtBQUQsQ0FEekQ7QUFFRW1EO0FBRkYsU0FGTjtBQU1ILE9BVkU7O0FBV0g7QUFDQSxPQUFDbkosTUFBTSxDQUFDK0ksUUFBUixJQUFvQjtBQUNoQixlQUFPLElBQVA7QUFDSDs7QUFkRSxLQUFQO0FBZ0JILEdBNUJEO0FBNkJIOztBQUNELFNBQVNLLG9CQUFULENBQThCaEgsSUFBOUIsRUFBb0M7QUFDaEMsU0FBTyxVQUFVLEdBQUcwQyxJQUFiLEVBQW1CO0FBQ3RCLFFBQUs3RSxJQUFMLEVBQTZDO0FBQ3pDLFlBQU1vQyxHQUFHLEdBQUd5QyxJQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVcsV0FBVUEsSUFBSSxDQUFDLENBQUQsQ0FBSSxJQUE3QixHQUFvQyxFQUFoRDtBQUNBZ0MsYUFBTyxDQUFDQyxJQUFSLENBQWMsR0FBRXNDLHVEQUFVLENBQUNqSCxJQUFELENBQU8sY0FBYUMsR0FBSSw2QkFBbEQsRUFBZ0YyQyxLQUFLLENBQUMsSUFBRCxDQUFyRjtBQUNIOztBQUNELFdBQU81QyxJQUFJLEtBQUs7QUFBUztBQUFsQixNQUFpQyxLQUFqQyxHQUF5QyxJQUFoRDtBQUNILEdBTkQ7QUFPSDs7QUFDRCxTQUFTa0gsc0JBQVQsR0FBa0M7QUFDOUIsUUFBTUMsdUJBQXVCLEdBQUc7QUFDNUJoSCxPQUFHLENBQUNGLEdBQUQsRUFBTTtBQUNMLGFBQU9xRixLQUFLLENBQUMsSUFBRCxFQUFPckYsR0FBUCxDQUFaO0FBQ0gsS0FIMkI7O0FBSTVCLFFBQUk0RixJQUFKLEdBQVc7QUFDUCxhQUFPQSxJQUFJLENBQUMsSUFBRCxDQUFYO0FBQ0gsS0FOMkI7O0FBTzVCckYsT0FBRyxFQUFFb0YsS0FQdUI7QUFRNUJuRixPQVI0QjtBQVM1QkwsT0FBRyxFQUFFMkYsS0FUdUI7QUFVNUJ2RyxVQUFNLEVBQUV5RyxXQVZvQjtBQVc1QkMsU0FYNEI7QUFZNUJqRixXQUFPLEVBQUVtRixhQUFhLENBQUMsS0FBRCxFQUFRLEtBQVI7QUFaTSxHQUFoQztBQWNBLFFBQU1nQix1QkFBdUIsR0FBRztBQUM1QmpILE9BQUcsQ0FBQ0YsR0FBRCxFQUFNO0FBQ0wsYUFBT3FGLEtBQUssQ0FBQyxJQUFELEVBQU9yRixHQUFQLEVBQVksS0FBWixFQUFtQixJQUFuQixDQUFaO0FBQ0gsS0FIMkI7O0FBSTVCLFFBQUk0RixJQUFKLEdBQVc7QUFDUCxhQUFPQSxJQUFJLENBQUMsSUFBRCxDQUFYO0FBQ0gsS0FOMkI7O0FBTzVCckYsT0FBRyxFQUFFb0YsS0FQdUI7QUFRNUJuRixPQVI0QjtBQVM1QkwsT0FBRyxFQUFFMkYsS0FUdUI7QUFVNUJ2RyxVQUFNLEVBQUV5RyxXQVZvQjtBQVc1QkMsU0FYNEI7QUFZNUJqRixXQUFPLEVBQUVtRixhQUFhLENBQUMsS0FBRCxFQUFRLElBQVI7QUFaTSxHQUFoQztBQWNBLFFBQU1pQix3QkFBd0IsR0FBRztBQUM3QmxILE9BQUcsQ0FBQ0YsR0FBRCxFQUFNO0FBQ0wsYUFBT3FGLEtBQUssQ0FBQyxJQUFELEVBQU9yRixHQUFQLEVBQVksSUFBWixDQUFaO0FBQ0gsS0FINEI7O0FBSTdCLFFBQUk0RixJQUFKLEdBQVc7QUFDUCxhQUFPQSxJQUFJLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FBWDtBQUNILEtBTjRCOztBQU83QnJGLE9BQUcsQ0FBQ1AsR0FBRCxFQUFNO0FBQ0wsYUFBTzJGLEtBQUssQ0FBQ0QsSUFBTixDQUFXLElBQVgsRUFBaUIxRixHQUFqQixFQUFzQixJQUF0QixDQUFQO0FBQ0gsS0FUNEI7O0FBVTdCUSxPQUFHLEVBQUV1RyxvQkFBb0IsQ0FBQztBQUFNO0FBQVAsS0FWSTtBQVc3QjVHLE9BQUcsRUFBRTRHLG9CQUFvQixDQUFDO0FBQU07QUFBUCxLQVhJO0FBWTdCeEgsVUFBTSxFQUFFd0gsb0JBQW9CLENBQUM7QUFBUztBQUFWLEtBWkM7QUFhN0JkLFNBQUssRUFBRWMsb0JBQW9CLENBQUM7QUFBUTtBQUFULEtBYkU7QUFjN0IvRixXQUFPLEVBQUVtRixhQUFhLENBQUMsSUFBRCxFQUFPLEtBQVA7QUFkTyxHQUFqQztBQWdCQSxRQUFNa0IsK0JBQStCLEdBQUc7QUFDcENuSCxPQUFHLENBQUNGLEdBQUQsRUFBTTtBQUNMLGFBQU9xRixLQUFLLENBQUMsSUFBRCxFQUFPckYsR0FBUCxFQUFZLElBQVosRUFBa0IsSUFBbEIsQ0FBWjtBQUNILEtBSG1DOztBQUlwQyxRQUFJNEYsSUFBSixHQUFXO0FBQ1AsYUFBT0EsSUFBSSxDQUFDLElBQUQsRUFBTyxJQUFQLENBQVg7QUFDSCxLQU5tQzs7QUFPcENyRixPQUFHLENBQUNQLEdBQUQsRUFBTTtBQUNMLGFBQU8yRixLQUFLLENBQUNELElBQU4sQ0FBVyxJQUFYLEVBQWlCMUYsR0FBakIsRUFBc0IsSUFBdEIsQ0FBUDtBQUNILEtBVG1DOztBQVVwQ1EsT0FBRyxFQUFFdUcsb0JBQW9CLENBQUM7QUFBTTtBQUFQLEtBVlc7QUFXcEM1RyxPQUFHLEVBQUU0RyxvQkFBb0IsQ0FBQztBQUFNO0FBQVAsS0FYVztBQVlwQ3hILFVBQU0sRUFBRXdILG9CQUFvQixDQUFDO0FBQVM7QUFBVixLQVpRO0FBYXBDZCxTQUFLLEVBQUVjLG9CQUFvQixDQUFDO0FBQVE7QUFBVCxLQWJTO0FBY3BDL0YsV0FBTyxFQUFFbUYsYUFBYSxDQUFDLElBQUQsRUFBTyxJQUFQO0FBZGMsR0FBeEM7QUFnQkEsUUFBTW1CLGVBQWUsR0FBRyxDQUFDLE1BQUQsRUFBUyxRQUFULEVBQW1CLFNBQW5CLEVBQThCM0osTUFBTSxDQUFDK0ksUUFBckMsQ0FBeEI7QUFDQVksaUJBQWUsQ0FBQ3RHLE9BQWhCLENBQXdCc0IsTUFBTSxJQUFJO0FBQzlCNEUsMkJBQXVCLENBQUM1RSxNQUFELENBQXZCLEdBQWtDaUUsb0JBQW9CLENBQUNqRSxNQUFELEVBQVMsS0FBVCxFQUFnQixLQUFoQixDQUF0RDtBQUNBOEUsNEJBQXdCLENBQUM5RSxNQUFELENBQXhCLEdBQW1DaUUsb0JBQW9CLENBQUNqRSxNQUFELEVBQVMsSUFBVCxFQUFlLEtBQWYsQ0FBdkQ7QUFDQTZFLDJCQUF1QixDQUFDN0UsTUFBRCxDQUF2QixHQUFrQ2lFLG9CQUFvQixDQUFDakUsTUFBRCxFQUFTLEtBQVQsRUFBZ0IsSUFBaEIsQ0FBdEQ7QUFDQStFLG1DQUErQixDQUFDL0UsTUFBRCxDQUEvQixHQUEwQ2lFLG9CQUFvQixDQUFDakUsTUFBRCxFQUFTLElBQVQsRUFBZSxJQUFmLENBQTlEO0FBQ0gsR0FMRDtBQU1BLFNBQU8sQ0FDSDRFLHVCQURHLEVBRUhFLHdCQUZHLEVBR0hELHVCQUhHLEVBSUhFLCtCQUpHLENBQVA7QUFNSDs7QUFDRCxNQUFNLENBQUNILHVCQUFELEVBQTBCRSx3QkFBMUIsRUFBb0RELHVCQUFwRCxFQUE2RUUsK0JBQTdFLElBQWdILGNBQWVKLHNCQUFzQixFQUEzSjs7QUFDQSxTQUFTTSwyQkFBVCxDQUFxQ3hFLFVBQXJDLEVBQWlEQyxPQUFqRCxFQUEwRDtBQUN0RCxRQUFNWCxnQkFBZ0IsR0FBR1csT0FBTyxHQUMxQkQsVUFBVSxHQUNOc0UsK0JBRE0sR0FFTkYsdUJBSHNCLEdBSTFCcEUsVUFBVSxHQUNOcUUsd0JBRE0sR0FFTkYsdUJBTlY7QUFPQSxTQUFPLENBQUNwSCxNQUFELEVBQVNFLEdBQVQsRUFBY2lELFFBQWQsS0FBMkI7QUFDOUIsUUFBSWpELEdBQUcsS0FBSztBQUFpQjtBQUE3QixNQUFnRDtBQUM1QyxlQUFPLENBQUMrQyxVQUFSO0FBQ0gsT0FGRCxNQUdLLElBQUkvQyxHQUFHLEtBQUs7QUFBaUI7QUFBN0IsTUFBZ0Q7QUFDakQsZUFBTytDLFVBQVA7QUFDSCxPQUZJLE1BR0EsSUFBSS9DLEdBQUcsS0FBSztBQUFVO0FBQXRCLE1BQWlDO0FBQ2xDLGVBQU9GLE1BQVA7QUFDSDs7QUFDRCxXQUFPMEQsT0FBTyxDQUFDdEQsR0FBUixDQUFZcUQsbURBQU0sQ0FBQ2xCLGdCQUFELEVBQW1CckMsR0FBbkIsQ0FBTixJQUFpQ0EsR0FBRyxJQUFJRixNQUF4QyxHQUNidUMsZ0JBRGEsR0FFYnZDLE1BRkMsRUFFT0UsR0FGUCxFQUVZaUQsUUFGWixDQUFQO0FBR0gsR0FiRDtBQWNIOztBQUNELE1BQU11RSx5QkFBeUIsR0FBRztBQUM5QnRILEtBQUcsRUFBRSxhQUFjcUgsMkJBQTJCLENBQUMsS0FBRCxFQUFRLEtBQVI7QUFEaEIsQ0FBbEM7QUFHQSxNQUFNRSx5QkFBeUIsR0FBRztBQUM5QnZILEtBQUcsRUFBRSxhQUFjcUgsMkJBQTJCLENBQUMsS0FBRCxFQUFRLElBQVI7QUFEaEIsQ0FBbEM7QUFHQSxNQUFNRywwQkFBMEIsR0FBRztBQUMvQnhILEtBQUcsRUFBRSxhQUFjcUgsMkJBQTJCLENBQUMsSUFBRCxFQUFPLEtBQVA7QUFEZixDQUFuQztBQUdBLE1BQU1JLGlDQUFpQyxHQUFHO0FBQ3RDekgsS0FBRyxFQUFFLGFBQWNxSCwyQkFBMkIsQ0FBQyxJQUFELEVBQU8sSUFBUDtBQURSLENBQTFDOztBQUdBLFNBQVN4QixpQkFBVCxDQUEyQmpHLE1BQTNCLEVBQW1DUyxHQUFuQyxFQUF3Q1AsR0FBeEMsRUFBNkM7QUFDekMsUUFBTXdGLE1BQU0sR0FBRzdDLEtBQUssQ0FBQzNDLEdBQUQsQ0FBcEI7O0FBQ0EsTUFBSXdGLE1BQU0sS0FBS3hGLEdBQVgsSUFBa0JPLEdBQUcsQ0FBQ21GLElBQUosQ0FBUzVGLE1BQVQsRUFBaUIwRixNQUFqQixDQUF0QixFQUFnRDtBQUM1QyxVQUFNekYsSUFBSSxHQUFHNkgsc0RBQVMsQ0FBQzlILE1BQUQsQ0FBdEI7QUFDQTJFLFdBQU8sQ0FBQ0MsSUFBUixDQUFjLFlBQVczRSxJQUFLLHNDQUFqQixHQUNSLDhCQUE2QkEsSUFBSSxLQUFNLEtBQVYsR0FBa0IsVUFBbEIsR0FBK0IsRUFBRSxJQUR0RCxHQUVSLHFDQUZRLEdBR1IsOERBSFEsR0FJUiw2REFKTDtBQUtIO0FBQ0o7O0FBRUQsTUFBTXNELFdBQVcsR0FBRyxJQUFJOUYsT0FBSixFQUFwQjtBQUNBLE1BQU02RixrQkFBa0IsR0FBRyxJQUFJN0YsT0FBSixFQUEzQjtBQUNBLE1BQU00RixXQUFXLEdBQUcsSUFBSTVGLE9BQUosRUFBcEI7QUFDQSxNQUFNMkYsa0JBQWtCLEdBQUcsSUFBSTNGLE9BQUosRUFBM0I7O0FBQ0EsU0FBU3NLLGFBQVQsQ0FBdUJDLE9BQXZCLEVBQWdDO0FBQzVCLFVBQVFBLE9BQVI7QUFDSSxTQUFLLFFBQUw7QUFDQSxTQUFLLE9BQUw7QUFDSSxhQUFPO0FBQUU7QUFBVDs7QUFDSixTQUFLLEtBQUw7QUFDQSxTQUFLLEtBQUw7QUFDQSxTQUFLLFNBQUw7QUFDQSxTQUFLLFNBQUw7QUFDSSxhQUFPO0FBQUU7QUFBVDs7QUFDSjtBQUNJLGFBQU87QUFBRTtBQUFUO0FBVlI7QUFZSDs7QUFDRCxTQUFTQyxhQUFULENBQXVCcEUsS0FBdkIsRUFBOEI7QUFDMUIsU0FBT0EsS0FBSyxDQUFDO0FBQVc7QUFBWixHQUFMLElBQWdDLENBQUNqQyxNQUFNLENBQUNzRyxZQUFQLENBQW9CckUsS0FBcEIsQ0FBakMsR0FDRDtBQUFFO0FBREQsSUFFRGtFLGFBQWEsQ0FBQ0Qsc0RBQVMsQ0FBQ2pFLEtBQUQsQ0FBVixDQUZuQjtBQUdIOztBQUNELFNBQVNHLFFBQVQsQ0FBa0JoRSxNQUFsQixFQUEwQjtBQUN0QjtBQUNBLE1BQUlBLE1BQU0sSUFBSUEsTUFBTSxDQUFDO0FBQWlCO0FBQWxCLEdBQXBCLEVBQTBEO0FBQ3RELFdBQU9BLE1BQVA7QUFDSDs7QUFDRCxTQUFPbUksb0JBQW9CLENBQUNuSSxNQUFELEVBQVMsS0FBVCxFQUFnQnlFLGVBQWhCLEVBQWlDaUQseUJBQWpDLEVBQTREbkUsV0FBNUQsQ0FBM0I7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVM2RSxlQUFULENBQXlCcEksTUFBekIsRUFBaUM7QUFDN0IsU0FBT21JLG9CQUFvQixDQUFDbkksTUFBRCxFQUFTLEtBQVQsRUFBZ0I4RSx1QkFBaEIsRUFBeUM2Qyx5QkFBekMsRUFBb0VyRSxrQkFBcEUsQ0FBM0I7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTUyxRQUFULENBQWtCL0QsTUFBbEIsRUFBMEI7QUFDdEIsU0FBT21JLG9CQUFvQixDQUFDbkksTUFBRCxFQUFTLElBQVQsRUFBZTBFLGdCQUFmLEVBQWlDa0QsMEJBQWpDLEVBQTZEdkUsV0FBN0QsQ0FBM0I7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU2dGLGVBQVQsQ0FBeUJySSxNQUF6QixFQUFpQztBQUM3QixTQUFPbUksb0JBQW9CLENBQUNuSSxNQUFELEVBQVMsSUFBVCxFQUFlZ0YsdUJBQWYsRUFBd0M2QyxpQ0FBeEMsRUFBMkV6RSxrQkFBM0UsQ0FBM0I7QUFDSDs7QUFDRCxTQUFTK0Usb0JBQVQsQ0FBOEJuSSxNQUE5QixFQUFzQ2lELFVBQXRDLEVBQWtEcUYsWUFBbEQsRUFBZ0VDLGtCQUFoRSxFQUFvRkMsUUFBcEYsRUFBOEY7QUFDMUYsTUFBSSxDQUFDMUUscURBQVEsQ0FBQzlELE1BQUQsQ0FBYixFQUF1QjtBQUNuQixRQUFLbEMsSUFBTCxFQUE2QztBQUN6QzZHLGFBQU8sQ0FBQ0MsSUFBUixDQUFjLGtDQUFpQ0MsTUFBTSxDQUFDN0UsTUFBRCxDQUFTLEVBQTlEO0FBQ0g7O0FBQ0QsV0FBT0EsTUFBUDtBQUNILEdBTnlGLENBTzFGO0FBQ0E7OztBQUNBLE1BQUlBLE1BQU0sQ0FBQztBQUFVO0FBQVgsR0FBTixJQUNBLEVBQUVpRCxVQUFVLElBQUlqRCxNQUFNLENBQUM7QUFBaUI7QUFBbEIsR0FBdEIsQ0FESixFQUNpRTtBQUM3RCxXQUFPQSxNQUFQO0FBQ0gsR0FaeUYsQ0FhMUY7OztBQUNBLFFBQU15SSxhQUFhLEdBQUdELFFBQVEsQ0FBQ3BJLEdBQVQsQ0FBYUosTUFBYixDQUF0Qjs7QUFDQSxNQUFJeUksYUFBSixFQUFtQjtBQUNmLFdBQU9BLGFBQVA7QUFDSCxHQWpCeUYsQ0FrQjFGOzs7QUFDQSxRQUFNQyxVQUFVLEdBQUdULGFBQWEsQ0FBQ2pJLE1BQUQsQ0FBaEM7O0FBQ0EsTUFBSTBJLFVBQVUsS0FBSztBQUFFO0FBQXJCLElBQW9DO0FBQ2hDLGFBQU8xSSxNQUFQO0FBQ0g7O0FBQ0QsUUFBTTJJLEtBQUssR0FBRyxJQUFJQyxLQUFKLENBQVU1SSxNQUFWLEVBQWtCMEksVUFBVSxLQUFLO0FBQUU7QUFBakIsSUFBb0NILGtCQUFwQyxHQUF5REQsWUFBM0UsQ0FBZDtBQUNBRSxVQUFRLENBQUNuSSxHQUFULENBQWFMLE1BQWIsRUFBcUIySSxLQUFyQjtBQUNBLFNBQU9BLEtBQVA7QUFDSDs7QUFDRCxTQUFTRSxVQUFULENBQW9CaEYsS0FBcEIsRUFBMkI7QUFDdkIsTUFBSVosVUFBVSxDQUFDWSxLQUFELENBQWQsRUFBdUI7QUFDbkIsV0FBT2dGLFVBQVUsQ0FBQ2hGLEtBQUssQ0FBQztBQUFVO0FBQVgsS0FBTixDQUFqQjtBQUNIOztBQUNELFNBQU8sQ0FBQyxFQUFFQSxLQUFLLElBQUlBLEtBQUssQ0FBQztBQUFpQjtBQUFsQixHQUFoQixDQUFSO0FBQ0g7O0FBQ0QsU0FBU1osVUFBVCxDQUFvQlksS0FBcEIsRUFBMkI7QUFDdkIsU0FBTyxDQUFDLEVBQUVBLEtBQUssSUFBSUEsS0FBSyxDQUFDO0FBQWlCO0FBQWxCLEdBQWhCLENBQVI7QUFDSDs7QUFDRCxTQUFTaUYsT0FBVCxDQUFpQmpGLEtBQWpCLEVBQXdCO0FBQ3BCLFNBQU9nRixVQUFVLENBQUNoRixLQUFELENBQVYsSUFBcUJaLFVBQVUsQ0FBQ1ksS0FBRCxDQUF0QztBQUNIOztBQUNELFNBQVNoQixLQUFULENBQWUyRCxRQUFmLEVBQXlCO0FBQ3JCLFNBQVNBLFFBQVEsSUFBSTNELEtBQUssQ0FBQzJELFFBQVEsQ0FBQztBQUFVO0FBQVgsR0FBVCxDQUFsQixJQUFzREEsUUFBOUQ7QUFDSDs7QUFDRCxTQUFTdUMsT0FBVCxDQUFpQmxGLEtBQWpCLEVBQXdCO0FBQ3BCbUYsa0RBQUcsQ0FBQ25GLEtBQUQsRUFBUTtBQUFXO0FBQW5CLElBQStCLElBQS9CLENBQUg7QUFDQSxTQUFPQSxLQUFQO0FBQ0g7O0FBRUQsTUFBTW9GLE9BQU8sR0FBSUMsR0FBRCxJQUFTcEYscURBQVEsQ0FBQ29GLEdBQUQsQ0FBUixHQUFnQmxGLFFBQVEsQ0FBQ2tGLEdBQUQsQ0FBeEIsR0FBZ0NBLEdBQXpEOztBQUNBLFNBQVN2RixLQUFULENBQWV3RixDQUFmLEVBQWtCO0FBQ2QsU0FBT0MsT0FBTyxDQUFDRCxDQUFDLElBQUlBLENBQUMsQ0FBQ0UsU0FBRixLQUFnQixJQUF0QixDQUFkO0FBQ0g7O0FBQ0QsU0FBU0MsR0FBVCxDQUFhekYsS0FBYixFQUFvQjtBQUNoQixTQUFPMEYsU0FBUyxDQUFDMUYsS0FBRCxDQUFoQjtBQUNIOztBQUNELFNBQVMyRixVQUFULENBQW9CM0YsS0FBcEIsRUFBMkI7QUFDdkIsU0FBTzBGLFNBQVMsQ0FBQzFGLEtBQUQsRUFBUSxJQUFSLENBQWhCO0FBQ0g7O0FBQ0QsTUFBTTRGLE9BQU4sQ0FBYztBQUNWQyxhQUFXLENBQUNDLFNBQUQsRUFBWUMsUUFBWixFQUFzQjtBQUM3QixTQUFLRCxTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLFNBQUtDLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsU0FBS1AsU0FBTCxHQUFpQixJQUFqQjtBQUNBLFNBQUtRLE1BQUwsR0FBY0QsUUFBUSxHQUFHRCxTQUFILEdBQWVWLE9BQU8sQ0FBQ1UsU0FBRCxDQUE1QztBQUNIOztBQUNRLE1BQUw5RixLQUFLLEdBQUc7QUFDUjlELFNBQUssQ0FBQzhDLEtBQUssQ0FBQyxJQUFELENBQU4sRUFBYztBQUFNO0FBQXBCLE1BQStCLE9BQS9CLENBQUw7QUFDQSxXQUFPLEtBQUtnSCxNQUFaO0FBQ0g7O0FBQ1EsTUFBTGhHLEtBQUssQ0FBQ2lHLE1BQUQsRUFBUztBQUNkLFFBQUl4Rix1REFBVSxDQUFDekIsS0FBSyxDQUFDaUgsTUFBRCxDQUFOLEVBQWdCLEtBQUtILFNBQXJCLENBQWQsRUFBK0M7QUFDM0MsV0FBS0EsU0FBTCxHQUFpQkcsTUFBakI7QUFDQSxXQUFLRCxNQUFMLEdBQWMsS0FBS0QsUUFBTCxHQUFnQkUsTUFBaEIsR0FBeUJiLE9BQU8sQ0FBQ2EsTUFBRCxDQUE5QztBQUNBbEosYUFBTyxDQUFDaUMsS0FBSyxDQUFDLElBQUQsQ0FBTixFQUFjO0FBQU07QUFBcEIsUUFBK0IsT0FBL0IsRUFBd0NpSCxNQUF4QyxDQUFQO0FBQ0g7QUFDSjs7QUFqQlM7O0FBbUJkLFNBQVNQLFNBQVQsQ0FBbUJRLFFBQW5CLEVBQTZCN0csT0FBTyxHQUFHLEtBQXZDLEVBQThDO0FBQzFDLE1BQUlTLEtBQUssQ0FBQ29HLFFBQUQsQ0FBVCxFQUFxQjtBQUNqQixXQUFPQSxRQUFQO0FBQ0g7O0FBQ0QsU0FBTyxJQUFJTixPQUFKLENBQVlNLFFBQVosRUFBc0I3RyxPQUF0QixDQUFQO0FBQ0g7O0FBQ0QsU0FBUzhHLFVBQVQsQ0FBb0JWLEdBQXBCLEVBQXlCO0FBQ3JCMUksU0FBTyxDQUFDaUMsS0FBSyxDQUFDeUcsR0FBRCxDQUFOLEVBQWE7QUFBTTtBQUFuQixJQUE4QixPQUE5QixFQUF3Q3hMLEtBQUQsR0FBMEN3TCxHQUFHLENBQUN6RixLQUE5QyxHQUFzRCxDQUE3RixDQUFQO0FBQ0g7O0FBQ0QsU0FBU29HLEtBQVQsQ0FBZVgsR0FBZixFQUFvQjtBQUNoQixTQUFPM0YsS0FBSyxDQUFDMkYsR0FBRCxDQUFMLEdBQWFBLEdBQUcsQ0FBQ3pGLEtBQWpCLEdBQXlCeUYsR0FBaEM7QUFDSDs7QUFDRCxNQUFNWSxxQkFBcUIsR0FBRztBQUMxQjlKLEtBQUcsRUFBRSxDQUFDSixNQUFELEVBQVNFLEdBQVQsRUFBY2lELFFBQWQsS0FBMkI4RyxLQUFLLENBQUN2RyxPQUFPLENBQUN0RCxHQUFSLENBQVlKLE1BQVosRUFBb0JFLEdBQXBCLEVBQXlCaUQsUUFBekIsQ0FBRCxDQURYO0FBRTFCOUMsS0FBRyxFQUFFLENBQUNMLE1BQUQsRUFBU0UsR0FBVCxFQUFjMkQsS0FBZCxFQUFxQlYsUUFBckIsS0FBa0M7QUFDbkMsVUFBTXJDLFFBQVEsR0FBR2QsTUFBTSxDQUFDRSxHQUFELENBQXZCOztBQUNBLFFBQUl5RCxLQUFLLENBQUM3QyxRQUFELENBQUwsSUFBbUIsQ0FBQzZDLEtBQUssQ0FBQ0UsS0FBRCxDQUE3QixFQUFzQztBQUNsQy9DLGNBQVEsQ0FBQytDLEtBQVQsR0FBaUJBLEtBQWpCO0FBQ0EsYUFBTyxJQUFQO0FBQ0gsS0FIRCxNQUlLO0FBQ0QsYUFBT0gsT0FBTyxDQUFDckQsR0FBUixDQUFZTCxNQUFaLEVBQW9CRSxHQUFwQixFQUF5QjJELEtBQXpCLEVBQWdDVixRQUFoQyxDQUFQO0FBQ0g7QUFDSjtBQVh5QixDQUE5Qjs7QUFhQSxTQUFTZ0gsU0FBVCxDQUFtQkMsY0FBbkIsRUFBbUM7QUFDL0IsU0FBT3ZCLFVBQVUsQ0FBQ3VCLGNBQUQsQ0FBVixHQUNEQSxjQURDLEdBRUQsSUFBSXhCLEtBQUosQ0FBVXdCLGNBQVYsRUFBMEJGLHFCQUExQixDQUZOO0FBR0g7O0FBQ0QsTUFBTUcsYUFBTixDQUFvQjtBQUNoQlgsYUFBVyxDQUFDWSxPQUFELEVBQVU7QUFDakIsU0FBS2pCLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxVQUFNO0FBQUVqSixTQUFGO0FBQU9DO0FBQVAsUUFBZWlLLE9BQU8sQ0FBQyxNQUFNdkssS0FBSyxDQUFDLElBQUQsRUFBTztBQUFNO0FBQWIsTUFBd0IsT0FBeEIsQ0FBWixFQUE4QyxNQUFNYSxPQUFPLENBQUMsSUFBRCxFQUFPO0FBQU07QUFBYixNQUF3QixPQUF4QixDQUEzRCxDQUE1QjtBQUNBLFNBQUsySixJQUFMLEdBQVluSyxHQUFaO0FBQ0EsU0FBS29LLElBQUwsR0FBWW5LLEdBQVo7QUFDSDs7QUFDUSxNQUFMd0QsS0FBSyxHQUFHO0FBQ1IsV0FBTyxLQUFLMEcsSUFBTCxFQUFQO0FBQ0g7O0FBQ1EsTUFBTDFHLEtBQUssQ0FBQ2lHLE1BQUQsRUFBUztBQUNkLFNBQUtVLElBQUwsQ0FBVVYsTUFBVjtBQUNIOztBQVplOztBQWNwQixTQUFTVyxTQUFULENBQW1CSCxPQUFuQixFQUE0QjtBQUN4QixTQUFPLElBQUlELGFBQUosQ0FBa0JDLE9BQWxCLENBQVA7QUFDSDs7QUFDRCxTQUFTSSxNQUFULENBQWdCQyxNQUFoQixFQUF3QjtBQUNwQixNQUFLN00sS0FBRCxJQUEyQyxDQUFDZ0wsT0FBTyxDQUFDNkIsTUFBRCxDQUF2RCxFQUFpRTtBQUM3RGhHLFdBQU8sQ0FBQ0MsSUFBUixDQUFjLDhEQUFkO0FBQ0g7O0FBQ0QsUUFBTWdHLEdBQUcsR0FBR3pKLG9EQUFPLENBQUN3SixNQUFELENBQVAsR0FBa0IsSUFBSWxJLEtBQUosQ0FBVWtJLE1BQU0sQ0FBQ3ZMLE1BQWpCLENBQWxCLEdBQTZDLEVBQXpEOztBQUNBLE9BQUssTUFBTWMsR0FBWCxJQUFrQnlLLE1BQWxCLEVBQTBCO0FBQ3RCQyxPQUFHLENBQUMxSyxHQUFELENBQUgsR0FBVzJLLEtBQUssQ0FBQ0YsTUFBRCxFQUFTekssR0FBVCxDQUFoQjtBQUNIOztBQUNELFNBQU8wSyxHQUFQO0FBQ0g7O0FBQ0QsTUFBTUUsYUFBTixDQUFvQjtBQUNoQnBCLGFBQVcsQ0FBQ3FCLE9BQUQsRUFBVUMsSUFBVixFQUFnQjtBQUN2QixTQUFLRCxPQUFMLEdBQWVBLE9BQWY7QUFDQSxTQUFLQyxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLM0IsU0FBTCxHQUFpQixJQUFqQjtBQUNIOztBQUNRLE1BQUx4RixLQUFLLEdBQUc7QUFDUixXQUFPLEtBQUtrSCxPQUFMLENBQWEsS0FBS0MsSUFBbEIsQ0FBUDtBQUNIOztBQUNRLE1BQUxuSCxLQUFLLENBQUNpRyxNQUFELEVBQVM7QUFDZCxTQUFLaUIsT0FBTCxDQUFhLEtBQUtDLElBQWxCLElBQTBCbEIsTUFBMUI7QUFDSDs7QUFYZTs7QUFhcEIsU0FBU2UsS0FBVCxDQUFlRixNQUFmLEVBQXVCekssR0FBdkIsRUFBNEI7QUFDeEIsU0FBT3lELEtBQUssQ0FBQ2dILE1BQU0sQ0FBQ3pLLEdBQUQsQ0FBUCxDQUFMLEdBQ0R5SyxNQUFNLENBQUN6SyxHQUFELENBREwsR0FFRCxJQUFJNEssYUFBSixDQUFrQkgsTUFBbEIsRUFBMEJ6SyxHQUExQixDQUZOO0FBR0g7O0FBRUQsTUFBTStLLGVBQU4sQ0FBc0I7QUFDbEJ2QixhQUFXLENBQUN3QixNQUFELEVBQVNDLE9BQVQsRUFBa0JsSSxVQUFsQixFQUE4QjtBQUNyQyxTQUFLa0ksT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS0MsTUFBTCxHQUFjLElBQWQ7QUFDQSxTQUFLL0IsU0FBTCxHQUFpQixJQUFqQjtBQUNBLFNBQUtsTCxNQUFMLEdBQWNBLE1BQU0sQ0FBQytNLE1BQUQsRUFBUztBQUN6QjFNLFVBQUksRUFBRSxJQURtQjtBQUV6QmdELGVBQVMsRUFBRSxNQUFNO0FBQ2IsWUFBSSxDQUFDLEtBQUs0SixNQUFWLEVBQWtCO0FBQ2QsZUFBS0EsTUFBTCxHQUFjLElBQWQ7QUFDQXhLLGlCQUFPLENBQUNpQyxLQUFLLENBQUMsSUFBRCxDQUFOLEVBQWM7QUFBTTtBQUFwQixZQUErQixPQUEvQixDQUFQO0FBQ0g7QUFDSjtBQVB3QixLQUFULENBQXBCO0FBU0EsU0FBSztBQUFpQjtBQUF0QixRQUEyQ0ksVUFBM0M7QUFDSDs7QUFDUSxNQUFMWSxLQUFLLEdBQUc7QUFDUjtBQUNBLFVBQU13SCxJQUFJLEdBQUd4SSxLQUFLLENBQUMsSUFBRCxDQUFsQjs7QUFDQSxRQUFJd0ksSUFBSSxDQUFDRCxNQUFULEVBQWlCO0FBQ2JDLFVBQUksQ0FBQ3hCLE1BQUwsR0FBYyxLQUFLMUwsTUFBTCxFQUFkO0FBQ0FrTixVQUFJLENBQUNELE1BQUwsR0FBYyxLQUFkO0FBQ0g7O0FBQ0RyTCxTQUFLLENBQUNzTCxJQUFELEVBQU87QUFBTTtBQUFiLE1BQXdCLE9BQXhCLENBQUw7QUFDQSxXQUFPQSxJQUFJLENBQUN4QixNQUFaO0FBQ0g7O0FBQ1EsTUFBTGhHLEtBQUssQ0FBQ2hELFFBQUQsRUFBVztBQUNoQixTQUFLc0ssT0FBTCxDQUFhdEssUUFBYjtBQUNIOztBQTVCaUI7O0FBOEJ0QixTQUFTeUssUUFBVCxDQUFrQkMsZUFBbEIsRUFBbUM7QUFDL0IsTUFBSUwsTUFBSjtBQUNBLE1BQUlNLE1BQUo7O0FBQ0EsTUFBSUMsdURBQVUsQ0FBQ0YsZUFBRCxDQUFkLEVBQWlDO0FBQzdCTCxVQUFNLEdBQUdLLGVBQVQ7QUFDQUMsVUFBTSxHQUFJMU4sS0FBRCxHQUNILE1BQU07QUFDSjZHLGFBQU8sQ0FBQ0MsSUFBUixDQUFhLG9EQUFiO0FBQ0gsS0FISSxHQUlIOEcsQ0FKTjtBQUtILEdBUEQsTUFRSztBQUNEUixVQUFNLEdBQUdLLGVBQWUsQ0FBQ25MLEdBQXpCO0FBQ0FvTCxVQUFNLEdBQUdELGVBQWUsQ0FBQ2xMLEdBQXpCO0FBQ0g7O0FBQ0QsU0FBTyxJQUFJNEssZUFBSixDQUFvQkMsTUFBcEIsRUFBNEJNLE1BQTVCLEVBQW9DQyx1REFBVSxDQUFDRixlQUFELENBQVYsSUFBK0IsQ0FBQ0EsZUFBZSxDQUFDbEwsR0FBcEYsQ0FBUDtBQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3Q0QkQ7QUFDQTtBQUNBO0FBQ0E7QUFFQSxNQUFNc0wsS0FBSyxHQUFHLEVBQWQ7O0FBQ0EsU0FBU0Msa0JBQVQsQ0FBNEJDLEtBQTVCLEVBQW1DO0FBQy9CRixPQUFLLENBQUMxTSxJQUFOLENBQVc0TSxLQUFYO0FBQ0g7O0FBQ0QsU0FBU0MsaUJBQVQsR0FBNkI7QUFDekJILE9BQUssQ0FBQ3pNLEdBQU47QUFDSDs7QUFDRCxTQUFTMEYsSUFBVCxDQUFjbUgsR0FBZCxFQUFtQixHQUFHcEosSUFBdEIsRUFBNEI7QUFDeEI7QUFDQTtBQUNBL0MsZ0VBQWE7QUFDYixRQUFNb00sUUFBUSxHQUFHTCxLQUFLLENBQUN2TSxNQUFOLEdBQWV1TSxLQUFLLENBQUNBLEtBQUssQ0FBQ3ZNLE1BQU4sR0FBZSxDQUFoQixDQUFMLENBQXdCNk0sU0FBdkMsR0FBbUQsSUFBcEU7QUFDQSxRQUFNQyxjQUFjLEdBQUdGLFFBQVEsSUFBSUEsUUFBUSxDQUFDRyxVQUFULENBQW9CQyxNQUFwQixDQUEyQkMsV0FBOUQ7QUFDQSxRQUFNQyxLQUFLLEdBQUdDLGlCQUFpQixFQUEvQjs7QUFDQSxNQUFJTCxjQUFKLEVBQW9CO0FBQ2hCTSx5QkFBcUIsQ0FBQ04sY0FBRCxFQUFpQkYsUUFBakIsRUFBMkI7QUFBRztBQUE5QixNQUFzRCxDQUN2RUQsR0FBRyxHQUFHcEosSUFBSSxDQUFDOEosSUFBTCxDQUFVLEVBQVYsQ0FEaUUsRUFFdkVULFFBQVEsSUFBSUEsUUFBUSxDQUFDckQsS0FGa0QsRUFHdkUyRCxLQUFLLENBQ0F4SyxHQURMLENBQ1MsQ0FBQztBQUFFK0o7QUFBRixLQUFELEtBQWdCLE9BQU1hLG1CQUFtQixDQUFDVixRQUFELEVBQVdILEtBQUssQ0FBQzVMLElBQWpCLENBQXVCLEdBRHpFLEVBRUt3TSxJQUZMLENBRVUsSUFGVixDQUh1RSxFQU12RUgsS0FOdUUsQ0FBdEQsQ0FBckI7QUFRSCxHQVRELE1BVUs7QUFDRCxVQUFNSyxRQUFRLEdBQUcsQ0FBRSxlQUFjWixHQUFJLEVBQXBCLEVBQXVCLEdBQUdwSixJQUExQixDQUFqQjtBQUNBOztBQUNBLFFBQUkySixLQUFLLENBQUNsTixNQUFOLElBQ0E7QUFDQSxLQUFDLEtBRkwsRUFFWTtBQUNSdU4sY0FBUSxDQUFDMU4sSUFBVCxDQUFlLElBQWYsRUFBb0IsR0FBRzJOLFdBQVcsQ0FBQ04sS0FBRCxDQUFsQztBQUNIOztBQUNEM0gsV0FBTyxDQUFDQyxJQUFSLENBQWEsR0FBRytILFFBQWhCO0FBQ0g7O0FBQ0R4TixnRUFBYTtBQUNoQjs7QUFDRCxTQUFTb04saUJBQVQsR0FBNkI7QUFDekIsTUFBSU0sWUFBWSxHQUFHbEIsS0FBSyxDQUFDQSxLQUFLLENBQUN2TSxNQUFOLEdBQWUsQ0FBaEIsQ0FBeEI7O0FBQ0EsTUFBSSxDQUFDeU4sWUFBTCxFQUFtQjtBQUNmLFdBQU8sRUFBUDtBQUNILEdBSndCLENBS3pCO0FBQ0E7QUFDQTs7O0FBQ0EsUUFBTUMsZUFBZSxHQUFHLEVBQXhCOztBQUNBLFNBQU9ELFlBQVAsRUFBcUI7QUFDakIsVUFBTWhOLElBQUksR0FBR2lOLGVBQWUsQ0FBQyxDQUFELENBQTVCOztBQUNBLFFBQUlqTixJQUFJLElBQUlBLElBQUksQ0FBQ2dNLEtBQUwsS0FBZWdCLFlBQTNCLEVBQXlDO0FBQ3JDaE4sVUFBSSxDQUFDa04sWUFBTDtBQUNILEtBRkQsTUFHSztBQUNERCxxQkFBZSxDQUFDN04sSUFBaEIsQ0FBcUI7QUFDakI0TSxhQUFLLEVBQUVnQixZQURVO0FBRWpCRSxvQkFBWSxFQUFFO0FBRkcsT0FBckI7QUFJSDs7QUFDRCxVQUFNQyxjQUFjLEdBQUdILFlBQVksQ0FBQ1osU0FBYixJQUEwQlksWUFBWSxDQUFDWixTQUFiLENBQXVCZ0IsTUFBeEU7QUFDQUosZ0JBQVksR0FBR0csY0FBYyxJQUFJQSxjQUFjLENBQUNuQixLQUFoRDtBQUNIOztBQUNELFNBQU9pQixlQUFQO0FBQ0g7QUFDRDs7O0FBQ0EsU0FBU0YsV0FBVCxDQUFxQk4sS0FBckIsRUFBNEI7QUFDeEIsUUFBTVksSUFBSSxHQUFHLEVBQWI7QUFDQVosT0FBSyxDQUFDcEwsT0FBTixDQUFjLENBQUNpTSxLQUFELEVBQVEzTixDQUFSLEtBQWM7QUFDeEIwTixRQUFJLENBQUNqTyxJQUFMLENBQVUsSUFBSU8sQ0FBQyxLQUFLLENBQU4sR0FBVSxFQUFWLEdBQWUsQ0FBRSxJQUFGLENBQW5CLENBQVYsRUFBc0MsR0FBRzROLGdCQUFnQixDQUFDRCxLQUFELENBQXpEO0FBQ0gsR0FGRDtBQUdBLFNBQU9ELElBQVA7QUFDSDs7QUFDRCxTQUFTRSxnQkFBVCxDQUEwQjtBQUFFdkIsT0FBRjtBQUFTa0I7QUFBVCxDQUExQixFQUFtRDtBQUMvQyxRQUFNTSxPQUFPLEdBQUdOLFlBQVksR0FBRyxDQUFmLEdBQW9CLFFBQU9BLFlBQWEsbUJBQXhDLEdBQThELEVBQTlFO0FBQ0EsUUFBTU8sTUFBTSxHQUFHekIsS0FBSyxDQUFDSSxTQUFOLEdBQWtCSixLQUFLLENBQUNJLFNBQU4sQ0FBZ0JnQixNQUFoQixJQUEwQixJQUE1QyxHQUFtRCxLQUFsRTtBQUNBLFFBQU1NLElBQUksR0FBSSxRQUFPYixtQkFBbUIsQ0FBQ2IsS0FBSyxDQUFDSSxTQUFQLEVBQWtCSixLQUFLLENBQUM1TCxJQUF4QixFQUE4QnFOLE1BQTlCLENBQXNDLEVBQTlFO0FBQ0EsUUFBTUUsS0FBSyxHQUFJLEdBQUQsR0FBTUgsT0FBcEI7QUFDQSxTQUFPeEIsS0FBSyxDQUFDNEIsS0FBTixHQUNELENBQUNGLElBQUQsRUFBTyxHQUFHRyxXQUFXLENBQUM3QixLQUFLLENBQUM0QixLQUFQLENBQXJCLEVBQW9DRCxLQUFwQyxDQURDLEdBRUQsQ0FBQ0QsSUFBSSxHQUFHQyxLQUFSLENBRk47QUFHSDtBQUNEOzs7QUFDQSxTQUFTRSxXQUFULENBQXFCRCxLQUFyQixFQUE0QjtBQUN4QixRQUFNMUssR0FBRyxHQUFHLEVBQVo7QUFDQSxRQUFNNEssSUFBSSxHQUFHL0wsTUFBTSxDQUFDK0wsSUFBUCxDQUFZRixLQUFaLENBQWI7QUFDQUUsTUFBSSxDQUFDQyxLQUFMLENBQVcsQ0FBWCxFQUFjLENBQWQsRUFBaUIxTSxPQUFqQixDQUF5QmhCLEdBQUcsSUFBSTtBQUM1QjZDLE9BQUcsQ0FBQzlELElBQUosQ0FBUyxHQUFHNE8sVUFBVSxDQUFDM04sR0FBRCxFQUFNdU4sS0FBSyxDQUFDdk4sR0FBRCxDQUFYLENBQXRCO0FBQ0gsR0FGRDs7QUFHQSxNQUFJeU4sSUFBSSxDQUFDdk8sTUFBTCxHQUFjLENBQWxCLEVBQXFCO0FBQ2pCMkQsT0FBRyxDQUFDOUQsSUFBSixDQUFVLE1BQVY7QUFDSDs7QUFDRCxTQUFPOEQsR0FBUDtBQUNIO0FBQ0Q7OztBQUNBLFNBQVM4SyxVQUFULENBQW9CM04sR0FBcEIsRUFBeUIyRCxLQUF6QixFQUFnQ3ZGLEdBQWhDLEVBQXFDO0FBQ2pDLE1BQUl3UCxxREFBUSxDQUFDakssS0FBRCxDQUFaLEVBQXFCO0FBQ2pCQSxTQUFLLEdBQUdrSyxJQUFJLENBQUNDLFNBQUwsQ0FBZW5LLEtBQWYsQ0FBUjtBQUNBLFdBQU92RixHQUFHLEdBQUd1RixLQUFILEdBQVcsQ0FBRSxHQUFFM0QsR0FBSSxJQUFHMkQsS0FBTSxFQUFqQixDQUFyQjtBQUNILEdBSEQsTUFJSyxJQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFDTCxPQUFPQSxLQUFQLEtBQWlCLFNBRFosSUFFTEEsS0FBSyxJQUFJLElBRlIsRUFFYztBQUNmLFdBQU92RixHQUFHLEdBQUd1RixLQUFILEdBQVcsQ0FBRSxHQUFFM0QsR0FBSSxJQUFHMkQsS0FBTSxFQUFqQixDQUFyQjtBQUNILEdBSkksTUFLQSxJQUFJRixzREFBSyxDQUFDRSxLQUFELENBQVQsRUFBa0I7QUFDbkJBLFNBQUssR0FBR2dLLFVBQVUsQ0FBQzNOLEdBQUQsRUFBTTJDLHNEQUFLLENBQUNnQixLQUFLLENBQUNBLEtBQVAsQ0FBWCxFQUEwQixJQUExQixDQUFsQjtBQUNBLFdBQU92RixHQUFHLEdBQUd1RixLQUFILEdBQVcsQ0FBRSxHQUFFM0QsR0FBSSxPQUFSLEVBQWdCMkQsS0FBaEIsRUFBd0IsR0FBeEIsQ0FBckI7QUFDSCxHQUhJLE1BSUEsSUFBSW9LLHVEQUFZLENBQUNwSyxLQUFELENBQWhCLEVBQXlCO0FBQzFCLFdBQU8sQ0FBRSxHQUFFM0QsR0FBSSxNQUFLMkQsS0FBSyxDQUFDcUssSUFBTixHQUFjLElBQUdySyxLQUFLLENBQUNxSyxJQUFLLEdBQTVCLEdBQWtDLEVBQUUsRUFBakQsQ0FBUDtBQUNILEdBRkksTUFHQTtBQUNEckssU0FBSyxHQUFHaEIsc0RBQUssQ0FBQ2dCLEtBQUQsQ0FBYjtBQUNBLFdBQU92RixHQUFHLEdBQUd1RixLQUFILEdBQVcsQ0FBRSxHQUFFM0QsR0FBSSxHQUFSLEVBQVkyRCxLQUFaLENBQXJCO0FBQ0g7QUFDSjs7QUFFRCxNQUFNc0ssZ0JBQWdCLEdBQUc7QUFDckIsR0FBQztBQUFLO0FBQU4sS0FBOEIscUJBRFQ7QUFFckIsR0FBQztBQUFLO0FBQU4sS0FBNEIsbUJBRlA7QUFHckIsR0FBQztBQUFJO0FBQUwsS0FBcUIsY0FIQTtBQUlyQixHQUFDO0FBQUs7QUFBTixLQUEyQixrQkFKTjtBQUtyQixHQUFDO0FBQUk7QUFBTCxLQUFxQixjQUxBO0FBTXJCLEdBQUM7QUFBSztBQUFOLEtBQTRCLG1CQU5QO0FBT3JCLEdBQUM7QUFBSTtBQUFMLEtBQXFCLFNBUEE7QUFRckIsR0FBQztBQUFNO0FBQVAsS0FBOEIsb0JBUlQ7QUFTckIsR0FBQztBQUFLO0FBQU4sS0FBd0IsZ0JBVEg7QUFVckIsR0FBQztBQUFJO0FBQUwsS0FBdUIsZ0JBVkY7QUFXckIsR0FBQztBQUFLO0FBQU4sS0FBMEIsa0JBWEw7QUFZckIsR0FBQztBQUFLO0FBQU4sS0FBNkIsb0JBWlI7QUFhckIsR0FBQztBQUFNO0FBQVAsS0FBOEIsb0JBYlQ7QUFjckIsR0FBQztBQUFNO0FBQVAsS0FBZ0Msc0JBZFg7QUFlckIsR0FBQztBQUFFO0FBQUgsS0FBMEIsZ0JBZkw7QUFnQnJCLEdBQUM7QUFBRTtBQUFILEtBQTJCLGlCQWhCTjtBQWlCckIsR0FBQztBQUFFO0FBQUgsS0FBd0IsZ0JBakJIO0FBa0JyQixHQUFDO0FBQUU7QUFBSCxLQUEwQixrQkFsQkw7QUFtQnJCLEdBQUM7QUFBRTtBQUFILEtBQXlCLDBCQW5CSjtBQW9CckIsR0FBQztBQUFFO0FBQUgsS0FBZ0Msc0JBcEJYO0FBcUJyQixHQUFDO0FBQUU7QUFBSCxLQUFtQyx5QkFyQmQ7QUFzQnJCLEdBQUM7QUFBRTtBQUFILEtBQXNCLFlBdEJEO0FBdUJyQixHQUFDO0FBQUU7QUFBSCxLQUEwQixnQkF2Qkw7QUF3QnJCLEdBQUM7QUFBRTtBQUFILEtBQTJCLGlCQXhCTjtBQXlCckIsR0FBQztBQUFHO0FBQUosS0FBOEIsa0JBekJUO0FBMEJyQixHQUFDO0FBQUc7QUFBSixLQUE2QixpQkExQlI7QUEyQnJCLEdBQUM7QUFBRztBQUFKLEtBQXlCLGNBM0JKO0FBNEJyQixHQUFDO0FBQUc7QUFBSixLQUFtQyx3QkE1QmQ7QUE2QnJCLEdBQUM7QUFBRztBQUFKLEtBQXNCLDBEQUNsQjtBQTlCaUIsQ0FBekI7O0FBZ0NBLFNBQVMzQixxQkFBVCxDQUErQnZPLEVBQS9CLEVBQW1DK04sUUFBbkMsRUFBNkMvTCxJQUE3QyxFQUFtRDBDLElBQW5ELEVBQXlEO0FBQ3JELE1BQUlJLEdBQUo7O0FBQ0EsTUFBSTtBQUNBQSxPQUFHLEdBQUdKLElBQUksR0FBRzFFLEVBQUUsQ0FBQyxHQUFHMEUsSUFBSixDQUFMLEdBQWlCMUUsRUFBRSxFQUE3QjtBQUNILEdBRkQsQ0FHQSxPQUFPbVEsR0FBUCxFQUFZO0FBQ1JDLGVBQVcsQ0FBQ0QsR0FBRCxFQUFNcEMsUUFBTixFQUFnQi9MLElBQWhCLENBQVg7QUFDSDs7QUFDRCxTQUFPOEMsR0FBUDtBQUNIOztBQUNELFNBQVN1TCwwQkFBVCxDQUFvQ3JRLEVBQXBDLEVBQXdDK04sUUFBeEMsRUFBa0QvTCxJQUFsRCxFQUF3RDBDLElBQXhELEVBQThEO0FBQzFELE1BQUlzTCx1REFBWSxDQUFDaFEsRUFBRCxDQUFoQixFQUFzQjtBQUNsQixVQUFNOEUsR0FBRyxHQUFHeUoscUJBQXFCLENBQUN2TyxFQUFELEVBQUsrTixRQUFMLEVBQWUvTCxJQUFmLEVBQXFCMEMsSUFBckIsQ0FBakM7O0FBQ0EsUUFBSUksR0FBRyxJQUFJd0wsc0RBQVcsQ0FBQ3hMLEdBQUQsQ0FBdEIsRUFBNkI7QUFDekJBLFNBQUcsQ0FBQ3lMLEtBQUosQ0FBVUosR0FBRyxJQUFJO0FBQ2JDLG1CQUFXLENBQUNELEdBQUQsRUFBTXBDLFFBQU4sRUFBZ0IvTCxJQUFoQixDQUFYO0FBQ0gsT0FGRDtBQUdIOztBQUNELFdBQU84QyxHQUFQO0FBQ0g7O0FBQ0QsUUFBTTBMLE1BQU0sR0FBRyxFQUFmOztBQUNBLE9BQUssSUFBSWpQLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd2QixFQUFFLENBQUNtQixNQUF2QixFQUErQkksQ0FBQyxFQUFoQyxFQUFvQztBQUNoQ2lQLFVBQU0sQ0FBQ3hQLElBQVAsQ0FBWXFQLDBCQUEwQixDQUFDclEsRUFBRSxDQUFDdUIsQ0FBRCxDQUFILEVBQVF3TSxRQUFSLEVBQWtCL0wsSUFBbEIsRUFBd0IwQyxJQUF4QixDQUF0QztBQUNIOztBQUNELFNBQU84TCxNQUFQO0FBQ0g7O0FBQ0QsU0FBU0osV0FBVCxDQUFxQkQsR0FBckIsRUFBMEJwQyxRQUExQixFQUFvQy9MLElBQXBDLEVBQTBDeU8sVUFBVSxHQUFHLElBQXZELEVBQTZEO0FBQ3pELFFBQU1DLFlBQVksR0FBRzNDLFFBQVEsR0FBR0EsUUFBUSxDQUFDSCxLQUFaLEdBQW9CLElBQWpEOztBQUNBLE1BQUlHLFFBQUosRUFBYztBQUNWLFFBQUk0QyxHQUFHLEdBQUc1QyxRQUFRLENBQUNpQixNQUFuQixDQURVLENBRVY7O0FBQ0EsVUFBTTRCLGVBQWUsR0FBRzdDLFFBQVEsQ0FBQ3JELEtBQWpDLENBSFUsQ0FJVjs7QUFDQSxVQUFNbUcsU0FBUyxHQUFJaFIsS0FBRCxHQUEwQ3FRLGdCQUFnQixDQUFDbE8sSUFBRCxDQUExRCxHQUFtRUEsQ0FBckY7O0FBQ0EsV0FBTzJPLEdBQVAsRUFBWTtBQUNSLFlBQU1HLGtCQUFrQixHQUFHSCxHQUFHLENBQUNJLEVBQS9COztBQUNBLFVBQUlELGtCQUFKLEVBQXdCO0FBQ3BCLGFBQUssSUFBSXZQLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1UCxrQkFBa0IsQ0FBQzNQLE1BQXZDLEVBQStDSSxDQUFDLEVBQWhELEVBQW9EO0FBQ2hELGNBQUl1UCxrQkFBa0IsQ0FBQ3ZQLENBQUQsQ0FBbEIsQ0FBc0I0TyxHQUF0QixFQUEyQlMsZUFBM0IsRUFBNENDLFNBQTVDLE1BQTJELEtBQS9ELEVBQXNFO0FBQ2xFO0FBQ0g7QUFDSjtBQUNKOztBQUNERixTQUFHLEdBQUdBLEdBQUcsQ0FBQzNCLE1BQVY7QUFDSCxLQWhCUyxDQWlCVjs7O0FBQ0EsVUFBTWdDLGVBQWUsR0FBR2pELFFBQVEsQ0FBQ0csVUFBVCxDQUFvQkMsTUFBcEIsQ0FBMkI4QyxZQUFuRDs7QUFDQSxRQUFJRCxlQUFKLEVBQXFCO0FBQ2pCekMsMkJBQXFCLENBQUN5QyxlQUFELEVBQWtCLElBQWxCLEVBQXdCO0FBQUc7QUFBM0IsUUFBb0QsQ0FBQ2IsR0FBRCxFQUFNUyxlQUFOLEVBQXVCQyxTQUF2QixDQUFwRCxDQUFyQjtBQUNBO0FBQ0g7QUFDSjs7QUFDREssVUFBUSxDQUFDZixHQUFELEVBQU1uTyxJQUFOLEVBQVkwTyxZQUFaLEVBQTBCRCxVQUExQixDQUFSO0FBQ0g7O0FBQ0QsU0FBU1MsUUFBVCxDQUFrQmYsR0FBbEIsRUFBdUJuTyxJQUF2QixFQUE2QjBPLFlBQTdCLEVBQTJDRCxVQUFVLEdBQUcsSUFBeEQsRUFBOEQ7QUFDMUQsTUFBSzVRLElBQUwsRUFBNkM7QUFDekMsVUFBTXNSLElBQUksR0FBR2pCLGdCQUFnQixDQUFDbE8sSUFBRCxDQUE3Qjs7QUFDQSxRQUFJME8sWUFBSixFQUFrQjtBQUNkL0Msd0JBQWtCLENBQUMrQyxZQUFELENBQWxCO0FBQ0g7O0FBQ0QvSixRQUFJLENBQUUsa0JBQWlCd0ssSUFBSSxHQUFJLHdCQUF1QkEsSUFBSyxFQUFoQyxHQUFxQyxFQUFFLEVBQTlELENBQUo7O0FBQ0EsUUFBSVQsWUFBSixFQUFrQjtBQUNkN0MsdUJBQWlCO0FBQ3BCLEtBUndDLENBU3pDOzs7QUFDQSxRQUFJNEMsVUFBSixFQUFnQjtBQUNaLFlBQU1OLEdBQU47QUFDSCxLQUZELE1BR0s7QUFDRHpKLGFBQU8sQ0FBQzBLLEtBQVIsQ0FBY2pCLEdBQWQ7QUFDSDtBQUNKLEdBaEJELE1BaUJLLEVBR0o7QUFDSjs7QUFFRCxJQUFJa0IsVUFBVSxHQUFHLEtBQWpCO0FBQ0EsSUFBSUMsY0FBYyxHQUFHLEtBQXJCO0FBQ0EsTUFBTUMsS0FBSyxHQUFHLEVBQWQ7QUFDQSxJQUFJQyxVQUFVLEdBQUcsQ0FBakI7QUFDQSxNQUFNQyxrQkFBa0IsR0FBRyxFQUEzQjtBQUNBLElBQUlDLGlCQUFpQixHQUFHLElBQXhCO0FBQ0EsSUFBSUMsYUFBYSxHQUFHLENBQXBCO0FBQ0EsTUFBTUMsbUJBQW1CLEdBQUcsRUFBNUI7QUFDQSxJQUFJQyxrQkFBa0IsR0FBRyxJQUF6QjtBQUNBLElBQUlDLGNBQWMsR0FBRyxDQUFyQjtBQUNBLE1BQU1DLGVBQWUsR0FBR0MsT0FBTyxDQUFDQyxPQUFSLEVBQXhCO0FBQ0EsSUFBSUMsbUJBQW1CLEdBQUcsSUFBMUI7QUFDQSxJQUFJQyx3QkFBd0IsR0FBRyxJQUEvQjtBQUNBLE1BQU1DLGVBQWUsR0FBRyxHQUF4Qjs7QUFDQSxTQUFTQyxRQUFULENBQWtCclMsRUFBbEIsRUFBc0I7QUFDbEIsUUFBTXNTLENBQUMsR0FBR0osbUJBQW1CLElBQUlILGVBQWpDO0FBQ0EsU0FBTy9SLEVBQUUsR0FBR3NTLENBQUMsQ0FBQ0MsSUFBRixDQUFPLE9BQU92UyxFQUFFLENBQUN3UyxJQUFILENBQVEsSUFBUixDQUFQLEdBQXVCeFMsRUFBOUIsQ0FBSCxHQUF1Q3NTLENBQWhEO0FBQ0gsQyxDQUNEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTRyxrQkFBVCxDQUE0QkMsR0FBNUIsRUFBaUM7QUFDN0I7QUFDQSxNQUFJQyxLQUFLLEdBQUduQixVQUFVLEdBQUcsQ0FBekI7QUFDQSxNQUFJb0IsR0FBRyxHQUFHckIsS0FBSyxDQUFDcFEsTUFBaEI7QUFDQSxRQUFNMFIsS0FBSyxHQUFHQyxLQUFLLENBQUNKLEdBQUQsQ0FBbkI7O0FBQ0EsU0FBT0MsS0FBSyxHQUFHQyxHQUFmLEVBQW9CO0FBQ2hCLFVBQU1HLE1BQU0sR0FBSUosS0FBSyxHQUFHQyxHQUFULEtBQWtCLENBQWpDO0FBQ0EsVUFBTUksV0FBVyxHQUFHRixLQUFLLENBQUN2QixLQUFLLENBQUN3QixNQUFELENBQU4sQ0FBekI7QUFDQUMsZUFBVyxHQUFHSCxLQUFkLEdBQXVCRixLQUFLLEdBQUdJLE1BQU0sR0FBRyxDQUF4QyxHQUE4Q0gsR0FBRyxHQUFHRyxNQUFwRDtBQUNIOztBQUNELFNBQU9KLEtBQVA7QUFDSDs7QUFDRCxTQUFTTSxRQUFULENBQWtCUCxHQUFsQixFQUF1QjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJLENBQUMsQ0FBQ25CLEtBQUssQ0FBQ3BRLE1BQVAsSUFDRCxDQUFDb1EsS0FBSyxDQUFDelEsUUFBTixDQUFlNFIsR0FBZixFQUFvQnJCLFVBQVUsSUFBSXFCLEdBQUcsQ0FBQ3JSLFlBQWxCLEdBQWlDbVEsVUFBVSxHQUFHLENBQTlDLEdBQWtEQSxVQUF0RSxDQURELEtBRUFrQixHQUFHLEtBQUtQLHdCQUZaLEVBRXNDO0FBQ2xDLFVBQU1lLEdBQUcsR0FBR1Qsa0JBQWtCLENBQUNDLEdBQUQsQ0FBOUI7O0FBQ0EsUUFBSVEsR0FBRyxHQUFHLENBQUMsQ0FBWCxFQUFjO0FBQ1YzQixXQUFLLENBQUM0QixNQUFOLENBQWFELEdBQWIsRUFBa0IsQ0FBbEIsRUFBcUJSLEdBQXJCO0FBQ0gsS0FGRCxNQUdLO0FBQ0RuQixXQUFLLENBQUN2USxJQUFOLENBQVcwUixHQUFYO0FBQ0g7O0FBQ0RVLGNBQVU7QUFDYjtBQUNKOztBQUNELFNBQVNBLFVBQVQsR0FBc0I7QUFDbEIsTUFBSSxDQUFDL0IsVUFBRCxJQUFlLENBQUNDLGNBQXBCLEVBQW9DO0FBQ2hDQSxrQkFBYyxHQUFHLElBQWpCO0FBQ0FZLHVCQUFtQixHQUFHSCxlQUFlLENBQUNRLElBQWhCLENBQXFCYyxTQUFyQixDQUF0QjtBQUNIO0FBQ0o7O0FBQ0QsU0FBU0MsYUFBVCxDQUF1QlosR0FBdkIsRUFBNEI7QUFDeEIsUUFBTW5SLENBQUMsR0FBR2dRLEtBQUssQ0FBQ2dDLE9BQU4sQ0FBY2IsR0FBZCxDQUFWOztBQUNBLE1BQUluUixDQUFDLEdBQUdpUSxVQUFSLEVBQW9CO0FBQ2hCRCxTQUFLLENBQUM0QixNQUFOLENBQWE1UixDQUFiLEVBQWdCLENBQWhCO0FBQ0g7QUFDSjs7QUFDRCxTQUFTaVMsT0FBVCxDQUFpQkMsRUFBakIsRUFBcUJDLFdBQXJCLEVBQWtDQyxZQUFsQyxFQUFnREMsS0FBaEQsRUFBdUQ7QUFDbkQsTUFBSSxDQUFDMVEsb0RBQU8sQ0FBQ3VRLEVBQUQsQ0FBWixFQUFrQjtBQUNkLFFBQUksQ0FBQ0MsV0FBRCxJQUNBLENBQUNBLFdBQVcsQ0FBQzVTLFFBQVosQ0FBcUIyUyxFQUFyQixFQUF5QkEsRUFBRSxDQUFDcFMsWUFBSCxHQUFrQnVTLEtBQUssR0FBRyxDQUExQixHQUE4QkEsS0FBdkQsQ0FETCxFQUNvRTtBQUNoRUQsa0JBQVksQ0FBQzNTLElBQWIsQ0FBa0J5UyxFQUFsQjtBQUNIO0FBQ0osR0FMRCxNQU1LO0FBQ0Q7QUFDQTtBQUNBO0FBQ0FFLGdCQUFZLENBQUMzUyxJQUFiLENBQWtCLEdBQUd5UyxFQUFyQjtBQUNIOztBQUNETCxZQUFVO0FBQ2I7O0FBQ0QsU0FBU1MsZUFBVCxDQUF5QkosRUFBekIsRUFBNkI7QUFDekJELFNBQU8sQ0FBQ0MsRUFBRCxFQUFLL0IsaUJBQUwsRUFBd0JELGtCQUF4QixFQUE0Q0UsYUFBNUMsQ0FBUDtBQUNIOztBQUNELFNBQVNtQyxnQkFBVCxDQUEwQkwsRUFBMUIsRUFBOEI7QUFDMUJELFNBQU8sQ0FBQ0MsRUFBRCxFQUFLNUIsa0JBQUwsRUFBeUJELG1CQUF6QixFQUE4Q0UsY0FBOUMsQ0FBUDtBQUNIOztBQUNELFNBQVNpQyxnQkFBVCxDQUEwQkMsSUFBMUIsRUFBZ0NDLFNBQVMsR0FBRyxJQUE1QyxFQUFrRDtBQUM5QyxNQUFJeEMsa0JBQWtCLENBQUN0USxNQUF2QixFQUErQjtBQUMzQmdSLDRCQUF3QixHQUFHOEIsU0FBM0I7QUFDQXZDLHFCQUFpQixHQUFHLENBQUMsR0FBRyxJQUFJblAsR0FBSixDQUFRa1Asa0JBQVIsQ0FBSixDQUFwQjtBQUNBQSxzQkFBa0IsQ0FBQ3RRLE1BQW5CLEdBQTRCLENBQTVCOztBQUNBLFFBQUt0QixJQUFMLEVBQTZDO0FBQ3pDbVUsVUFBSSxHQUFHQSxJQUFJLElBQUksSUFBSTNSLEdBQUosRUFBZjtBQUNIOztBQUNELFNBQUtzUCxhQUFhLEdBQUcsQ0FBckIsRUFBd0JBLGFBQWEsR0FBR0QsaUJBQWlCLENBQUN2USxNQUExRCxFQUFrRXdRLGFBQWEsRUFBL0UsRUFBbUY7QUFDL0UsVUFBSzlSLEtBQUQsSUFDQXFVLHFCQUFxQixDQUFDRixJQUFELEVBQU90QyxpQkFBaUIsQ0FBQ0MsYUFBRCxDQUF4QixDQUR6QixFQUNtRTtBQUMvRDtBQUNIOztBQUNERCx1QkFBaUIsQ0FBQ0MsYUFBRCxDQUFqQjtBQUNIOztBQUNERCxxQkFBaUIsR0FBRyxJQUFwQjtBQUNBQyxpQkFBYSxHQUFHLENBQWhCO0FBQ0FRLDRCQUF3QixHQUFHLElBQTNCLENBaEIyQixDQWlCM0I7O0FBQ0E0QixvQkFBZ0IsQ0FBQ0MsSUFBRCxFQUFPQyxTQUFQLENBQWhCO0FBQ0g7QUFDSjs7QUFDRCxTQUFTRSxpQkFBVCxDQUEyQkgsSUFBM0IsRUFBaUM7QUFDN0IsTUFBSXBDLG1CQUFtQixDQUFDelEsTUFBeEIsRUFBZ0M7QUFDNUIsVUFBTWlULE9BQU8sR0FBRyxDQUFDLEdBQUcsSUFBSTdSLEdBQUosQ0FBUXFQLG1CQUFSLENBQUosQ0FBaEI7QUFDQUEsdUJBQW1CLENBQUN6USxNQUFwQixHQUE2QixDQUE3QixDQUY0QixDQUc1Qjs7QUFDQSxRQUFJMFEsa0JBQUosRUFBd0I7QUFDcEJBLHdCQUFrQixDQUFDN1EsSUFBbkIsQ0FBd0IsR0FBR29ULE9BQTNCO0FBQ0E7QUFDSDs7QUFDRHZDLHNCQUFrQixHQUFHdUMsT0FBckI7O0FBQ0EsUUFBS3ZVLElBQUwsRUFBNkM7QUFDekNtVSxVQUFJLEdBQUdBLElBQUksSUFBSSxJQUFJM1IsR0FBSixFQUFmO0FBQ0g7O0FBQ0R3UCxzQkFBa0IsQ0FBQ3dDLElBQW5CLENBQXdCLENBQUNDLENBQUQsRUFBSUMsQ0FBSixLQUFVekIsS0FBSyxDQUFDd0IsQ0FBRCxDQUFMLEdBQVd4QixLQUFLLENBQUN5QixDQUFELENBQWxEOztBQUNBLFNBQUt6QyxjQUFjLEdBQUcsQ0FBdEIsRUFBeUJBLGNBQWMsR0FBR0Qsa0JBQWtCLENBQUMxUSxNQUE3RCxFQUFxRTJRLGNBQWMsRUFBbkYsRUFBdUY7QUFDbkYsVUFBS2pTLEtBQUQsSUFDQXFVLHFCQUFxQixDQUFDRixJQUFELEVBQU9uQyxrQkFBa0IsQ0FBQ0MsY0FBRCxDQUF6QixDQUR6QixFQUNxRTtBQUNqRTtBQUNIOztBQUNERCx3QkFBa0IsQ0FBQ0MsY0FBRCxDQUFsQjtBQUNIOztBQUNERCxzQkFBa0IsR0FBRyxJQUFyQjtBQUNBQyxrQkFBYyxHQUFHLENBQWpCO0FBQ0g7QUFDSjs7QUFDRCxNQUFNZ0IsS0FBSyxHQUFJSixHQUFELElBQVNBLEdBQUcsQ0FBQ3RSLEVBQUosSUFBVSxJQUFWLEdBQWlCb1QsUUFBakIsR0FBNEI5QixHQUFHLENBQUN0UixFQUF2RDs7QUFDQSxTQUFTaVMsU0FBVCxDQUFtQlcsSUFBbkIsRUFBeUI7QUFDckIxQyxnQkFBYyxHQUFHLEtBQWpCO0FBQ0FELFlBQVUsR0FBRyxJQUFiOztBQUNBLE1BQUt4UixJQUFMLEVBQTZDO0FBQ3pDbVUsUUFBSSxHQUFHQSxJQUFJLElBQUksSUFBSTNSLEdBQUosRUFBZjtBQUNIOztBQUNEMFIsa0JBQWdCLENBQUNDLElBQUQsQ0FBaEIsQ0FOcUIsQ0FPckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0F6QyxPQUFLLENBQUM4QyxJQUFOLENBQVcsQ0FBQ0MsQ0FBRCxFQUFJQyxDQUFKLEtBQVV6QixLQUFLLENBQUN3QixDQUFELENBQUwsR0FBV3hCLEtBQUssQ0FBQ3lCLENBQUQsQ0FBckM7O0FBQ0EsTUFBSTtBQUNBLFNBQUsvQyxVQUFVLEdBQUcsQ0FBbEIsRUFBcUJBLFVBQVUsR0FBR0QsS0FBSyxDQUFDcFEsTUFBeEMsRUFBZ0RxUSxVQUFVLEVBQTFELEVBQThEO0FBQzFELFlBQU1rQixHQUFHLEdBQUduQixLQUFLLENBQUNDLFVBQUQsQ0FBakI7O0FBQ0EsVUFBSWtCLEdBQUcsSUFBSUEsR0FBRyxDQUFDalMsTUFBSixLQUFlLEtBQTFCLEVBQWlDO0FBQzdCLFlBQUtaLEtBQUQsSUFBMkNxVSxxQkFBcUIsQ0FBQ0YsSUFBRCxFQUFPdEIsR0FBUCxDQUFwRSxFQUFpRjtBQUM3RTtBQUNIOztBQUNEbkUsNkJBQXFCLENBQUNtRSxHQUFELEVBQU0sSUFBTixFQUFZO0FBQUc7QUFBZixTQUFyQjtBQUNIO0FBQ0o7QUFDSixHQVZELFNBV1E7QUFDSmxCLGNBQVUsR0FBRyxDQUFiO0FBQ0FELFNBQUssQ0FBQ3BRLE1BQU4sR0FBZSxDQUFmO0FBQ0FnVCxxQkFBaUIsQ0FBQ0gsSUFBRCxDQUFqQjtBQUNBM0MsY0FBVSxHQUFHLEtBQWI7QUFDQWEsdUJBQW1CLEdBQUcsSUFBdEIsQ0FMSSxDQU1KO0FBQ0E7O0FBQ0EsUUFBSVgsS0FBSyxDQUFDcFEsTUFBTixJQUNBc1Esa0JBQWtCLENBQUN0USxNQURuQixJQUVBeVEsbUJBQW1CLENBQUN6USxNQUZ4QixFQUVnQztBQUM1QmtTLGVBQVMsQ0FBQ1csSUFBRCxDQUFUO0FBQ0g7QUFDSjtBQUNKOztBQUNELFNBQVNFLHFCQUFULENBQStCRixJQUEvQixFQUFxQ2hVLEVBQXJDLEVBQXlDO0FBQ3JDLE1BQUksQ0FBQ2dVLElBQUksQ0FBQ3hSLEdBQUwsQ0FBU3hDLEVBQVQsQ0FBTCxFQUFtQjtBQUNmZ1UsUUFBSSxDQUFDNVIsR0FBTCxDQUFTcEMsRUFBVCxFQUFhLENBQWI7QUFDSCxHQUZELE1BR0s7QUFDRCxVQUFNeVUsS0FBSyxHQUFHVCxJQUFJLENBQUM3UixHQUFMLENBQVNuQyxFQUFULENBQWQ7O0FBQ0EsUUFBSXlVLEtBQUssR0FBR3JDLGVBQVosRUFBNkI7QUFDekIsWUFBTXJFLFFBQVEsR0FBRy9OLEVBQUUsQ0FBQzBVLGFBQXBCO0FBQ0EsWUFBTUMsYUFBYSxHQUFHNUcsUUFBUSxJQUFJNkcsZ0JBQWdCLENBQUM3RyxRQUFRLENBQUMvTCxJQUFWLENBQWxEO0FBQ0EyRSxVQUFJLENBQUUscUNBQW9DZ08sYUFBYSxHQUFJLGtCQUFpQkEsYUFBYyxHQUFuQyxHQUF5QyxFQUFFLElBQTdGLEdBQ0EsaUVBREEsR0FFQSx3RUFGQSxHQUdBLCtEQUhBLEdBSUEsMEJBSkQsQ0FBSjtBQUtBLGFBQU8sSUFBUDtBQUNILEtBVEQsTUFVSztBQUNEWCxVQUFJLENBQUM1UixHQUFMLENBQVNwQyxFQUFULEVBQWF5VSxLQUFLLEdBQUcsQ0FBckI7QUFDSDtBQUNKO0FBQ0o7QUFFRDs7O0FBQ0EsSUFBSUksYUFBYSxHQUFHLEtBQXBCO0FBQ0EsTUFBTUMsa0JBQWtCLEdBQUcsSUFBSXZTLEdBQUosRUFBM0IsQyxDQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsSUFBSzFDLElBQUwsRUFBNkM7QUFDekMsUUFBTWtWLFlBQVksR0FBRyxPQUFPQyxxQkFBUCxLQUFrQixXQUFsQixHQUNmQSxxQkFEZSxHQUVmLE9BQU81SCxJQUFQLEtBQWdCLFdBQWhCLEdBQ0lBLElBREosR0FFSSxPQUFPNkgsTUFBUCxLQUFrQixXQUFsQixHQUNJQSxNQURKLEdBRUksRUFOZDtBQU9BRixjQUFZLENBQUNHLG1CQUFiLEdBQW1DO0FBQy9CQyxnQkFBWSxFQUFFQyxPQUFPLENBQUNELFlBQUQsQ0FEVTtBQUUvQkUsWUFBUSxFQUFFRCxPQUFPLENBQUNDLFFBQUQsQ0FGYztBQUcvQkMsVUFBTSxFQUFFRixPQUFPLENBQUNFLE1BQUQ7QUFIZ0IsR0FBbkM7QUFLSDs7QUFDRCxNQUFNelIsR0FBRyxHQUFHLElBQUl4QixHQUFKLEVBQVo7O0FBQ0EsU0FBU2tULFdBQVQsQ0FBcUJ4SCxRQUFyQixFQUErQjtBQUMzQixRQUFNM00sRUFBRSxHQUFHMk0sUUFBUSxDQUFDL0wsSUFBVCxDQUFjd1QsT0FBekI7QUFDQSxNQUFJQyxNQUFNLEdBQUc1UixHQUFHLENBQUMxQixHQUFKLENBQVFmLEVBQVIsQ0FBYjs7QUFDQSxNQUFJLENBQUNxVSxNQUFMLEVBQWE7QUFDVE4sZ0JBQVksQ0FBQy9ULEVBQUQsRUFBSzJNLFFBQVEsQ0FBQy9MLElBQWQsQ0FBWjtBQUNBeVQsVUFBTSxHQUFHNVIsR0FBRyxDQUFDMUIsR0FBSixDQUFRZixFQUFSLENBQVQ7QUFDSDs7QUFDRHFVLFFBQU0sQ0FBQ0MsU0FBUCxDQUFpQmpULEdBQWpCLENBQXFCc0wsUUFBckI7QUFDSDs7QUFDRCxTQUFTNEgsYUFBVCxDQUF1QjVILFFBQXZCLEVBQWlDO0FBQzdCbEssS0FBRyxDQUFDMUIsR0FBSixDQUFRNEwsUUFBUSxDQUFDL0wsSUFBVCxDQUFjd1QsT0FBdEIsRUFBK0JFLFNBQS9CLENBQXlDbFUsTUFBekMsQ0FBZ0R1TSxRQUFoRDtBQUNIOztBQUNELFNBQVNvSCxZQUFULENBQXNCL1QsRUFBdEIsRUFBMEI0TSxTQUExQixFQUFxQztBQUNqQyxNQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFDWnJILFFBQUksQ0FBRSxpQ0FBRCxHQUNBLHFFQURBLEdBRUEsOENBRkQsQ0FBSjtBQUdBcUgsYUFBUyxHQUFHLEVBQVo7QUFDSDs7QUFDRCxNQUFJbkssR0FBRyxDQUFDckIsR0FBSixDQUFRcEIsRUFBUixDQUFKLEVBQWlCO0FBQ2IsV0FBTyxLQUFQO0FBQ0g7O0FBQ0R5QyxLQUFHLENBQUN6QixHQUFKLENBQVFoQixFQUFSLEVBQVk7QUFDUjRNLGFBQVMsRUFBRTRILGdCQUFnQixDQUFDNUgsU0FBRCxDQUFoQixHQUE4QkEsU0FBUyxDQUFDNkgsU0FBeEMsR0FBb0Q3SCxTQUR2RDtBQUVSMEgsYUFBUyxFQUFFLElBQUluVCxHQUFKO0FBRkgsR0FBWjtBQUlBLFNBQU8sSUFBUDtBQUNIOztBQUNELFNBQVM4UyxRQUFULENBQWtCalUsRUFBbEIsRUFBc0IwVSxTQUF0QixFQUFpQztBQUM3QixRQUFNTCxNQUFNLEdBQUc1UixHQUFHLENBQUMxQixHQUFKLENBQVFmLEVBQVIsQ0FBZjtBQUNBLE1BQUksQ0FBQ3FVLE1BQUwsRUFDSTtBQUNKLE1BQUlLLFNBQUosRUFDSUwsTUFBTSxDQUFDekgsU0FBUCxDQUFpQitILE1BQWpCLEdBQTBCRCxTQUExQixDQUx5QixDQU03QjtBQUNBOztBQUNBdFIsT0FBSyxDQUFDd1IsSUFBTixDQUFXUCxNQUFNLENBQUNDLFNBQWxCLEVBQTZCelMsT0FBN0IsQ0FBcUM4SyxRQUFRLElBQUk7QUFDN0MsUUFBSStILFNBQUosRUFBZTtBQUNYL0gsY0FBUSxDQUFDZ0ksTUFBVCxHQUFrQkQsU0FBbEI7QUFDSDs7QUFDRC9ILFlBQVEsQ0FBQ2tJLFdBQVQsR0FBdUIsRUFBdkIsQ0FKNkMsQ0FLN0M7O0FBQ0FwQixpQkFBYSxHQUFHLElBQWhCO0FBQ0E5RyxZQUFRLENBQUNtSSxNQUFUO0FBQ0FyQixpQkFBYSxHQUFHLEtBQWhCO0FBQ0gsR0FURDtBQVVIOztBQUNELFNBQVNTLE1BQVQsQ0FBZ0JsVSxFQUFoQixFQUFvQitVLE9BQXBCLEVBQTZCO0FBQ3pCLFFBQU1WLE1BQU0sR0FBRzVSLEdBQUcsQ0FBQzFCLEdBQUosQ0FBUWYsRUFBUixDQUFmO0FBQ0EsTUFBSSxDQUFDcVUsTUFBTCxFQUNJLE9BSHFCLENBSXpCO0FBQ0E7O0FBQ0EsUUFBTTtBQUFFekgsYUFBRjtBQUFhMEg7QUFBYixNQUEyQkQsTUFBakM7O0FBQ0EsTUFBSSxDQUFDWCxrQkFBa0IsQ0FBQ3RTLEdBQW5CLENBQXVCd0wsU0FBdkIsQ0FBTCxFQUF3QztBQUNwQztBQUNBbUksV0FBTyxHQUFHUCxnQkFBZ0IsQ0FBQ08sT0FBRCxDQUFoQixHQUE0QkEsT0FBTyxDQUFDTixTQUFwQyxHQUFnRE0sT0FBMUQ7QUFDQXJQLHVEQUFNLENBQUNrSCxTQUFELEVBQVltSSxPQUFaLENBQU47O0FBQ0EsU0FBSyxNQUFNbFUsR0FBWCxJQUFrQitMLFNBQWxCLEVBQTZCO0FBQ3pCLFVBQUkvTCxHQUFHLEtBQUssUUFBUixJQUFvQixFQUFFQSxHQUFHLElBQUlrVSxPQUFULENBQXhCLEVBQTJDO0FBQ3ZDLGVBQU9uSSxTQUFTLENBQUMvTCxHQUFELENBQWhCO0FBQ0g7QUFDSixLQVJtQyxDQVNwQztBQUNBOzs7QUFDQTZTLHNCQUFrQixDQUFDclMsR0FBbkIsQ0FBdUJ1TCxTQUF2QixFQVhvQyxDQVlwQzs7QUFDQThGLG9CQUFnQixDQUFDLE1BQU07QUFDbkJnQix3QkFBa0IsQ0FBQ3RULE1BQW5CLENBQTBCd00sU0FBMUI7QUFDSCxLQUZlLENBQWhCO0FBR0g7O0FBQ0R4SixPQUFLLENBQUN3UixJQUFOLENBQVdOLFNBQVgsRUFBc0J6UyxPQUF0QixDQUE4QjhLLFFBQVEsSUFBSTtBQUN0QyxRQUFJQSxRQUFRLENBQUNpQixNQUFiLEVBQXFCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBaUUsY0FBUSxDQUFDbEYsUUFBUSxDQUFDaUIsTUFBVCxDQUFnQmtILE1BQWpCLENBQVI7QUFDSCxLQUxELE1BTUssSUFBSW5JLFFBQVEsQ0FBQ0csVUFBVCxDQUFvQm9ILE1BQXhCLEVBQWdDO0FBQ2pDO0FBQ0F2SCxjQUFRLENBQUNHLFVBQVQsQ0FBb0JvSCxNQUFwQjtBQUNILEtBSEksTUFJQSxJQUFJLE9BQU9MLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7QUFDcEM7QUFDQUEsWUFBTSxDQUFDbUIsUUFBUCxDQUFnQmQsTUFBaEI7QUFDSCxLQUhJLE1BSUE7QUFDRDVPLGFBQU8sQ0FBQ0MsSUFBUixDQUFhLHlFQUFiO0FBQ0g7QUFDSixHQWxCRDtBQW1CSDs7QUFDRCxTQUFTeU8sT0FBVCxDQUFpQnBWLEVBQWpCLEVBQXFCO0FBQ2pCLFNBQU8sQ0FBQ29CLEVBQUQsRUFBS2lWLEdBQUwsS0FBYTtBQUNoQixRQUFJO0FBQ0EsYUFBT3JXLEVBQUUsQ0FBQ29CLEVBQUQsRUFBS2lWLEdBQUwsQ0FBVDtBQUNILEtBRkQsQ0FHQSxPQUFPQyxDQUFQLEVBQVU7QUFDTjVQLGFBQU8sQ0FBQzBLLEtBQVIsQ0FBY2tGLENBQWQ7QUFDQTVQLGFBQU8sQ0FBQ0MsSUFBUixDQUFjLDhEQUFELEdBQ1IsdUJBREw7QUFFSDtBQUNKLEdBVEQ7QUFVSDs7QUFFRCxJQUFJNFAsUUFBSjs7QUFDQSxTQUFTQyxlQUFULENBQXlCQyxJQUF6QixFQUErQjtBQUMzQkYsVUFBUSxHQUFHRSxJQUFYO0FBQ0g7O0FBQ0QsU0FBU0MsZUFBVCxDQUF5QkMsR0FBekIsRUFBOEJDLE9BQTlCLEVBQXVDO0FBQ25DO0FBQ0EsTUFBSSxDQUFDTCxRQUFMLEVBQ0k7QUFDSkEsVUFBUSxDQUFDTSxJQUFULENBQWM7QUFBVztBQUF6QixJQUF5Q0YsR0FBekMsRUFBOENDLE9BQTlDLEVBQXVEO0FBQ25ERSxZQURtRDtBQUVuREMsUUFGbUQ7QUFHbkRDLFdBQU8sRUFBRUMsU0FIMEM7QUFJbkRDO0FBSm1ELEdBQXZEO0FBTUg7O0FBQ0QsU0FBU0Msa0JBQVQsQ0FBNEJSLEdBQTVCLEVBQWlDO0FBQzdCLE1BQUksQ0FBQ0osUUFBTCxFQUNJO0FBQ0pBLFVBQVEsQ0FBQ00sSUFBVCxDQUFjO0FBQWM7QUFBNUIsSUFBK0NGLEdBQS9DO0FBQ0g7O0FBQ0QsTUFBTVMsc0JBQXNCLEdBQUcsYUFBY0MsMkJBQTJCLENBQUM7QUFBa0I7QUFBbkIsQ0FBeEU7QUFDQSxNQUFNQyx3QkFBd0IsR0FBRyxhQUFjRCwyQkFBMkIsQ0FBQztBQUFvQjtBQUFyQixDQUExRTtBQUNBLE1BQU1FLHdCQUF3QixHQUFHLGFBQWNGLDJCQUEyQixDQUFDO0FBQW9CO0FBQXJCLENBQTFFOztBQUNBLFNBQVNBLDJCQUFULENBQXFDWixJQUFyQyxFQUEyQztBQUN2QyxTQUFRekksU0FBRCxJQUFlO0FBQ2xCLFFBQUksQ0FBQ3VJLFFBQUwsRUFDSTtBQUNKQSxZQUFRLENBQUNNLElBQVQsQ0FBY0osSUFBZCxFQUFvQnpJLFNBQVMsQ0FBQ0UsVUFBVixDQUFxQnlJLEdBQXpDLEVBQThDM0ksU0FBUyxDQUFDcE4sR0FBeEQsRUFBNkRvTixTQUFTLENBQUNnQixNQUFWLEdBQW1CaEIsU0FBUyxDQUFDZ0IsTUFBVixDQUFpQnBPLEdBQXBDLEdBQTBDaUIsU0FBdkcsRUFBa0htTSxTQUFsSDtBQUNILEdBSkQ7QUFLSDs7QUFDRCxNQUFNd0osaUJBQWlCLEdBQUcsYUFBY0MsNkJBQTZCLENBQUM7QUFBYTtBQUFkLENBQXJFO0FBQ0EsTUFBTUMsZUFBZSxHQUFHLGFBQWNELDZCQUE2QixDQUFDO0FBQVc7QUFBWixDQUFuRTs7QUFDQSxTQUFTQSw2QkFBVCxDQUF1Q2hCLElBQXZDLEVBQTZDO0FBQ3pDLFNBQU8sQ0FBQ3pJLFNBQUQsRUFBWWhNLElBQVosRUFBa0IyVixJQUFsQixLQUEyQjtBQUM5QixRQUFJLENBQUNwQixRQUFMLEVBQ0k7QUFDSkEsWUFBUSxDQUFDTSxJQUFULENBQWNKLElBQWQsRUFBb0J6SSxTQUFTLENBQUNFLFVBQVYsQ0FBcUJ5SSxHQUF6QyxFQUE4QzNJLFNBQVMsQ0FBQ3BOLEdBQXhELEVBQTZEb04sU0FBN0QsRUFBd0VoTSxJQUF4RSxFQUE4RTJWLElBQTlFO0FBQ0gsR0FKRDtBQUtIOztBQUNELFNBQVNDLHFCQUFULENBQStCNUosU0FBL0IsRUFBMEM2SixLQUExQyxFQUFpREMsTUFBakQsRUFBeUQ7QUFDckQsTUFBSSxDQUFDdkIsUUFBTCxFQUNJO0FBQ0pBLFVBQVEsQ0FBQ00sSUFBVCxDQUFjO0FBQWlCO0FBQS9CLElBQXFEN0ksU0FBUyxDQUFDRSxVQUFWLENBQXFCeUksR0FBMUUsRUFBK0UzSSxTQUEvRSxFQUEwRjZKLEtBQTFGLEVBQWlHQyxNQUFqRztBQUNIOztBQUVELE1BQU1DLGVBQWUsR0FBRztBQUNwQixHQUFDO0FBQWU7QUFBaEIsS0FBcUM7QUFDakNDLFdBQU8sRUFBRyx5RUFBRCxHQUNKLHlFQUY0QjtBQUdqQ0MsUUFBSSxFQUFHO0FBSDBCLEdBRGpCO0FBTXBCLEdBQUM7QUFBeUI7QUFBMUIsS0FBeUQ7QUFDckRELFdBQU8sRUFBRyxrREFBRCxHQUNKLHVFQURJLEdBRUoscUNBSGdEO0FBSXJEQyxRQUFJLEVBQUc7QUFKOEMsR0FOckM7QUFZcEIsR0FBQztBQUFnQjtBQUFqQixLQUF1QztBQUNuQ0QsV0FBTyxFQUFHLDBDQUFELEdBQ0osZ0NBRjhCO0FBR25DQyxRQUFJLEVBQUc7QUFINEIsR0FabkI7QUFpQnBCLEdBQUM7QUFBbUI7QUFBcEIsS0FBNkM7QUFDekNELFdBQU8sRUFBRyxpREFBRCxHQUNKLDBDQUZvQztBQUd6Q0MsUUFBSSxFQUFHO0FBSGtDLEdBakJ6QjtBQXNCcEIsR0FBQztBQUFhO0FBQWQsS0FBaUM7QUFDN0JELFdBQU8sRUFBRyxpRUFBRCxHQUNKO0FBRndCLEdBdEJiO0FBMEJwQixHQUFDO0FBQWdCO0FBQWpCLEtBQXVDO0FBQ25DQSxXQUFPLEVBQUcsb0VBQUQsR0FDSjtBQUY4QixHQTFCbkI7QUE4QnBCLEdBQUM7QUFBb0I7QUFBckIsS0FBK0M7QUFDM0NBLFdBQU8sRUFBRyxxQ0FBRCxHQUNKLHNFQUZzQztBQUczQ0MsUUFBSSxFQUFHO0FBSG9DLEdBOUIzQjtBQW1DcEIsR0FBQztBQUFzQjtBQUF2QixLQUFtRDtBQUMvQ0QsV0FBTyxFQUFHLGdFQUFELEdBQ0o7QUFGMEMsR0FuQy9CO0FBdUNwQixHQUFDO0FBQWdCO0FBQWpCLEtBQXVDO0FBQ25DQSxXQUFPLEVBQUcsb0VBQUQsR0FDSixzRUFESSxHQUVKO0FBSDhCLEdBdkNuQjtBQTRDcEIsR0FBQztBQUFrQjtBQUFuQixLQUEyQztBQUN2Q0EsV0FBTyxFQUFHLDJEQUFELEdBQ0osb0VBRmtDO0FBR3ZDQyxRQUFJLEVBQUc7QUFIZ0MsR0E1Q3ZCO0FBaURwQixHQUFDO0FBQW1CO0FBQXBCLEtBQTZDO0FBQ3pDRCxXQUFPLEVBQUcsb0NBQUQsR0FDSiw0RUFGb0M7QUFHekNDLFFBQUksRUFBRztBQUhrQyxHQWpEekI7QUFzRHBCLEdBQUM7QUFBd0I7QUFBekIsS0FBdUQ7QUFDbkRELFdBQU8sRUFBRyx3Q0FEeUM7QUFFbkRDLFFBQUksRUFBRztBQUY0QyxHQXREbkM7QUEwRHBCLEdBQUM7QUFBMEI7QUFBM0IsS0FBMkQ7QUFDdkRELFdBQU8sRUFBRSxNQUFNO0FBQ1gsVUFBSWxLLEdBQUcsR0FBSSwwQ0FBWDs7QUFDQSxVQUFJb0ssYUFBYSxFQUFqQixFQUFxQjtBQUNqQnBLLFdBQUcsSUFBSyxrRUFBUjtBQUNILE9BRkQsTUFHSztBQUNEQSxXQUFHLElBQUssc0NBQVI7QUFDSDs7QUFDRCxhQUFPQSxHQUFQO0FBQ0gsS0FWc0Q7QUFXdkRtSyxRQUFJLEVBQUc7QUFYZ0QsR0ExRHZDO0FBdUVwQixHQUFDO0FBQW9CO0FBQXJCLEtBQStDO0FBQzNDO0FBQ0E7QUFDQUQsV0FBTyxFQUFHLDJFQUFELEdBQ0osc0VBREksR0FFSjtBQUxzQyxHQXZFM0I7QUE4RXBCLEdBQUM7QUFBNkI7QUFBOUIsS0FBaUU7QUFDN0RBLFdBQU8sRUFBRyxzRUFBRCxHQUNKO0FBRndELEdBOUU3QztBQWtGcEIsR0FBQztBQUFlO0FBQWhCLEtBQXFDO0FBQ2pDQSxXQUFPLEVBQUcsaUVBQUQsR0FDSjtBQUY0QixHQWxGakI7QUFzRnBCLEdBQUM7QUFBa0I7QUFBbkIsS0FBMkM7QUFDdkNBLFdBQU8sRUFBRyxvRUFBRCxHQUNKO0FBRmtDLEdBdEZ2QjtBQTBGcEIsR0FBQztBQUFtQjtBQUFwQixLQUE2QztBQUN6Q0EsV0FBTyxFQUFHLDREQUQrQjtBQUV6Q0MsUUFBSSxFQUFHO0FBRmtDLEdBMUZ6QjtBQThGcEIsR0FBQztBQUF5QjtBQUExQixLQUF5RDtBQUNyREQsV0FBTyxFQUFHLHlDQUFELEdBQ0osZ0RBRmdEO0FBR3JEQyxRQUFJLEVBQUc7QUFIOEMsR0E5RnJDO0FBbUdwQixHQUFDO0FBQXVCO0FBQXhCLEtBQXFEO0FBQ2pERCxXQUFPLEVBQUVILEtBQUssSUFBSyxJQUFHQSxLQUFNLDhEQUFWLEdBQ2IsNERBQTJEQSxLQUFNLEdBRHBELEdBRWIsK0JBQThCQSxLQUFLLENBQUNsSSxLQUFOLENBQVksQ0FBWixDQUFlLElBRmhDLEdBR2IseUVBSGEsR0FJYixRQUw0QztBQU1qRHNJLFFBQUksRUFBRztBQU4wQyxHQW5HakM7QUEyR3BCLEdBQUM7QUFBb0I7QUFBckIsS0FBK0M7QUFDM0NELFdBQU8sRUFBRyxpRUFBRCxHQUNKLHdEQUZzQztBQUczQ0MsUUFBSSxFQUFHO0FBSG9DLEdBM0czQjtBQWdIcEIsR0FBQztBQUFxQjtBQUF0QixLQUFpRDtBQUM3Q0QsV0FBTyxFQUFHLHNFQUFELEdBQ0osd0VBREksR0FFSiw4REFGSSxHQUdKLDJFQUp3QztBQUs3Q0MsUUFBSSxFQUFHO0FBTHNDLEdBaEg3QjtBQXVIcEIsR0FBQztBQUF3QjtBQUF6QixLQUF1RDtBQUNuREQsV0FBTyxFQUFHLDBEQUR5QztBQUVuREMsUUFBSSxFQUFHO0FBRjRDLEdBdkhuQztBQTJIcEIsR0FBQztBQUE2QjtBQUE5QixLQUFpRTtBQUM3REQsV0FBTyxFQUFFckQsYUFBYSxJQUFLLGNBQWFBLGFBQWEsSUFDakQsV0FBWSx1Q0FEVSxHQUVyQix3RUFGcUIsR0FHckIsaUVBSHFCLEdBSXJCLHFFQUpxQixHQUtyQix1REFMcUIsR0FNckIsZ0VBTnFCLEdBT3JCLHlFQVBxQixHQVFyQix5Q0FUd0Q7QUFVN0RzRCxRQUFJLEVBQUc7QUFWc0QsR0EzSDdDO0FBdUlwQixHQUFDO0FBQWtCO0FBQW5CLEtBQTJDO0FBQ3ZDRCxXQUFPLEVBQUcscURBQUQsR0FDSix3QkFGa0M7QUFHdkNDLFFBQUksRUFBRztBQUhnQyxHQXZJdkI7QUE0SXBCLEdBQUM7QUFBcUI7QUFBdEIsS0FBaUQ7QUFDN0NELFdBQU8sRUFBRy9WLEdBQUQsSUFBVSw2QkFBNEJBLEdBQUkscUNBQWpDLEdBQ2IseUVBRndDO0FBRzdDZ1csUUFBSSxFQUFHO0FBSHNDLEdBNUk3QjtBQWlKcEIsR0FBQztBQUF5QjtBQUExQixLQUF5RDtBQUNyREQsV0FBTyxFQUFHO0FBRDJDLEdBakpyQztBQW9KcEIsR0FBQztBQUFvQjtBQUFyQixLQUErQztBQUMzQ0EsV0FBTyxFQUFHO0FBRGlDLEdBcEozQjtBQXVKcEIsR0FBQztBQUFjO0FBQWYsS0FBbUM7QUFDL0JBLFdBQU8sRUFBRywrREFBRCxHQUNKLG1FQURJLEdBRUosd0VBRkksR0FHSiw2QkFISSxHQUlKLDJCQUEwQjtBQUFjO0FBQWtCLGtCQUxoQztBQU0vQkMsUUFBSSxFQUFHO0FBTndCLEdBdkpmO0FBK0pwQixHQUFDO0FBQXFCO0FBQXRCLEtBQWlEO0FBQzdDRCxXQUFPLEVBQUcvVixHQUFELElBQVUsMEVBQUQsR0FDYiw0Q0FEYSxHQUViLG1CQUFrQkEsR0FBSSxJQUhrQjtBQUk3Q2dXLFFBQUksRUFBRztBQUpzQyxHQS9KN0I7QUFxS3BCLEdBQUM7QUFBYTtBQUFkLEtBQWlDO0FBQzdCRCxXQUFPLEVBQUUsQ0FBQ0csVUFBRCxFQUFhQyxPQUFiLEtBQTBCLDBCQUF5QkQsVUFBVyxzQkFBckMsR0FDN0IsUUFBT0MsT0FBUSxZQUZTO0FBRzdCSCxRQUFJLEVBQUc7QUFIc0IsR0FyS2I7QUEwS3BCLEdBQUM7QUFBWTtBQUFiLEtBQStCO0FBQzNCRCxXQUFPLEVBQUcsa0VBQUQsR0FDSix5RUFGc0I7QUFHM0JDLFFBQUksRUFBRztBQUhvQixHQTFLWDtBQStLcEIsR0FBQztBQUF3QjtBQUF6QixLQUF1RDtBQUNuREQsV0FBTyxFQUFHLHlEQUFELEdBQ0osNENBRjhDO0FBR25EQyxRQUFJLEVBQUc7QUFINEMsR0EvS25DO0FBb0xwQixHQUFDO0FBQW1CO0FBQXBCLEtBQTZDO0FBQ3pDRCxXQUFPLEVBQUcvSCxJQUFELElBQVcsY0FBYUEsSUFBSyw0Q0FBbkIsR0FDZCxHQUFFQSxJQUFLLHFFQURPLEdBRWQsbUVBRmMsR0FHZCxxRUFIYyxHQUlkLDJCQUEwQjtBQUFtQjtBQUF1QixrQkFMaEM7QUFNekNnSSxRQUFJLEVBQUc7QUFOa0MsR0FwTHpCO0FBNExwQixHQUFDO0FBQTJCO0FBQTVCLEtBQTZEO0FBQ3pERCxXQUFPLEVBQUUsQ0FBQy9ILElBQUQsRUFBT3JLLEtBQVAsRUFBY3lTLE9BQWQsS0FBMkIseUJBQXdCcEksSUFBSyx5QkFBd0JySyxLQUFNLFVBQTVELEdBQzlCLEdBQUVBLEtBQUssS0FBSyxJQUFWLEdBQWtCLFlBQWxCLEdBQWlDLHdCQUF3QixzQ0FBcUN5UyxPQUFRLGNBRDFFLEdBRTlCLDBFQUY4QixHQUc5Qiw0QkFIOEIsR0FJOUIscUVBSjhCLEdBSzlCLDJCQUEwQjtBQUEyQjtBQUErQixrQkFOaEM7QUFPekRKLFFBQUksRUFBRztBQVBrRCxHQTVMekM7QUFxTXBCLEdBQUM7QUFBcUI7QUFBdEIsS0FBaUQ7QUFDN0NELFdBQU8sRUFBRyxFQURtQyxDQUNqQzs7QUFEaUMsR0FyTTdCO0FBd01wQixHQUFDO0FBQXdCO0FBQXpCLEtBQXVEO0FBQ25EQSxXQUFPLEVBQUcsK0RBQUQsR0FDSix3RUFESSxHQUVKLHFFQUZJLEdBR0osZUFISSxHQUlKLDJCQUEwQjtBQUF3QjtBQUE0QixrQkFMaEM7QUFNbkRDLFFBQUksRUFBRztBQU40QyxHQXhNbkM7QUFnTnBCLEdBQUM7QUFBa0I7QUFBbkIsS0FBMkM7QUFDdkNELFdBQU8sRUFBR00sSUFBRCxJQUFVO0FBQ2YsWUFBTXJJLElBQUksR0FBRzJFLGdCQUFnQixDQUFDMEQsSUFBRCxDQUE3QjtBQUNBLGFBQVMsa0JBQWlCckksSUFBSSxHQUFJLEtBQUlBLElBQUssR0FBYixHQUFtQixHQUFHLCtEQUE1QyxHQUNILHdFQURHLEdBRUgscUVBRkcsR0FHSCxxRUFIRyxHQUlILHdEQUpHLEdBS0gsZUFMRyxHQU1ILDJCQUEwQjtBQUFrQjtBQUFzQixvQkFOdkU7QUFPSCxLQVZzQztBQVd2Q2dJLFFBQUksRUFBRztBQVhnQyxHQWhOdkI7QUE2TnBCLEdBQUM7QUFBdUI7QUFBeEIsS0FBcUQ7QUFDakRELFdBQU8sRUFBR00sSUFBRCxJQUFVO0FBQ2YsWUFBTXJJLElBQUksR0FBRzJFLGdCQUFnQixDQUFDMEQsSUFBRCxDQUE3QjtBQUNBLGFBQVMsdUJBQXNCckksSUFBSSxHQUFJLEtBQUlBLElBQUssR0FBYixHQUFtQixHQUFHLG9FQUFqRCxHQUNILCtEQURHLEdBRUgsc0VBRkcsR0FHSCxrRUFIRyxHQUlILGdCQUpMO0FBS0gsS0FSZ0Q7QUFTakRnSSxRQUFJLEVBQUc7QUFUMEMsR0E3TmpDO0FBd09wQixHQUFDO0FBQW9CO0FBQXJCLEtBQStDO0FBQzNDRCxXQUFPLEVBQUdNLElBQUQsSUFBVTtBQUNmLFlBQU1DLFNBQVMsR0FBSSxZQUFELEdBQ2Isa0VBQWlFO0FBQW9CO0FBQXdCLG9CQURsSDs7QUFFQSxVQUFJRCxJQUFJLENBQUM5SSxLQUFMLElBQWN0TSxvREFBTyxDQUFDb1YsSUFBSSxDQUFDOUksS0FBTixDQUFyQixHQUNFOEksSUFBSSxDQUFDOUksS0FBTCxDQUFXMU8sUUFBWCxDQUFvQixZQUFwQixDQURGLEdBRUUwRSxtREFBTSxDQUFDOFMsSUFBSSxDQUFDOUksS0FBTixFQUFhLFlBQWIsQ0FGWixFQUV3QztBQUNwQyxlQUFTLGtFQUFELEdBQ0gsMkRBQTBEK0ksU0FBVSxFQUR6RTtBQUVIOztBQUNELGFBQVMsMEVBQUQsR0FDSCx5RUFERyxHQUVILGdFQUErREEsU0FBVSxFQUY5RTtBQUdILEtBYjBDO0FBYzNDTixRQUFJLEVBQUc7QUFkb0MsR0F4TzNCO0FBd1BwQixHQUFDO0FBQWtCO0FBQW5CLEtBQTJDO0FBQ3ZDRCxXQUFPLEVBQUcsMkNBQUQsR0FDSixxQ0FESSxHQUVKLDJCQUEwQjtBQUFrQjtBQUFzQixrQkFGOUQsR0FHSiwwRUFKa0M7QUFLdkNDLFFBQUksRUFBRztBQUxnQyxHQXhQdkI7QUErUHBCLEdBQUM7QUFBVTtBQUFYLEtBQTJCO0FBQ3ZCRCxXQUFPLEVBQUcsc0NBQUQsR0FDSiwyRUFESSxHQUVKLGtEQUhrQjtBQUl2QkMsUUFBSSxFQUFHO0FBSmdCLEdBL1BQO0FBcVFwQixHQUFDO0FBQWU7QUFBaEIsS0FBcUM7QUFDakNELFdBQU8sRUFBRS9ILElBQUksSUFBSyxJQUFHQSxJQUFLLDJEQUFULEdBQ1osbUVBRFksR0FFWjtBQUg0QjtBQXJRakIsQ0FBeEI7QUEyUUEsTUFBTXVJLGNBQWMsR0FBRzdVLE1BQU0sQ0FBQzhVLE1BQVAsQ0FBYyxJQUFkLENBQXZCO0FBQ0EsTUFBTUMsU0FBUyxHQUFHL1UsTUFBTSxDQUFDOFUsTUFBUCxDQUFjLElBQWQsQ0FBbEI7O0FBQ0EsU0FBU0UsZUFBVCxDQUF5QjFXLEdBQXpCLEVBQThCOEwsUUFBOUIsRUFBd0MsR0FBR3JKLElBQTNDLEVBQWlEO0FBQzdDLE1BQUksS0FBSixFQUE4QyxFQUU3Qzs7QUFDRHFKLFVBQVEsR0FBR0EsUUFBUSxJQUFJNkssa0JBQWtCLEVBQXpDLENBSjZDLENBSzdDOztBQUNBLFFBQU16SyxNQUFNLEdBQUcwSyxxQkFBcUIsQ0FBQzVXLEdBQUQsRUFBTThMLFFBQU4sQ0FBcEM7O0FBQ0EsTUFBSUksTUFBTSxLQUFLLGtCQUFmLEVBQW1DO0FBQy9CO0FBQ0g7O0FBQ0QsUUFBTTJLLE1BQU0sR0FBRzdXLEdBQUcsR0FBR3lDLElBQUksQ0FBQzhKLElBQUwsQ0FBVSxFQUFWLENBQXJCO0FBQ0EsTUFBSXVLLE1BQU0sR0FBR2hMLFFBQVEsSUFBSVUsbUJBQW1CLENBQUNWLFFBQUQsRUFBV0EsUUFBUSxDQUFDL0wsSUFBcEIsQ0FBNUM7O0FBQ0EsTUFBSStXLE1BQU0sS0FBSyxXQUFYLElBQTBCaEwsUUFBOUIsRUFBd0M7QUFDcENnTCxVQUFNLEdBQUdoTCxRQUFRLENBQUNuTixHQUFsQjtBQUNILEdBZDRDLENBZTdDOzs7QUFDQSxRQUFNb1ksZUFBZSxHQUFHRixNQUFNLEdBQUdDLE1BQWpDOztBQUNBLE1BQUlDLGVBQWUsSUFBSVIsY0FBdkIsRUFBdUM7QUFDbkM7QUFDSDs7QUFDREEsZ0JBQWMsQ0FBQ1EsZUFBRCxDQUFkLEdBQWtDLElBQWxDLENBcEI2QyxDQXFCN0M7QUFDQTs7QUFDQSxNQUFJRixNQUFNLElBQUlKLFNBQWQsRUFBeUI7QUFDckIvUixRQUFJLENBQUUsZ0JBQWUxRSxHQUFJLE1BQUssRUFBRXlXLFNBQVMsQ0FBQ0ksTUFBRCxDQUFYLEdBQXNCLENBQUUsR0FBbEQsQ0FBSjtBQUNBO0FBQ0g7O0FBQ0RKLFdBQVMsQ0FBQ0ksTUFBRCxDQUFULEdBQW9CLENBQXBCO0FBQ0EsUUFBTTtBQUFFZCxXQUFGO0FBQVdDO0FBQVgsTUFBb0JGLGVBQWUsQ0FBQzlWLEdBQUQsQ0FBekM7QUFDQTBFLE1BQUksQ0FBRSxnQkFBZTFFLEdBQUksS0FBSSxPQUFPK1YsT0FBUCxLQUFtQixVQUFuQixHQUFnQ0EsT0FBTyxDQUFDLEdBQUd0VCxJQUFKLENBQXZDLEdBQW1Ec1QsT0FBUSxHQUFFQyxJQUFJLEdBQUksZ0JBQWVBLElBQUssRUFBeEIsR0FBNkIsRUFBRSxFQUF6SCxDQUFKOztBQUNBLE1BQUksQ0FBQ2dCLGVBQWUsQ0FBQ2hYLEdBQUQsRUFBTThMLFFBQU4sRUFBZ0IsSUFBaEIsQ0FBcEIsRUFBMkM7QUFDdkNySCxXQUFPLENBQUMwSyxLQUFSLENBQWUsd0VBQUQsR0FDVCx5QkFETDtBQUVIO0FBQ0o7O0FBQ0QsTUFBTThILGtCQUFrQixHQUFHO0FBQ3ZCQyxNQUFJLEVBQUU7QUFEaUIsQ0FBM0I7O0FBR0EsU0FBU04scUJBQVQsQ0FBK0I1VyxHQUEvQixFQUFvQzhMLFFBQXBDLEVBQThDO0FBQzFDLFFBQU1xTCxjQUFjLEdBQUdyTCxRQUFRLElBQUlBLFFBQVEsQ0FBQy9MLElBQVQsQ0FBY3FYLFlBQWpEOztBQUNBLE1BQUlELGNBQWMsSUFBSW5YLEdBQUcsSUFBSW1YLGNBQTdCLEVBQTZDO0FBQ3pDLFdBQU9BLGNBQWMsQ0FBQ25YLEdBQUQsQ0FBckI7QUFDSDs7QUFDRCxTQUFPaVgsa0JBQWtCLENBQUNqWCxHQUFELENBQXpCO0FBQ0g7O0FBQ0QsU0FBU2dYLGVBQVQsQ0FBeUJoWCxHQUF6QixFQUE4QjhMLFFBQTlCLEVBQXdDdUwsZ0JBQWdCLEdBQUcsS0FBM0QsRUFBa0U7QUFDOUQ7QUFDQSxNQUFJLENBQUNBLGdCQUFELElBQXFCdkwsUUFBckIsSUFBaUNBLFFBQVEsQ0FBQy9MLElBQVQsQ0FBY3VYLFdBQW5ELEVBQWdFO0FBQzVELFdBQU8sS0FBUDtBQUNIOztBQUNELFFBQU1DLE9BQU8sR0FBR1gscUJBQXFCLENBQUMsTUFBRCxFQUFTOUssUUFBVCxDQUFyQixJQUEyQyxDQUEzRDtBQUNBLFFBQU05QyxHQUFHLEdBQUc0TixxQkFBcUIsQ0FBQzVXLEdBQUQsRUFBTThMLFFBQU4sQ0FBakM7QUFDQSxRQUFNMEwsSUFBSSxHQUFHekosdURBQVksQ0FBQ3dKLE9BQUQsQ0FBWixHQUNQQSxPQUFPLENBQUN6TCxRQUFRLElBQUlBLFFBQVEsQ0FBQy9MLElBQXRCLENBREEsR0FFUHdYLE9BRk47O0FBR0EsTUFBSUMsSUFBSSxLQUFLLENBQWIsRUFBZ0I7QUFDWixXQUFPeE8sR0FBRyxLQUFLLEtBQWY7QUFDSCxHQUZELE1BR0s7QUFDRCxXQUFPQSxHQUFHLEtBQUssSUFBUixJQUFnQkEsR0FBRyxLQUFLLGtCQUEvQjtBQUNIO0FBQ0o7O0FBRUQsU0FBUzRMLElBQVQsQ0FBYzlJLFFBQWQsRUFBd0I4SixLQUF4QixFQUErQixHQUFHNkIsT0FBbEMsRUFBMkM7QUFDdkMsUUFBTWxLLEtBQUssR0FBR3pCLFFBQVEsQ0FBQ0gsS0FBVCxDQUFlNEIsS0FBZixJQUF3QnBQLGtEQUF0Qzs7QUFDQSxNQUFLUCxJQUFMLEVBQTZDO0FBQ3pDLFVBQU07QUFBRThaLGtCQUFGO0FBQWdCQyxrQkFBWSxFQUFFLENBQUNBLFlBQUQ7QUFBOUIsUUFBaUQ3TCxRQUF2RDs7QUFDQSxRQUFJNEwsWUFBSixFQUFrQjtBQUNkLFVBQUksRUFBRTlCLEtBQUssSUFBSThCLFlBQVgsS0FDQSxDQUFFLEtBRE4sRUFDZTtBQUNYLFlBQUksQ0FBQ0MsWUFBRCxJQUFpQixFQUFFQyx5REFBWSxDQUFDaEMsS0FBRCxDQUFaLElBQXVCK0IsWUFBekIsQ0FBckIsRUFBNkQ7QUFDekRqVCxjQUFJLENBQUUsNEJBQTJCa1IsS0FBTSxrQ0FBbEMsR0FDQSwrQkFBOEJnQyx5REFBWSxDQUFDaEMsS0FBRCxDQUFRLFNBRG5ELENBQUo7QUFFSDtBQUNKLE9BTkQsTUFPSztBQUNELGNBQU1pQyxTQUFTLEdBQUdILFlBQVksQ0FBQzlCLEtBQUQsQ0FBOUI7O0FBQ0EsWUFBSTdILHVEQUFZLENBQUM4SixTQUFELENBQWhCLEVBQTZCO0FBQ3pCLGdCQUFNQyxPQUFPLEdBQUdELFNBQVMsQ0FBQyxHQUFHSixPQUFKLENBQXpCOztBQUNBLGNBQUksQ0FBQ0ssT0FBTCxFQUFjO0FBQ1ZwVCxnQkFBSSxDQUFFLCtEQUE4RGtSLEtBQU0sSUFBdEUsQ0FBSjtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0o7O0FBQ0QsTUFBSW5ULElBQUksR0FBR2dWLE9BQVg7QUFDQSxRQUFNTSxlQUFlLEdBQUduQyxLQUFLLENBQUNvQyxVQUFOLENBQWlCLFNBQWpCLENBQXhCLENBeEJ1QyxDQXlCdkM7O0FBQ0EsUUFBTUMsUUFBUSxHQUFHRixlQUFlLElBQUluQyxLQUFLLENBQUNsSSxLQUFOLENBQVksQ0FBWixDQUFwQzs7QUFDQSxNQUFJdUssUUFBUSxJQUFJQSxRQUFRLElBQUkxSyxLQUE1QixFQUFtQztBQUMvQixVQUFNMkssWUFBWSxHQUFJLEdBQUVELFFBQVEsS0FBSyxZQUFiLEdBQTRCLE9BQTVCLEdBQXNDQSxRQUFTLFdBQXZFO0FBQ0EsVUFBTTtBQUFFRSxZQUFGO0FBQVVDO0FBQVYsUUFBbUI3SyxLQUFLLENBQUMySyxZQUFELENBQUwsSUFBdUIvWixrREFBaEQ7O0FBQ0EsUUFBSWlhLElBQUosRUFBVTtBQUNOM1YsVUFBSSxHQUFHZ1YsT0FBTyxDQUFDN1YsR0FBUixDQUFZeVEsQ0FBQyxJQUFJQSxDQUFDLENBQUMrRixJQUFGLEVBQWpCLENBQVA7QUFDSCxLQUZELE1BR0ssSUFBSUQsTUFBSixFQUFZO0FBQ2IxVixVQUFJLEdBQUdnVixPQUFPLENBQUM3VixHQUFSLENBQVl5VyxpREFBWixDQUFQO0FBQ0g7QUFDSjs7QUFDRCxNQUFLemEsSUFBTCxFQUFzRTtBQUNsRStYLHlCQUFxQixDQUFDN0osUUFBRCxFQUFXOEosS0FBWCxFQUFrQm5ULElBQWxCLENBQXJCO0FBQ0g7O0FBQ0QsTUFBSzdFLElBQUwsRUFBNkM7QUFDekMsVUFBTTBhLGNBQWMsR0FBRzFDLEtBQUssQ0FBQzJDLFdBQU4sRUFBdkI7O0FBQ0EsUUFBSUQsY0FBYyxLQUFLMUMsS0FBbkIsSUFBNEJySSxLQUFLLENBQUNxSyx5REFBWSxDQUFDVSxjQUFELENBQWIsQ0FBckMsRUFBcUU7QUFDakU1VCxVQUFJLENBQUUsVUFBUzRULGNBQWUsNEJBQXpCLEdBQ0EsR0FBRTlMLG1CQUFtQixDQUFDVixRQUFELEVBQVdBLFFBQVEsQ0FBQy9MLElBQXBCLENBQTBCLHVDQUFzQzZWLEtBQU0sS0FEM0YsR0FFQSxvRUFGQSxHQUdBLGtFQUhBLEdBSUEsNEJBQTJCNEMsc0RBQVMsQ0FBQzVDLEtBQUQsQ0FBUSxpQkFBZ0JBLEtBQU0sSUFKbkUsQ0FBSjtBQUtIO0FBQ0o7O0FBQ0QsTUFBSTZDLFdBQUo7QUFDQSxNQUFJQyxPQUFPLEdBQUduTCxLQUFLLENBQUVrTCxXQUFXLEdBQUdiLHlEQUFZLENBQUNoQyxLQUFELENBQTVCLENBQUwsSUFDVjtBQUNBckksT0FBSyxDQUFFa0wsV0FBVyxHQUFHYix5REFBWSxDQUFDZSxxREFBUSxDQUFDL0MsS0FBRCxDQUFULENBQTVCLENBRlQsQ0FuRHVDLENBc0R2QztBQUNBOztBQUNBLE1BQUksQ0FBQzhDLE9BQUQsSUFBWVgsZUFBaEIsRUFBaUM7QUFDN0JXLFdBQU8sR0FBR25MLEtBQUssQ0FBRWtMLFdBQVcsR0FBR2IseURBQVksQ0FBQ1ksc0RBQVMsQ0FBQzVDLEtBQUQsQ0FBVixDQUE1QixDQUFmO0FBQ0g7O0FBQ0QsTUFBSThDLE9BQUosRUFBYTtBQUNUdEssOEJBQTBCLENBQUNzSyxPQUFELEVBQVU1TSxRQUFWLEVBQW9CO0FBQUU7QUFBdEIsTUFBcURySixJQUFyRCxDQUExQjtBQUNIOztBQUNELFFBQU1tVyxXQUFXLEdBQUdyTCxLQUFLLENBQUNrTCxXQUFXLEdBQUksTUFBaEIsQ0FBekI7O0FBQ0EsTUFBSUcsV0FBSixFQUFpQjtBQUNiLFFBQUksQ0FBQzlNLFFBQVEsQ0FBQytNLE9BQWQsRUFBdUI7QUFDbkIvTSxjQUFRLENBQUMrTSxPQUFULEdBQW1CLEVBQW5CO0FBQ0gsS0FGRCxNQUdLLElBQUkvTSxRQUFRLENBQUMrTSxPQUFULENBQWlCSixXQUFqQixDQUFKLEVBQW1DO0FBQ3BDO0FBQ0g7O0FBQ0QzTSxZQUFRLENBQUMrTSxPQUFULENBQWlCSixXQUFqQixJQUFnQyxJQUFoQztBQUNBckssOEJBQTBCLENBQUN3SyxXQUFELEVBQWM5TSxRQUFkLEVBQXdCO0FBQUU7QUFBMUIsTUFBeURySixJQUF6RCxDQUExQjtBQUNIO0FBQ0o7O0FBQ0QsU0FBU3FXLHFCQUFULENBQStCekMsSUFBL0IsRUFBcUNwSyxVQUFyQyxFQUFpRDhNLE9BQU8sR0FBRyxLQUEzRCxFQUFrRTtBQUM5RCxRQUFNQyxLQUFLLEdBQUcvTSxVQUFVLENBQUNnTixVQUF6QjtBQUNBLFFBQU1DLE1BQU0sR0FBR0YsS0FBSyxDQUFDOVksR0FBTixDQUFVbVcsSUFBVixDQUFmOztBQUNBLE1BQUk2QyxNQUFNLEtBQUt0WixTQUFmLEVBQTBCO0FBQ3RCLFdBQU9zWixNQUFQO0FBQ0g7O0FBQ0QsUUFBTTlhLEdBQUcsR0FBR2lZLElBQUksQ0FBQzhDLEtBQWpCO0FBQ0EsTUFBSUMsVUFBVSxHQUFHLEVBQWpCLENBUDhELENBUTlEOztBQUNBLE1BQUlDLFVBQVUsR0FBRyxLQUFqQjs7QUFDQSxNQUFJQyxLQUFtQixJQUFJLENBQUN2TCx1REFBWSxDQUFDc0ksSUFBRCxDQUF4QyxFQUFnRDtBQUM1QyxVQUFNa0QsV0FBVyxHQUFJbmIsR0FBRCxJQUFTO0FBQ3pCLFlBQU1vYixvQkFBb0IsR0FBR1YscUJBQXFCLENBQUMxYSxHQUFELEVBQU02TixVQUFOLEVBQWtCLElBQWxCLENBQWxEOztBQUNBLFVBQUl1TixvQkFBSixFQUEwQjtBQUN0Qkgsa0JBQVUsR0FBRyxJQUFiO0FBQ0F4VSwyREFBTSxDQUFDdVUsVUFBRCxFQUFhSSxvQkFBYixDQUFOO0FBQ0g7QUFDSixLQU5EOztBQU9BLFFBQUksQ0FBQ1QsT0FBRCxJQUFZOU0sVUFBVSxDQUFDd04sTUFBWCxDQUFrQnZhLE1BQWxDLEVBQTBDO0FBQ3RDK00sZ0JBQVUsQ0FBQ3dOLE1BQVgsQ0FBa0J6WSxPQUFsQixDQUEwQnVZLFdBQTFCO0FBQ0g7O0FBQ0QsUUFBSWxELElBQUksQ0FBQ3FELE9BQVQsRUFBa0I7QUFDZEgsaUJBQVcsQ0FBQ2xELElBQUksQ0FBQ3FELE9BQU4sQ0FBWDtBQUNIOztBQUNELFFBQUlyRCxJQUFJLENBQUNvRCxNQUFULEVBQWlCO0FBQ2JwRCxVQUFJLENBQUNvRCxNQUFMLENBQVl6WSxPQUFaLENBQW9CdVksV0FBcEI7QUFDSDtBQUNKOztBQUNELE1BQUksQ0FBQ25iLEdBQUQsSUFBUSxDQUFDaWIsVUFBYixFQUF5QjtBQUNyQkwsU0FBSyxDQUFDN1ksR0FBTixDQUFVa1csSUFBVixFQUFnQixJQUFoQjtBQUNBLFdBQU8sSUFBUDtBQUNIOztBQUNELE1BQUlwVixvREFBTyxDQUFDN0MsR0FBRCxDQUFYLEVBQWtCO0FBQ2RBLE9BQUcsQ0FBQzRDLE9BQUosQ0FBWWhCLEdBQUcsSUFBS29aLFVBQVUsQ0FBQ3BaLEdBQUQsQ0FBVixHQUFrQixJQUF0QztBQUNILEdBRkQsTUFHSztBQUNENkUsdURBQU0sQ0FBQ3VVLFVBQUQsRUFBYWhiLEdBQWIsQ0FBTjtBQUNIOztBQUNENGEsT0FBSyxDQUFDN1ksR0FBTixDQUFVa1csSUFBVixFQUFnQitDLFVBQWhCO0FBQ0EsU0FBT0EsVUFBUDtBQUNILEMsQ0FDRDtBQUNBO0FBQ0E7OztBQUNBLFNBQVNPLGNBQVQsQ0FBd0J6YixPQUF4QixFQUFpQzhCLEdBQWpDLEVBQXNDO0FBQ2xDLE1BQUksQ0FBQzlCLE9BQUQsSUFBWSxDQUFDMGIsaURBQUksQ0FBQzVaLEdBQUQsQ0FBckIsRUFBNEI7QUFDeEIsV0FBTyxLQUFQO0FBQ0g7O0FBQ0RBLEtBQUcsR0FBR0EsR0FBRyxDQUFDME4sS0FBSixDQUFVLENBQVYsRUFBYW1NLE9BQWIsQ0FBcUIsT0FBckIsRUFBOEIsRUFBOUIsQ0FBTjtBQUNBLFNBQVF0VyxtREFBTSxDQUFDckYsT0FBRCxFQUFVOEIsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFPdVksV0FBUCxLQUF1QnZZLEdBQUcsQ0FBQzBOLEtBQUosQ0FBVSxDQUFWLENBQWpDLENBQU4sSUFDSm5LLG1EQUFNLENBQUNyRixPQUFELEVBQVVzYSxzREFBUyxDQUFDeFksR0FBRCxDQUFuQixDQURGLElBRUp1RCxtREFBTSxDQUFDckYsT0FBRCxFQUFVOEIsR0FBVixDQUZWO0FBR0g7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsSUFBSThaLHdCQUF3QixHQUFHLElBQS9CO0FBQ0EsSUFBSUMsY0FBYyxHQUFHLElBQXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBU0MsMkJBQVQsQ0FBcUNsTyxRQUFyQyxFQUErQztBQUMzQyxRQUFNbU8sSUFBSSxHQUFHSCx3QkFBYjtBQUNBQSwwQkFBd0IsR0FBR2hPLFFBQTNCO0FBQ0FpTyxnQkFBYyxHQUFJak8sUUFBUSxJQUFJQSxRQUFRLENBQUMvTCxJQUFULENBQWNtYSxTQUEzQixJQUF5QyxJQUExRDtBQUNBLFNBQU9ELElBQVA7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTRSxXQUFULENBQXFCaGIsRUFBckIsRUFBeUI7QUFDckI0YSxnQkFBYyxHQUFHNWEsRUFBakI7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNpYixVQUFULEdBQXNCO0FBQ2xCTCxnQkFBYyxHQUFHLElBQWpCO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTU0sV0FBVyxHQUFJQyxHQUFELElBQVNDLE9BQTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNBLE9BQVQsQ0FBaUJ4YyxFQUFqQixFQUFxQnljLEdBQUcsR0FBR1Ysd0JBQTNCLEVBQXFEVyxlQUFyRCxDQUFxRTtBQUFyRSxFQUNFO0FBQ0UsTUFBSSxDQUFDRCxHQUFMLEVBQ0ksT0FBT3pjLEVBQVAsQ0FGTixDQUdFOztBQUNBLE1BQUlBLEVBQUUsQ0FBQzJjLEVBQVAsRUFBVztBQUNQLFdBQU8zYyxFQUFQO0FBQ0g7O0FBQ0QsUUFBTTRjLG1CQUFtQixHQUFHLENBQUMsR0FBR2xZLElBQUosS0FBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSWtZLG1CQUFtQixDQUFDQyxFQUF4QixFQUE0QjtBQUN4QkMsc0JBQWdCLENBQUMsQ0FBQyxDQUFGLENBQWhCO0FBQ0g7O0FBQ0QsVUFBTUMsWUFBWSxHQUFHZCwyQkFBMkIsQ0FBQ1EsR0FBRCxDQUFoRDtBQUNBLFVBQU0zWCxHQUFHLEdBQUc5RSxFQUFFLENBQUMsR0FBRzBFLElBQUosQ0FBZDtBQUNBdVgsK0JBQTJCLENBQUNjLFlBQUQsQ0FBM0I7O0FBQ0EsUUFBSUgsbUJBQW1CLENBQUNDLEVBQXhCLEVBQTRCO0FBQ3hCQyxzQkFBZ0IsQ0FBQyxDQUFELENBQWhCO0FBQ0g7O0FBQ0QsUUFBS2pkLElBQUwsRUFBc0U7QUFDbEV5WCw4QkFBd0IsQ0FBQ21GLEdBQUQsQ0FBeEI7QUFDSDs7QUFDRCxXQUFPM1gsR0FBUDtBQUNILEdBbkJELENBUEYsQ0EyQkU7OztBQUNBOFgscUJBQW1CLENBQUNELEVBQXBCLEdBQXlCLElBQXpCLENBNUJGLENBNkJFO0FBQ0E7QUFDQTs7QUFDQUMscUJBQW1CLENBQUNJLEVBQXBCLEdBQXlCLElBQXpCLENBaENGLENBaUNFOztBQUNBSixxQkFBbUIsQ0FBQ0MsRUFBcEIsR0FBeUIsSUFBekI7QUFDQSxTQUFPRCxtQkFBUDtBQUNIO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsSUFBSUssYUFBYSxHQUFHLEtBQXBCOztBQUNBLFNBQVNDLGlCQUFULEdBQTZCO0FBQ3pCRCxlQUFhLEdBQUcsSUFBaEI7QUFDSDs7QUFDRCxTQUFTRSxtQkFBVCxDQUE2QnBQLFFBQTdCLEVBQXVDO0FBQ25DLFFBQU07QUFBRS9MLFFBQUksRUFBRW9iLFNBQVI7QUFBbUJ4UCxTQUFuQjtBQUEwQmxELFNBQTFCO0FBQWlDMlMsYUFBakM7QUFBNEM3TixTQUE1QztBQUFtRG9LLGdCQUFZLEVBQUUsQ0FBQ0EsWUFBRCxDQUFqRTtBQUFpRjBELFNBQWpGO0FBQXdGQyxTQUF4RjtBQUErRjFHLFFBQS9GO0FBQXFHZCxVQUFyRztBQUE2R0UsZUFBN0c7QUFBMEh1SCxRQUExSDtBQUFnSUMsY0FBaEk7QUFBNEloQixPQUE1STtBQUFpSmlCO0FBQWpKLE1BQWtLM1AsUUFBeEs7QUFDQSxNQUFJM0gsTUFBSjtBQUNBLFFBQU04VixJQUFJLEdBQUdELDJCQUEyQixDQUFDbE8sUUFBRCxDQUF4Qzs7QUFDQSxNQUFLbE8sSUFBTCxFQUE2QztBQUN6Q29kLGlCQUFhLEdBQUcsS0FBaEI7QUFDSDs7QUFDRCxNQUFJO0FBQ0EsUUFBSVUsZ0JBQUo7O0FBQ0EsUUFBSS9QLEtBQUssQ0FBQ2dRLFNBQU4sR0FBa0I7QUFBRTtBQUF4QixNQUFrRDtBQUM5QztBQUNBO0FBQ0EsY0FBTUMsVUFBVSxHQUFHUixTQUFTLElBQUkzUyxLQUFoQztBQUNBdEUsY0FBTSxHQUFHMFgsY0FBYyxDQUFDL0gsTUFBTSxDQUFDcE8sSUFBUCxDQUFZa1csVUFBWixFQUF3QkEsVUFBeEIsRUFBb0M1SCxXQUFwQyxFQUFpRHpHLEtBQWpELEVBQXdEaU8sVUFBeEQsRUFBb0VELElBQXBFLEVBQTBFZixHQUExRSxDQUFELENBQXZCO0FBQ0FrQix3QkFBZ0IsR0FBR0osS0FBbkI7QUFDSCxPQU5ELE1BT0s7QUFDRDtBQUNBLFlBQU14SCxNQUFNLEdBQUdxSCxTQUFmLENBRkMsQ0FHRDs7QUFDQSxVQUFLdmQsS0FBRCxJQUEyQzBkLEtBQUssS0FBSy9OLEtBQXpELEVBQWdFO0FBQzVEME4seUJBQWlCO0FBQ3BCOztBQUNEOVcsWUFBTSxHQUFHMFgsY0FBYyxDQUFDL0gsTUFBTSxDQUFDNVUsTUFBUCxHQUFnQixDQUFoQixHQUNsQjRVLE1BQU0sQ0FBQ3ZHLEtBQUQsRUFBUzNQLEtBQUQsR0FDVjtBQUNFLFlBQUkwZCxLQUFKLEdBQVk7QUFDUkwsMkJBQWlCO0FBQ2pCLGlCQUFPSyxLQUFQO0FBQ0gsU0FKSDs7QUFLRUQsYUFMRjtBQU1Fekc7QUFORixPQURVLEdBU1YsQ0FURSxDQURZLEdBV2xCZCxNQUFNLENBQUN2RyxLQUFELEVBQVE7QUFBSztBQUFiLE9BWFcsQ0FBdkI7QUFZQW1PLHNCQUFnQixHQUFHUCxTQUFTLENBQUM1TixLQUFWLEdBQ2IrTixLQURhLEdBRWJRLHdCQUF3QixDQUFDUixLQUFELENBRjlCO0FBR0gsS0EvQkQsQ0FnQ0E7QUFDQTtBQUNBOzs7QUFDQSxRQUFJUyxJQUFJLEdBQUc1WCxNQUFYO0FBQ0EsUUFBSTZYLE9BQU8sR0FBR3BjLFNBQWQ7O0FBQ0EsUUFBS2hDLEtBQUQsSUFDQXVHLE1BQU0sQ0FBQzhYLFNBQVAsR0FBbUIsQ0FEbkIsSUFFQTlYLE1BQU0sQ0FBQzhYLFNBQVAsR0FBbUI7QUFBSztBQUY1QixNQUVxRDtBQUNqRDtBQUNBLFNBQUNGLElBQUQsRUFBT0MsT0FBUCxJQUFrQkUsWUFBWSxDQUFDL1gsTUFBRCxDQUE5QjtBQUNIOztBQUNELFFBQUl1WCxnQkFBZ0IsSUFBSUQsWUFBWSxLQUFLLEtBQXpDLEVBQWdEO0FBQzVDLFlBQU1oTyxJQUFJLEdBQUcvTCxNQUFNLENBQUMrTCxJQUFQLENBQVlpTyxnQkFBWixDQUFiO0FBQ0EsWUFBTTtBQUFFQztBQUFGLFVBQWdCSSxJQUF0Qjs7QUFDQSxVQUFJdE8sSUFBSSxDQUFDdk8sTUFBVCxFQUFpQjtBQUNiLFlBQUl5YyxTQUFTLEdBQUc7QUFBRTtBQUFkLFdBQ0FBLFNBQVMsR0FBRztBQUFFO0FBRGxCLFVBQ21DO0FBQy9CLGdCQUFJaEUsWUFBWSxJQUFJbEssSUFBSSxDQUFDME8sSUFBTCxDQUFVcEUsd0RBQVYsQ0FBcEIsRUFBZ0Q7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTJELDhCQUFnQixHQUFHVSxvQkFBb0IsQ0FBQ1YsZ0JBQUQsRUFBbUIvRCxZQUFuQixDQUF2QztBQUNIOztBQUNEb0UsZ0JBQUksR0FBR00sVUFBVSxDQUFDTixJQUFELEVBQU9MLGdCQUFQLENBQWpCO0FBQ0gsV0FWRCxNQVdLLElBQUs5ZCxLQUFELElBQTJDLENBQUNvZCxhQUE1QyxJQUE2RGUsSUFBSSxDQUFDaGMsSUFBTCxLQUFjaVYsU0FBL0UsRUFBMEY7QUFDM0YsZ0JBQU1zSCxRQUFRLEdBQUc1YSxNQUFNLENBQUMrTCxJQUFQLENBQVk2TixLQUFaLENBQWpCO0FBQ0EsZ0JBQU1pQixVQUFVLEdBQUcsRUFBbkI7QUFDQSxnQkFBTUMsVUFBVSxHQUFHLEVBQW5COztBQUNBLGVBQUssSUFBSWxkLENBQUMsR0FBRyxDQUFSLEVBQVdzRCxDQUFDLEdBQUcwWixRQUFRLENBQUNwZCxNQUE3QixFQUFxQ0ksQ0FBQyxHQUFHc0QsQ0FBekMsRUFBNEN0RCxDQUFDLEVBQTdDLEVBQWlEO0FBQzdDLGtCQUFNVSxHQUFHLEdBQUdzYyxRQUFRLENBQUNoZCxDQUFELENBQXBCOztBQUNBLGdCQUFJc2EsaURBQUksQ0FBQzVaLEdBQUQsQ0FBUixFQUFlO0FBQ1g7QUFDQSxrQkFBSSxDQUFDK1gsNERBQWUsQ0FBQy9YLEdBQUQsQ0FBcEIsRUFBMkI7QUFDdkI7QUFDQTtBQUNBdWMsMEJBQVUsQ0FBQ3hkLElBQVgsQ0FBZ0JpQixHQUFHLENBQUMsQ0FBRCxDQUFILENBQU91WSxXQUFQLEtBQXVCdlksR0FBRyxDQUFDME4sS0FBSixDQUFVLENBQVYsQ0FBdkM7QUFDSDtBQUNKLGFBUEQsTUFRSztBQUNEOE8sd0JBQVUsQ0FBQ3pkLElBQVgsQ0FBZ0JpQixHQUFoQjtBQUNIO0FBQ0o7O0FBQ0QsY0FBSXdjLFVBQVUsQ0FBQ3RkLE1BQWYsRUFBdUI7QUFDbkJ3RixnQkFBSSxDQUFFLG1DQUFELEdBQ0EsR0FBRThYLFVBQVUsQ0FBQ2pRLElBQVgsQ0FBZ0IsSUFBaEIsQ0FBc0IsSUFEeEIsR0FFQSxvRUFGQSxHQUdBLHdEQUhELENBQUo7QUFJSDs7QUFDRCxjQUFJZ1EsVUFBVSxDQUFDcmQsTUFBZixFQUF1QjtBQUNuQndGLGdCQUFJLENBQUUsd0NBQUQsR0FDQSxHQUFFNlgsVUFBVSxDQUFDaFEsSUFBWCxDQUFnQixJQUFoQixDQUFzQixJQUR4QixHQUVBLG9FQUZBLEdBR0EseURBSEEsR0FJQSw0RUFKQSxHQUtBLHNDQUxELENBQUo7QUFNSDtBQUNKO0FBQ0o7QUFDSjs7QUFDRCxRQUFJLEtBQUosRUFJNkMsRUFqRzdDLENBa0dBOztBQUNBLFFBQUlaLEtBQUssQ0FBQzhRLElBQVYsRUFBZ0I7QUFDWixVQUFLN2UsS0FBRCxJQUEyQyxDQUFDOGUsYUFBYSxDQUFDWCxJQUFELENBQTdELEVBQXFFO0FBQ2pFclgsWUFBSSxDQUFFLGtFQUFELEdBQ0EsK0NBREQsQ0FBSjtBQUVIOztBQUNEcVgsVUFBSSxDQUFDVSxJQUFMLEdBQVlWLElBQUksQ0FBQ1UsSUFBTCxHQUFZVixJQUFJLENBQUNVLElBQUwsQ0FBVUUsTUFBVixDQUFpQmhSLEtBQUssQ0FBQzhRLElBQXZCLENBQVosR0FBMkM5USxLQUFLLENBQUM4USxJQUE3RDtBQUNILEtBekdELENBMEdBOzs7QUFDQSxRQUFJOVEsS0FBSyxDQUFDaVIsVUFBVixFQUFzQjtBQUNsQixVQUFLaGYsS0FBRCxJQUEyQyxDQUFDOGUsYUFBYSxDQUFDWCxJQUFELENBQTdELEVBQXFFO0FBQ2pFclgsWUFBSSxDQUFFLDhEQUFELEdBQ0EsMEJBREQsQ0FBSjtBQUVIOztBQUNEcVgsVUFBSSxDQUFDYSxVQUFMLEdBQWtCalIsS0FBSyxDQUFDaVIsVUFBeEI7QUFDSDs7QUFDRCxRQUFLaGYsS0FBRCxJQUEyQ29lLE9BQS9DLEVBQXdEO0FBQ3BEQSxhQUFPLENBQUNELElBQUQsQ0FBUDtBQUNILEtBRkQsTUFHSztBQUNENVgsWUFBTSxHQUFHNFgsSUFBVDtBQUNIO0FBQ0osR0F4SEQsQ0F5SEEsT0FBTzdOLEdBQVAsRUFBWTtBQUNSMk8sY0FBVSxDQUFDM2QsTUFBWCxHQUFvQixDQUFwQjtBQUNBaVAsZUFBVyxDQUFDRCxHQUFELEVBQU1wQyxRQUFOLEVBQWdCO0FBQUU7QUFBbEIsS0FBWDtBQUNBM0gsVUFBTSxHQUFHMlksV0FBVyxDQUFDOUgsU0FBRCxDQUFwQjtBQUNIOztBQUNEZ0YsNkJBQTJCLENBQUNDLElBQUQsQ0FBM0I7QUFDQSxTQUFPOVYsTUFBUDtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNK1gsWUFBWSxHQUFJdlEsS0FBRCxJQUFXO0FBQzVCLFFBQU1vUixXQUFXLEdBQUdwUixLQUFLLENBQUNxUixRQUExQjtBQUNBLFFBQU1DLGVBQWUsR0FBR3RSLEtBQUssQ0FBQ3NSLGVBQTlCO0FBQ0EsUUFBTUMsU0FBUyxHQUFHQyxnQkFBZ0IsQ0FBQ0osV0FBRCxDQUFsQzs7QUFDQSxNQUFJLENBQUNHLFNBQUwsRUFBZ0I7QUFDWixXQUFPLENBQUN2UixLQUFELEVBQVEvTCxTQUFSLENBQVA7QUFDSDs7QUFDRCxRQUFNK1IsS0FBSyxHQUFHb0wsV0FBVyxDQUFDekwsT0FBWixDQUFvQjRMLFNBQXBCLENBQWQ7QUFDQSxRQUFNRSxZQUFZLEdBQUdILGVBQWUsR0FBR0EsZUFBZSxDQUFDM0wsT0FBaEIsQ0FBd0I0TCxTQUF4QixDQUFILEdBQXdDLENBQUMsQ0FBN0U7O0FBQ0EsUUFBTWxCLE9BQU8sR0FBSXFCLFdBQUQsSUFBaUI7QUFDN0JOLGVBQVcsQ0FBQ3BMLEtBQUQsQ0FBWCxHQUFxQjBMLFdBQXJCOztBQUNBLFFBQUlKLGVBQUosRUFBcUI7QUFDakIsVUFBSUcsWUFBWSxHQUFHLENBQUMsQ0FBcEIsRUFBdUI7QUFDbkJILHVCQUFlLENBQUNHLFlBQUQsQ0FBZixHQUFnQ0MsV0FBaEM7QUFDSCxPQUZELE1BR0ssSUFBSUEsV0FBVyxDQUFDcEIsU0FBWixHQUF3QixDQUE1QixFQUErQjtBQUNoQ3RRLGFBQUssQ0FBQ3NSLGVBQU4sR0FBd0IsQ0FBQyxHQUFHQSxlQUFKLEVBQXFCSSxXQUFyQixDQUF4QjtBQUNIO0FBQ0o7QUFDSixHQVZEOztBQVdBLFNBQU8sQ0FBQ3hCLGNBQWMsQ0FBQ3FCLFNBQUQsQ0FBZixFQUE0QmxCLE9BQTVCLENBQVA7QUFDSCxDQXJCRDs7QUFzQkEsU0FBU21CLGdCQUFULENBQTBCSCxRQUExQixFQUFvQztBQUNoQyxNQUFJTSxVQUFKOztBQUNBLE9BQUssSUFBSWhlLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcwZCxRQUFRLENBQUM5ZCxNQUE3QixFQUFxQ0ksQ0FBQyxFQUF0QyxFQUEwQztBQUN0QyxVQUFNaWUsS0FBSyxHQUFHUCxRQUFRLENBQUMxZCxDQUFELENBQXRCOztBQUNBLFFBQUlrZSxPQUFPLENBQUNELEtBQUQsQ0FBWCxFQUFvQjtBQUNoQjtBQUNBLFVBQUlBLEtBQUssQ0FBQ3hkLElBQU4sS0FBZWlWLFNBQWYsSUFBNEJ1SSxLQUFLLENBQUNQLFFBQU4sS0FBbUIsTUFBbkQsRUFBMkQ7QUFDdkQsWUFBSU0sVUFBSixFQUFnQjtBQUNaO0FBQ0E7QUFDSCxTQUhELE1BSUs7QUFDREEsb0JBQVUsR0FBR0MsS0FBYjtBQUNIO0FBQ0o7QUFDSixLQVhELE1BWUs7QUFDRDtBQUNIO0FBQ0o7O0FBQ0QsU0FBT0QsVUFBUDtBQUNIOztBQUNELE1BQU14Qix3QkFBd0IsR0FBSVIsS0FBRCxJQUFXO0FBQ3hDLE1BQUl6WSxHQUFKOztBQUNBLE9BQUssTUFBTTdDLEdBQVgsSUFBa0JzYixLQUFsQixFQUF5QjtBQUNyQixRQUFJdGIsR0FBRyxLQUFLLE9BQVIsSUFBbUJBLEdBQUcsS0FBSyxPQUEzQixJQUFzQzRaLGlEQUFJLENBQUM1WixHQUFELENBQTlDLEVBQXFEO0FBQ2pELE9BQUM2QyxHQUFHLEtBQUtBLEdBQUcsR0FBRyxFQUFYLENBQUosRUFBb0I3QyxHQUFwQixJQUEyQnNiLEtBQUssQ0FBQ3RiLEdBQUQsQ0FBaEM7QUFDSDtBQUNKOztBQUNELFNBQU82QyxHQUFQO0FBQ0gsQ0FSRDs7QUFTQSxNQUFNdVosb0JBQW9CLEdBQUcsQ0FBQ2QsS0FBRCxFQUFRL04sS0FBUixLQUFrQjtBQUMzQyxRQUFNMUssR0FBRyxHQUFHLEVBQVo7O0FBQ0EsT0FBSyxNQUFNN0MsR0FBWCxJQUFrQnNiLEtBQWxCLEVBQXlCO0FBQ3JCLFFBQUksQ0FBQ3ZELDREQUFlLENBQUMvWCxHQUFELENBQWhCLElBQXlCLEVBQUVBLEdBQUcsQ0FBQzBOLEtBQUosQ0FBVSxDQUFWLEtBQWdCSCxLQUFsQixDQUE3QixFQUF1RDtBQUNuRDFLLFNBQUcsQ0FBQzdDLEdBQUQsQ0FBSCxHQUFXc2IsS0FBSyxDQUFDdGIsR0FBRCxDQUFoQjtBQUNIO0FBQ0o7O0FBQ0QsU0FBTzZDLEdBQVA7QUFDSCxDQVJEOztBQVNBLE1BQU02WixhQUFhLEdBQUkvUSxLQUFELElBQVc7QUFDN0IsU0FBUUEsS0FBSyxDQUFDZ1EsU0FBTixHQUFrQjtBQUFFO0FBQXBCLEtBQ0poUSxLQUFLLENBQUNnUSxTQUFOLEdBQWtCO0FBQUU7QUFEaEIsS0FFSmhRLEtBQUssQ0FBQzVMLElBQU4sS0FBZWlWLFNBRm5CLENBRTZCO0FBRjdCO0FBSUgsQ0FMRDs7QUFNQSxTQUFTeUkscUJBQVQsQ0FBK0JDLFNBQS9CLEVBQTBDQyxTQUExQyxFQUFxREMsU0FBckQsRUFBZ0U7QUFDNUQsUUFBTTtBQUFFclEsU0FBSyxFQUFFc1EsU0FBVDtBQUFvQmIsWUFBUSxFQUFFYyxZQUE5QjtBQUE0Qy9SO0FBQTVDLE1BQTBEMlIsU0FBaEU7QUFDQSxRQUFNO0FBQUVuUSxTQUFLLEVBQUV3USxTQUFUO0FBQW9CZixZQUFRLEVBQUVnQixZQUE5QjtBQUE0Qy9CO0FBQTVDLE1BQTBEMEIsU0FBaEU7QUFDQSxRQUFNeEUsS0FBSyxHQUFHcE4sU0FBUyxDQUFDMkwsWUFBeEIsQ0FINEQsQ0FJNUQ7QUFDQTtBQUNBOztBQUNBLE1BQUs5WixLQUFELEtBQTRDa2dCLFlBQVksSUFBSUUsWUFBNUQsS0FBNkVwTCxhQUFqRixFQUFnRztBQUM1RixXQUFPLElBQVA7QUFDSCxHQVQyRCxDQVU1RDs7O0FBQ0EsTUFBSStLLFNBQVMsQ0FBQ2xCLElBQVYsSUFBa0JrQixTQUFTLENBQUNmLFVBQWhDLEVBQTRDO0FBQ3hDLFdBQU8sSUFBUDtBQUNIOztBQUNELE1BQUlnQixTQUFTLElBQUkzQixTQUFTLElBQUksQ0FBOUIsRUFBaUM7QUFDN0IsUUFBSUEsU0FBUyxHQUFHO0FBQUs7QUFBckIsTUFBMEM7QUFDdEM7QUFDQTtBQUNBLGVBQU8sSUFBUDtBQUNIOztBQUNELFFBQUlBLFNBQVMsR0FBRztBQUFHO0FBQW5CLE1BQXFDO0FBQ2pDLFlBQUksQ0FBQzRCLFNBQUwsRUFBZ0I7QUFDWixpQkFBTyxDQUFDLENBQUNFLFNBQVQ7QUFDSCxTQUhnQyxDQUlqQzs7O0FBQ0EsZUFBT0UsZUFBZSxDQUFDSixTQUFELEVBQVlFLFNBQVosRUFBdUI1RSxLQUF2QixDQUF0QjtBQUNILE9BTkQsTUFPSyxJQUFJOEMsU0FBUyxHQUFHO0FBQUU7QUFBbEIsTUFBK0I7QUFDaEMsY0FBTWlDLFlBQVksR0FBR1AsU0FBUyxDQUFDTyxZQUEvQjs7QUFDQSxhQUFLLElBQUk1ZSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNGUsWUFBWSxDQUFDaGYsTUFBakMsRUFBeUNJLENBQUMsRUFBMUMsRUFBOEM7QUFDMUMsZ0JBQU1VLEdBQUcsR0FBR2tlLFlBQVksQ0FBQzVlLENBQUQsQ0FBeEI7O0FBQ0EsY0FBSXllLFNBQVMsQ0FBQy9kLEdBQUQsQ0FBVCxLQUFtQjZkLFNBQVMsQ0FBQzdkLEdBQUQsQ0FBNUIsSUFDQSxDQUFDMlosY0FBYyxDQUFDUixLQUFELEVBQVFuWixHQUFSLENBRG5CLEVBQ2lDO0FBQzdCLG1CQUFPLElBQVA7QUFDSDtBQUNKO0FBQ0o7QUFDSixHQXZCRCxNQXdCSztBQUNEO0FBQ0E7QUFDQSxRQUFJOGQsWUFBWSxJQUFJRSxZQUFwQixFQUFrQztBQUM5QixVQUFJLENBQUNBLFlBQUQsSUFBaUIsQ0FBQ0EsWUFBWSxDQUFDRyxPQUFuQyxFQUE0QztBQUN4QyxlQUFPLElBQVA7QUFDSDtBQUNKOztBQUNELFFBQUlOLFNBQVMsS0FBS0UsU0FBbEIsRUFBNkI7QUFDekIsYUFBTyxLQUFQO0FBQ0g7O0FBQ0QsUUFBSSxDQUFDRixTQUFMLEVBQWdCO0FBQ1osYUFBTyxDQUFDLENBQUNFLFNBQVQ7QUFDSDs7QUFDRCxRQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFDWixhQUFPLElBQVA7QUFDSDs7QUFDRCxXQUFPRSxlQUFlLENBQUNKLFNBQUQsRUFBWUUsU0FBWixFQUF1QjVFLEtBQXZCLENBQXRCO0FBQ0g7O0FBQ0QsU0FBTyxLQUFQO0FBQ0g7O0FBQ0QsU0FBUzhFLGVBQVQsQ0FBeUJKLFNBQXpCLEVBQW9DRSxTQUFwQyxFQUErQ3JHLFlBQS9DLEVBQTZEO0FBQ3pELFFBQU0wRyxRQUFRLEdBQUcxYyxNQUFNLENBQUMrTCxJQUFQLENBQVlzUSxTQUFaLENBQWpCOztBQUNBLE1BQUlLLFFBQVEsQ0FBQ2xmLE1BQVQsS0FBb0J3QyxNQUFNLENBQUMrTCxJQUFQLENBQVlvUSxTQUFaLEVBQXVCM2UsTUFBL0MsRUFBdUQ7QUFDbkQsV0FBTyxJQUFQO0FBQ0g7O0FBQ0QsT0FBSyxJQUFJSSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHOGUsUUFBUSxDQUFDbGYsTUFBN0IsRUFBcUNJLENBQUMsRUFBdEMsRUFBMEM7QUFDdEMsVUFBTVUsR0FBRyxHQUFHb2UsUUFBUSxDQUFDOWUsQ0FBRCxDQUFwQjs7QUFDQSxRQUFJeWUsU0FBUyxDQUFDL2QsR0FBRCxDQUFULEtBQW1CNmQsU0FBUyxDQUFDN2QsR0FBRCxDQUE1QixJQUNBLENBQUMyWixjQUFjLENBQUNqQyxZQUFELEVBQWUxWCxHQUFmLENBRG5CLEVBQ3dDO0FBQ3BDLGFBQU8sSUFBUDtBQUNIO0FBQ0o7O0FBQ0QsU0FBTyxLQUFQO0FBQ0g7O0FBQ0QsU0FBU3FlLGVBQVQsQ0FBeUI7QUFBRTFTLE9BQUY7QUFBU29CO0FBQVQsQ0FBekIsRUFBNEN1UixFQUE1QyxDQUErQztBQUEvQyxFQUNFO0FBQ0UsU0FBT3ZSLE1BQU0sSUFBSUEsTUFBTSxDQUFDd1IsT0FBUCxLQUFtQjVTLEtBQXBDLEVBQTJDO0FBQ3ZDLEtBQUNBLEtBQUssR0FBR29CLE1BQU0sQ0FBQ3BCLEtBQWhCLEVBQXVCMlMsRUFBdkIsR0FBNEJBLEVBQTVCO0FBQ0F2UixVQUFNLEdBQUdBLE1BQU0sQ0FBQ0EsTUFBaEI7QUFDSDtBQUNKOztBQUVELE1BQU15UixVQUFVLEdBQUl6ZSxJQUFELElBQVVBLElBQUksQ0FBQzBlLFlBQWxDLEMsQ0FDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1DLFlBQVksR0FBRztBQUNqQjFRLE1BQUksRUFBRSxVQURXO0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0F5USxjQUFZLEVBQUUsSUFORzs7QUFPakI3Z0IsU0FBTyxDQUFDK2dCLEVBQUQsRUFBS0MsRUFBTCxFQUFTQyxTQUFULEVBQW9CQyxNQUFwQixFQUE0QkMsZUFBNUIsRUFBNkNDLGNBQTdDLEVBQTZEQyxLQUE3RCxFQUFvRUMsWUFBcEUsRUFBa0Z0QixTQUFsRixFQUNQO0FBQ0F1QixtQkFGTyxFQUVZO0FBQ2YsUUFBSVIsRUFBRSxJQUFJLElBQVYsRUFBZ0I7QUFDWlMsbUJBQWEsQ0FBQ1IsRUFBRCxFQUFLQyxTQUFMLEVBQWdCQyxNQUFoQixFQUF3QkMsZUFBeEIsRUFBeUNDLGNBQXpDLEVBQXlEQyxLQUF6RCxFQUFnRUMsWUFBaEUsRUFBOEV0QixTQUE5RSxFQUF5RnVCLGlCQUF6RixDQUFiO0FBQ0gsS0FGRCxNQUdLO0FBQ0RFLG1CQUFhLENBQUNWLEVBQUQsRUFBS0MsRUFBTCxFQUFTQyxTQUFULEVBQW9CQyxNQUFwQixFQUE0QkMsZUFBNUIsRUFBNkNFLEtBQTdDLEVBQW9EQyxZQUFwRCxFQUFrRXRCLFNBQWxFLEVBQTZFdUIsaUJBQTdFLENBQWI7QUFDSDtBQUNKLEdBaEJnQjs7QUFpQmpCRyxTQUFPLEVBQUVDLGVBakJRO0FBa0JqQi9JLFFBQU0sRUFBRWdKLHNCQWxCUztBQW1CakJDLFdBQVMsRUFBRUM7QUFuQk0sQ0FBckIsQyxDQXFCQTs7QUFDQSxNQUFNQyxRQUFRLEdBQUlqQixZQUFsQjs7QUFFQSxTQUFTa0IsWUFBVCxDQUFzQmpVLEtBQXRCLEVBQTZCcUMsSUFBN0IsRUFBbUM7QUFDL0IsUUFBTTZSLGFBQWEsR0FBR2xVLEtBQUssQ0FBQzRCLEtBQU4sSUFBZTVCLEtBQUssQ0FBQzRCLEtBQU4sQ0FBWVMsSUFBWixDQUFyQzs7QUFDQSxNQUFJRCx1REFBWSxDQUFDOFIsYUFBRCxDQUFoQixFQUFpQztBQUM3QkEsaUJBQWE7QUFDaEI7QUFDSjs7QUFDRCxTQUFTVCxhQUFULENBQXVCelQsS0FBdkIsRUFBOEJrVCxTQUE5QixFQUF5Q0MsTUFBekMsRUFBaURDLGVBQWpELEVBQWtFQyxjQUFsRSxFQUFrRkMsS0FBbEYsRUFBeUZDLFlBQXpGLEVBQXVHdEIsU0FBdkcsRUFBa0h1QixpQkFBbEgsRUFBcUk7QUFDakksUUFBTTtBQUFFOU8sS0FBQyxFQUFFeVAsS0FBTDtBQUFZQyxLQUFDLEVBQUU7QUFBRUM7QUFBRjtBQUFmLE1BQXFDYixpQkFBM0M7QUFDQSxRQUFNYyxlQUFlLEdBQUdELGFBQWEsQ0FBQyxLQUFELENBQXJDO0FBQ0EsUUFBTUUsUUFBUSxHQUFJdlUsS0FBSyxDQUFDdVUsUUFBTixHQUFpQlYsc0JBQXNCLENBQUM3VCxLQUFELEVBQVFxVCxjQUFSLEVBQXdCRCxlQUF4QixFQUF5Q0YsU0FBekMsRUFBb0RvQixlQUFwRCxFQUFxRW5CLE1BQXJFLEVBQTZFRyxLQUE3RSxFQUFvRkMsWUFBcEYsRUFBa0d0QixTQUFsRyxFQUE2R3VCLGlCQUE3RyxDQUF6RCxDQUhpSSxDQUlqSTs7QUFDQVcsT0FBSyxDQUFDLElBQUQsRUFBUUksUUFBUSxDQUFDQyxhQUFULEdBQXlCeFUsS0FBSyxDQUFDeVUsU0FBdkMsRUFBbURILGVBQW5ELEVBQW9FLElBQXBFLEVBQTBFbEIsZUFBMUUsRUFBMkZtQixRQUEzRixFQUFxR2pCLEtBQXJHLEVBQTRHQyxZQUE1RyxDQUFMLENBTGlJLENBTWpJOztBQUNBLE1BQUlnQixRQUFRLENBQUM3Z0IsSUFBVCxHQUFnQixDQUFwQixFQUF1QjtBQUNuQjtBQUNBO0FBQ0F1Z0IsZ0JBQVksQ0FBQ2pVLEtBQUQsRUFBUSxXQUFSLENBQVo7QUFDQWlVLGdCQUFZLENBQUNqVSxLQUFELEVBQVEsWUFBUixDQUFaLENBSm1CLENBS25COztBQUNBbVUsU0FBSyxDQUFDLElBQUQsRUFBT25VLEtBQUssQ0FBQzBVLFVBQWIsRUFBeUJ4QixTQUF6QixFQUFvQ0MsTUFBcEMsRUFBNENDLGVBQTVDLEVBQTZELElBQTdELEVBQW1FO0FBQ3hFRSxTQURLLEVBQ0VDLFlBREYsQ0FBTDtBQUVBb0IsbUJBQWUsQ0FBQ0osUUFBRCxFQUFXdlUsS0FBSyxDQUFDMFUsVUFBakIsQ0FBZjtBQUNILEdBVEQsTUFVSztBQUNEO0FBQ0FILFlBQVEsQ0FBQ2xRLE9BQVQ7QUFDSDtBQUNKOztBQUNELFNBQVNxUCxhQUFULENBQXVCVixFQUF2QixFQUEyQkMsRUFBM0IsRUFBK0JDLFNBQS9CLEVBQTBDQyxNQUExQyxFQUFrREMsZUFBbEQsRUFBbUVFLEtBQW5FLEVBQTBFQyxZQUExRSxFQUF3RnRCLFNBQXhGLEVBQW1HO0FBQUV2TixHQUFDLEVBQUV5UCxLQUFMO0FBQVlTLElBQUUsRUFBRUMsT0FBaEI7QUFBeUJULEdBQUMsRUFBRTtBQUFFQztBQUFGO0FBQTVCLENBQW5HLEVBQW9KO0FBQ2hKLFFBQU1FLFFBQVEsR0FBSXRCLEVBQUUsQ0FBQ3NCLFFBQUgsR0FBY3ZCLEVBQUUsQ0FBQ3VCLFFBQW5DO0FBQ0FBLFVBQVEsQ0FBQ3ZVLEtBQVQsR0FBaUJpVCxFQUFqQjtBQUNBQSxJQUFFLENBQUNOLEVBQUgsR0FBUUssRUFBRSxDQUFDTCxFQUFYO0FBQ0EsUUFBTW1DLFNBQVMsR0FBRzdCLEVBQUUsQ0FBQ3dCLFNBQXJCO0FBQ0EsUUFBTU0sV0FBVyxHQUFHOUIsRUFBRSxDQUFDeUIsVUFBdkI7QUFDQSxRQUFNO0FBQUVNLGdCQUFGO0FBQWdCUixpQkFBaEI7QUFBK0JTLGdCQUEvQjtBQUE2Q0M7QUFBN0MsTUFBNkRYLFFBQW5FOztBQUNBLE1BQUlDLGFBQUosRUFBbUI7QUFDZkQsWUFBUSxDQUFDQyxhQUFULEdBQXlCTSxTQUF6Qjs7QUFDQSxRQUFJSyxlQUFlLENBQUNMLFNBQUQsRUFBWU4sYUFBWixDQUFuQixFQUErQztBQUMzQztBQUNBTCxXQUFLLENBQUNLLGFBQUQsRUFBZ0JNLFNBQWhCLEVBQTJCUCxRQUFRLENBQUNELGVBQXBDLEVBQXFELElBQXJELEVBQTJEbEIsZUFBM0QsRUFBNEVtQixRQUE1RSxFQUFzRmpCLEtBQXRGLEVBQTZGQyxZQUE3RixFQUEyR3RCLFNBQTNHLENBQUw7O0FBQ0EsVUFBSXNDLFFBQVEsQ0FBQzdnQixJQUFULElBQWlCLENBQXJCLEVBQXdCO0FBQ3BCNmdCLGdCQUFRLENBQUNsUSxPQUFUO0FBQ0gsT0FGRCxNQUdLLElBQUk0USxZQUFKLEVBQWtCO0FBQ25CZCxhQUFLLENBQUNhLFlBQUQsRUFBZUQsV0FBZixFQUE0QjdCLFNBQTVCLEVBQXVDQyxNQUF2QyxFQUErQ0MsZUFBL0MsRUFBZ0UsSUFBaEUsRUFBc0U7QUFDM0VFLGFBREssRUFDRUMsWUFERixFQUNnQnRCLFNBRGhCLENBQUw7QUFFQTBDLHVCQUFlLENBQUNKLFFBQUQsRUFBV1EsV0FBWCxDQUFmO0FBQ0g7QUFDSixLQVhELE1BWUs7QUFDRDtBQUNBUixjQUFRLENBQUNhLFNBQVQ7O0FBQ0EsVUFBSUYsV0FBSixFQUFpQjtBQUNiO0FBQ0E7QUFDQTtBQUNBWCxnQkFBUSxDQUFDVyxXQUFULEdBQXVCLEtBQXZCO0FBQ0FYLGdCQUFRLENBQUNTLFlBQVQsR0FBd0JSLGFBQXhCO0FBQ0gsT0FORCxNQU9LO0FBQ0RLLGVBQU8sQ0FBQ0wsYUFBRCxFQUFnQnBCLGVBQWhCLEVBQWlDbUIsUUFBakMsQ0FBUDtBQUNILE9BWkEsQ0FhRDtBQUNBOzs7QUFDQUEsY0FBUSxDQUFDN2dCLElBQVQsR0FBZ0IsQ0FBaEIsQ0FmQyxDQWdCRDs7QUFDQTZnQixjQUFRLENBQUNwZixPQUFULENBQWlCNUIsTUFBakIsR0FBMEIsQ0FBMUIsQ0FqQkMsQ0FrQkQ7O0FBQ0FnaEIsY0FBUSxDQUFDRCxlQUFULEdBQTJCRCxhQUFhLENBQUMsS0FBRCxDQUF4Qzs7QUFDQSxVQUFJWSxZQUFKLEVBQWtCO0FBQ2Q7QUFDQWQsYUFBSyxDQUFDLElBQUQsRUFBT1csU0FBUCxFQUFrQlAsUUFBUSxDQUFDRCxlQUEzQixFQUE0QyxJQUE1QyxFQUFrRGxCLGVBQWxELEVBQW1FbUIsUUFBbkUsRUFBNkVqQixLQUE3RSxFQUFvRkMsWUFBcEYsRUFBa0d0QixTQUFsRyxDQUFMOztBQUNBLFlBQUlzQyxRQUFRLENBQUM3Z0IsSUFBVCxJQUFpQixDQUFyQixFQUF3QjtBQUNwQjZnQixrQkFBUSxDQUFDbFEsT0FBVDtBQUNILFNBRkQsTUFHSztBQUNEOFAsZUFBSyxDQUFDYSxZQUFELEVBQWVELFdBQWYsRUFBNEI3QixTQUE1QixFQUF1Q0MsTUFBdkMsRUFBK0NDLGVBQS9DLEVBQWdFLElBQWhFLEVBQXNFO0FBQzNFRSxlQURLLEVBQ0VDLFlBREYsRUFDZ0J0QixTQURoQixDQUFMO0FBRUEwQyx5QkFBZSxDQUFDSixRQUFELEVBQVdRLFdBQVgsQ0FBZjtBQUNIO0FBQ0osT0FYRCxNQVlLLElBQUlDLFlBQVksSUFBSUcsZUFBZSxDQUFDTCxTQUFELEVBQVlFLFlBQVosQ0FBbkMsRUFBOEQ7QUFDL0Q7QUFDQWIsYUFBSyxDQUFDYSxZQUFELEVBQWVGLFNBQWYsRUFBMEI1QixTQUExQixFQUFxQ0MsTUFBckMsRUFBNkNDLGVBQTdDLEVBQThEbUIsUUFBOUQsRUFBd0VqQixLQUF4RSxFQUErRUMsWUFBL0UsRUFBNkZ0QixTQUE3RixDQUFMLENBRitELENBRy9EOztBQUNBc0MsZ0JBQVEsQ0FBQ2xRLE9BQVQsQ0FBaUIsSUFBakI7QUFDSCxPQUxJLE1BTUE7QUFDRDtBQUNBOFAsYUFBSyxDQUFDLElBQUQsRUFBT1csU0FBUCxFQUFrQlAsUUFBUSxDQUFDRCxlQUEzQixFQUE0QyxJQUE1QyxFQUFrRGxCLGVBQWxELEVBQW1FbUIsUUFBbkUsRUFBNkVqQixLQUE3RSxFQUFvRkMsWUFBcEYsRUFBa0d0QixTQUFsRyxDQUFMOztBQUNBLFlBQUlzQyxRQUFRLENBQUM3Z0IsSUFBVCxJQUFpQixDQUFyQixFQUF3QjtBQUNwQjZnQixrQkFBUSxDQUFDbFEsT0FBVDtBQUNIO0FBQ0o7QUFDSjtBQUNKLEdBNURELE1BNkRLO0FBQ0QsUUFBSTJRLFlBQVksSUFBSUcsZUFBZSxDQUFDTCxTQUFELEVBQVlFLFlBQVosQ0FBbkMsRUFBOEQ7QUFDMUQ7QUFDQWIsV0FBSyxDQUFDYSxZQUFELEVBQWVGLFNBQWYsRUFBMEI1QixTQUExQixFQUFxQ0MsTUFBckMsRUFBNkNDLGVBQTdDLEVBQThEbUIsUUFBOUQsRUFBd0VqQixLQUF4RSxFQUErRUMsWUFBL0UsRUFBNkZ0QixTQUE3RixDQUFMO0FBQ0EwQyxxQkFBZSxDQUFDSixRQUFELEVBQVdPLFNBQVgsQ0FBZjtBQUNILEtBSkQsTUFLSztBQUNEO0FBQ0E7QUFDQWIsa0JBQVksQ0FBQ2hCLEVBQUQsRUFBSyxXQUFMLENBQVosQ0FIQyxDQUlEOztBQUNBc0IsY0FBUSxDQUFDQyxhQUFULEdBQXlCTSxTQUF6QjtBQUNBUCxjQUFRLENBQUNhLFNBQVQ7QUFDQWpCLFdBQUssQ0FBQyxJQUFELEVBQU9XLFNBQVAsRUFBa0JQLFFBQVEsQ0FBQ0QsZUFBM0IsRUFBNEMsSUFBNUMsRUFBa0RsQixlQUFsRCxFQUFtRW1CLFFBQW5FLEVBQTZFakIsS0FBN0UsRUFBb0ZDLFlBQXBGLEVBQWtHdEIsU0FBbEcsQ0FBTDs7QUFDQSxVQUFJc0MsUUFBUSxDQUFDN2dCLElBQVQsSUFBaUIsQ0FBckIsRUFBd0I7QUFDcEI7QUFDQTZnQixnQkFBUSxDQUFDbFEsT0FBVDtBQUNILE9BSEQsTUFJSztBQUNELGNBQU07QUFBRWdSLGlCQUFGO0FBQVdEO0FBQVgsWUFBeUJiLFFBQS9COztBQUNBLFlBQUljLE9BQU8sR0FBRyxDQUFkLEVBQWlCO0FBQ2JDLG9CQUFVLENBQUMsTUFBTTtBQUNiLGdCQUFJZixRQUFRLENBQUNhLFNBQVQsS0FBdUJBLFNBQTNCLEVBQXNDO0FBQ2xDYixzQkFBUSxDQUFDZ0IsUUFBVCxDQUFrQlIsV0FBbEI7QUFDSDtBQUNKLFdBSlMsRUFJUE0sT0FKTyxDQUFWO0FBS0gsU0FORCxNQU9LLElBQUlBLE9BQU8sS0FBSyxDQUFoQixFQUFtQjtBQUNwQmQsa0JBQVEsQ0FBQ2dCLFFBQVQsQ0FBa0JSLFdBQWxCO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDSjs7QUFDRCxJQUFJUyxTQUFTLEdBQUcsS0FBaEI7O0FBQ0EsU0FBUzNCLHNCQUFULENBQWdDN1QsS0FBaEMsRUFBdUNvQixNQUF2QyxFQUErQ2dTLGVBQS9DLEVBQWdFRixTQUFoRSxFQUEyRW9CLGVBQTNFLEVBQTRGbkIsTUFBNUYsRUFBb0dHLEtBQXBHLEVBQTJHQyxZQUEzRyxFQUF5SHRCLFNBQXpILEVBQW9JdUIsaUJBQXBJLEVBQXVKMEIsV0FBVyxHQUFHLEtBQXJLLEVBQTRLO0FBQ3hLO0FBQ0EsTUFBS2pqQixLQUFELElBQXFELENBQUN1akIsU0FBMUQsRUFBcUU7QUFDakVBLGFBQVMsR0FBRyxJQUFaLENBRGlFLENBRWpFOztBQUNBMWMsV0FBTyxDQUFDQSxPQUFPLENBQUN5SyxJQUFSLEdBQWUsTUFBZixHQUF3QixLQUF6QixDQUFQLENBQXdDLHVFQUF4QztBQUNIOztBQUNELFFBQU07QUFBRW1CLEtBQUMsRUFBRXlQLEtBQUw7QUFBWXNCLEtBQUMsRUFBRUMsSUFBZjtBQUFxQmQsTUFBRSxFQUFFQyxPQUF6QjtBQUFrQ2MsS0FBQyxFQUFFemEsSUFBckM7QUFBMkNrWixLQUFDLEVBQUU7QUFBRXdCLGdCQUFGO0FBQWNDO0FBQWQ7QUFBOUMsTUFBeUVyQyxpQkFBL0U7QUFDQSxRQUFNNkIsT0FBTyxHQUFHM0kscURBQVEsQ0FBQzFNLEtBQUssQ0FBQzRCLEtBQU4sSUFBZTVCLEtBQUssQ0FBQzRCLEtBQU4sQ0FBWXlULE9BQTVCLENBQXhCO0FBQ0EsUUFBTWQsUUFBUSxHQUFHO0FBQ2J2VSxTQURhO0FBRWJvQixVQUZhO0FBR2JnUyxtQkFIYTtBQUliRSxTQUphO0FBS2JKLGFBTGE7QUFNYm9CLG1CQU5hO0FBT2JuQixVQVBhO0FBUWJ6ZixRQUFJLEVBQUUsQ0FSTztBQVNiMGhCLGFBQVMsRUFBRSxDQVRFO0FBVWJDLFdBQU8sRUFBRSxPQUFPQSxPQUFQLEtBQW1CLFFBQW5CLEdBQThCQSxPQUE5QixHQUF3QyxDQUFDLENBVnJDO0FBV2JMLGdCQUFZLEVBQUUsSUFYRDtBQVliUixpQkFBYSxFQUFFLElBWkY7QUFhYlMsZ0JBQVksRUFBRSxJQWJEO0FBY2JDLGVBZGE7QUFlYlksZUFBVyxFQUFFLEtBZkE7QUFnQmIzZ0IsV0FBTyxFQUFFLEVBaEJJOztBQWlCYmtQLFdBQU8sQ0FBQzBSLE1BQU0sR0FBRyxLQUFWLEVBQWlCO0FBQ3BCLFVBQUs5akIsSUFBTCxFQUE2QztBQUN6QyxZQUFJLENBQUM4akIsTUFBRCxJQUFXLENBQUN4QixRQUFRLENBQUNDLGFBQXpCLEVBQXdDO0FBQ3BDLGdCQUFNLElBQUl3QixLQUFKLENBQVcsd0RBQVgsQ0FBTjtBQUNIOztBQUNELFlBQUl6QixRQUFRLENBQUN1QixXQUFiLEVBQTBCO0FBQ3RCLGdCQUFNLElBQUlFLEtBQUosQ0FBVyx5RUFBWCxDQUFOO0FBQ0g7QUFDSjs7QUFDRCxZQUFNO0FBQUVoVyxhQUFGO0FBQVNnVixvQkFBVDtBQUF1QlIscUJBQXZCO0FBQXNDWSxpQkFBdEM7QUFBaURqZ0IsZUFBakQ7QUFBMERpZSx1QkFBMUQ7QUFBMkVGO0FBQTNFLFVBQXlGcUIsUUFBL0Y7O0FBQ0EsVUFBSUEsUUFBUSxDQUFDVyxXQUFiLEVBQTBCO0FBQ3RCWCxnQkFBUSxDQUFDVyxXQUFULEdBQXVCLEtBQXZCO0FBQ0gsT0FGRCxNQUdLLElBQUksQ0FBQ2EsTUFBTCxFQUFhO0FBQ2QsY0FBTUUsVUFBVSxHQUFHakIsWUFBWSxJQUMzQlIsYUFBYSxDQUFDdkQsVUFEQyxJQUVmdUQsYUFBYSxDQUFDdkQsVUFBZCxDQUF5QnBGLElBQXpCLEtBQWtDLFFBRnRDOztBQUdBLFlBQUlvSyxVQUFKLEVBQWdCO0FBQ1pqQixzQkFBWSxDQUFDL0QsVUFBYixDQUF3QmlGLFVBQXhCLEdBQXFDLE1BQU07QUFDdkMsZ0JBQUlkLFNBQVMsS0FBS2IsUUFBUSxDQUFDYSxTQUEzQixFQUFzQztBQUNsQ00sa0JBQUksQ0FBQ2xCLGFBQUQsRUFBZ0J0QixTQUFoQixFQUEyQkMsTUFBM0IsRUFBbUM7QUFBRTtBQUFyQyxlQUFKO0FBQ0g7QUFDSixXQUpEO0FBS0gsU0FWYSxDQVdkOzs7QUFDQSxZQUFJO0FBQUVBO0FBQUYsWUFBYW9CLFFBQWpCLENBWmMsQ0FhZDs7QUFDQSxZQUFJUyxZQUFKLEVBQWtCO0FBQ2Q7QUFDQTtBQUNBN0IsZ0JBQU0sR0FBR2pZLElBQUksQ0FBQzhaLFlBQUQsQ0FBYjtBQUNBSCxpQkFBTyxDQUFDRyxZQUFELEVBQWU1QixlQUFmLEVBQWdDbUIsUUFBaEMsRUFBMEMsSUFBMUMsQ0FBUDtBQUNIOztBQUNELFlBQUksQ0FBQzBCLFVBQUwsRUFBaUI7QUFDYjtBQUNBUCxjQUFJLENBQUNsQixhQUFELEVBQWdCdEIsU0FBaEIsRUFBMkJDLE1BQTNCLEVBQW1DO0FBQUU7QUFBckMsV0FBSjtBQUNIO0FBQ0o7O0FBQ0R3QixxQkFBZSxDQUFDSixRQUFELEVBQVdDLGFBQVgsQ0FBZjtBQUNBRCxjQUFRLENBQUNDLGFBQVQsR0FBeUIsSUFBekI7QUFDQUQsY0FBUSxDQUFDVSxZQUFULEdBQXdCLEtBQXhCLENBeENvQixDQXlDcEI7QUFDQTs7QUFDQSxVQUFJN1QsTUFBTSxHQUFHbVQsUUFBUSxDQUFDblQsTUFBdEI7QUFDQSxVQUFJK1UscUJBQXFCLEdBQUcsS0FBNUI7O0FBQ0EsYUFBTy9VLE1BQVAsRUFBZTtBQUNYLFlBQUlBLE1BQU0sQ0FBQ29ULGFBQVgsRUFBMEI7QUFDdEI7QUFDQTtBQUNBcFQsZ0JBQU0sQ0FBQ2pNLE9BQVAsQ0FBZS9CLElBQWYsQ0FBb0IsR0FBRytCLE9BQXZCO0FBQ0FnaEIsK0JBQXFCLEdBQUcsSUFBeEI7QUFDQTtBQUNIOztBQUNEL1UsY0FBTSxHQUFHQSxNQUFNLENBQUNBLE1BQWhCO0FBQ0gsT0F0RG1CLENBdURwQjs7O0FBQ0EsVUFBSSxDQUFDK1UscUJBQUwsRUFBNEI7QUFDeEJqUSx3QkFBZ0IsQ0FBQy9RLE9BQUQsQ0FBaEI7QUFDSDs7QUFDRG9mLGNBQVEsQ0FBQ3BmLE9BQVQsR0FBbUIsRUFBbkIsQ0EzRG9CLENBNERwQjs7QUFDQThlLGtCQUFZLENBQUNqVSxLQUFELEVBQVEsV0FBUixDQUFaO0FBQ0gsS0EvRVk7O0FBZ0ZidVYsWUFBUSxDQUFDYSxhQUFELEVBQWdCO0FBQ3BCLFVBQUksQ0FBQzdCLFFBQVEsQ0FBQ0MsYUFBZCxFQUE2QjtBQUN6QjtBQUNIOztBQUNELFlBQU07QUFBRXhVLGFBQUY7QUFBU2dWLG9CQUFUO0FBQXVCNUIsdUJBQXZCO0FBQXdDRixpQkFBeEM7QUFBbURJO0FBQW5ELFVBQTZEaUIsUUFBbkUsQ0FKb0IsQ0FLcEI7O0FBQ0FOLGtCQUFZLENBQUNqVSxLQUFELEVBQVEsWUFBUixDQUFaO0FBQ0EsWUFBTW1ULE1BQU0sR0FBR2pZLElBQUksQ0FBQzhaLFlBQUQsQ0FBbkI7O0FBQ0EsWUFBTXFCLGFBQWEsR0FBRyxNQUFNO0FBQ3hCLFlBQUksQ0FBQzlCLFFBQVEsQ0FBQ1UsWUFBZCxFQUE0QjtBQUN4QjtBQUNILFNBSHVCLENBSXhCOzs7QUFDQWQsYUFBSyxDQUFDLElBQUQsRUFBT2lDLGFBQVAsRUFBc0JsRCxTQUF0QixFQUFpQ0MsTUFBakMsRUFBeUNDLGVBQXpDLEVBQTBELElBQTFELEVBQWdFO0FBQ3JFRSxhQURLLEVBQ0VDLFlBREYsRUFDZ0J0QixTQURoQixDQUFMO0FBRUEwQyx1QkFBZSxDQUFDSixRQUFELEVBQVc2QixhQUFYLENBQWY7QUFDSCxPQVJEOztBQVNBLFlBQU1ILFVBQVUsR0FBR0csYUFBYSxDQUFDbkYsVUFBZCxJQUE0Qm1GLGFBQWEsQ0FBQ25GLFVBQWQsQ0FBeUJwRixJQUF6QixLQUFrQyxRQUFqRjs7QUFDQSxVQUFJb0ssVUFBSixFQUFnQjtBQUNaakIsb0JBQVksQ0FBQy9ELFVBQWIsQ0FBd0JpRixVQUF4QixHQUFxQ0csYUFBckM7QUFDSDs7QUFDRDlCLGNBQVEsQ0FBQ1UsWUFBVCxHQUF3QixJQUF4QixDQXJCb0IsQ0FzQnBCOztBQUNBSixhQUFPLENBQUNHLFlBQUQsRUFBZTVCLGVBQWYsRUFBZ0MsSUFBaEMsRUFBc0M7QUFDN0MsVUFETyxDQUNGO0FBREUsT0FBUDs7QUFHQSxVQUFJLENBQUM2QyxVQUFMLEVBQWlCO0FBQ2JJLHFCQUFhO0FBQ2hCO0FBQ0osS0E3R1k7O0FBOEdiWCxRQUFJLENBQUN4QyxTQUFELEVBQVlDLE1BQVosRUFBb0IvZSxJQUFwQixFQUEwQjtBQUMxQm1nQixjQUFRLENBQUNTLFlBQVQsSUFDSVUsSUFBSSxDQUFDbkIsUUFBUSxDQUFDUyxZQUFWLEVBQXdCOUIsU0FBeEIsRUFBbUNDLE1BQW5DLEVBQTJDL2UsSUFBM0MsQ0FEUjtBQUVBbWdCLGNBQVEsQ0FBQ3JCLFNBQVQsR0FBcUJBLFNBQXJCO0FBQ0gsS0FsSFk7O0FBbUhiaFksUUFBSSxHQUFHO0FBQ0gsYUFBT3FaLFFBQVEsQ0FBQ1MsWUFBVCxJQUF5QjlaLElBQUksQ0FBQ3FaLFFBQVEsQ0FBQ1MsWUFBVixDQUFwQztBQUNILEtBckhZOztBQXNIYnNCLGVBQVcsQ0FBQ25XLFFBQUQsRUFBV29XLGlCQUFYLEVBQThCO0FBQ3JDLFlBQU1DLG1CQUFtQixHQUFHLENBQUMsQ0FBQ2pDLFFBQVEsQ0FBQ0MsYUFBdkM7O0FBQ0EsVUFBSWdDLG1CQUFKLEVBQXlCO0FBQ3JCakMsZ0JBQVEsQ0FBQzdnQixJQUFUO0FBQ0g7O0FBQ0QsWUFBTStpQixVQUFVLEdBQUd0VyxRQUFRLENBQUNILEtBQVQsQ0FBZTJTLEVBQWxDO0FBQ0F4UyxjQUFRLENBQ0h1VyxRQURMLENBQ2MvVCxLQURkLENBQ29CSixHQUFHLElBQUk7QUFDdkJDLG1CQUFXLENBQUNELEdBQUQsRUFBTXBDLFFBQU4sRUFBZ0I7QUFBRTtBQUFsQixTQUFYO0FBQ0gsT0FIRCxFQUlLd0UsSUFKTCxDQUlVZ1MsZ0JBQWdCLElBQUk7QUFDMUI7QUFDQTtBQUNBLFlBQUl4VyxRQUFRLENBQUMyVixXQUFULElBQ0F2QixRQUFRLENBQUN1QixXQURULElBRUF2QixRQUFRLENBQUNhLFNBQVQsS0FBdUJqVixRQUFRLENBQUN5VyxVQUZwQyxFQUVnRDtBQUM1QztBQUNILFNBUHlCLENBUTFCOzs7QUFDQXpXLGdCQUFRLENBQUMwVyxhQUFULEdBQXlCLElBQXpCO0FBQ0EsY0FBTTtBQUFFN1c7QUFBRixZQUFZRyxRQUFsQjs7QUFDQSxZQUFLbE8sSUFBTCxFQUE2QztBQUN6QzhOLDRCQUFrQixDQUFDQyxLQUFELENBQWxCO0FBQ0g7O0FBQ0Q4Vyx5QkFBaUIsQ0FBQzNXLFFBQUQsRUFBV3dXLGdCQUFYLEVBQTZCLEtBQTdCLENBQWpCOztBQUNBLFlBQUlGLFVBQUosRUFBZ0I7QUFDWjtBQUNBO0FBQ0F6VyxlQUFLLENBQUMyUyxFQUFOLEdBQVc4RCxVQUFYO0FBQ0g7O0FBQ0QsY0FBTU0sV0FBVyxHQUFHLENBQUNOLFVBQUQsSUFBZXRXLFFBQVEsQ0FBQ3lTLE9BQVQsQ0FBaUJELEVBQXBEO0FBQ0E0RCx5QkFBaUIsQ0FBQ3BXLFFBQUQsRUFBV0gsS0FBWCxFQUNqQjtBQUNBO0FBQ0E7QUFDQTRWLGtCQUFVLENBQUNhLFVBQVUsSUFBSXRXLFFBQVEsQ0FBQ3lTLE9BQVQsQ0FBaUJELEVBQWhDLENBSk8sRUFLakI7QUFDQTtBQUNBOEQsa0JBQVUsR0FBRyxJQUFILEdBQVV2YixJQUFJLENBQUNpRixRQUFRLENBQUN5UyxPQUFWLENBUFAsRUFPMkIyQixRQVAzQixFQU9xQ2pCLEtBUHJDLEVBTzRDckIsU0FQNUMsQ0FBakI7O0FBUUEsWUFBSThFLFdBQUosRUFBaUI7QUFDYmxCLGdCQUFNLENBQUNrQixXQUFELENBQU47QUFDSDs7QUFDRHJFLHVCQUFlLENBQUN2UyxRQUFELEVBQVdILEtBQUssQ0FBQzJTLEVBQWpCLENBQWY7O0FBQ0EsWUFBSzFnQixJQUFMLEVBQTZDO0FBQ3pDZ08sMkJBQWlCO0FBQ3BCLFNBbkN5QixDQW9DMUI7OztBQUNBLFlBQUl1VyxtQkFBbUIsSUFBSSxFQUFFakMsUUFBUSxDQUFDN2dCLElBQVgsS0FBb0IsQ0FBL0MsRUFBa0Q7QUFDOUM2Z0Isa0JBQVEsQ0FBQ2xRLE9BQVQ7QUFDSDtBQUNKLE9BNUNEO0FBNkNILEtBektZOztBQTBLYndRLFdBQU8sQ0FBQ3hCLGNBQUQsRUFBaUIyRCxRQUFqQixFQUEyQjtBQUM5QnpDLGNBQVEsQ0FBQ3VCLFdBQVQsR0FBdUIsSUFBdkI7O0FBQ0EsVUFBSXZCLFFBQVEsQ0FBQ1MsWUFBYixFQUEyQjtBQUN2QkgsZUFBTyxDQUFDTixRQUFRLENBQUNTLFlBQVYsRUFBd0I1QixlQUF4QixFQUF5Q0MsY0FBekMsRUFBeUQyRCxRQUF6RCxDQUFQO0FBQ0g7O0FBQ0QsVUFBSXpDLFFBQVEsQ0FBQ0MsYUFBYixFQUE0QjtBQUN4QkssZUFBTyxDQUFDTixRQUFRLENBQUNDLGFBQVYsRUFBeUJwQixlQUF6QixFQUEwQ0MsY0FBMUMsRUFBMEQyRCxRQUExRCxDQUFQO0FBQ0g7QUFDSjs7QUFsTFksR0FBakI7QUFvTEEsU0FBT3pDLFFBQVA7QUFDSDs7QUFDRCxTQUFTWCxlQUFULENBQXlCcUQsSUFBekIsRUFBK0JqWCxLQUEvQixFQUFzQ29ULGVBQXRDLEVBQXVEQyxjQUF2RCxFQUF1RUMsS0FBdkUsRUFBOEVDLFlBQTlFLEVBQTRGdEIsU0FBNUYsRUFBdUd1QixpQkFBdkcsRUFBMEgwRCxXQUExSCxFQUF1STtBQUNuSTtBQUNBLFFBQU0zQyxRQUFRLEdBQUl2VSxLQUFLLENBQUN1VSxRQUFOLEdBQWlCVixzQkFBc0IsQ0FBQzdULEtBQUQsRUFBUXFULGNBQVIsRUFBd0JELGVBQXhCLEVBQXlDNkQsSUFBSSxDQUFDckIsVUFBOUMsRUFBMER1QixRQUFRLENBQUM5QyxhQUFULENBQXVCLEtBQXZCLENBQTFELEVBQXlGLElBQXpGLEVBQStGZixLQUEvRixFQUFzR0MsWUFBdEcsRUFBb0h0QixTQUFwSCxFQUErSHVCLGlCQUEvSCxFQUFrSjtBQUFLO0FBQXZKLEdBQXpELENBRm1JLENBR25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxRQUFNaGIsTUFBTSxHQUFHMGUsV0FBVyxDQUFDRCxJQUFELEVBQVExQyxRQUFRLENBQUNDLGFBQVQsR0FBeUJ4VSxLQUFLLENBQUN5VSxTQUF2QyxFQUFtRHJCLGVBQW5ELEVBQW9FbUIsUUFBcEUsRUFBOEVoQixZQUE5RSxFQUE0RnRCLFNBQTVGLENBQTFCOztBQUNBLE1BQUlzQyxRQUFRLENBQUM3Z0IsSUFBVCxLQUFrQixDQUF0QixFQUF5QjtBQUNyQjZnQixZQUFRLENBQUNsUSxPQUFUO0FBQ0g7O0FBQ0QsU0FBTzdMLE1BQVA7QUFDQTtBQUNIOztBQUNELFNBQVN1Yix5QkFBVCxDQUFtQy9ULEtBQW5DLEVBQTBDO0FBQ3RDLFFBQU07QUFBRWdRLGFBQUY7QUFBYXFCO0FBQWIsTUFBMEJyUixLQUFoQztBQUNBLFFBQU1vWCxjQUFjLEdBQUdwSCxTQUFTLEdBQUc7QUFBRztBQUF0QztBQUNBaFEsT0FBSyxDQUFDeVUsU0FBTixHQUFrQjRDLHFCQUFxQixDQUFDRCxjQUFjLEdBQUcvRixRQUFRLENBQUNpRyxPQUFaLEdBQXNCakcsUUFBckMsQ0FBdkM7QUFDQXJSLE9BQUssQ0FBQzBVLFVBQU4sR0FBbUIwQyxjQUFjLEdBQzNCQyxxQkFBcUIsQ0FBQ2hHLFFBQVEsQ0FBQ2tFLFFBQVYsQ0FETSxHQUUzQnBFLFdBQVcsQ0FBQy9ILE9BQUQsQ0FGakI7QUFHSDs7QUFDRCxTQUFTaU8scUJBQVQsQ0FBK0JFLENBQS9CLEVBQWtDO0FBQzlCLE1BQUlDLEtBQUo7O0FBQ0EsTUFBSXBWLHVEQUFZLENBQUNtVixDQUFELENBQWhCLEVBQXFCO0FBQ2pCLFVBQU1FLGNBQWMsR0FBR0YsQ0FBQyxDQUFDbkksRUFBekI7O0FBQ0EsUUFBSXFJLGNBQUosRUFBb0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0FGLE9BQUMsQ0FBQ3RJLEVBQUYsR0FBTyxLQUFQO0FBQ0F5SSxlQUFTO0FBQ1o7O0FBQ0RILEtBQUMsR0FBR0EsQ0FBQyxFQUFMOztBQUNBLFFBQUlFLGNBQUosRUFBb0I7QUFDaEJGLE9BQUMsQ0FBQ3RJLEVBQUYsR0FBTyxJQUFQO0FBQ0F1SSxXQUFLLEdBQUdHLFlBQVI7QUFDQUMsZ0JBQVU7QUFDYjtBQUNKOztBQUNELE1BQUl0aUIsb0RBQU8sQ0FBQ2lpQixDQUFELENBQVgsRUFBZ0I7QUFDWixVQUFNTSxXQUFXLEdBQUdyRyxnQkFBZ0IsQ0FBQytGLENBQUQsQ0FBcEM7O0FBQ0EsUUFBS3RsQixLQUFELElBQTJDLENBQUM0bEIsV0FBaEQsRUFBNkQ7QUFDekQ5ZSxVQUFJLENBQUUsNkNBQUYsQ0FBSjtBQUNIOztBQUNEd2UsS0FBQyxHQUFHTSxXQUFKO0FBQ0g7O0FBQ0ROLEdBQUMsR0FBR3JILGNBQWMsQ0FBQ3FILENBQUQsQ0FBbEI7O0FBQ0EsTUFBSUMsS0FBSixFQUFXO0FBQ1BELEtBQUMsQ0FBQ2pHLGVBQUYsR0FBb0JrRyxLQUFLLENBQUN0aEIsTUFBTixDQUFhNGhCLENBQUMsSUFBSUEsQ0FBQyxLQUFLUCxDQUF4QixDQUFwQjtBQUNIOztBQUNELFNBQU9BLENBQVA7QUFDSDs7QUFDRCxTQUFTUSx1QkFBVCxDQUFpQzNsQixFQUFqQyxFQUFxQ21pQixRQUFyQyxFQUErQztBQUMzQyxNQUFJQSxRQUFRLElBQUlBLFFBQVEsQ0FBQ0MsYUFBekIsRUFBd0M7QUFDcEMsUUFBSWxmLG9EQUFPLENBQUNsRCxFQUFELENBQVgsRUFBaUI7QUFDYm1pQixjQUFRLENBQUNwZixPQUFULENBQWlCL0IsSUFBakIsQ0FBc0IsR0FBR2hCLEVBQXpCO0FBQ0gsS0FGRCxNQUdLO0FBQ0RtaUIsY0FBUSxDQUFDcGYsT0FBVCxDQUFpQi9CLElBQWpCLENBQXNCaEIsRUFBdEI7QUFDSDtBQUNKLEdBUEQsTUFRSztBQUNEOFQsb0JBQWdCLENBQUM5VCxFQUFELENBQWhCO0FBQ0g7QUFDSjs7QUFDRCxTQUFTdWlCLGVBQVQsQ0FBeUJKLFFBQXpCLEVBQW1DeUQsTUFBbkMsRUFBMkM7QUFDdkN6RCxVQUFRLENBQUNTLFlBQVQsR0FBd0JnRCxNQUF4QjtBQUNBLFFBQU07QUFBRWhZLFNBQUY7QUFBU29UO0FBQVQsTUFBNkJtQixRQUFuQztBQUNBLFFBQU01QixFQUFFLEdBQUkzUyxLQUFLLENBQUMyUyxFQUFOLEdBQVdxRixNQUFNLENBQUNyRixFQUE5QixDQUh1QyxDQUl2QztBQUNBOztBQUNBLE1BQUlTLGVBQWUsSUFBSUEsZUFBZSxDQUFDUixPQUFoQixLQUE0QjVTLEtBQW5ELEVBQTBEO0FBQ3REb1QsbUJBQWUsQ0FBQ3BULEtBQWhCLENBQXNCMlMsRUFBdEIsR0FBMkJBLEVBQTNCO0FBQ0FELG1CQUFlLENBQUNVLGVBQUQsRUFBa0JULEVBQWxCLENBQWY7QUFDSDtBQUNKOztBQUVELFNBQVNzRixPQUFULENBQWlCNWpCLEdBQWpCLEVBQXNCMkQsS0FBdEIsRUFBNkI7QUFDekIsTUFBSSxDQUFDa2dCLGVBQUwsRUFBc0I7QUFDbEIsUUFBS2ptQixJQUFMLEVBQTZDO0FBQ3pDOEcsVUFBSSxDQUFFLDRDQUFGLENBQUo7QUFDSDtBQUNKLEdBSkQsTUFLSztBQUNELFFBQUlvZixRQUFRLEdBQUdELGVBQWUsQ0FBQ0MsUUFBL0IsQ0FEQyxDQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsVUFBTUMsY0FBYyxHQUFHRixlQUFlLENBQUM5VyxNQUFoQixJQUEwQjhXLGVBQWUsQ0FBQzlXLE1BQWhCLENBQXVCK1csUUFBeEU7O0FBQ0EsUUFBSUMsY0FBYyxLQUFLRCxRQUF2QixFQUFpQztBQUM3QkEsY0FBUSxHQUFHRCxlQUFlLENBQUNDLFFBQWhCLEdBQTJCcGlCLE1BQU0sQ0FBQzhVLE1BQVAsQ0FBY3VOLGNBQWQsQ0FBdEM7QUFDSCxLQVZBLENBV0Q7OztBQUNBRCxZQUFRLENBQUM5akIsR0FBRCxDQUFSLEdBQWdCMkQsS0FBaEI7QUFDSDtBQUNKOztBQUNELFNBQVNxZ0IsTUFBVCxDQUFnQmhrQixHQUFoQixFQUFxQmlrQixZQUFyQixFQUFtQ0MscUJBQXFCLEdBQUcsS0FBM0QsRUFBa0U7QUFDOUQ7QUFDQTtBQUNBLFFBQU1wWSxRQUFRLEdBQUcrWCxlQUFlLElBQUkvSix3QkFBcEM7O0FBQ0EsTUFBSWhPLFFBQUosRUFBYztBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQU1nWSxRQUFRLEdBQUdoWSxRQUFRLENBQUNpQixNQUFULElBQW1CLElBQW5CLEdBQ1hqQixRQUFRLENBQUNILEtBQVQsQ0FBZU0sVUFBZixJQUE2QkgsUUFBUSxDQUFDSCxLQUFULENBQWVNLFVBQWYsQ0FBMEI2WCxRQUQ1QyxHQUVYaFksUUFBUSxDQUFDaUIsTUFBVCxDQUFnQitXLFFBRnRCOztBQUdBLFFBQUlBLFFBQVEsSUFBSTlqQixHQUFHLElBQUk4akIsUUFBdkIsRUFBaUM7QUFDN0I7QUFDQSxhQUFPQSxRQUFRLENBQUM5akIsR0FBRCxDQUFmO0FBQ0gsS0FIRCxNQUlLLElBQUlta0IsU0FBUyxDQUFDamxCLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDM0IsYUFBT2dsQixxQkFBcUIsSUFBSW5XLHVEQUFZLENBQUNrVyxZQUFELENBQXJDLEdBQ0RBLFlBQVksQ0FBQ3ZlLElBQWIsQ0FBa0JvRyxRQUFRLENBQUNyRCxLQUEzQixDQURDLEdBRUR3YixZQUZOO0FBR0gsS0FKSSxNQUtBLElBQUtybUIsSUFBTCxFQUE2QztBQUM5QzhHLFVBQUksQ0FBRSxjQUFhQyxNQUFNLENBQUMzRSxHQUFELENBQU0sY0FBM0IsQ0FBSjtBQUNIO0FBQ0osR0FuQkQsTUFvQkssSUFBS3BDLElBQUwsRUFBNkM7QUFDOUM4RyxRQUFJLENBQUUsb0VBQUYsQ0FBSjtBQUNIO0FBQ0osQyxDQUVEOzs7QUFDQSxTQUFTMGYsV0FBVCxDQUFxQm5tQixNQUFyQixFQUE2QkMsT0FBN0IsRUFBc0M7QUFDbEMsU0FBT21tQixPQUFPLENBQUNwbUIsTUFBRCxFQUFTLElBQVQsRUFBZUMsT0FBZixDQUFkO0FBQ0gsQyxDQUNEOzs7QUFDQSxNQUFNb21CLHFCQUFxQixHQUFHLEVBQTlCLEMsQ0FDQTs7QUFDQSxTQUFTQyxLQUFULENBQWVDLE1BQWYsRUFBdUJoVCxFQUF2QixFQUEyQnRULE9BQTNCLEVBQW9DO0FBQ2hDLE1BQUtOLEtBQUQsSUFBMkMsQ0FBQ21RLHVEQUFZLENBQUN5RCxFQUFELENBQTVELEVBQWtFO0FBQzlEOU0sUUFBSSxDQUFFLHNFQUFELEdBQ0EsZ0VBREEsR0FFQSxtREFGRCxDQUFKO0FBR0g7O0FBQ0QsU0FBTzJmLE9BQU8sQ0FBQ0csTUFBRCxFQUFTaFQsRUFBVCxFQUFhdFQsT0FBYixDQUFkO0FBQ0g7O0FBQ0QsU0FBU21tQixPQUFULENBQWlCRyxNQUFqQixFQUF5QmhULEVBQXpCLEVBQTZCO0FBQUVpVCxXQUFGO0FBQWFDLE1BQWI7QUFBbUJDLE9BQW5CO0FBQTBCbGtCLFNBQTFCO0FBQW1DWTtBQUFuQyxJQUFpRGxELGtEQUE5RSxFQUF5RjJOLFFBQVEsR0FBRytYLGVBQXBHLEVBQXFIO0FBQ2pILE1BQUtqbUIsS0FBRCxJQUEyQyxDQUFDNFQsRUFBaEQsRUFBb0Q7QUFDaEQsUUFBSWlULFNBQVMsS0FBSzdrQixTQUFsQixFQUE2QjtBQUN6QjhFLFVBQUksQ0FBRSw4REFBRCxHQUNBLDhDQURELENBQUo7QUFFSDs7QUFDRCxRQUFJZ2dCLElBQUksS0FBSzlrQixTQUFiLEVBQXdCO0FBQ3BCOEUsVUFBSSxDQUFFLHlEQUFELEdBQ0EsOENBREQsQ0FBSjtBQUVIO0FBQ0o7O0FBQ0QsUUFBTWtnQixpQkFBaUIsR0FBSTFCLENBQUQsSUFBTztBQUM3QnhlLFFBQUksQ0FBRSx3QkFBRixFQUEyQndlLENBQTNCLEVBQStCLDhEQUFELEdBQzdCLGdEQURELENBQUo7QUFFSCxHQUhEOztBQUlBLE1BQUlsWSxNQUFKO0FBQ0EsTUFBSTZaLFlBQVksR0FBRyxLQUFuQjtBQUNBLE1BQUlDLGFBQWEsR0FBRyxLQUFwQjs7QUFDQSxNQUFJcmhCLHNEQUFLLENBQUMrZ0IsTUFBRCxDQUFULEVBQW1CO0FBQ2Z4WixVQUFNLEdBQUcsTUFBTXdaLE1BQU0sQ0FBQzdnQixLQUF0Qjs7QUFDQWtoQixnQkFBWSxHQUFHLENBQUMsQ0FBQ0wsTUFBTSxDQUFDOWEsUUFBeEI7QUFDSCxHQUhELE1BSUssSUFBSWYsMkRBQVUsQ0FBQzZiLE1BQUQsQ0FBZCxFQUF3QjtBQUN6QnhaLFVBQU0sR0FBRyxNQUFNd1osTUFBZjs7QUFDQUUsUUFBSSxHQUFHLElBQVA7QUFDSCxHQUhJLE1BSUEsSUFBSXpqQixvREFBTyxDQUFDdWpCLE1BQUQsQ0FBWCxFQUFxQjtBQUN0Qk0saUJBQWEsR0FBRyxJQUFoQjtBQUNBRCxnQkFBWSxHQUFHTCxNQUFNLENBQUNySSxJQUFQLENBQVl4VCx1REFBWixDQUFmOztBQUNBcUMsVUFBTSxHQUFHLE1BQU13WixNQUFNLENBQUM1aUIsR0FBUCxDQUFXc2hCLENBQUMsSUFBSTtBQUMzQixVQUFJemYsc0RBQUssQ0FBQ3lmLENBQUQsQ0FBVCxFQUFjO0FBQ1YsZUFBT0EsQ0FBQyxDQUFDdmYsS0FBVDtBQUNILE9BRkQsTUFHSyxJQUFJZ0YsMkRBQVUsQ0FBQ3VhLENBQUQsQ0FBZCxFQUFtQjtBQUNwQixlQUFPNkIsUUFBUSxDQUFDN0IsQ0FBRCxDQUFmO0FBQ0gsT0FGSSxNQUdBLElBQUluVix1REFBWSxDQUFDbVYsQ0FBRCxDQUFoQixFQUFxQjtBQUN0QixlQUFPNVcscUJBQXFCLENBQUM0VyxDQUFELEVBQUlwWCxRQUFKLEVBQWM7QUFBRTtBQUFoQixTQUE1QjtBQUNILE9BRkksTUFHQTtBQUNBbE8sYUFBRCxJQUEyQ2duQixpQkFBaUIsQ0FBQzFCLENBQUQsQ0FBNUQ7QUFDSDtBQUNKLEtBYmMsQ0FBZjtBQWNILEdBakJJLE1Ba0JBLElBQUluVix1REFBWSxDQUFDeVcsTUFBRCxDQUFoQixFQUEwQjtBQUMzQixRQUFJaFQsRUFBSixFQUFRO0FBQ0o7QUFDQXhHLFlBQU0sR0FBRyxNQUFNc0IscUJBQXFCLENBQUNrWSxNQUFELEVBQVMxWSxRQUFULEVBQW1CO0FBQUU7QUFBckIsT0FBcEM7QUFDSCxLQUhELE1BSUs7QUFDRDtBQUNBZCxZQUFNLEdBQUcsTUFBTTtBQUNYLFlBQUljLFFBQVEsSUFBSUEsUUFBUSxDQUFDMlYsV0FBekIsRUFBc0M7QUFDbEM7QUFDSDs7QUFDRCxZQUFJaGpCLE9BQUosRUFBYTtBQUNUQSxpQkFBTztBQUNWOztBQUNELGVBQU8yUCwwQkFBMEIsQ0FBQ29XLE1BQUQsRUFBUzFZLFFBQVQsRUFBbUI7QUFBRTtBQUFyQixVQUEyQyxDQUFDa1osWUFBRCxDQUEzQyxDQUFqQztBQUNILE9BUkQ7QUFTSDtBQUNKLEdBakJJLE1Ba0JBO0FBQ0RoYSxVQUFNLEdBQUdRLDZDQUFUO0FBQ0M1TixTQUFELElBQTJDZ25CLGlCQUFpQixDQUFDSixNQUFELENBQTVEO0FBQ0g7O0FBQ0QsTUFBSWhULEVBQUUsSUFBSWtULElBQVYsRUFBZ0I7QUFDWixVQUFNTyxVQUFVLEdBQUdqYSxNQUFuQjs7QUFDQUEsVUFBTSxHQUFHLE1BQU0rWixRQUFRLENBQUNFLFVBQVUsRUFBWCxDQUF2QjtBQUNIOztBQUNELE1BQUl4bUIsT0FBSjs7QUFDQSxNQUFJdW1CLFlBQVksR0FBSWpuQixFQUFELElBQVE7QUFDdkJVLFdBQU8sR0FBR3ltQixNQUFNLENBQUNobkIsT0FBUCxDQUFlUSxNQUFmLEdBQXdCLE1BQU07QUFDcEM0TiwyQkFBcUIsQ0FBQ3ZPLEVBQUQsRUFBSytOLFFBQUwsRUFBZTtBQUFFO0FBQWpCLE9BQXJCO0FBQ0gsS0FGRDtBQUdILEdBSkQ7O0FBS0EsTUFBSWxMLFFBQVEsR0FBR2trQixhQUFhLEdBQUcsRUFBSCxHQUFRUixxQkFBcEM7O0FBQ0EsUUFBTTdULEdBQUcsR0FBRyxNQUFNO0FBQ2QsUUFBSSxDQUFDeVUsTUFBTSxDQUFDMW1CLE1BQVosRUFBb0I7QUFDaEI7QUFDSDs7QUFDRCxRQUFJZ1QsRUFBSixFQUFRO0FBQ0o7QUFDQSxZQUFNN1EsUUFBUSxHQUFHdWtCLE1BQU0sRUFBdkI7O0FBQ0EsVUFBSVIsSUFBSSxJQUNKRyxZQURBLEtBRUNDLGFBQWEsR0FDUm5rQixRQUFRLENBQUN3YixJQUFULENBQWMsQ0FBQ2hYLENBQUQsRUFBSTdGLENBQUosS0FBVThFLHVEQUFVLENBQUNlLENBQUQsRUFBSXZFLFFBQVEsQ0FBQ3RCLENBQUQsQ0FBWixDQUFsQyxDQURRLEdBRVI4RSx1REFBVSxDQUFDekQsUUFBRCxFQUFXQyxRQUFYLENBSmhCLEtBS0MsS0FMTCxFQUtlO0FBQ1g7QUFDQSxZQUFJbkMsT0FBSixFQUFhO0FBQ1RBLGlCQUFPO0FBQ1Y7O0FBQ0QyUCxrQ0FBMEIsQ0FBQ29ELEVBQUQsRUFBSzFGLFFBQUwsRUFBZTtBQUFFO0FBQWpCLFVBQXVDLENBQzdEbkwsUUFENkQsRUFFN0Q7QUFDQUMsZ0JBQVEsS0FBSzBqQixxQkFBYixHQUFxQzFrQixTQUFyQyxHQUFpRGdCLFFBSFksRUFJN0Rva0IsWUFKNkQsQ0FBdkMsQ0FBMUI7QUFNQXBrQixnQkFBUSxHQUFHRCxRQUFYO0FBQ0g7QUFDSixLQXJCRCxNQXNCSztBQUNEO0FBQ0F1a0IsWUFBTTtBQUNUO0FBQ0osR0E5QkQsQ0E3RWlILENBNEdqSDtBQUNBOzs7QUFDQXpVLEtBQUcsQ0FBQ3JSLFlBQUosR0FBbUIsQ0FBQyxDQUFDb1MsRUFBckI7QUFDQSxNQUFJbFEsU0FBSjs7QUFDQSxNQUFJcWpCLEtBQUssS0FBSyxNQUFkLEVBQXNCO0FBQ2xCcmpCLGFBQVMsR0FBR21QLEdBQVosQ0FEa0IsQ0FDRDtBQUNwQixHQUZELE1BR0ssSUFBSWtVLEtBQUssS0FBSyxNQUFkLEVBQXNCO0FBQ3ZCcmpCLGFBQVMsR0FBRyxNQUFNNmpCLHFCQUFxQixDQUFDMVUsR0FBRCxFQUFNM0UsUUFBUSxJQUFJQSxRQUFRLENBQUNvVSxRQUEzQixDQUF2QztBQUNILEdBRkksTUFHQTtBQUNEO0FBQ0E1ZSxhQUFTLEdBQUcsTUFBTTtBQUNkLFVBQUksQ0FBQ3dLLFFBQUQsSUFBYUEsUUFBUSxDQUFDc1osU0FBMUIsRUFBcUM7QUFDakN4VCx1QkFBZSxDQUFDbkIsR0FBRCxDQUFmO0FBQ0gsT0FGRCxNQUdLO0FBQ0Q7QUFDQTtBQUNBQSxXQUFHO0FBQ047QUFDSixLQVREO0FBVUg7O0FBQ0QsUUFBTXlVLE1BQU0sR0FBR2puQix1REFBTSxDQUFDK00sTUFBRCxFQUFTO0FBQzFCMU0sUUFBSSxFQUFFLElBRG9CO0FBRTFCbUMsV0FGMEI7QUFHMUJZLGFBSDBCO0FBSTFCQztBQUowQixHQUFULENBQXJCO0FBTUErakIsMkJBQXlCLENBQUNILE1BQUQsRUFBU3BaLFFBQVQsQ0FBekIsQ0F6SWlILENBMElqSDs7QUFDQSxNQUFJMEYsRUFBSixFQUFRO0FBQ0osUUFBSWlULFNBQUosRUFBZTtBQUNYaFUsU0FBRztBQUNOLEtBRkQsTUFHSztBQUNEN1AsY0FBUSxHQUFHc2tCLE1BQU0sRUFBakI7QUFDSDtBQUNKLEdBUEQsTUFRSyxJQUFJUCxLQUFLLEtBQUssTUFBZCxFQUFzQjtBQUN2QlEseUJBQXFCLENBQUNELE1BQUQsRUFBU3BaLFFBQVEsSUFBSUEsUUFBUSxDQUFDb1UsUUFBOUIsQ0FBckI7QUFDSCxHQUZJLE1BR0E7QUFDRGdGLFVBQU07QUFDVDs7QUFDRCxTQUFPLE1BQU07QUFDVDNtQix5REFBSSxDQUFDMm1CLE1BQUQsQ0FBSjs7QUFDQSxRQUFJcFosUUFBSixFQUFjO0FBQ1YwVix5REFBTSxDQUFDMVYsUUFBUSxDQUFDaEwsT0FBVixFQUFtQm9rQixNQUFuQixDQUFOO0FBQ0g7QUFDSixHQUxEO0FBTUgsQyxDQUNEOzs7QUFDQSxTQUFTSSxhQUFULENBQXVCZCxNQUF2QixFQUErQjdnQixLQUEvQixFQUFzQ3pGLE9BQXRDLEVBQStDO0FBQzNDLFFBQU1xbkIsVUFBVSxHQUFHLEtBQUs5YyxLQUF4QjtBQUNBLFFBQU11QyxNQUFNLEdBQUc0QyxxREFBUSxDQUFDNFcsTUFBRCxDQUFSLEdBQ1RBLE1BQU0sQ0FBQzNsQixRQUFQLENBQWdCLEdBQWhCLElBQ0kybUIsZ0JBQWdCLENBQUNELFVBQUQsRUFBYWYsTUFBYixDQURwQixHQUVJLE1BQU1lLFVBQVUsQ0FBQ2YsTUFBRCxDQUhYLEdBSVRBLE1BQU0sQ0FBQ2pVLElBQVAsQ0FBWWdWLFVBQVosRUFBd0JBLFVBQXhCLENBSk47QUFLQSxNQUFJL1QsRUFBSjs7QUFDQSxNQUFJekQsdURBQVksQ0FBQ3BLLEtBQUQsQ0FBaEIsRUFBeUI7QUFDckI2TixNQUFFLEdBQUc3TixLQUFMO0FBQ0gsR0FGRCxNQUdLO0FBQ0Q2TixNQUFFLEdBQUc3TixLQUFLLENBQUMrVSxPQUFYO0FBQ0F4YSxXQUFPLEdBQUd5RixLQUFWO0FBQ0g7O0FBQ0QsU0FBTzBnQixPQUFPLENBQUNyWixNQUFELEVBQVN3RyxFQUFFLENBQUNqQixJQUFILENBQVFnVixVQUFSLENBQVQsRUFBOEJybkIsT0FBOUIsRUFBdUMsSUFBdkMsQ0FBZDtBQUNIOztBQUNELFNBQVNzbkIsZ0JBQVQsQ0FBMEJoTCxHQUExQixFQUErQmlMLElBQS9CLEVBQXFDO0FBQ2pDLFFBQU1DLFFBQVEsR0FBR0QsSUFBSSxDQUFDRSxLQUFMLENBQVcsR0FBWCxDQUFqQjtBQUNBLFNBQU8sTUFBTTtBQUNULFFBQUlqWCxHQUFHLEdBQUc4TCxHQUFWOztBQUNBLFNBQUssSUFBSWxiLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdvbUIsUUFBUSxDQUFDeG1CLE1BQWIsSUFBdUJ3UCxHQUF2QyxFQUE0Q3BQLENBQUMsRUFBN0MsRUFBaUQ7QUFDN0NvUCxTQUFHLEdBQUdBLEdBQUcsQ0FBQ2dYLFFBQVEsQ0FBQ3BtQixDQUFELENBQVQsQ0FBVDtBQUNIOztBQUNELFdBQU9vUCxHQUFQO0FBQ0gsR0FORDtBQU9IOztBQUNELFNBQVNxVyxRQUFULENBQWtCcGhCLEtBQWxCLEVBQXlCb08sSUFBSSxHQUFHLElBQUl6UixHQUFKLEVBQWhDLEVBQTJDO0FBQ3ZDLE1BQUksQ0FBQ3NsQixxREFBVSxDQUFDamlCLEtBQUQsQ0FBWCxJQUNBb08sSUFBSSxDQUFDeFIsR0FBTCxDQUFTb0QsS0FBVCxDQURBLElBRUFBLEtBQUssQ0FBQztBQUFXO0FBQVosR0FGVCxFQUVrQztBQUM5QixXQUFPQSxLQUFQO0FBQ0g7O0FBQ0RvTyxNQUFJLENBQUN2UixHQUFMLENBQVNtRCxLQUFUOztBQUNBLE1BQUlGLHNEQUFLLENBQUNFLEtBQUQsQ0FBVCxFQUFrQjtBQUNkb2hCLFlBQVEsQ0FBQ3BoQixLQUFLLENBQUNBLEtBQVAsRUFBY29PLElBQWQsQ0FBUjtBQUNILEdBRkQsTUFHSyxJQUFJOVEsb0RBQU8sQ0FBQzBDLEtBQUQsQ0FBWCxFQUFvQjtBQUNyQixTQUFLLElBQUlyRSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcUUsS0FBSyxDQUFDekUsTUFBMUIsRUFBa0NJLENBQUMsRUFBbkMsRUFBdUM7QUFDbkN5bEIsY0FBUSxDQUFDcGhCLEtBQUssQ0FBQ3JFLENBQUQsQ0FBTixFQUFXeVMsSUFBWCxDQUFSO0FBQ0g7QUFDSixHQUpJLE1BS0EsSUFBSThULGtEQUFLLENBQUNsaUIsS0FBRCxDQUFMLElBQWdCekMsa0RBQUssQ0FBQ3lDLEtBQUQsQ0FBekIsRUFBa0M7QUFDbkNBLFNBQUssQ0FBQzNDLE9BQU4sQ0FBZW1FLENBQUQsSUFBTztBQUNqQjRmLGNBQVEsQ0FBQzVmLENBQUQsRUFBSTRNLElBQUosQ0FBUjtBQUNILEtBRkQ7QUFHSCxHQUpJLE1BS0EsSUFBSStULDBEQUFhLENBQUNuaUIsS0FBRCxDQUFqQixFQUEwQjtBQUMzQixTQUFLLE1BQU0zRCxHQUFYLElBQWtCMkQsS0FBbEIsRUFBeUI7QUFDckJvaEIsY0FBUSxDQUFDcGhCLEtBQUssQ0FBQzNELEdBQUQsQ0FBTixFQUFhK1IsSUFBYixDQUFSO0FBQ0g7QUFDSjs7QUFDRCxTQUFPcE8sS0FBUDtBQUNIOztBQUVELFNBQVNvaUIsa0JBQVQsR0FBOEI7QUFDMUIsUUFBTUMsS0FBSyxHQUFHO0FBQ1ZaLGFBQVMsRUFBRSxLQUREO0FBRVZhLGFBQVMsRUFBRSxLQUZEO0FBR1ZDLGdCQUFZLEVBQUUsS0FISjtBQUlWQyxpQkFBYSxFQUFFLElBQUkvbEIsR0FBSjtBQUpMLEdBQWQ7QUFNQWdtQixXQUFTLENBQUMsTUFBTTtBQUNaSixTQUFLLENBQUNaLFNBQU4sR0FBa0IsSUFBbEI7QUFDSCxHQUZRLENBQVQ7QUFHQWlCLGlCQUFlLENBQUMsTUFBTTtBQUNsQkwsU0FBSyxDQUFDRSxZQUFOLEdBQXFCLElBQXJCO0FBQ0gsR0FGYyxDQUFmO0FBR0EsU0FBT0YsS0FBUDtBQUNIOztBQUNELE1BQU1NLHVCQUF1QixHQUFHLENBQUNDLFFBQUQsRUFBV2hrQixLQUFYLENBQWhDO0FBQ0EsTUFBTWlrQixrQkFBa0IsR0FBRztBQUN2QnhZLE1BQUksRUFBRyxnQkFEZ0I7QUFFdkJULE9BQUssRUFBRTtBQUNIaUssUUFBSSxFQUFFN1MsTUFESDtBQUVIOGhCLFVBQU0sRUFBRXZkLE9BRkw7QUFHSHdkLGFBQVMsRUFBRXhkLE9BSFI7QUFJSDtBQUNBeWQsaUJBQWEsRUFBRUwsdUJBTFo7QUFNSE0sV0FBTyxFQUFFTix1QkFOTjtBQU9ITyxnQkFBWSxFQUFFUCx1QkFQWDtBQVFIUSxvQkFBZ0IsRUFBRVIsdUJBUmY7QUFTSDtBQUNBUyxpQkFBYSxFQUFFVCx1QkFWWjtBQVdIVSxXQUFPLEVBQUVWLHVCQVhOO0FBWUhXLGdCQUFZLEVBQUVYLHVCQVpYO0FBYUhZLG9CQUFnQixFQUFFWix1QkFiZjtBQWNIO0FBQ0FhLGtCQUFjLEVBQUViLHVCQWZiO0FBZ0JIYyxZQUFRLEVBQUVkLHVCQWhCUDtBQWlCSGUsaUJBQWEsRUFBRWYsdUJBakJaO0FBa0JIZ0IscUJBQWlCLEVBQUVoQjtBQWxCaEIsR0FGZ0I7O0FBc0J2QmlCLE9BQUssQ0FBQ2hhLEtBQUQsRUFBUTtBQUFFOE47QUFBRixHQUFSLEVBQW1CO0FBQ3BCLFVBQU12UCxRQUFRLEdBQUc2SyxrQkFBa0IsRUFBbkM7QUFDQSxVQUFNcVAsS0FBSyxHQUFHRCxrQkFBa0IsRUFBaEM7QUFDQSxRQUFJeUIsaUJBQUo7QUFDQSxXQUFPLE1BQU07QUFDVCxZQUFNeEssUUFBUSxHQUFHM0IsS0FBSyxDQUFDNEgsT0FBTixJQUFpQndFLHdCQUF3QixDQUFDcE0sS0FBSyxDQUFDNEgsT0FBTixFQUFELEVBQWtCLElBQWxCLENBQTFEOztBQUNBLFVBQUksQ0FBQ2pHLFFBQUQsSUFBYSxDQUFDQSxRQUFRLENBQUM5ZCxNQUEzQixFQUFtQztBQUMvQjtBQUNILE9BSlEsQ0FLVDs7O0FBQ0EsVUFBS3RCLEtBQUQsSUFBMkNvZixRQUFRLENBQUM5ZCxNQUFULEdBQWtCLENBQWpFLEVBQW9FO0FBQ2hFd0YsWUFBSSxDQUFDLHlFQUNELCtCQURBLENBQUo7QUFFSCxPQVRRLENBVVQ7QUFDQTs7O0FBQ0EsWUFBTWdqQixRQUFRLEdBQUcva0Isc0RBQUssQ0FBQzRLLEtBQUQsQ0FBdEI7QUFDQSxZQUFNO0FBQUVpSztBQUFGLFVBQVdrUSxRQUFqQixDQWJTLENBY1Q7O0FBQ0EsVUFBSzlwQixLQUFELElBQTJDNFosSUFBM0MsSUFBbUQsQ0FBQyxDQUFDLFFBQUQsRUFBVyxRQUFYLEVBQXFCLFNBQXJCLEVBQWdDM1ksUUFBaEMsQ0FBeUMyWSxJQUF6QyxDQUF4RCxFQUF3RztBQUNwRzlTLFlBQUksQ0FBRSw4QkFBNkI4UyxJQUFLLEVBQXBDLENBQUo7QUFDSCxPQWpCUSxDQWtCVDs7O0FBQ0EsWUFBTStGLEtBQUssR0FBR1AsUUFBUSxDQUFDLENBQUQsQ0FBdEI7O0FBQ0EsVUFBSWdKLEtBQUssQ0FBQ0MsU0FBVixFQUFxQjtBQUNqQixlQUFPMEIsZ0JBQWdCLENBQUNwSyxLQUFELENBQXZCO0FBQ0gsT0F0QlEsQ0F1QlQ7QUFDQTs7O0FBQ0EsWUFBTXFLLFVBQVUsR0FBR0MsaUJBQWlCLENBQUN0SyxLQUFELENBQXBDOztBQUNBLFVBQUksQ0FBQ3FLLFVBQUwsRUFBaUI7QUFDYixlQUFPRCxnQkFBZ0IsQ0FBQ3BLLEtBQUQsQ0FBdkI7QUFDSDs7QUFDRCxZQUFNdUssVUFBVSxHQUFHQyxzQkFBc0IsQ0FBQ0gsVUFBRCxFQUFhRixRQUFiLEVBQXVCMUIsS0FBdkIsRUFBOEJsYSxRQUE5QixDQUF6QztBQUNBa2Msd0JBQWtCLENBQUNKLFVBQUQsRUFBYUUsVUFBYixDQUFsQjtBQUNBLFlBQU1HLFFBQVEsR0FBR25jLFFBQVEsQ0FBQ3lTLE9BQTFCO0FBQ0EsWUFBTTJKLGFBQWEsR0FBR0QsUUFBUSxJQUFJSixpQkFBaUIsQ0FBQ0ksUUFBRCxDQUFuRDtBQUNBLFVBQUlFLG9CQUFvQixHQUFHLEtBQTNCO0FBQ0EsWUFBTTtBQUFFQztBQUFGLFVBQXVCUixVQUFVLENBQUM3bkIsSUFBeEM7O0FBQ0EsVUFBSXFvQixnQkFBSixFQUFzQjtBQUNsQixjQUFNcG9CLEdBQUcsR0FBR29vQixnQkFBZ0IsRUFBNUI7O0FBQ0EsWUFBSVosaUJBQWlCLEtBQUs1bkIsU0FBMUIsRUFBcUM7QUFDakM0bkIsMkJBQWlCLEdBQUd4bkIsR0FBcEI7QUFDSCxTQUZELE1BR0ssSUFBSUEsR0FBRyxLQUFLd25CLGlCQUFaLEVBQStCO0FBQ2hDQSwyQkFBaUIsR0FBR3huQixHQUFwQjtBQUNBbW9CLDhCQUFvQixHQUFHLElBQXZCO0FBQ0g7QUFDSixPQTVDUSxDQTZDVDs7O0FBQ0EsVUFBSUQsYUFBYSxJQUNiQSxhQUFhLENBQUNub0IsSUFBZCxLQUF1QmlWLFNBRHZCLEtBRUMsQ0FBQzhMLGVBQWUsQ0FBQzhHLFVBQUQsRUFBYU0sYUFBYixDQUFoQixJQUErQ0Msb0JBRmhELENBQUosRUFFMkU7QUFDdkUsY0FBTUUsWUFBWSxHQUFHTixzQkFBc0IsQ0FBQ0csYUFBRCxFQUFnQlIsUUFBaEIsRUFBMEIxQixLQUExQixFQUFpQ2xhLFFBQWpDLENBQTNDLENBRHVFLENBRXZFOztBQUNBa2MsMEJBQWtCLENBQUNFLGFBQUQsRUFBZ0JHLFlBQWhCLENBQWxCLENBSHVFLENBSXZFOztBQUNBLFlBQUk3USxJQUFJLEtBQUssUUFBYixFQUF1QjtBQUNuQndPLGVBQUssQ0FBQ0MsU0FBTixHQUFrQixJQUFsQixDQURtQixDQUVuQjs7QUFDQW9DLHNCQUFZLENBQUN4RyxVQUFiLEdBQTBCLE1BQU07QUFDNUJtRSxpQkFBSyxDQUFDQyxTQUFOLEdBQWtCLEtBQWxCO0FBQ0FuYSxvQkFBUSxDQUFDbUksTUFBVDtBQUNILFdBSEQ7O0FBSUEsaUJBQU8wVCxnQkFBZ0IsQ0FBQ3BLLEtBQUQsQ0FBdkI7QUFDSCxTQVJELE1BU0ssSUFBSS9GLElBQUksS0FBSyxRQUFULElBQXFCb1EsVUFBVSxDQUFDN25CLElBQVgsS0FBb0JpVixTQUE3QyxFQUF3RDtBQUN6RHFULHNCQUFZLENBQUNDLFVBQWIsR0FBMEIsQ0FBQ2hLLEVBQUQsRUFBS2lLLFdBQUwsRUFBa0JDLFlBQWxCLEtBQW1DO0FBQ3pELGtCQUFNQyxrQkFBa0IsR0FBR0Msc0JBQXNCLENBQUMxQyxLQUFELEVBQVFrQyxhQUFSLENBQWpEO0FBQ0FPLDhCQUFrQixDQUFDOWpCLE1BQU0sQ0FBQ3VqQixhQUFhLENBQUNsb0IsR0FBZixDQUFQLENBQWxCLEdBQWdEa29CLGFBQWhELENBRnlELENBR3pEOztBQUNBNUosY0FBRSxDQUFDcUssUUFBSCxHQUFjLE1BQU07QUFDaEJKLHlCQUFXO0FBQ1hqSyxnQkFBRSxDQUFDcUssUUFBSCxHQUFjL29CLFNBQWQ7QUFDQSxxQkFBT2tvQixVQUFVLENBQUNVLFlBQWxCO0FBQ0gsYUFKRDs7QUFLQVYsc0JBQVUsQ0FBQ1UsWUFBWCxHQUEwQkEsWUFBMUI7QUFDSCxXQVZEO0FBV0g7QUFDSjs7QUFDRCxhQUFPakwsS0FBUDtBQUNILEtBN0VEO0FBOEVIOztBQXhHc0IsQ0FBM0IsQyxDQTBHQTtBQUNBOztBQUNBLE1BQU1xTCxjQUFjLEdBQUdwQyxrQkFBdkI7O0FBQ0EsU0FBU2tDLHNCQUFULENBQWdDMUMsS0FBaEMsRUFBdUNyYSxLQUF2QyxFQUE4QztBQUMxQyxRQUFNO0FBQUV3YTtBQUFGLE1BQW9CSCxLQUExQjtBQUNBLE1BQUl5QyxrQkFBa0IsR0FBR3RDLGFBQWEsQ0FBQ2ptQixHQUFkLENBQWtCeUwsS0FBSyxDQUFDNUwsSUFBeEIsQ0FBekI7O0FBQ0EsTUFBSSxDQUFDMG9CLGtCQUFMLEVBQXlCO0FBQ3JCQSxzQkFBa0IsR0FBRy9tQixNQUFNLENBQUM4VSxNQUFQLENBQWMsSUFBZCxDQUFyQjtBQUNBMlAsaUJBQWEsQ0FBQ2htQixHQUFkLENBQWtCd0wsS0FBSyxDQUFDNUwsSUFBeEIsRUFBOEIwb0Isa0JBQTlCO0FBQ0g7O0FBQ0QsU0FBT0Esa0JBQVA7QUFDSCxDLENBQ0Q7QUFDQTs7O0FBQ0EsU0FBU1Ysc0JBQVQsQ0FBZ0NwYyxLQUFoQyxFQUF1QzRCLEtBQXZDLEVBQThDeVksS0FBOUMsRUFBcURsYSxRQUFyRCxFQUErRDtBQUMzRCxRQUFNO0FBQUUyYSxVQUFGO0FBQVVqUCxRQUFWO0FBQWdCa1AsYUFBUyxHQUFHLEtBQTVCO0FBQW1DQyxpQkFBbkM7QUFBa0RDLFdBQWxEO0FBQTJEQyxnQkFBM0Q7QUFBeUVDLG9CQUF6RTtBQUEyRkMsaUJBQTNGO0FBQTBHQyxXQUExRztBQUFtSEMsZ0JBQW5IO0FBQWlJQyxvQkFBakk7QUFBbUpDLGtCQUFuSjtBQUFtS0MsWUFBbks7QUFBNktDLGlCQUE3SztBQUE0TEM7QUFBNUwsTUFBa04vWixLQUF4TjtBQUNBLFFBQU12TixHQUFHLEdBQUcyRSxNQUFNLENBQUNnSCxLQUFLLENBQUMzTCxHQUFQLENBQWxCO0FBQ0EsUUFBTXlvQixrQkFBa0IsR0FBR0Msc0JBQXNCLENBQUMxQyxLQUFELEVBQVFyYSxLQUFSLENBQWpEOztBQUNBLFFBQU1rZCxRQUFRLEdBQUcsQ0FBQ3JVLElBQUQsRUFBTy9SLElBQVAsS0FBZ0I7QUFDN0IrUixRQUFJLElBQ0FwRywwQkFBMEIsQ0FBQ29HLElBQUQsRUFBTzFJLFFBQVAsRUFBaUI7QUFBRTtBQUFuQixNQUEwQ3JKLElBQTFDLENBRDlCO0FBRUgsR0FIRDs7QUFJQSxRQUFNcW1CLEtBQUssR0FBRztBQUNWdFIsUUFEVTtBQUVWa1AsYUFGVTs7QUFHVnFDLGVBQVcsQ0FBQ3pLLEVBQUQsRUFBSztBQUNaLFVBQUk5SixJQUFJLEdBQUdtUyxhQUFYOztBQUNBLFVBQUksQ0FBQ1gsS0FBSyxDQUFDWixTQUFYLEVBQXNCO0FBQ2xCLFlBQUlxQixNQUFKLEVBQVk7QUFDUmpTLGNBQUksR0FBRzJTLGNBQWMsSUFBSVIsYUFBekI7QUFDSCxTQUZELE1BR0s7QUFDRDtBQUNIO0FBQ0osT0FUVyxDQVVaOzs7QUFDQSxVQUFJckksRUFBRSxDQUFDcUssUUFBUCxFQUFpQjtBQUNickssVUFBRSxDQUFDcUssUUFBSCxDQUFZO0FBQUs7QUFBakI7QUFDSCxPQWJXLENBY1o7OztBQUNBLFlBQU1LLFlBQVksR0FBR1Asa0JBQWtCLENBQUN6b0IsR0FBRCxDQUF2Qzs7QUFDQSxVQUFJZ3BCLFlBQVksSUFDWmxJLGVBQWUsQ0FBQ25WLEtBQUQsRUFBUXFkLFlBQVIsQ0FEZixJQUVBQSxZQUFZLENBQUMxSyxFQUFiLENBQWdCcUssUUFGcEIsRUFFOEI7QUFDMUI7QUFDQUssb0JBQVksQ0FBQzFLLEVBQWIsQ0FBZ0JxSyxRQUFoQjtBQUNIOztBQUNERSxjQUFRLENBQUNyVSxJQUFELEVBQU8sQ0FBQzhKLEVBQUQsQ0FBUCxDQUFSO0FBQ0gsS0ExQlM7O0FBMkJWMkssU0FBSyxDQUFDM0ssRUFBRCxFQUFLO0FBQ04sVUFBSTlKLElBQUksR0FBR29TLE9BQVg7QUFDQSxVQUFJc0MsU0FBUyxHQUFHckMsWUFBaEI7QUFDQSxVQUFJc0MsVUFBVSxHQUFHckMsZ0JBQWpCOztBQUNBLFVBQUksQ0FBQ2QsS0FBSyxDQUFDWixTQUFYLEVBQXNCO0FBQ2xCLFlBQUlxQixNQUFKLEVBQVk7QUFDUmpTLGNBQUksR0FBRzRTLFFBQVEsSUFBSVIsT0FBbkI7QUFDQXNDLG1CQUFTLEdBQUc3QixhQUFhLElBQUlSLFlBQTdCO0FBQ0FzQyxvQkFBVSxHQUFHN0IsaUJBQWlCLElBQUlSLGdCQUFsQztBQUNILFNBSkQsTUFLSztBQUNEO0FBQ0g7QUFDSjs7QUFDRCxVQUFJc0MsTUFBTSxHQUFHLEtBQWI7O0FBQ0EsWUFBTXRpQixJQUFJLEdBQUl3WCxFQUFFLENBQUMrSyxRQUFILEdBQWVDLFNBQUQsSUFBZTtBQUN2QyxZQUFJRixNQUFKLEVBQ0k7QUFDSkEsY0FBTSxHQUFHLElBQVQ7O0FBQ0EsWUFBSUUsU0FBSixFQUFlO0FBQ1hULGtCQUFRLENBQUNNLFVBQUQsRUFBYSxDQUFDN0ssRUFBRCxDQUFiLENBQVI7QUFDSCxTQUZELE1BR0s7QUFDRHVLLGtCQUFRLENBQUNLLFNBQUQsRUFBWSxDQUFDNUssRUFBRCxDQUFaLENBQVI7QUFDSDs7QUFDRCxZQUFJd0ssS0FBSyxDQUFDTixZQUFWLEVBQXdCO0FBQ3BCTSxlQUFLLENBQUNOLFlBQU47QUFDSDs7QUFDRGxLLFVBQUUsQ0FBQytLLFFBQUgsR0FBY3pwQixTQUFkO0FBQ0gsT0FkRDs7QUFlQSxVQUFJNFUsSUFBSixFQUFVO0FBQ05BLFlBQUksQ0FBQzhKLEVBQUQsRUFBS3hYLElBQUwsQ0FBSjs7QUFDQSxZQUFJME4sSUFBSSxDQUFDdFYsTUFBTCxJQUFlLENBQW5CLEVBQXNCO0FBQ2xCNEgsY0FBSTtBQUNQO0FBQ0osT0FMRCxNQU1LO0FBQ0RBLFlBQUk7QUFDUDtBQUNKLEtBbEVTOztBQW1FVnlpQixTQUFLLENBQUNqTCxFQUFELEVBQUtrRCxNQUFMLEVBQWE7QUFDZCxZQUFNeGhCLEdBQUcsR0FBRzJFLE1BQU0sQ0FBQ2dILEtBQUssQ0FBQzNMLEdBQVAsQ0FBbEI7O0FBQ0EsVUFBSXNlLEVBQUUsQ0FBQytLLFFBQVAsRUFBaUI7QUFDYi9LLFVBQUUsQ0FBQytLLFFBQUgsQ0FBWTtBQUFLO0FBQWpCO0FBQ0g7O0FBQ0QsVUFBSXJELEtBQUssQ0FBQ0UsWUFBVixFQUF3QjtBQUNwQixlQUFPMUUsTUFBTSxFQUFiO0FBQ0g7O0FBQ0RxSCxjQUFRLENBQUM5QixhQUFELEVBQWdCLENBQUN6SSxFQUFELENBQWhCLENBQVI7QUFDQSxVQUFJOEssTUFBTSxHQUFHLEtBQWI7O0FBQ0EsWUFBTXRpQixJQUFJLEdBQUl3WCxFQUFFLENBQUNxSyxRQUFILEdBQWVXLFNBQUQsSUFBZTtBQUN2QyxZQUFJRixNQUFKLEVBQ0k7QUFDSkEsY0FBTSxHQUFHLElBQVQ7QUFDQTVILGNBQU07O0FBQ04sWUFBSThILFNBQUosRUFBZTtBQUNYVCxrQkFBUSxDQUFDM0IsZ0JBQUQsRUFBbUIsQ0FBQzVJLEVBQUQsQ0FBbkIsQ0FBUjtBQUNILFNBRkQsTUFHSztBQUNEdUssa0JBQVEsQ0FBQzVCLFlBQUQsRUFBZSxDQUFDM0ksRUFBRCxDQUFmLENBQVI7QUFDSDs7QUFDREEsVUFBRSxDQUFDcUssUUFBSCxHQUFjL29CLFNBQWQ7O0FBQ0EsWUFBSTZvQixrQkFBa0IsQ0FBQ3pvQixHQUFELENBQWxCLEtBQTRCMkwsS0FBaEMsRUFBdUM7QUFDbkMsaUJBQU84YyxrQkFBa0IsQ0FBQ3pvQixHQUFELENBQXpCO0FBQ0g7QUFDSixPQWZEOztBQWdCQXlvQix3QkFBa0IsQ0FBQ3pvQixHQUFELENBQWxCLEdBQTBCMkwsS0FBMUI7O0FBQ0EsVUFBSXFiLE9BQUosRUFBYTtBQUNUQSxlQUFPLENBQUMxSSxFQUFELEVBQUt4WCxJQUFMLENBQVA7O0FBQ0EsWUFBSWtnQixPQUFPLENBQUM5bkIsTUFBUixJQUFrQixDQUF0QixFQUF5QjtBQUNyQjRILGNBQUk7QUFDUDtBQUNKLE9BTEQsTUFNSztBQUNEQSxZQUFJO0FBQ1A7QUFDSixLQXZHUzs7QUF3R1YwaUIsU0FBSyxDQUFDN2QsS0FBRCxFQUFRO0FBQ1QsYUFBT29jLHNCQUFzQixDQUFDcGMsS0FBRCxFQUFRNEIsS0FBUixFQUFleVksS0FBZixFQUFzQmxhLFFBQXRCLENBQTdCO0FBQ0g7O0FBMUdTLEdBQWQ7QUE0R0EsU0FBT2dkLEtBQVA7QUFDSCxDLENBQ0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNuQixnQkFBVCxDQUEwQmhjLEtBQTFCLEVBQWlDO0FBQzdCLE1BQUk4ZCxXQUFXLENBQUM5ZCxLQUFELENBQWYsRUFBd0I7QUFDcEJBLFNBQUssR0FBRzBRLFVBQVUsQ0FBQzFRLEtBQUQsQ0FBbEI7QUFDQUEsU0FBSyxDQUFDcVIsUUFBTixHQUFpQixJQUFqQjtBQUNBLFdBQU9yUixLQUFQO0FBQ0g7QUFDSjs7QUFDRCxTQUFTa2MsaUJBQVQsQ0FBMkJsYyxLQUEzQixFQUFrQztBQUM5QixTQUFPOGQsV0FBVyxDQUFDOWQsS0FBRCxDQUFYLEdBQ0RBLEtBQUssQ0FBQ3FSLFFBQU4sR0FDSXJSLEtBQUssQ0FBQ3FSLFFBQU4sQ0FBZSxDQUFmLENBREosR0FFSXBkLFNBSEgsR0FJRCtMLEtBSk47QUFLSDs7QUFDRCxTQUFTcWMsa0JBQVQsQ0FBNEJyYyxLQUE1QixFQUFtQ21kLEtBQW5DLEVBQTBDO0FBQ3RDLE1BQUluZCxLQUFLLENBQUNnUSxTQUFOLEdBQWtCO0FBQUU7QUFBcEIsS0FBdUNoUSxLQUFLLENBQUNJLFNBQWpELEVBQTREO0FBQ3hEaWMsc0JBQWtCLENBQUNyYyxLQUFLLENBQUNJLFNBQU4sQ0FBZ0J3UyxPQUFqQixFQUEwQnVLLEtBQTFCLENBQWxCO0FBQ0gsR0FGRCxNQUdLLElBQUluZCxLQUFLLENBQUNnUSxTQUFOLEdBQWtCO0FBQUk7QUFBMUIsSUFBMEM7QUFDM0NoUSxXQUFLLENBQUN5VSxTQUFOLENBQWdCeEQsVUFBaEIsR0FBNkJrTSxLQUFLLENBQUNVLEtBQU4sQ0FBWTdkLEtBQUssQ0FBQ3lVLFNBQWxCLENBQTdCO0FBQ0F6VSxXQUFLLENBQUMwVSxVQUFOLENBQWlCekQsVUFBakIsR0FBOEJrTSxLQUFLLENBQUNVLEtBQU4sQ0FBWTdkLEtBQUssQ0FBQzBVLFVBQWxCLENBQTlCO0FBQ0gsS0FISSxNQUlBO0FBQ0QxVSxTQUFLLENBQUNpUixVQUFOLEdBQW1Ca00sS0FBbkI7QUFDSDtBQUNKOztBQUNELFNBQVNyQix3QkFBVCxDQUFrQ3pLLFFBQWxDLEVBQTRDME0sV0FBVyxHQUFHLEtBQTFELEVBQWlFO0FBQzdELE1BQUloZixHQUFHLEdBQUcsRUFBVjtBQUNBLE1BQUlpZixrQkFBa0IsR0FBRyxDQUF6Qjs7QUFDQSxPQUFLLElBQUlycUIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzBkLFFBQVEsQ0FBQzlkLE1BQTdCLEVBQXFDSSxDQUFDLEVBQXRDLEVBQTBDO0FBQ3RDLFVBQU1pZSxLQUFLLEdBQUdQLFFBQVEsQ0FBQzFkLENBQUQsQ0FBdEIsQ0FEc0MsQ0FFdEM7O0FBQ0EsUUFBSWllLEtBQUssQ0FBQ3hkLElBQU4sS0FBZThVLFFBQW5CLEVBQTZCO0FBQ3pCLFVBQUkwSSxLQUFLLENBQUN0QixTQUFOLEdBQWtCO0FBQUk7QUFBMUIsUUFDSTBOLGtCQUFrQjtBQUN0QmpmLFNBQUcsR0FBR0EsR0FBRyxDQUFDaVMsTUFBSixDQUFXOEssd0JBQXdCLENBQUNsSyxLQUFLLENBQUNQLFFBQVAsRUFBaUIwTSxXQUFqQixDQUFuQyxDQUFOO0FBQ0gsS0FKRCxDQUtBO0FBTEEsU0FNSyxJQUFJQSxXQUFXLElBQUluTSxLQUFLLENBQUN4ZCxJQUFOLEtBQWVpVixTQUFsQyxFQUE2QztBQUM5Q3RLLFdBQUcsQ0FBQzNMLElBQUosQ0FBU3dlLEtBQVQ7QUFDSDtBQUNKLEdBZjRELENBZ0I3RDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBSW9NLGtCQUFrQixHQUFHLENBQXpCLEVBQTRCO0FBQ3hCLFNBQUssSUFBSXJxQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHb0wsR0FBRyxDQUFDeEwsTUFBeEIsRUFBZ0NJLENBQUMsRUFBakMsRUFBcUM7QUFDakNvTCxTQUFHLENBQUNwTCxDQUFELENBQUgsQ0FBTzJjLFNBQVAsR0FBbUIsQ0FBQztBQUFFO0FBQXRCO0FBQ0g7QUFDSjs7QUFDRCxTQUFPdlIsR0FBUDtBQUNILEMsQ0FFRDs7O0FBQ0EsU0FBU2tmLGVBQVQsQ0FBeUIxckIsT0FBekIsRUFBa0M7QUFDOUIsU0FBTzZQLHVEQUFZLENBQUM3UCxPQUFELENBQVosR0FBd0I7QUFBRXFwQixTQUFLLEVBQUVycEIsT0FBVDtBQUFrQjhQLFFBQUksRUFBRTlQLE9BQU8sQ0FBQzhQO0FBQWhDLEdBQXhCLEdBQWlFOVAsT0FBeEU7QUFDSDs7QUFFRCxNQUFNMnJCLGNBQWMsR0FBSXZxQixDQUFELElBQU8sQ0FBQyxDQUFDQSxDQUFDLENBQUNTLElBQUYsQ0FBTytwQixhQUF2Qzs7QUFDQSxTQUFTQyxvQkFBVCxDQUE4QnZGLE1BQTlCLEVBQXNDO0FBQ2xDLE1BQUl6Vyx1REFBWSxDQUFDeVcsTUFBRCxDQUFoQixFQUEwQjtBQUN0QkEsVUFBTSxHQUFHO0FBQUV3RixZQUFNLEVBQUV4RjtBQUFWLEtBQVQ7QUFDSDs7QUFDRCxRQUFNO0FBQUV3RixVQUFGO0FBQVVDLG9CQUFWO0FBQTRCQyxrQkFBNUI7QUFBNENDLFNBQUssR0FBRyxHQUFwRDtBQUF5RG5KLFdBQXpEO0FBQWtFO0FBQ3hFb0osZUFBVyxHQUFHLElBRFI7QUFDY0MsV0FBTyxFQUFFQztBQUR2QixNQUN1QzlGLE1BRDdDO0FBRUEsTUFBSStGLGNBQWMsR0FBRyxJQUFyQjtBQUNBLE1BQUlDLFlBQUo7QUFDQSxNQUFJQyxPQUFPLEdBQUcsQ0FBZDs7QUFDQSxRQUFNQyxLQUFLLEdBQUcsTUFBTTtBQUNoQkQsV0FBTztBQUNQRixrQkFBYyxHQUFHLElBQWpCO0FBQ0EsV0FBT0ksSUFBSSxFQUFYO0FBQ0gsR0FKRDs7QUFLQSxRQUFNQSxJQUFJLEdBQUcsTUFBTTtBQUNmLFFBQUlDLFdBQUo7QUFDQSxXQUFRTCxjQUFjLEtBQ2pCSyxXQUFXLEdBQUdMLGNBQWMsR0FBR1AsTUFBTSxHQUNqQzFiLEtBRDJCLENBQ3JCSixHQUFHLElBQUk7QUFDZEEsU0FBRyxHQUFHQSxHQUFHLFlBQVl5VCxLQUFmLEdBQXVCelQsR0FBdkIsR0FBNkIsSUFBSXlULEtBQUosQ0FBVWhkLE1BQU0sQ0FBQ3VKLEdBQUQsQ0FBaEIsQ0FBbkM7O0FBQ0EsVUFBSW9jLFdBQUosRUFBaUI7QUFDYixlQUFPLElBQUl2YSxPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVNmEsTUFBVixLQUFxQjtBQUNwQyxnQkFBTUMsU0FBUyxHQUFHLE1BQU05YSxPQUFPLENBQUMwYSxLQUFLLEVBQU4sQ0FBL0I7O0FBQ0EsZ0JBQU1LLFFBQVEsR0FBRyxNQUFNRixNQUFNLENBQUMzYyxHQUFELENBQTdCOztBQUNBb2MscUJBQVcsQ0FBQ3BjLEdBQUQsRUFBTTRjLFNBQU4sRUFBaUJDLFFBQWpCLEVBQTJCTixPQUFPLEdBQUcsQ0FBckMsQ0FBWDtBQUNILFNBSk0sQ0FBUDtBQUtILE9BTkQsTUFPSztBQUNELGNBQU12YyxHQUFOO0FBQ0g7QUFDSixLQWIrQixFQWMzQm9DLElBZDJCLENBY3JCK0YsSUFBRCxJQUFVO0FBQ2hCLFVBQUl1VSxXQUFXLEtBQUtMLGNBQWhCLElBQWtDQSxjQUF0QyxFQUFzRDtBQUNsRCxlQUFPQSxjQUFQO0FBQ0g7O0FBQ0QsVUFBSzNzQixLQUFELElBQTJDLENBQUN5WSxJQUFoRCxFQUFzRDtBQUNsRDNSLFlBQUksQ0FBRSxnREFBRCxHQUNBLGlFQURELENBQUo7QUFFSCxPQVBlLENBUWhCOzs7QUFDQSxVQUFJMlIsSUFBSSxLQUNIQSxJQUFJLENBQUMyVSxVQUFMLElBQW1CM1UsSUFBSSxDQUFDMVksTUFBTSxDQUFDc3RCLFdBQVIsQ0FBSixLQUE2QixRQUQ3QyxDQUFSLEVBQ2dFO0FBQzVENVUsWUFBSSxHQUFHQSxJQUFJLENBQUM0TSxPQUFaO0FBQ0g7O0FBQ0QsVUFBS3JsQixLQUFELElBQTJDeVksSUFBM0MsSUFBbUQsQ0FBQ3VQLHFEQUFVLENBQUN2UCxJQUFELENBQTlELElBQXdFLENBQUN0SSx1REFBWSxDQUFDc0ksSUFBRCxDQUF6RixFQUFpRztBQUM3RixjQUFNLElBQUlzTCxLQUFKLENBQVcsd0NBQXVDdEwsSUFBSyxFQUF2RCxDQUFOO0FBQ0g7O0FBQ0RtVSxrQkFBWSxHQUFHblUsSUFBZjtBQUNBLGFBQU9BLElBQVA7QUFDSCxLQWhDK0IsQ0FEZCxDQUF0QjtBQWtDSCxHQXBDRDs7QUFxQ0EsU0FBT3VULGVBQWUsQ0FBQztBQUNuQjViLFFBQUksRUFBRSx1QkFEYTtBQUVuQjhiLGlCQUFhLEVBQUVhLElBRkk7O0FBR25CLFFBQUlPLGVBQUosR0FBc0I7QUFDbEIsYUFBT1YsWUFBUDtBQUNILEtBTGtCOztBQU1uQmpELFNBQUssR0FBRztBQUNKLFlBQU16YixRQUFRLEdBQUcrWCxlQUFqQixDQURJLENBRUo7O0FBQ0EsVUFBSTJHLFlBQUosRUFBa0I7QUFDZCxlQUFPLE1BQU1XLGVBQWUsQ0FBQ1gsWUFBRCxFQUFlMWUsUUFBZixDQUE1QjtBQUNIOztBQUNELFlBQU11ZSxPQUFPLEdBQUluYyxHQUFELElBQVM7QUFDckJxYyxzQkFBYyxHQUFHLElBQWpCO0FBQ0FwYyxtQkFBVyxDQUFDRCxHQUFELEVBQU1wQyxRQUFOLEVBQWdCO0FBQUc7QUFBbkIsVUFBaUQsQ0FBQ29lO0FBQWU7QUFBakUsU0FBWDtBQUNILE9BSEQsQ0FOSSxDQVVKOzs7QUFDQSxVQUFLRSxXQUFXLElBQUl0ZSxRQUFRLENBQUNvVSxRQUF6QixJQUNDLEtBREwsRUFDYztBQUNWLGVBQU95SyxJQUFJLEdBQ05yYSxJQURFLENBQ0crRixJQUFJLElBQUk7QUFDZCxpQkFBTyxNQUFNOFUsZUFBZSxDQUFDOVUsSUFBRCxFQUFPdkssUUFBUCxDQUE1QjtBQUNILFNBSE0sRUFJRndDLEtBSkUsQ0FJSUosR0FBRyxJQUFJO0FBQ2RtYyxpQkFBTyxDQUFDbmMsR0FBRCxDQUFQO0FBQ0EsaUJBQU8sTUFBTWdjLGNBQWMsR0FDckJwTixXQUFXLENBQUNvTixjQUFELEVBQWlCO0FBQzFCL2EsaUJBQUssRUFBRWpCO0FBRG1CLFdBQWpCLENBRFUsR0FJckIsSUFKTjtBQUtILFNBWE0sQ0FBUDtBQVlIOztBQUNELFlBQU1rZCxNQUFNLEdBQUdoaUIsb0RBQUcsQ0FBQyxLQUFELENBQWxCO0FBQ0EsWUFBTStGLEtBQUssR0FBRy9GLG9EQUFHLEVBQWpCO0FBQ0EsWUFBTWlpQixPQUFPLEdBQUdqaUIsb0RBQUcsQ0FBQyxDQUFDLENBQUMrZ0IsS0FBSCxDQUFuQjs7QUFDQSxVQUFJQSxLQUFKLEVBQVc7QUFDUGxKLGtCQUFVLENBQUMsTUFBTTtBQUNib0ssaUJBQU8sQ0FBQzFuQixLQUFSLEdBQWdCLEtBQWhCO0FBQ0gsU0FGUyxFQUVQd21CLEtBRk8sQ0FBVjtBQUdIOztBQUNELFVBQUluSixPQUFPLElBQUksSUFBZixFQUFxQjtBQUNqQkMsa0JBQVUsQ0FBQyxNQUFNO0FBQ2IsY0FBSSxDQUFDbUssTUFBTSxDQUFDem5CLEtBQVIsSUFBaUIsQ0FBQ3dMLEtBQUssQ0FBQ3hMLEtBQTVCLEVBQW1DO0FBQy9CLGtCQUFNdUssR0FBRyxHQUFHLElBQUl5VCxLQUFKLENBQVcsbUNBQWtDWCxPQUFRLEtBQXJELENBQVo7QUFDQXFKLG1CQUFPLENBQUNuYyxHQUFELENBQVA7QUFDQWlCLGlCQUFLLENBQUN4TCxLQUFOLEdBQWN1SyxHQUFkO0FBQ0g7QUFDSixTQU5TLEVBTVA4UyxPQU5PLENBQVY7QUFPSDs7QUFDRDJKLFVBQUksR0FDQ3JhLElBREwsQ0FDVSxNQUFNO0FBQ1o4YSxjQUFNLENBQUN6bkIsS0FBUCxHQUFlLElBQWY7O0FBQ0EsWUFBSW1JLFFBQVEsQ0FBQ2lCLE1BQVQsSUFBbUIwYyxXQUFXLENBQUMzZCxRQUFRLENBQUNpQixNQUFULENBQWdCcEIsS0FBakIsQ0FBbEMsRUFBMkQ7QUFDdkQ7QUFDQTtBQUNBcUYsa0JBQVEsQ0FBQ2xGLFFBQVEsQ0FBQ2lCLE1BQVQsQ0FBZ0JrSCxNQUFqQixDQUFSO0FBQ0g7QUFDSixPQVJELEVBU0szRixLQVRMLENBU1dKLEdBQUcsSUFBSTtBQUNkbWMsZUFBTyxDQUFDbmMsR0FBRCxDQUFQO0FBQ0FpQixhQUFLLENBQUN4TCxLQUFOLEdBQWN1SyxHQUFkO0FBQ0gsT0FaRDtBQWFBLGFBQU8sTUFBTTtBQUNULFlBQUlrZCxNQUFNLENBQUN6bkIsS0FBUCxJQUFnQjZtQixZQUFwQixFQUFrQztBQUM5QixpQkFBT1csZUFBZSxDQUFDWCxZQUFELEVBQWUxZSxRQUFmLENBQXRCO0FBQ0gsU0FGRCxNQUdLLElBQUlxRCxLQUFLLENBQUN4TCxLQUFOLElBQWV1bUIsY0FBbkIsRUFBbUM7QUFDcEMsaUJBQU9wTixXQUFXLENBQUNvTixjQUFELEVBQWlCO0FBQy9CL2EsaUJBQUssRUFBRUEsS0FBSyxDQUFDeEw7QUFEa0IsV0FBakIsQ0FBbEI7QUFHSCxTQUpJLE1BS0EsSUFBSXNtQixnQkFBZ0IsSUFBSSxDQUFDb0IsT0FBTyxDQUFDMW5CLEtBQWpDLEVBQXdDO0FBQ3pDLGlCQUFPbVosV0FBVyxDQUFDbU4sZ0JBQUQsQ0FBbEI7QUFDSDtBQUNKLE9BWkQ7QUFhSDs7QUEzRWtCLEdBQUQsQ0FBdEI7QUE2RUg7O0FBQ0QsU0FBU2tCLGVBQVQsQ0FBeUI5VSxJQUF6QixFQUErQjtBQUFFMUssT0FBSyxFQUFFO0FBQUV2QyxPQUFGO0FBQU9tRSxTQUFQO0FBQWN5UDtBQUFkO0FBQVQsQ0FBL0IsRUFBb0U7QUFDaEUsUUFBTXJSLEtBQUssR0FBR21SLFdBQVcsQ0FBQ3pHLElBQUQsRUFBTzlJLEtBQVAsRUFBY3lQLFFBQWQsQ0FBekIsQ0FEZ0UsQ0FFaEU7O0FBQ0FyUixPQUFLLENBQUN2QyxHQUFOLEdBQVlBLEdBQVo7QUFDQSxTQUFPdUMsS0FBUDtBQUNIOztBQUVELE1BQU04ZCxXQUFXLEdBQUk5ZCxLQUFELElBQVdBLEtBQUssQ0FBQzVMLElBQU4sQ0FBV3VyQixhQUExQzs7QUFDQSxNQUFNQyxhQUFhLEdBQUc7QUFDbEJ2ZCxNQUFJLEVBQUcsV0FEVztBQUVsQjtBQUNBO0FBQ0E7QUFDQXNkLGVBQWEsRUFBRSxJQUxHO0FBTWxCL2QsT0FBSyxFQUFFO0FBQ0hpZSxXQUFPLEVBQUUsQ0FBQzdtQixNQUFELEVBQVM4bUIsTUFBVCxFQUFpQmxwQixLQUFqQixDQUROO0FBRUhtcEIsV0FBTyxFQUFFLENBQUMvbUIsTUFBRCxFQUFTOG1CLE1BQVQsRUFBaUJscEIsS0FBakIsQ0FGTjtBQUdIb3BCLE9BQUcsRUFBRSxDQUFDaG5CLE1BQUQsRUFBU1QsTUFBVDtBQUhGLEdBTlc7O0FBV2xCcWpCLE9BQUssQ0FBQ2hhLEtBQUQsRUFBUTtBQUFFOE47QUFBRixHQUFSLEVBQW1CO0FBQ3BCLFVBQU12UCxRQUFRLEdBQUc2SyxrQkFBa0IsRUFBbkMsQ0FEb0IsQ0FFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxVQUFNaVYsYUFBYSxHQUFHOWYsUUFBUSxDQUFDME8sR0FBL0IsQ0FQb0IsQ0FRcEI7QUFDQTs7QUFDQSxRQUFJLENBQUNvUixhQUFhLENBQUNDLFFBQW5CLEVBQTZCO0FBQ3pCLGFBQU94USxLQUFLLENBQUM0SCxPQUFiO0FBQ0g7O0FBQ0QsVUFBTWpLLEtBQUssR0FBRyxJQUFJNVksR0FBSixFQUFkO0FBQ0EsVUFBTXFOLElBQUksR0FBRyxJQUFJbk4sR0FBSixFQUFiO0FBQ0EsUUFBSXdyQixPQUFPLEdBQUcsSUFBZDs7QUFDQSxRQUFLbHVCLElBQUwsRUFBc0U7QUFDbEVrTyxjQUFRLENBQUNpZ0IsU0FBVCxHQUFxQi9TLEtBQXJCO0FBQ0g7O0FBQ0QsVUFBTWdHLGNBQWMsR0FBR2xULFFBQVEsQ0FBQ29VLFFBQWhDO0FBQ0EsVUFBTTtBQUFFMkwsY0FBUSxFQUFFO0FBQUV4YixTQUFDLEVBQUV5UCxLQUFMO0FBQVlzQixTQUFDLEVBQUVDLElBQWY7QUFBcUJkLFVBQUUsRUFBRXlMLFFBQXpCO0FBQW1Dak0sU0FBQyxFQUFFO0FBQUVDO0FBQUY7QUFBdEM7QUFBWixRQUEwRTRMLGFBQWhGO0FBQ0EsVUFBTUssZ0JBQWdCLEdBQUdqTSxhQUFhLENBQUMsS0FBRCxDQUF0Qzs7QUFDQTRMLGlCQUFhLENBQUNNLFFBQWQsR0FBeUIsQ0FBQ3ZnQixLQUFELEVBQVFrVCxTQUFSLEVBQW1CQyxNQUFuQixFQUEyQkcsS0FBM0IsRUFBa0NyQixTQUFsQyxLQUFnRDtBQUNyRSxZQUFNOVIsUUFBUSxHQUFHSCxLQUFLLENBQUNJLFNBQXZCO0FBQ0FzVixVQUFJLENBQUMxVixLQUFELEVBQVFrVCxTQUFSLEVBQW1CQyxNQUFuQixFQUEyQjtBQUFFO0FBQTdCLFFBQTBDRSxjQUExQyxDQUFKLENBRnFFLENBR3JFOztBQUNBYyxXQUFLLENBQUNoVSxRQUFRLENBQUNILEtBQVYsRUFBaUJBLEtBQWpCLEVBQXdCa1QsU0FBeEIsRUFBbUNDLE1BQW5DLEVBQTJDaFQsUUFBM0MsRUFBcURrVCxjQUFyRCxFQUFxRUMsS0FBckUsRUFBNEV0VCxLQUFLLENBQUN1VCxZQUFsRixFQUFnR3RCLFNBQWhHLENBQUw7QUFDQXVILDJCQUFxQixDQUFDLE1BQU07QUFDeEJyWixnQkFBUSxDQUFDcWdCLGFBQVQsR0FBeUIsS0FBekI7O0FBQ0EsWUFBSXJnQixRQUFRLENBQUN1RyxDQUFiLEVBQWdCO0FBQ1orWixxRUFBYyxDQUFDdGdCLFFBQVEsQ0FBQ3VHLENBQVYsQ0FBZDtBQUNIOztBQUNELGNBQU1nYSxTQUFTLEdBQUcxZ0IsS0FBSyxDQUFDNEIsS0FBTixJQUFlNUIsS0FBSyxDQUFDNEIsS0FBTixDQUFZK2UsY0FBN0M7O0FBQ0EsWUFBSUQsU0FBSixFQUFlO0FBQ1hFLHlCQUFlLENBQUNGLFNBQUQsRUFBWXZnQixRQUFRLENBQUNpQixNQUFyQixFQUE2QnBCLEtBQTdCLENBQWY7QUFDSDtBQUNKLE9BVG9CLEVBU2xCcVQsY0FUa0IsQ0FBckI7O0FBVUEsVUFBS3BoQixJQUFMLEVBQXNFO0FBQ2xFO0FBQ0F1WCw4QkFBc0IsQ0FBQ3JKLFFBQUQsQ0FBdEI7QUFDSDtBQUNKLEtBbkJEOztBQW9CQThmLGlCQUFhLENBQUNZLFVBQWQsR0FBNEI3Z0IsS0FBRCxJQUFXO0FBQ2xDLFlBQU1HLFFBQVEsR0FBR0gsS0FBSyxDQUFDSSxTQUF2QjtBQUNBc1YsVUFBSSxDQUFDMVYsS0FBRCxFQUFRc2dCLGdCQUFSLEVBQTBCLElBQTFCLEVBQWdDO0FBQUU7QUFBbEMsUUFBK0NqTixjQUEvQyxDQUFKO0FBQ0FtRywyQkFBcUIsQ0FBQyxNQUFNO0FBQ3hCLFlBQUlyWixRQUFRLENBQUMyZ0IsRUFBYixFQUFpQjtBQUNiTCxxRUFBYyxDQUFDdGdCLFFBQVEsQ0FBQzJnQixFQUFWLENBQWQ7QUFDSDs7QUFDRCxjQUFNSixTQUFTLEdBQUcxZ0IsS0FBSyxDQUFDNEIsS0FBTixJQUFlNUIsS0FBSyxDQUFDNEIsS0FBTixDQUFZbWYsZ0JBQTdDOztBQUNBLFlBQUlMLFNBQUosRUFBZTtBQUNYRSx5QkFBZSxDQUFDRixTQUFELEVBQVl2Z0IsUUFBUSxDQUFDaUIsTUFBckIsRUFBNkJwQixLQUE3QixDQUFmO0FBQ0g7O0FBQ0RHLGdCQUFRLENBQUNxZ0IsYUFBVCxHQUF5QixJQUF6QjtBQUNILE9BVG9CLEVBU2xCbk4sY0FUa0IsQ0FBckI7O0FBVUEsVUFBS3BoQixJQUFMLEVBQXNFO0FBQ2xFO0FBQ0F1WCw4QkFBc0IsQ0FBQ3JKLFFBQUQsQ0FBdEI7QUFDSDtBQUNKLEtBakJEOztBQWtCQSxhQUFTMFUsT0FBVCxDQUFpQjdVLEtBQWpCLEVBQXdCO0FBQ3BCO0FBQ0FnaEIsb0JBQWMsQ0FBQ2hoQixLQUFELENBQWQ7O0FBQ0FxZ0IsY0FBUSxDQUFDcmdCLEtBQUQsRUFBUUcsUUFBUixFQUFrQmtULGNBQWxCLENBQVI7QUFDSDs7QUFDRCxhQUFTNE4sVUFBVCxDQUFvQi9xQixNQUFwQixFQUE0QjtBQUN4Qm1YLFdBQUssQ0FBQ2hZLE9BQU4sQ0FBYyxDQUFDMkssS0FBRCxFQUFRM0wsR0FBUixLQUFnQjtBQUMxQixjQUFNZ08sSUFBSSxHQUFHMkUsZ0JBQWdCLENBQUNoSCxLQUFLLENBQUM1TCxJQUFQLENBQTdCOztBQUNBLFlBQUlpTyxJQUFJLEtBQUssQ0FBQ25NLE1BQUQsSUFBVyxDQUFDQSxNQUFNLENBQUNtTSxJQUFELENBQXZCLENBQVIsRUFBd0M7QUFDcEM2ZSx5QkFBZSxDQUFDN3NCLEdBQUQsQ0FBZjtBQUNIO0FBQ0osT0FMRDtBQU1IOztBQUNELGFBQVM2c0IsZUFBVCxDQUF5QjdzQixHQUF6QixFQUE4QjtBQUMxQixZQUFNa1osTUFBTSxHQUFHRixLQUFLLENBQUM5WSxHQUFOLENBQVVGLEdBQVYsQ0FBZjs7QUFDQSxVQUFJLENBQUM4ckIsT0FBRCxJQUFZNVMsTUFBTSxDQUFDblosSUFBUCxLQUFnQityQixPQUFPLENBQUMvckIsSUFBeEMsRUFBOEM7QUFDMUN5Z0IsZUFBTyxDQUFDdEgsTUFBRCxDQUFQO0FBQ0gsT0FGRCxNQUdLLElBQUk0UyxPQUFKLEVBQWE7QUFDZDtBQUNBO0FBQ0FhLHNCQUFjLENBQUNiLE9BQUQsQ0FBZDtBQUNIOztBQUNEOVMsV0FBSyxDQUFDelosTUFBTixDQUFhUyxHQUFiO0FBQ0F5TixVQUFJLENBQUNsTyxNQUFMLENBQVlTLEdBQVo7QUFDSCxLQXJGbUIsQ0FzRnBCOzs7QUFDQXVrQixTQUFLLENBQUMsTUFBTSxDQUFDaFgsS0FBSyxDQUFDaWUsT0FBUCxFQUFnQmplLEtBQUssQ0FBQ21lLE9BQXRCLENBQVAsRUFBdUMsQ0FBQyxDQUFDRixPQUFELEVBQVVFLE9BQVYsQ0FBRCxLQUF3QjtBQUNoRUYsYUFBTyxJQUFJb0IsVUFBVSxDQUFDNWUsSUFBSSxJQUFJOGUsT0FBTyxDQUFDdEIsT0FBRCxFQUFVeGQsSUFBVixDQUFoQixDQUFyQjtBQUNBMGQsYUFBTyxJQUFJa0IsVUFBVSxDQUFDNWUsSUFBSSxJQUFJLENBQUM4ZSxPQUFPLENBQUNwQixPQUFELEVBQVUxZCxJQUFWLENBQWpCLENBQXJCO0FBQ0gsS0FISSxFQUlMO0FBQ0E7QUFBRTJXLFdBQUssRUFBRSxNQUFUO0FBQWlCRCxVQUFJLEVBQUU7QUFBdkIsS0FMSyxDQUFMLENBdkZvQixDQTZGcEI7O0FBQ0EsUUFBSXFJLGVBQWUsR0FBRyxJQUF0Qjs7QUFDQSxVQUFNQyxZQUFZLEdBQUcsTUFBTTtBQUN2QjtBQUNBLFVBQUlELGVBQWUsSUFBSSxJQUF2QixFQUE2QjtBQUN6Qi9ULGFBQUssQ0FBQzdZLEdBQU4sQ0FBVTRzQixlQUFWLEVBQTJCRSxhQUFhLENBQUNuaEIsUUFBUSxDQUFDeVMsT0FBVixDQUF4QztBQUNIO0FBQ0osS0FMRDs7QUFNQTZILGFBQVMsQ0FBQzRHLFlBQUQsQ0FBVDtBQUNBRSxhQUFTLENBQUNGLFlBQUQsQ0FBVDtBQUNBM0csbUJBQWUsQ0FBQyxNQUFNO0FBQ2xCck4sV0FBSyxDQUFDaFksT0FBTixDQUFja1ksTUFBTSxJQUFJO0FBQ3BCLGNBQU07QUFBRXFGLGlCQUFGO0FBQVcyQjtBQUFYLFlBQXdCcFUsUUFBOUI7QUFDQSxjQUFNSCxLQUFLLEdBQUdzaEIsYUFBYSxDQUFDMU8sT0FBRCxDQUEzQjs7QUFDQSxZQUFJckYsTUFBTSxDQUFDblosSUFBUCxLQUFnQjRMLEtBQUssQ0FBQzVMLElBQTFCLEVBQWdDO0FBQzVCO0FBQ0E0c0Isd0JBQWMsQ0FBQ2hoQixLQUFELENBQWQsQ0FGNEIsQ0FHNUI7O0FBQ0EsZ0JBQU04Z0IsRUFBRSxHQUFHOWdCLEtBQUssQ0FBQ0ksU0FBTixDQUFnQjBnQixFQUEzQjtBQUNBQSxZQUFFLElBQUl0SCxxQkFBcUIsQ0FBQ3NILEVBQUQsRUFBS3ZNLFFBQUwsQ0FBM0I7QUFDQTtBQUNIOztBQUNETSxlQUFPLENBQUN0SCxNQUFELENBQVA7QUFDSCxPQVpEO0FBYUgsS0FkYyxDQUFmO0FBZUEsV0FBTyxNQUFNO0FBQ1Q2VCxxQkFBZSxHQUFHLElBQWxCOztBQUNBLFVBQUksQ0FBQzFSLEtBQUssQ0FBQzRILE9BQVgsRUFBb0I7QUFDaEIsZUFBTyxJQUFQO0FBQ0g7O0FBQ0QsWUFBTWpHLFFBQVEsR0FBRzNCLEtBQUssQ0FBQzRILE9BQU4sRUFBakI7QUFDQSxZQUFNa0ssUUFBUSxHQUFHblEsUUFBUSxDQUFDLENBQUQsQ0FBekI7O0FBQ0EsVUFBSUEsUUFBUSxDQUFDOWQsTUFBVCxHQUFrQixDQUF0QixFQUF5QjtBQUNyQixZQUFLdEIsSUFBTCxFQUE2QztBQUN6QzhHLGNBQUksQ0FBRSx1REFBRixDQUFKO0FBQ0g7O0FBQ0RvbkIsZUFBTyxHQUFHLElBQVY7QUFDQSxlQUFPOU8sUUFBUDtBQUNILE9BTkQsTUFPSyxJQUFJLENBQUNRLE9BQU8sQ0FBQzJQLFFBQUQsQ0FBUixJQUNKLEVBQUVBLFFBQVEsQ0FBQ3hSLFNBQVQsR0FBcUI7QUFBRTtBQUF6QixXQUNHLEVBQUV3UixRQUFRLENBQUN4UixTQUFULEdBQXFCO0FBQUk7QUFBM0IsT0FGSCxFQUVnRDtBQUNqRG1RLGVBQU8sR0FBRyxJQUFWO0FBQ0EsZUFBT3FCLFFBQVA7QUFDSDs7QUFDRCxVQUFJeGhCLEtBQUssR0FBR3NoQixhQUFhLENBQUNFLFFBQUQsQ0FBekI7QUFDQSxZQUFNOVcsSUFBSSxHQUFHMUssS0FBSyxDQUFDNUwsSUFBbkIsQ0FyQlMsQ0FzQlQ7QUFDQTs7QUFDQSxZQUFNaU8sSUFBSSxHQUFHMkUsZ0JBQWdCLENBQUNrWCxjQUFjLENBQUNsZSxLQUFELENBQWQsR0FDeEJBLEtBQUssQ0FBQzVMLElBQU4sQ0FBV21yQixlQUFYLElBQThCLEVBRE4sR0FFeEI3VSxJQUZ1QixDQUE3QjtBQUdBLFlBQU07QUFBRW1WLGVBQUY7QUFBV0UsZUFBWDtBQUFvQkM7QUFBcEIsVUFBNEJwZSxLQUFsQzs7QUFDQSxVQUFLaWUsT0FBTyxLQUFLLENBQUN4ZCxJQUFELElBQVMsQ0FBQzhlLE9BQU8sQ0FBQ3RCLE9BQUQsRUFBVXhkLElBQVYsQ0FBdEIsQ0FBUixJQUNDMGQsT0FBTyxJQUFJMWQsSUFBWCxJQUFtQjhlLE9BQU8sQ0FBQ3BCLE9BQUQsRUFBVTFkLElBQVYsQ0FEL0IsRUFDaUQ7QUFDN0M4ZCxlQUFPLEdBQUduZ0IsS0FBVjtBQUNBLGVBQU93aEIsUUFBUDtBQUNIOztBQUNELFlBQU1udEIsR0FBRyxHQUFHMkwsS0FBSyxDQUFDM0wsR0FBTixJQUFhLElBQWIsR0FBb0JxVyxJQUFwQixHQUEyQjFLLEtBQUssQ0FBQzNMLEdBQTdDO0FBQ0EsWUFBTW90QixXQUFXLEdBQUdwVSxLQUFLLENBQUM5WSxHQUFOLENBQVVGLEdBQVYsQ0FBcEIsQ0FsQ1MsQ0FtQ1Q7O0FBQ0EsVUFBSTJMLEtBQUssQ0FBQzJTLEVBQVYsRUFBYztBQUNWM1MsYUFBSyxHQUFHMFEsVUFBVSxDQUFDMVEsS0FBRCxDQUFsQjs7QUFDQSxZQUFJd2hCLFFBQVEsQ0FBQ3hSLFNBQVQsR0FBcUI7QUFBSTtBQUE3QixVQUE2QztBQUN6Q3dSLG9CQUFRLENBQUMvTSxTQUFULEdBQXFCelUsS0FBckI7QUFDSDtBQUNKLE9BekNRLENBMENUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBb2hCLHFCQUFlLEdBQUcvc0IsR0FBbEI7O0FBQ0EsVUFBSW90QixXQUFKLEVBQWlCO0FBQ2I7QUFDQXpoQixhQUFLLENBQUMyUyxFQUFOLEdBQVc4TyxXQUFXLENBQUM5TyxFQUF2QjtBQUNBM1MsYUFBSyxDQUFDSSxTQUFOLEdBQWtCcWhCLFdBQVcsQ0FBQ3JoQixTQUE5Qjs7QUFDQSxZQUFJSixLQUFLLENBQUNpUixVQUFWLEVBQXNCO0FBQ2xCO0FBQ0FvTCw0QkFBa0IsQ0FBQ3JjLEtBQUQsRUFBUUEsS0FBSyxDQUFDaVIsVUFBZCxDQUFsQjtBQUNILFNBUFksQ0FRYjs7O0FBQ0FqUixhQUFLLENBQUNnUSxTQUFOLElBQW1CO0FBQUk7QUFBdkIsU0FUYSxDQVViOztBQUNBbE8sWUFBSSxDQUFDbE8sTUFBTCxDQUFZUyxHQUFaO0FBQ0F5TixZQUFJLENBQUNqTixHQUFMLENBQVNSLEdBQVQ7QUFDSCxPQWJELE1BY0s7QUFDRHlOLFlBQUksQ0FBQ2pOLEdBQUwsQ0FBU1IsR0FBVCxFQURDLENBRUQ7O0FBQ0EsWUFBSTJyQixHQUFHLElBQUlsZSxJQUFJLENBQUM3SCxJQUFMLEdBQVl5bkIsUUFBUSxDQUFDMUIsR0FBRCxFQUFNLEVBQU4sQ0FBL0IsRUFBMEM7QUFDdENrQix5QkFBZSxDQUFDcGYsSUFBSSxDQUFDYyxNQUFMLEdBQWMxSCxJQUFkLEdBQXFCbEQsS0FBdEIsQ0FBZjtBQUNIO0FBQ0osT0FwRVEsQ0FxRVQ7OztBQUNBZ0ksV0FBSyxDQUFDZ1EsU0FBTixJQUFtQjtBQUFJO0FBQXZCO0FBQ0FtUSxhQUFPLEdBQUduZ0IsS0FBVjtBQUNBLGFBQU93aEIsUUFBUDtBQUNILEtBekVEO0FBMEVIOztBQTNNaUIsQ0FBdEIsQyxDQTZNQTtBQUNBOztBQUNBLE1BQU1HLFNBQVMsR0FBRy9CLGFBQWxCOztBQUNBLFNBQVN1QixPQUFULENBQWlCUyxPQUFqQixFQUEwQnZmLElBQTFCLEVBQWdDO0FBQzVCLE1BQUkvTSxvREFBTyxDQUFDc3NCLE9BQUQsQ0FBWCxFQUFzQjtBQUNsQixXQUFPQSxPQUFPLENBQUNwUixJQUFSLENBQWM5TCxDQUFELElBQU95YyxPQUFPLENBQUN6YyxDQUFELEVBQUlyQyxJQUFKLENBQTNCLENBQVA7QUFDSCxHQUZELE1BR0ssSUFBSUoscURBQVEsQ0FBQzJmLE9BQUQsQ0FBWixFQUF1QjtBQUN4QixXQUFPQSxPQUFPLENBQUM1SCxLQUFSLENBQWMsR0FBZCxFQUFtQnJVLE9BQW5CLENBQTJCdEQsSUFBM0IsSUFBbUMsQ0FBQyxDQUEzQztBQUNILEdBRkksTUFHQSxJQUFJdWYsT0FBTyxDQUFDQyxJQUFaLEVBQWtCO0FBQ25CLFdBQU9ELE9BQU8sQ0FBQ0MsSUFBUixDQUFheGYsSUFBYixDQUFQO0FBQ0g7QUFDRDs7O0FBQ0EsU0FBTyxLQUFQO0FBQ0g7O0FBQ0QsU0FBU3lmLFdBQVQsQ0FBcUJqWixJQUFyQixFQUEyQjFVLE1BQTNCLEVBQW1DO0FBQy9CNHRCLHVCQUFxQixDQUFDbFosSUFBRCxFQUFPO0FBQUk7QUFBWCxJQUE0QjFVLE1BQTVCLENBQXJCO0FBQ0g7O0FBQ0QsU0FBUzZ0QixhQUFULENBQXVCblosSUFBdkIsRUFBNkIxVSxNQUE3QixFQUFxQztBQUNqQzR0Qix1QkFBcUIsQ0FBQ2xaLElBQUQsRUFBTztBQUFLO0FBQVosSUFBK0IxVSxNQUEvQixDQUFyQjtBQUNIOztBQUNELFNBQVM0dEIscUJBQVQsQ0FBK0JsWixJQUEvQixFQUFxQ3pVLElBQXJDLEVBQTJDRCxNQUFNLEdBQUcrakIsZUFBcEQsRUFBcUU7QUFDakU7QUFDQTtBQUNBO0FBQ0EsUUFBTStKLFdBQVcsR0FBR3BaLElBQUksQ0FBQ3FaLEtBQUwsS0FDZnJaLElBQUksQ0FBQ3FaLEtBQUwsR0FBYSxNQUFNO0FBQ2hCO0FBQ0EsUUFBSS9CLE9BQU8sR0FBR2hzQixNQUFkOztBQUNBLFdBQU9nc0IsT0FBUCxFQUFnQjtBQUNaLFVBQUlBLE9BQU8sQ0FBQ0ssYUFBWixFQUEyQjtBQUN2QjtBQUNIOztBQUNETCxhQUFPLEdBQUdBLE9BQU8sQ0FBQy9lLE1BQWxCO0FBQ0g7O0FBQ0R5SCxRQUFJO0FBQ1AsR0FYZSxDQUFwQjs7QUFZQXNaLFlBQVUsQ0FBQy90QixJQUFELEVBQU82dEIsV0FBUCxFQUFvQjl0QixNQUFwQixDQUFWLENBaEJpRSxDQWlCakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFJQSxNQUFKLEVBQVk7QUFDUixRQUFJZ3NCLE9BQU8sR0FBR2hzQixNQUFNLENBQUNpTixNQUFyQjs7QUFDQSxXQUFPK2UsT0FBTyxJQUFJQSxPQUFPLENBQUMvZSxNQUExQixFQUFrQztBQUM5QixVQUFJMGMsV0FBVyxDQUFDcUMsT0FBTyxDQUFDL2UsTUFBUixDQUFlcEIsS0FBaEIsQ0FBZixFQUF1QztBQUNuQ29pQiw2QkFBcUIsQ0FBQ0gsV0FBRCxFQUFjN3RCLElBQWQsRUFBb0JELE1BQXBCLEVBQTRCZ3NCLE9BQTVCLENBQXJCO0FBQ0g7O0FBQ0RBLGFBQU8sR0FBR0EsT0FBTyxDQUFDL2UsTUFBbEI7QUFDSDtBQUNKO0FBQ0o7O0FBQ0QsU0FBU2doQixxQkFBVCxDQUErQnZaLElBQS9CLEVBQXFDelUsSUFBckMsRUFBMkNELE1BQTNDLEVBQW1Ea3VCLGFBQW5ELEVBQWtFO0FBQzlEO0FBQ0E7QUFDQSxRQUFNQyxRQUFRLEdBQUdILFVBQVUsQ0FBQy90QixJQUFELEVBQU95VSxJQUFQLEVBQWF3WixhQUFiLEVBQTRCO0FBQUs7QUFBakMsR0FBM0I7QUFDQUUsYUFBVyxDQUFDLE1BQU07QUFDZDFNLHVEQUFNLENBQUN3TSxhQUFhLENBQUNqdUIsSUFBRCxDQUFkLEVBQXNCa3VCLFFBQXRCLENBQU47QUFDSCxHQUZVLEVBRVJudUIsTUFGUSxDQUFYO0FBR0g7O0FBQ0QsU0FBUzZzQixjQUFULENBQXdCaGhCLEtBQXhCLEVBQStCO0FBQzNCLE1BQUlnUSxTQUFTLEdBQUdoUSxLQUFLLENBQUNnUSxTQUF0Qjs7QUFDQSxNQUFJQSxTQUFTLEdBQUc7QUFBSTtBQUFwQixJQUF1RDtBQUNuREEsZUFBUyxJQUFJO0FBQUk7QUFBakI7QUFDSDs7QUFDRCxNQUFJQSxTQUFTLEdBQUc7QUFBSTtBQUFwQixJQUFnRDtBQUM1Q0EsZUFBUyxJQUFJO0FBQUk7QUFBakI7QUFDSDs7QUFDRGhRLE9BQUssQ0FBQ2dRLFNBQU4sR0FBa0JBLFNBQWxCO0FBQ0g7O0FBQ0QsU0FBU3NSLGFBQVQsQ0FBdUJ0aEIsS0FBdkIsRUFBOEI7QUFDMUIsU0FBT0EsS0FBSyxDQUFDZ1EsU0FBTixHQUFrQjtBQUFJO0FBQXRCLElBQXVDaFEsS0FBSyxDQUFDeVUsU0FBN0MsR0FBeUR6VSxLQUFoRTtBQUNIOztBQUVELFNBQVNtaUIsVUFBVCxDQUFvQi90QixJQUFwQixFQUEwQnlVLElBQTFCLEVBQWdDMVUsTUFBTSxHQUFHK2pCLGVBQXpDLEVBQTBEc0ssT0FBTyxHQUFHLEtBQXBFLEVBQTJFO0FBQ3ZFLE1BQUlydUIsTUFBSixFQUFZO0FBQ1IsVUFBTWdwQixLQUFLLEdBQUdocEIsTUFBTSxDQUFDQyxJQUFELENBQU4sS0FBaUJELE1BQU0sQ0FBQ0MsSUFBRCxDQUFOLEdBQWUsRUFBaEMsQ0FBZCxDQURRLENBRVI7QUFDQTtBQUNBOztBQUNBLFVBQU02dEIsV0FBVyxHQUFHcFosSUFBSSxDQUFDNFosS0FBTCxLQUNmNVosSUFBSSxDQUFDNFosS0FBTCxHQUFhLENBQUMsR0FBRzNyQixJQUFKLEtBQWE7QUFDdkIsVUFBSTNDLE1BQU0sQ0FBQzJoQixXQUFYLEVBQXdCO0FBQ3BCO0FBQ0gsT0FIc0IsQ0FJdkI7QUFDQTs7O0FBQ0EvaEIsb0VBQWEsR0FOVSxDQU92QjtBQUNBO0FBQ0E7O0FBQ0EydUIsd0JBQWtCLENBQUN2dUIsTUFBRCxDQUFsQjtBQUNBLFlBQU0rQyxHQUFHLEdBQUd1TCwwQkFBMEIsQ0FBQ29HLElBQUQsRUFBTzFVLE1BQVAsRUFBZUMsSUFBZixFQUFxQjBDLElBQXJCLENBQXRDO0FBQ0E0ckIsd0JBQWtCLENBQUMsSUFBRCxDQUFsQjtBQUNBcHZCLG9FQUFhO0FBQ2IsYUFBTzRELEdBQVA7QUFDSCxLQWhCZSxDQUFwQjs7QUFpQkEsUUFBSXNyQixPQUFKLEVBQWE7QUFDVHJGLFdBQUssQ0FBQ3dGLE9BQU4sQ0FBY1YsV0FBZDtBQUNILEtBRkQsTUFHSztBQUNEOUUsV0FBSyxDQUFDL3BCLElBQU4sQ0FBVzZ1QixXQUFYO0FBQ0g7O0FBQ0QsV0FBT0EsV0FBUDtBQUNILEdBN0JELE1BOEJLLElBQUtod0IsSUFBTCxFQUE2QztBQUM5QyxVQUFNMndCLE9BQU8sR0FBRzNXLHlEQUFZLENBQUMzSixnQkFBZ0IsQ0FBQ2xPLElBQUQsQ0FBaEIsQ0FBdUI4WixPQUF2QixDQUErQixRQUEvQixFQUF5QyxFQUF6QyxDQUFELENBQTVCO0FBQ0FuVixRQUFJLENBQUUsR0FBRTZwQixPQUFRLDhEQUFYLEdBQ0EsbUJBREEsR0FFQSx3RUFGQSxJQUdDLG1FQUFELEdBQ1EseUNBSlIsQ0FBRCxDQUFKO0FBTUg7QUFDSjs7QUFDRCxNQUFNQyxVQUFVLEdBQUlDLFNBQUQsSUFBZSxDQUFDamEsSUFBRCxFQUFPMVUsTUFBTSxHQUFHK2pCLGVBQWhCLEtBQ2xDO0FBQ0EsQ0FBQyxDQUFDNksscUJBQUQsSUFBMEJELFNBQVMsS0FBSztBQUFLO0FBQTlDLEtBQ0lYLFVBQVUsQ0FBQ1csU0FBRCxFQUFZamEsSUFBWixFQUFrQjFVLE1BQWxCLENBSGQ7O0FBSUEsTUFBTTZ1QixhQUFhLEdBQUdILFVBQVUsQ0FBQztBQUFLO0FBQU4sQ0FBaEM7QUFDQSxNQUFNcEksU0FBUyxHQUFHb0ksVUFBVSxDQUFDO0FBQUk7QUFBTCxDQUE1QjtBQUNBLE1BQU1JLGNBQWMsR0FBR0osVUFBVSxDQUFDO0FBQUs7QUFBTixDQUFqQztBQUNBLE1BQU10QixTQUFTLEdBQUdzQixVQUFVLENBQUM7QUFBSTtBQUFMLENBQTVCO0FBQ0EsTUFBTW5JLGVBQWUsR0FBR21JLFVBQVUsQ0FBQztBQUFNO0FBQVAsQ0FBbEM7QUFDQSxNQUFNTixXQUFXLEdBQUdNLFVBQVUsQ0FBQztBQUFLO0FBQU4sQ0FBOUI7QUFDQSxNQUFNSyxnQkFBZ0IsR0FBR0wsVUFBVSxDQUFDO0FBQUs7QUFBTixDQUFuQztBQUNBLE1BQU1NLGlCQUFpQixHQUFHTixVQUFVLENBQUM7QUFBTTtBQUFQLENBQXBDO0FBQ0EsTUFBTU8sZUFBZSxHQUFHUCxVQUFVLENBQUM7QUFBTTtBQUFQLENBQWxDOztBQUNBLFNBQVNRLGVBQVQsQ0FBeUJ4YSxJQUF6QixFQUErQjFVLE1BQU0sR0FBRytqQixlQUF4QyxFQUF5RDtBQUNyRGlLLFlBQVUsQ0FBQztBQUFLO0FBQU4sSUFBNEJ0WixJQUE1QixFQUFrQzFVLE1BQWxDLENBQVY7QUFDSDs7QUFFRCxTQUFTbXZCLHNCQUFULEdBQWtDO0FBQzlCLFFBQU1qVyxLQUFLLEdBQUd0WCxNQUFNLENBQUM4VSxNQUFQLENBQWMsSUFBZCxDQUFkO0FBQ0EsU0FBTyxDQUFDelcsSUFBRCxFQUFPQyxHQUFQLEtBQWU7QUFDbEIsUUFBSWdaLEtBQUssQ0FBQ2haLEdBQUQsQ0FBVCxFQUFnQjtBQUNaMEUsVUFBSSxDQUFFLEdBQUUzRSxJQUFLLGNBQWFDLEdBQUksMkJBQTBCZ1osS0FBSyxDQUFDaFosR0FBRCxDQUFNLEdBQS9ELENBQUo7QUFDSCxLQUZELE1BR0s7QUFDRGdaLFdBQUssQ0FBQ2haLEdBQUQsQ0FBTCxHQUFhRCxJQUFiO0FBQ0g7QUFDSixHQVBEO0FBUUg7O0FBQ0QsSUFBSW12QixpQkFBaUIsR0FBRyxJQUF4Qjs7QUFDQSxTQUFTQyxZQUFULENBQXNCcmpCLFFBQXRCLEVBQWdDO0FBQzVCLFFBQU01TixPQUFPLEdBQUdreEIsb0JBQW9CLENBQUN0akIsUUFBRCxDQUFwQztBQUNBLFFBQU15WixVQUFVLEdBQUd6WixRQUFRLENBQUNyRCxLQUE1QjtBQUNBLFFBQU0rUixHQUFHLEdBQUcxTyxRQUFRLENBQUMwTyxHQUFyQixDQUg0QixDQUk1Qjs7QUFDQTBVLG1CQUFpQixHQUFHLEtBQXBCLENBTDRCLENBTTVCO0FBQ0E7O0FBQ0EsTUFBSWh4QixPQUFPLENBQUNteEIsWUFBWixFQUEwQjtBQUN0QnhHLFlBQVEsQ0FBQzNxQixPQUFPLENBQUNteEIsWUFBVCxFQUF1QnZqQixRQUF2QixFQUFpQztBQUFLO0FBQXRDLEtBQVI7QUFDSDs7QUFDRCxRQUFNO0FBQ047QUFDQXlQLFFBQUksRUFBRStULFdBRkE7QUFFYWxrQixZQUFRLEVBQUVta0IsZUFGdkI7QUFFd0NDLFdBRnhDO0FBRWlEakwsU0FBSyxFQUFFa0wsWUFGeEQ7QUFFc0U3TCxXQUFPLEVBQUU4TCxjQUYvRTtBQUUrRjFMLFVBQU0sRUFBRTJMLGFBRnZHO0FBR047QUFDQUMsV0FKTTtBQUlHQyxlQUpIO0FBSWdCQyxXQUpoQjtBQUl5QkMsZ0JBSnpCO0FBSXVDQyxXQUp2QztBQUlnREMsYUFKaEQ7QUFJMkRDLGVBSjNEO0FBSXdFQyxpQkFKeEU7QUFJdUZDLGlCQUp2RjtBQUlzR0MsYUFKdEc7QUFJaUhDLGFBSmpIO0FBSTRIeGMsVUFKNUg7QUFJb0l5YyxpQkFKcEk7QUFJbUpDLG1CQUpuSjtBQUlvS0MsaUJBSnBLO0FBSW1MQyxrQkFKbkw7QUFLTjtBQUNBQyxVQU5NO0FBTUVsVixnQkFORjtBQU9OO0FBQ0FtVixjQVJNO0FBUU1DLGNBUk47QUFRa0JDO0FBUmxCLE1BUThCNXlCLE9BUnBDO0FBU0EsUUFBTTZ5Qix3QkFBd0IsR0FBSW56QixLQUFELEdBQTBDcXhCLHNCQUFzQixFQUFoRSxHQUFxRSxDQUF0Rzs7QUFDQSxNQUFLcnhCLElBQUwsRUFBNkM7QUFDekMsVUFBTSxDQUFDK1osWUFBRCxJQUFpQjdMLFFBQVEsQ0FBQzZMLFlBQWhDOztBQUNBLFFBQUlBLFlBQUosRUFBa0I7QUFDZCxXQUFLLE1BQU0zWCxHQUFYLElBQWtCMlgsWUFBbEIsRUFBZ0M7QUFDNUJvWixnQ0FBd0IsQ0FBQztBQUFRO0FBQVQsVUFBc0Ivd0IsR0FBdEIsQ0FBeEI7QUFDSDtBQUNKO0FBQ0osR0E1QjJCLENBNkI1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBSTJ2QixhQUFKLEVBQW1CO0FBQ2ZxQixxQkFBaUIsQ0FBQ3JCLGFBQUQsRUFBZ0JuVixHQUFoQixFQUFxQnVXLHdCQUFyQixDQUFqQjtBQUNIOztBQUNELE1BQUl2QixPQUFKLEVBQWE7QUFDVCxTQUFLLE1BQU14dkIsR0FBWCxJQUFrQnd2QixPQUFsQixFQUEyQjtBQUN2QixZQUFNeUIsYUFBYSxHQUFHekIsT0FBTyxDQUFDeHZCLEdBQUQsQ0FBN0I7O0FBQ0EsVUFBSStOLHVEQUFZLENBQUNrakIsYUFBRCxDQUFoQixFQUFpQztBQUM3QjtBQUNBO0FBQ0EsWUFBS3J6QixJQUFMLEVBQTZDO0FBQ3pDOEQsZ0JBQU0sQ0FBQ3d2QixjQUFQLENBQXNCMVcsR0FBdEIsRUFBMkJ4YSxHQUEzQixFQUFnQztBQUM1QjJELGlCQUFLLEVBQUVzdEIsYUFBYSxDQUFDMWdCLElBQWQsQ0FBbUJnVixVQUFuQixDQURxQjtBQUU1QjRMLHdCQUFZLEVBQUUsSUFGYztBQUc1QkMsc0JBQVUsRUFBRSxJQUhnQjtBQUk1QkMsb0JBQVEsRUFBRTtBQUprQixXQUFoQztBQU1ILFNBUEQsTUFRSyxFQUVKOztBQUNELFlBQUt6ekIsSUFBTCxFQUE2QztBQUN6Q216QixrQ0FBd0IsQ0FBQztBQUFVO0FBQVgsWUFBMEIvd0IsR0FBMUIsQ0FBeEI7QUFDSDtBQUNKLE9BakJELE1Ba0JLLElBQUtwQyxJQUFMLEVBQTZDO0FBQzlDOEcsWUFBSSxDQUFFLFdBQVUxRSxHQUFJLGVBQWMsT0FBT2l4QixhQUFjLGlDQUFsRCxHQUNBLDJDQURELENBQUo7QUFFSDtBQUNKO0FBQ0o7O0FBQ0QsTUFBSTNCLFdBQUosRUFBaUI7QUFDYixRQUFLMXhCLEtBQUQsSUFBMkMsQ0FBQ21RLHVEQUFZLENBQUN1aEIsV0FBRCxDQUE1RCxFQUEyRTtBQUN2RTVxQixVQUFJLENBQUUsc0NBQUQsR0FDQSw0Q0FERCxDQUFKO0FBRUg7O0FBQ0QsVUFBTTZXLElBQUksR0FBRytULFdBQVcsQ0FBQzVwQixJQUFaLENBQWlCNmYsVUFBakIsRUFBNkJBLFVBQTdCLENBQWI7O0FBQ0EsUUFBSzNuQixLQUFELElBQTJDeVEsc0RBQVcsQ0FBQ2tOLElBQUQsQ0FBMUQsRUFBa0U7QUFDOUQ3VyxVQUFJLENBQUUsa0VBQUQsR0FDQSxnRUFEQSxHQUVBLDZCQUZELENBQUo7QUFHSDs7QUFDRCxRQUFJLENBQUNraEIscURBQVUsQ0FBQ3JLLElBQUQsQ0FBZixFQUF1QjtBQUNsQjNkLFdBQUQsSUFBMkM4RyxJQUFJLENBQUUsaUNBQUYsQ0FBL0M7QUFDSCxLQUZELE1BR0s7QUFDRG9ILGNBQVEsQ0FBQ3lQLElBQVQsR0FBZ0J6WCx5REFBUSxDQUFDeVgsSUFBRCxDQUF4Qjs7QUFDQSxVQUFLM2QsSUFBTCxFQUE2QztBQUN6QyxhQUFLLE1BQU1vQyxHQUFYLElBQWtCdWIsSUFBbEIsRUFBd0I7QUFDcEJ3VixrQ0FBd0IsQ0FBQztBQUFPO0FBQVIsWUFBb0Ivd0IsR0FBcEIsQ0FBeEIsQ0FEb0IsQ0FFcEI7O0FBQ0EsY0FBSUEsR0FBRyxDQUFDLENBQUQsQ0FBSCxLQUFXLEdBQVgsSUFBa0JBLEdBQUcsQ0FBQyxDQUFELENBQUgsS0FBVyxHQUFqQyxFQUFzQztBQUNsQzBCLGtCQUFNLENBQUN3dkIsY0FBUCxDQUFzQjFXLEdBQXRCLEVBQTJCeGEsR0FBM0IsRUFBZ0M7QUFDNUJteEIsMEJBQVksRUFBRSxJQURjO0FBRTVCQyx3QkFBVSxFQUFFLElBRmdCO0FBRzVCbHhCLGlCQUFHLEVBQUUsTUFBTXFiLElBQUksQ0FBQ3ZiLEdBQUQsQ0FIYTtBQUk1QkcsaUJBQUcsRUFBRXFMLDZDQUFJQTtBQUptQixhQUFoQztBQU1IO0FBQ0o7QUFDSjtBQUNKO0FBQ0osR0FqRzJCLENBa0c1Qjs7O0FBQ0EwakIsbUJBQWlCLEdBQUcsSUFBcEI7O0FBQ0EsTUFBSUssZUFBSixFQUFxQjtBQUNqQixTQUFLLE1BQU12dkIsR0FBWCxJQUFrQnV2QixlQUFsQixFQUFtQztBQUMvQixZQUFNK0IsR0FBRyxHQUFHL0IsZUFBZSxDQUFDdnZCLEdBQUQsQ0FBM0I7QUFDQSxZQUFNRSxHQUFHLEdBQUc2Tix1REFBWSxDQUFDdWpCLEdBQUQsQ0FBWixHQUNOQSxHQUFHLENBQUMvZ0IsSUFBSixDQUFTZ1YsVUFBVCxFQUFxQkEsVUFBckIsQ0FETSxHQUVOeFgsdURBQVksQ0FBQ3VqQixHQUFHLENBQUNweEIsR0FBTCxDQUFaLEdBQ0lveEIsR0FBRyxDQUFDcHhCLEdBQUosQ0FBUXFRLElBQVIsQ0FBYWdWLFVBQWIsRUFBeUJBLFVBQXpCLENBREosR0FFSS9aLDZDQUpWOztBQUtBLFVBQUs1TixLQUFELElBQTJDc0MsR0FBRyxLQUFLc0wsNkNBQXZELEVBQTZEO0FBQ3pEOUcsWUFBSSxDQUFFLHNCQUFxQjFFLEdBQUksa0JBQTNCLENBQUo7QUFDSDs7QUFDRCxZQUFNRyxHQUFHLEdBQUcsQ0FBQzROLHVEQUFZLENBQUN1akIsR0FBRCxDQUFiLElBQXNCdmpCLHVEQUFZLENBQUN1akIsR0FBRyxDQUFDbnhCLEdBQUwsQ0FBbEMsR0FDTm14QixHQUFHLENBQUNueEIsR0FBSixDQUFRb1EsSUFBUixDQUFhZ1YsVUFBYixDQURNLEdBRUwzbkIsS0FBRCxHQUNJLE1BQU07QUFDSjhHLFlBQUksQ0FBRSw4Q0FBNkMxRSxHQUFJLGdCQUFuRCxDQUFKO0FBQ0gsT0FISCxHQUlJd0wsQ0FOVjtBQU9BLFlBQU1pWSxDQUFDLEdBQUdyWSxRQUFRLENBQUM7QUFDZmxMLFdBRGU7QUFFZkM7QUFGZSxPQUFELENBQWxCO0FBSUF1QixZQUFNLENBQUN3dkIsY0FBUCxDQUFzQjFXLEdBQXRCLEVBQTJCeGEsR0FBM0IsRUFBZ0M7QUFDNUJveEIsa0JBQVUsRUFBRSxJQURnQjtBQUU1QkQsb0JBQVksRUFBRSxJQUZjO0FBRzVCanhCLFdBQUcsRUFBRSxNQUFNdWpCLENBQUMsQ0FBQzlmLEtBSGU7QUFJNUJ4RCxXQUFHLEVBQUVnRixDQUFDLElBQUtzZSxDQUFDLENBQUM5ZixLQUFGLEdBQVV3QjtBQUpPLE9BQWhDOztBQU1BLFVBQUt2SCxJQUFMLEVBQTZDO0FBQ3pDbXpCLGdDQUF3QixDQUFDO0FBQVc7QUFBWixVQUE0Qi93QixHQUE1QixDQUF4QjtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxNQUFJeXZCLFlBQUosRUFBa0I7QUFDZCxTQUFLLE1BQU16dkIsR0FBWCxJQUFrQnl2QixZQUFsQixFQUFnQztBQUM1QjhCLG1CQUFhLENBQUM5QixZQUFZLENBQUN6dkIsR0FBRCxDQUFiLEVBQW9Cd2EsR0FBcEIsRUFBeUIrSyxVQUF6QixFQUFxQ3ZsQixHQUFyQyxDQUFiO0FBQ0g7QUFDSjs7QUFDRCxNQUFJMHZCLGNBQUosRUFBb0I7QUFDaEIsVUFBTTVMLFFBQVEsR0FBRy9WLHVEQUFZLENBQUMyaEIsY0FBRCxDQUFaLEdBQ1hBLGNBQWMsQ0FBQ2hxQixJQUFmLENBQW9CNmYsVUFBcEIsQ0FEVyxHQUVYbUssY0FGTjtBQUdBbHNCLFdBQU8sQ0FBQ2MsT0FBUixDQUFnQndmLFFBQWhCLEVBQTBCOWlCLE9BQTFCLENBQWtDaEIsR0FBRyxJQUFJO0FBQ3JDNGpCLGFBQU8sQ0FBQzVqQixHQUFELEVBQU04akIsUUFBUSxDQUFDOWpCLEdBQUQsQ0FBZCxDQUFQO0FBQ0gsS0FGRDtBQUdIOztBQUNELE1BQUk0dkIsT0FBSixFQUFhO0FBQ1QvRyxZQUFRLENBQUMrRyxPQUFELEVBQVU5akIsUUFBVixFQUFvQjtBQUFJO0FBQXhCLEtBQVI7QUFDSDs7QUFDRCxXQUFTMGxCLHFCQUFULENBQStCQyxRQUEvQixFQUF5Q2pkLElBQXpDLEVBQStDO0FBQzNDLFFBQUl2VCxvREFBTyxDQUFDdVQsSUFBRCxDQUFYLEVBQW1CO0FBQ2ZBLFVBQUksQ0FBQ3hULE9BQUwsQ0FBYTB3QixLQUFLLElBQUlELFFBQVEsQ0FBQ0MsS0FBSyxDQUFDbmhCLElBQU4sQ0FBV2dWLFVBQVgsQ0FBRCxDQUE5QjtBQUNILEtBRkQsTUFHSyxJQUFJL1EsSUFBSixFQUFVO0FBQ1hpZCxjQUFRLENBQUNqZCxJQUFJLENBQUNqRSxJQUFMLENBQVVnVixVQUFWLENBQUQsQ0FBUjtBQUNIO0FBQ0o7O0FBQ0RpTSx1QkFBcUIsQ0FBQzdDLGFBQUQsRUFBZ0JrQixXQUFoQixDQUFyQjtBQUNBMkIsdUJBQXFCLENBQUNwTCxTQUFELEVBQVkwSixPQUFaLENBQXJCO0FBQ0EwQix1QkFBcUIsQ0FBQzVDLGNBQUQsRUFBaUJtQixZQUFqQixDQUFyQjtBQUNBeUIsdUJBQXFCLENBQUN0RSxTQUFELEVBQVk4QyxPQUFaLENBQXJCO0FBQ0F3Qix1QkFBcUIsQ0FBQy9ELFdBQUQsRUFBY3dDLFNBQWQsQ0FBckI7QUFDQXVCLHVCQUFxQixDQUFDN0QsYUFBRCxFQUFnQnVDLFdBQWhCLENBQXJCO0FBQ0FzQix1QkFBcUIsQ0FBQ3hDLGVBQUQsRUFBa0J5QixhQUFsQixDQUFyQjtBQUNBZSx1QkFBcUIsQ0FBQ3pDLGVBQUQsRUFBa0J3QixhQUFsQixDQUFyQjtBQUNBaUIsdUJBQXFCLENBQUMxQyxpQkFBRCxFQUFvQjBCLGVBQXBCLENBQXJCO0FBQ0FnQix1QkFBcUIsQ0FBQ25MLGVBQUQsRUFBa0IrSixhQUFsQixDQUFyQjtBQUNBb0IsdUJBQXFCLENBQUN0RCxXQUFELEVBQWNvQyxTQUFkLENBQXJCO0FBQ0FrQix1QkFBcUIsQ0FBQzNDLGdCQUFELEVBQW1CNkIsY0FBbkIsQ0FBckI7O0FBQ0EsTUFBSXp2QixvREFBTyxDQUFDMHZCLE1BQUQsQ0FBWCxFQUFxQjtBQUNqQixRQUFJQSxNQUFNLENBQUN6eEIsTUFBWCxFQUFtQjtBQUNmLFlBQU15eUIsT0FBTyxHQUFHN2xCLFFBQVEsQ0FBQzZsQixPQUFULEtBQXFCN2xCLFFBQVEsQ0FBQzZsQixPQUFULEdBQW1CLEVBQXhDLENBQWhCO0FBQ0FoQixZQUFNLENBQUMzdkIsT0FBUCxDQUFlaEIsR0FBRyxJQUFJO0FBQ2xCMEIsY0FBTSxDQUFDd3ZCLGNBQVAsQ0FBc0JTLE9BQXRCLEVBQStCM3hCLEdBQS9CLEVBQW9DO0FBQ2hDRSxhQUFHLEVBQUUsTUFBTXFsQixVQUFVLENBQUN2bEIsR0FBRCxDQURXO0FBRWhDRyxhQUFHLEVBQUU2SSxHQUFHLElBQUt1YyxVQUFVLENBQUN2bEIsR0FBRCxDQUFWLEdBQWtCZ0o7QUFGQyxTQUFwQztBQUlILE9BTEQ7QUFNSCxLQVJELE1BU0ssSUFBSSxDQUFDOEMsUUFBUSxDQUFDNmxCLE9BQWQsRUFBdUI7QUFDeEI3bEIsY0FBUSxDQUFDNmxCLE9BQVQsR0FBbUIsRUFBbkI7QUFDSDtBQUNKLEdBdEwyQixDQXVMNUI7QUFDQTs7O0FBQ0EsTUFBSTdkLE1BQU0sSUFBSWhJLFFBQVEsQ0FBQ2dJLE1BQVQsS0FBb0J0SSw2Q0FBbEMsRUFBd0M7QUFDcENNLFlBQVEsQ0FBQ2dJLE1BQVQsR0FBa0JBLE1BQWxCO0FBQ0g7O0FBQ0QsTUFBSTJILFlBQVksSUFBSSxJQUFwQixFQUEwQjtBQUN0QjNQLFlBQVEsQ0FBQzJQLFlBQVQsR0FBd0JBLFlBQXhCO0FBQ0gsR0E5TDJCLENBK0w1Qjs7O0FBQ0EsTUFBSW1WLFVBQUosRUFDSTlrQixRQUFRLENBQUM4a0IsVUFBVCxHQUFzQkEsVUFBdEI7QUFDSixNQUFJQyxVQUFKLEVBQ0kva0IsUUFBUSxDQUFDK2tCLFVBQVQsR0FBc0JBLFVBQXRCO0FBQ1A7O0FBQ0QsU0FBU0csaUJBQVQsQ0FBMkJyQixhQUEzQixFQUEwQ25WLEdBQTFDLEVBQStDdVcsd0JBQXdCLEdBQUd2bEIsNkNBQTFFLEVBQWdGO0FBQzVFLE1BQUl2SyxvREFBTyxDQUFDMHVCLGFBQUQsQ0FBWCxFQUE0QjtBQUN4QkEsaUJBQWEsR0FBR2lDLGVBQWUsQ0FBQ2pDLGFBQUQsQ0FBL0I7QUFDSDs7QUFDRCxPQUFLLE1BQU0zdkIsR0FBWCxJQUFrQjJ2QixhQUFsQixFQUFpQztBQUM3QixVQUFNMkIsR0FBRyxHQUFHM0IsYUFBYSxDQUFDM3ZCLEdBQUQsQ0FBekI7O0FBQ0EsUUFBSTRsQixxREFBVSxDQUFDMEwsR0FBRCxDQUFkLEVBQXFCO0FBQ2pCLFVBQUksYUFBYUEsR0FBakIsRUFBc0I7QUFDbEI5VyxXQUFHLENBQUN4YSxHQUFELENBQUgsR0FBV2drQixNQUFNLENBQUNzTixHQUFHLENBQUN2ZCxJQUFKLElBQVkvVCxHQUFiLEVBQWtCc3hCLEdBQUcsQ0FBQ3JPLE9BQXRCLEVBQStCO0FBQUs7QUFBcEMsU0FBakI7QUFDSCxPQUZELE1BR0s7QUFDRHpJLFdBQUcsQ0FBQ3hhLEdBQUQsQ0FBSCxHQUFXZ2tCLE1BQU0sQ0FBQ3NOLEdBQUcsQ0FBQ3ZkLElBQUosSUFBWS9ULEdBQWIsQ0FBakI7QUFDSDtBQUNKLEtBUEQsTUFRSztBQUNEd2EsU0FBRyxDQUFDeGEsR0FBRCxDQUFILEdBQVdna0IsTUFBTSxDQUFDc04sR0FBRCxDQUFqQjtBQUNIOztBQUNELFFBQUsxekIsSUFBTCxFQUE2QztBQUN6Q216Qiw4QkFBd0IsQ0FBQztBQUFTO0FBQVYsUUFBd0Ivd0IsR0FBeEIsQ0FBeEI7QUFDSDtBQUNKO0FBQ0o7O0FBQ0QsU0FBUzZvQixRQUFULENBQWtCclUsSUFBbEIsRUFBd0IxSSxRQUF4QixFQUFrQy9MLElBQWxDLEVBQXdDO0FBQ3BDcU8sNEJBQTBCLENBQUNuTixvREFBTyxDQUFDdVQsSUFBRCxDQUFQLEdBQ3JCQSxJQUFJLENBQUM1UyxHQUFMLENBQVNpd0IsQ0FBQyxJQUFJQSxDQUFDLENBQUN0aEIsSUFBRixDQUFPekUsUUFBUSxDQUFDckQsS0FBaEIsQ0FBZCxDQURxQixHQUVyQitMLElBQUksQ0FBQ2pFLElBQUwsQ0FBVXpFLFFBQVEsQ0FBQ3JELEtBQW5CLENBRm9CLEVBRU9xRCxRQUZQLEVBRWlCL0wsSUFGakIsQ0FBMUI7QUFHSDs7QUFDRCxTQUFTd3hCLGFBQVQsQ0FBdUJuekIsR0FBdkIsRUFBNEJvYyxHQUE1QixFQUFpQytLLFVBQWpDLEVBQTZDdmxCLEdBQTdDLEVBQWtEO0FBQzlDLFFBQU1nTCxNQUFNLEdBQUdoTCxHQUFHLENBQUNuQixRQUFKLENBQWEsR0FBYixJQUNUMm1CLGdCQUFnQixDQUFDRCxVQUFELEVBQWF2bEIsR0FBYixDQURQLEdBRVQsTUFBTXVsQixVQUFVLENBQUN2bEIsR0FBRCxDQUZ0Qjs7QUFHQSxNQUFJNE4scURBQVEsQ0FBQ3hQLEdBQUQsQ0FBWixFQUFtQjtBQUNmLFVBQU1zYSxPQUFPLEdBQUc4QixHQUFHLENBQUNwYyxHQUFELENBQW5COztBQUNBLFFBQUkyUCx1REFBWSxDQUFDMkssT0FBRCxDQUFoQixFQUEyQjtBQUN2QjZMLFdBQUssQ0FBQ3ZaLE1BQUQsRUFBUzBOLE9BQVQsQ0FBTDtBQUNILEtBRkQsTUFHSyxJQUFLOWEsSUFBTCxFQUE2QztBQUM5QzhHLFVBQUksQ0FBRSwyQ0FBMEN0RyxHQUFJLEdBQWhELEVBQW9Ec2EsT0FBcEQsQ0FBSjtBQUNIO0FBQ0osR0FSRCxNQVNLLElBQUkzSyx1REFBWSxDQUFDM1AsR0FBRCxDQUFoQixFQUF1QjtBQUN4Qm1tQixTQUFLLENBQUN2WixNQUFELEVBQVM1TSxHQUFHLENBQUNtUyxJQUFKLENBQVNnVixVQUFULENBQVQsQ0FBTDtBQUNILEdBRkksTUFHQSxJQUFJSyxxREFBVSxDQUFDeG5CLEdBQUQsQ0FBZCxFQUFxQjtBQUN0QixRQUFJNkMsb0RBQU8sQ0FBQzdDLEdBQUQsQ0FBWCxFQUFrQjtBQUNkQSxTQUFHLENBQUM0QyxPQUFKLENBQVlpSSxDQUFDLElBQUlzb0IsYUFBYSxDQUFDdG9CLENBQUQsRUFBSXVSLEdBQUosRUFBUytLLFVBQVQsRUFBcUJ2bEIsR0FBckIsQ0FBOUI7QUFDSCxLQUZELE1BR0s7QUFDRCxZQUFNMFksT0FBTyxHQUFHM0ssdURBQVksQ0FBQzNQLEdBQUcsQ0FBQ3NhLE9BQUwsQ0FBWixHQUNWdGEsR0FBRyxDQUFDc2EsT0FBSixDQUFZbkksSUFBWixDQUFpQmdWLFVBQWpCLENBRFUsR0FFVi9LLEdBQUcsQ0FBQ3BjLEdBQUcsQ0FBQ3NhLE9BQUwsQ0FGVDs7QUFHQSxVQUFJM0ssdURBQVksQ0FBQzJLLE9BQUQsQ0FBaEIsRUFBMkI7QUFDdkI2TCxhQUFLLENBQUN2WixNQUFELEVBQVMwTixPQUFULEVBQWtCdGEsR0FBbEIsQ0FBTDtBQUNILE9BRkQsTUFHSyxJQUFLUixJQUFMLEVBQTZDO0FBQzlDOEcsWUFBSSxDQUFFLDJDQUEwQ3RHLEdBQUcsQ0FBQ3NhLE9BQVEsR0FBeEQsRUFBNERBLE9BQTVELENBQUo7QUFDSDtBQUNKO0FBQ0osR0FmSSxNQWdCQSxJQUFLOWEsSUFBTCxFQUE2QztBQUM5QzhHLFFBQUksQ0FBRSwwQkFBeUIxRSxHQUFJLEdBQS9CLEVBQW1DNUIsR0FBbkMsQ0FBSjtBQUNIO0FBQ0o7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTZ3hCLG9CQUFULENBQThCdGpCLFFBQTlCLEVBQXdDO0FBQ3BDLFFBQU1nbUIsSUFBSSxHQUFHaG1CLFFBQVEsQ0FBQy9MLElBQXRCO0FBQ0EsUUFBTTtBQUFFMFosVUFBRjtBQUFVQyxXQUFPLEVBQUVxWTtBQUFuQixNQUFzQ0QsSUFBNUM7QUFDQSxRQUFNO0FBQUVyWSxVQUFNLEVBQUV1WSxZQUFWO0FBQXdCQyxnQkFBWSxFQUFFalosS0FBdEM7QUFBNkM5TSxVQUFNLEVBQUU7QUFBRWdtQjtBQUFGO0FBQXJELE1BQW1GcG1CLFFBQVEsQ0FBQ0csVUFBbEc7QUFDQSxRQUFNaU4sTUFBTSxHQUFHRixLQUFLLENBQUM5WSxHQUFOLENBQVU0eEIsSUFBVixDQUFmO0FBQ0EsTUFBSUssUUFBSjs7QUFDQSxNQUFJalosTUFBSixFQUFZO0FBQ1JpWixZQUFRLEdBQUdqWixNQUFYO0FBQ0gsR0FGRCxNQUdLLElBQUksQ0FBQzhZLFlBQVksQ0FBQzl5QixNQUFkLElBQXdCLENBQUN1YSxNQUF6QixJQUFtQyxDQUFDc1ksY0FBeEMsRUFBd0Q7QUFDekQ7QUFDSUksY0FBUSxHQUFHTCxJQUFYO0FBQ0g7QUFDSixHQUpJLE1BS0E7QUFDREssWUFBUSxHQUFHLEVBQVg7O0FBQ0EsUUFBSUgsWUFBWSxDQUFDOXlCLE1BQWpCLEVBQXlCO0FBQ3JCOHlCLGtCQUFZLENBQUNoeEIsT0FBYixDQUFxQm9nQixDQUFDLElBQUlnUixZQUFZLENBQUNELFFBQUQsRUFBVy9RLENBQVgsRUFBYzhRLHFCQUFkLEVBQXFDLElBQXJDLENBQXRDO0FBQ0g7O0FBQ0RFLGdCQUFZLENBQUNELFFBQUQsRUFBV0wsSUFBWCxFQUFpQkkscUJBQWpCLENBQVo7QUFDSDs7QUFDRGxaLE9BQUssQ0FBQzdZLEdBQU4sQ0FBVTJ4QixJQUFWLEVBQWdCSyxRQUFoQjtBQUNBLFNBQU9BLFFBQVA7QUFDSDs7QUFDRCxTQUFTQyxZQUFULENBQXNCQyxFQUF0QixFQUEwQnRlLElBQTFCLEVBQWdDdWUsTUFBaEMsRUFBd0N2WixPQUFPLEdBQUcsS0FBbEQsRUFBeUQ7QUFDckQsUUFBTTtBQUFFVSxVQUFGO0FBQVVDLFdBQU8sRUFBRXFZO0FBQW5CLE1BQXNDaGUsSUFBNUM7O0FBQ0EsTUFBSWdlLGNBQUosRUFBb0I7QUFDaEJLLGdCQUFZLENBQUNDLEVBQUQsRUFBS04sY0FBTCxFQUFxQk8sTUFBckIsRUFBNkIsSUFBN0IsQ0FBWjtBQUNIOztBQUNELE1BQUk3WSxNQUFKLEVBQVk7QUFDUkEsVUFBTSxDQUFDelksT0FBUCxDQUFnQm9nQixDQUFELElBQU9nUixZQUFZLENBQUNDLEVBQUQsRUFBS2pSLENBQUwsRUFBUWtSLE1BQVIsRUFBZ0IsSUFBaEIsQ0FBbEM7QUFDSDs7QUFDRCxPQUFLLE1BQU10eUIsR0FBWCxJQUFrQitULElBQWxCLEVBQXdCO0FBQ3BCLFFBQUlnRixPQUFPLElBQUkvWSxHQUFHLEtBQUssUUFBdkIsRUFBaUM7QUFDNUJwQyxXQUFELElBQ0k4RyxJQUFJLENBQUUsaUVBQUQsR0FDQSwwREFERCxDQURSO0FBR0gsS0FKRCxNQUtLO0FBQ0QsWUFBTTZ0QixLQUFLLEdBQUdDLHlCQUF5QixDQUFDeHlCLEdBQUQsQ0FBekIsSUFBbUNzeUIsTUFBTSxJQUFJQSxNQUFNLENBQUN0eUIsR0FBRCxDQUFqRTtBQUNBcXlCLFFBQUUsQ0FBQ3J5QixHQUFELENBQUYsR0FBVXV5QixLQUFLLEdBQUdBLEtBQUssQ0FBQ0YsRUFBRSxDQUFDcnlCLEdBQUQsQ0FBSCxFQUFVK1QsSUFBSSxDQUFDL1QsR0FBRCxDQUFkLENBQVIsR0FBK0IrVCxJQUFJLENBQUMvVCxHQUFELENBQWxEO0FBQ0g7QUFDSjs7QUFDRCxTQUFPcXlCLEVBQVA7QUFDSDs7QUFDRCxNQUFNRyx5QkFBeUIsR0FBRztBQUM5QmpYLE1BQUksRUFBRWtYLFdBRHdCO0FBRTlCbGxCLE9BQUssRUFBRW1sQixrQkFGdUI7QUFHOUJ2WixPQUFLLEVBQUV1WixrQkFIdUI7QUFJOUI7QUFDQWxELFNBQU8sRUFBRWtELGtCQUxxQjtBQU05QnRuQixVQUFRLEVBQUVzbkIsa0JBTm9CO0FBTzlCO0FBQ0FyRCxjQUFZLEVBQUVzRCxZQVJnQjtBQVM5Qi9DLFNBQU8sRUFBRStDLFlBVHFCO0FBVTlCOUMsYUFBVyxFQUFFOEMsWUFWaUI7QUFXOUI3QyxTQUFPLEVBQUU2QyxZQVhxQjtBQVk5QjVDLGNBQVksRUFBRTRDLFlBWmdCO0FBYTlCM0MsU0FBTyxFQUFFMkMsWUFicUI7QUFjOUJ4QyxlQUFhLEVBQUV3QyxZQWRlO0FBZTlCdEMsV0FBUyxFQUFFc0MsWUFmbUI7QUFnQjlCMUMsV0FBUyxFQUFFMEMsWUFoQm1CO0FBaUI5QnpDLGFBQVcsRUFBRXlDLFlBakJpQjtBQWtCOUJsQyxlQUFhLEVBQUVrQyxZQWxCZTtBQW1COUJqQyxnQkFBYyxFQUFFaUMsWUFuQmM7QUFvQjlCO0FBQ0EvQixZQUFVLEVBQUU4QixrQkFyQmtCO0FBc0I5QjdCLFlBQVUsRUFBRTZCLGtCQXRCa0I7QUF1QjlCO0FBQ0FuTyxPQUFLLEVBQUVxTyxpQkF4QnVCO0FBeUI5QjtBQUNBaFAsU0FBTyxFQUFFNk8sV0ExQnFCO0FBMkI5QnpPLFFBQU0sRUFBRTZPO0FBM0JzQixDQUFsQzs7QUE2QkEsU0FBU0osV0FBVCxDQUFxQkosRUFBckIsRUFBeUJ0ZSxJQUF6QixFQUErQjtBQUMzQixNQUFJLENBQUNBLElBQUwsRUFBVztBQUNQLFdBQU9zZSxFQUFQO0FBQ0g7O0FBQ0QsTUFBSSxDQUFDQSxFQUFMLEVBQVM7QUFDTCxXQUFPdGUsSUFBUDtBQUNIOztBQUNELFNBQU8sU0FBUytlLFlBQVQsR0FBd0I7QUFDM0IsV0FBUWp1QixtREFBRCxDQUFTa0osdURBQVksQ0FBQ3NrQixFQUFELENBQVosR0FBbUJBLEVBQUUsQ0FBQzNzQixJQUFILENBQVEsSUFBUixFQUFjLElBQWQsQ0FBbkIsR0FBeUMyc0IsRUFBbEQsRUFBc0R0a0IsdURBQVksQ0FBQ2dHLElBQUQsQ0FBWixHQUFxQkEsSUFBSSxDQUFDck8sSUFBTCxDQUFVLElBQVYsRUFBZ0IsSUFBaEIsQ0FBckIsR0FBNkNxTyxJQUFuRyxDQUFQO0FBQ0gsR0FGRDtBQUdIOztBQUNELFNBQVM4ZSxXQUFULENBQXFCUixFQUFyQixFQUF5QnRlLElBQXpCLEVBQStCO0FBQzNCLFNBQU8yZSxrQkFBa0IsQ0FBQ2QsZUFBZSxDQUFDUyxFQUFELENBQWhCLEVBQXNCVCxlQUFlLENBQUM3ZCxJQUFELENBQXJDLENBQXpCO0FBQ0g7O0FBQ0QsU0FBUzZkLGVBQVQsQ0FBeUJ4ekIsR0FBekIsRUFBOEI7QUFDMUIsTUFBSTZDLG9EQUFPLENBQUM3QyxHQUFELENBQVgsRUFBa0I7QUFDZCxVQUFNeUUsR0FBRyxHQUFHLEVBQVo7O0FBQ0EsU0FBSyxJQUFJdkQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2xCLEdBQUcsQ0FBQ2MsTUFBeEIsRUFBZ0NJLENBQUMsRUFBakMsRUFBcUM7QUFDakN1RCxTQUFHLENBQUN6RSxHQUFHLENBQUNrQixDQUFELENBQUosQ0FBSCxHQUFjbEIsR0FBRyxDQUFDa0IsQ0FBRCxDQUFqQjtBQUNIOztBQUNELFdBQU91RCxHQUFQO0FBQ0g7O0FBQ0QsU0FBT3pFLEdBQVA7QUFDSDs7QUFDRCxTQUFTdTBCLFlBQVQsQ0FBc0JOLEVBQXRCLEVBQTBCdGUsSUFBMUIsRUFBZ0M7QUFDNUIsU0FBT3NlLEVBQUUsR0FBRyxDQUFDLEdBQUcsSUFBSS94QixHQUFKLENBQVEsR0FBR3FjLE1BQUgsQ0FBVTBWLEVBQVYsRUFBY3RlLElBQWQsQ0FBUixDQUFKLENBQUgsR0FBdUNBLElBQWhEO0FBQ0g7O0FBQ0QsU0FBUzJlLGtCQUFULENBQTRCTCxFQUE1QixFQUFnQ3RlLElBQWhDLEVBQXNDO0FBQ2xDLFNBQU9zZSxFQUFFLEdBQUd4dEIsbURBQU0sQ0FBQ0EsbURBQU0sQ0FBQ25ELE1BQU0sQ0FBQzhVLE1BQVAsQ0FBYyxJQUFkLENBQUQsRUFBc0I2YixFQUF0QixDQUFQLEVBQWtDdGUsSUFBbEMsQ0FBVCxHQUFtREEsSUFBNUQ7QUFDSDs7QUFDRCxTQUFTNmUsaUJBQVQsQ0FBMkJQLEVBQTNCLEVBQStCdGUsSUFBL0IsRUFBcUM7QUFDakMsTUFBSSxDQUFDc2UsRUFBTCxFQUNJLE9BQU90ZSxJQUFQO0FBQ0osTUFBSSxDQUFDQSxJQUFMLEVBQ0ksT0FBT3NlLEVBQVA7QUFDSixRQUFNVSxNQUFNLEdBQUdsdUIsbURBQU0sQ0FBQ25ELE1BQU0sQ0FBQzhVLE1BQVAsQ0FBYyxJQUFkLENBQUQsRUFBc0I2YixFQUF0QixDQUFyQjs7QUFDQSxPQUFLLE1BQU1yeUIsR0FBWCxJQUFrQitULElBQWxCLEVBQXdCO0FBQ3BCZ2YsVUFBTSxDQUFDL3lCLEdBQUQsQ0FBTixHQUFjMnlCLFlBQVksQ0FBQ04sRUFBRSxDQUFDcnlCLEdBQUQsQ0FBSCxFQUFVK1QsSUFBSSxDQUFDL1QsR0FBRCxDQUFkLENBQTFCO0FBQ0g7O0FBQ0QsU0FBTyt5QixNQUFQO0FBQ0g7O0FBRUQsU0FBU0MsU0FBVCxDQUFtQmxuQixRQUFuQixFQUE2QjRiLFFBQTdCLEVBQXVDdUwsVUFBdkMsRUFBbUQ7QUFDbkRDLEtBQUssR0FBRyxLQURSLEVBQ2U7QUFDWCxRQUFNM2xCLEtBQUssR0FBRyxFQUFkO0FBQ0EsUUFBTStOLEtBQUssR0FBRyxFQUFkO0FBQ0F4UyxrREFBRyxDQUFDd1MsS0FBRCxFQUFRNlgsaUJBQVIsRUFBMkIsQ0FBM0IsQ0FBSDtBQUNBcm5CLFVBQVEsQ0FBQ3NuQixhQUFULEdBQXlCMXhCLE1BQU0sQ0FBQzhVLE1BQVAsQ0FBYyxJQUFkLENBQXpCO0FBQ0E2YyxjQUFZLENBQUN2bkIsUUFBRCxFQUFXNGIsUUFBWCxFQUFxQm5hLEtBQXJCLEVBQTRCK04sS0FBNUIsQ0FBWixDQUxXLENBTVg7O0FBQ0EsT0FBSyxNQUFNdGIsR0FBWCxJQUFrQjhMLFFBQVEsQ0FBQzZMLFlBQVQsQ0FBc0IsQ0FBdEIsQ0FBbEIsRUFBNEM7QUFDeEMsUUFBSSxFQUFFM1gsR0FBRyxJQUFJdU4sS0FBVCxDQUFKLEVBQXFCO0FBQ2pCQSxXQUFLLENBQUN2TixHQUFELENBQUwsR0FBYUosU0FBYjtBQUNIO0FBQ0osR0FYVSxDQVlYOzs7QUFDQSxNQUFLaEMsSUFBTCxFQUE2QztBQUN6QzAxQixpQkFBYSxDQUFDNUwsUUFBUSxJQUFJLEVBQWIsRUFBaUJuYSxLQUFqQixFQUF3QnpCLFFBQXhCLENBQWI7QUFDSDs7QUFDRCxNQUFJbW5CLFVBQUosRUFBZ0I7QUFDWjtBQUNBbm5CLFlBQVEsQ0FBQ3lCLEtBQVQsR0FBaUIybEIsS0FBSyxHQUFHM2xCLEtBQUgsR0FBV3JGLGdFQUFlLENBQUNxRixLQUFELENBQWhEO0FBQ0gsR0FIRCxNQUlLO0FBQ0QsUUFBSSxDQUFDekIsUUFBUSxDQUFDL0wsSUFBVCxDQUFjd04sS0FBbkIsRUFBMEI7QUFDdEI7QUFDQXpCLGNBQVEsQ0FBQ3lCLEtBQVQsR0FBaUIrTixLQUFqQjtBQUNILEtBSEQsTUFJSztBQUNEO0FBQ0F4UCxjQUFRLENBQUN5QixLQUFULEdBQWlCQSxLQUFqQjtBQUNIO0FBQ0o7O0FBQ0R6QixVQUFRLENBQUN3UCxLQUFULEdBQWlCQSxLQUFqQjtBQUNIOztBQUNELFNBQVNpWSxXQUFULENBQXFCem5CLFFBQXJCLEVBQStCNGIsUUFBL0IsRUFBeUM4TCxZQUF6QyxFQUF1RDVWLFNBQXZELEVBQWtFO0FBQzlELFFBQU07QUFBRXJRLFNBQUY7QUFBUytOLFNBQVQ7QUFBZ0IzUCxTQUFLLEVBQUU7QUFBRXNRO0FBQUY7QUFBdkIsTUFBeUNuUSxRQUEvQztBQUNBLFFBQU0ybkIsZUFBZSxHQUFHOXdCLHNEQUFLLENBQUM0SyxLQUFELENBQTdCO0FBQ0EsUUFBTSxDQUFDclAsT0FBRCxJQUFZNE4sUUFBUSxDQUFDNkwsWUFBM0I7QUFDQSxNQUFJK2IsZUFBZSxHQUFHLEtBQXRCOztBQUNBLE9BQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzkxQixLQUFELEtBQ0drTyxRQUFRLENBQUMvTCxJQUFULENBQWN3VCxPQUFkLElBQ0l6SCxRQUFRLENBQUNpQixNQUFULElBQW1CakIsUUFBUSxDQUFDaUIsTUFBVCxDQUFnQmhOLElBQWhCLENBQXFCd1QsT0FGL0MsQ0FBRixNQUdLcUssU0FBUyxJQUFJM0IsU0FBUyxHQUFHLENBSDlCLEtBSUksRUFBRUEsU0FBUyxHQUFHO0FBQUc7QUFBakIsR0FSSixFQVF3QztBQUNwQyxRQUFJQSxTQUFTLEdBQUc7QUFBRTtBQUFsQixNQUErQjtBQUMzQjtBQUNBO0FBQ0EsY0FBTTBYLGFBQWEsR0FBRzduQixRQUFRLENBQUNILEtBQVQsQ0FBZXVTLFlBQXJDOztBQUNBLGFBQUssSUFBSTVlLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdxMEIsYUFBYSxDQUFDejBCLE1BQWxDLEVBQTBDSSxDQUFDLEVBQTNDLEVBQStDO0FBQzNDLGNBQUlVLEdBQUcsR0FBRzJ6QixhQUFhLENBQUNyMEIsQ0FBRCxDQUF2QixDQUQyQyxDQUUzQzs7QUFDQSxnQkFBTXFFLEtBQUssR0FBRytqQixRQUFRLENBQUMxbkIsR0FBRCxDQUF0Qjs7QUFDQSxjQUFJOUIsT0FBSixFQUFhO0FBQ1Q7QUFDQTtBQUNBLGdCQUFJcUYsbURBQU0sQ0FBQytYLEtBQUQsRUFBUXRiLEdBQVIsQ0FBVixFQUF3QjtBQUNwQixrQkFBSTJELEtBQUssS0FBSzJYLEtBQUssQ0FBQ3RiLEdBQUQsQ0FBbkIsRUFBMEI7QUFDdEJzYixxQkFBSyxDQUFDdGIsR0FBRCxDQUFMLEdBQWEyRCxLQUFiO0FBQ0ErdkIsK0JBQWUsR0FBRyxJQUFsQjtBQUNIO0FBQ0osYUFMRCxNQU1LO0FBQ0Qsb0JBQU1FLFlBQVksR0FBR2piLHFEQUFRLENBQUMzWSxHQUFELENBQTdCO0FBQ0F1TixtQkFBSyxDQUFDcW1CLFlBQUQsQ0FBTCxHQUFzQkMsZ0JBQWdCLENBQUMzMUIsT0FBRCxFQUFVdTFCLGVBQVYsRUFBMkJHLFlBQTNCLEVBQXlDandCLEtBQXpDLEVBQWdEbUksUUFBaEQsRUFBMEQ7QUFBTTtBQUFoRSxlQUF0QztBQUNIO0FBQ0osV0FiRCxNQWNLO0FBQ0QsZ0JBQUluSSxLQUFLLEtBQUsyWCxLQUFLLENBQUN0YixHQUFELENBQW5CLEVBQTBCO0FBQ3RCc2IsbUJBQUssQ0FBQ3RiLEdBQUQsQ0FBTCxHQUFhMkQsS0FBYjtBQUNBK3ZCLDZCQUFlLEdBQUcsSUFBbEI7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNKLEdBdkNELE1Bd0NLO0FBQ0Q7QUFDQSxRQUFJTCxZQUFZLENBQUN2bkIsUUFBRCxFQUFXNGIsUUFBWCxFQUFxQm5hLEtBQXJCLEVBQTRCK04sS0FBNUIsQ0FBaEIsRUFBb0Q7QUFDaERvWSxxQkFBZSxHQUFHLElBQWxCO0FBQ0gsS0FKQSxDQUtEO0FBQ0E7OztBQUNBLFFBQUlJLFFBQUo7O0FBQ0EsU0FBSyxNQUFNOXpCLEdBQVgsSUFBa0J5ekIsZUFBbEIsRUFBbUM7QUFDL0IsVUFBSSxDQUFDL0wsUUFBRCxJQUNBO0FBQ0MsT0FBQ25rQixtREFBTSxDQUFDbWtCLFFBQUQsRUFBVzFuQixHQUFYLENBQVAsTUFDRztBQUNBO0FBQ0MsT0FBQzh6QixRQUFRLEdBQUd0YixzREFBUyxDQUFDeFksR0FBRCxDQUFyQixNQUFnQ0EsR0FBaEMsSUFBdUMsQ0FBQ3VELG1EQUFNLENBQUNta0IsUUFBRCxFQUFXb00sUUFBWCxDQUhsRCxDQUZMLEVBSytFO0FBQzNFLFlBQUk1MUIsT0FBSixFQUFhO0FBQ1QsY0FBSXMxQixZQUFZLE1BQ1o7QUFDQ0Esc0JBQVksQ0FBQ3h6QixHQUFELENBQVosS0FBc0JKLFNBQXRCLElBQ0c7QUFDQTR6QixzQkFBWSxDQUFDTSxRQUFELENBQVosS0FBMkJsMEIsU0FKbkIsQ0FBaEIsRUFJK0M7QUFDM0MyTixpQkFBSyxDQUFDdk4sR0FBRCxDQUFMLEdBQWE2ekIsZ0JBQWdCLENBQUMzMUIsT0FBRCxFQUFVdTFCLGVBQVYsRUFBMkJ6ekIsR0FBM0IsRUFBZ0NKLFNBQWhDLEVBQTJDa00sUUFBM0MsRUFBcUQ7QUFBSztBQUExRCxhQUE3QjtBQUNIO0FBQ0osU0FSRCxNQVNLO0FBQ0QsaUJBQU95QixLQUFLLENBQUN2TixHQUFELENBQVo7QUFDSDtBQUNKO0FBQ0osS0E1QkEsQ0E2QkQ7QUFDQTs7O0FBQ0EsUUFBSXNiLEtBQUssS0FBS21ZLGVBQWQsRUFBK0I7QUFDM0IsV0FBSyxNQUFNenpCLEdBQVgsSUFBa0JzYixLQUFsQixFQUF5QjtBQUNyQixZQUFJLENBQUNvTSxRQUFELElBQWEsQ0FBQ25rQixtREFBTSxDQUFDbWtCLFFBQUQsRUFBVzFuQixHQUFYLENBQXhCLEVBQXlDO0FBQ3JDLGlCQUFPc2IsS0FBSyxDQUFDdGIsR0FBRCxDQUFaO0FBQ0EwekIseUJBQWUsR0FBRyxJQUFsQjtBQUNIO0FBQ0o7QUFDSjtBQUNKLEdBcEY2RCxDQXFGOUQ7OztBQUNBLE1BQUlBLGVBQUosRUFBcUI7QUFDakJoekIsNERBQU8sQ0FBQ29MLFFBQUQsRUFBVztBQUFNO0FBQWpCLE1BQTRCLFFBQTVCLENBQVA7QUFDSDs7QUFDRCxNQUFLbE8sSUFBTCxFQUE2QztBQUN6QzAxQixpQkFBYSxDQUFDNUwsUUFBUSxJQUFJLEVBQWIsRUFBaUJuYSxLQUFqQixFQUF3QnpCLFFBQXhCLENBQWI7QUFDSDtBQUNKOztBQUNELFNBQVN1bkIsWUFBVCxDQUFzQnZuQixRQUF0QixFQUFnQzRiLFFBQWhDLEVBQTBDbmEsS0FBMUMsRUFBaUQrTixLQUFqRCxFQUF3RDtBQUNwRCxRQUFNLENBQUNwZCxPQUFELEVBQVU2MUIsWUFBVixJQUEwQmpvQixRQUFRLENBQUM2TCxZQUF6QztBQUNBLE1BQUkrYixlQUFlLEdBQUcsS0FBdEI7QUFDQSxNQUFJTSxhQUFKOztBQUNBLE1BQUl0TSxRQUFKLEVBQWM7QUFDVixTQUFLLElBQUkxbkIsR0FBVCxJQUFnQjBuQixRQUFoQixFQUEwQjtBQUN0QjtBQUNBLFVBQUl1TSwyREFBYyxDQUFDajBCLEdBQUQsQ0FBbEIsRUFBeUI7QUFDckI7QUFDSDs7QUFDRCxZQUFNMkQsS0FBSyxHQUFHK2pCLFFBQVEsQ0FBQzFuQixHQUFELENBQXRCLENBTHNCLENBTXRCO0FBQ0E7O0FBQ0EsVUFBSWswQixRQUFKOztBQUNBLFVBQUloMkIsT0FBTyxJQUFJcUYsbURBQU0sQ0FBQ3JGLE9BQUQsRUFBV2cyQixRQUFRLEdBQUd2YixxREFBUSxDQUFDM1ksR0FBRCxDQUE5QixDQUFyQixFQUE0RDtBQUN4RCxZQUFJLENBQUMrekIsWUFBRCxJQUFpQixDQUFDQSxZQUFZLENBQUNsMUIsUUFBYixDQUFzQnExQixRQUF0QixDQUF0QixFQUF1RDtBQUNuRDNtQixlQUFLLENBQUMybUIsUUFBRCxDQUFMLEdBQWtCdndCLEtBQWxCO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsV0FBQ3F3QixhQUFhLEtBQUtBLGFBQWEsR0FBRyxFQUFyQixDQUFkLEVBQXdDRSxRQUF4QyxJQUFvRHZ3QixLQUFwRDtBQUNIO0FBQ0osT0FQRCxNQVFLLElBQUksQ0FBQ2dXLGNBQWMsQ0FBQzdOLFFBQVEsQ0FBQzRMLFlBQVYsRUFBd0IxWCxHQUF4QixDQUFuQixFQUFpRDtBQUNsRCxZQUFJMkQsS0FBSyxLQUFLMlgsS0FBSyxDQUFDdGIsR0FBRCxDQUFuQixFQUEwQjtBQUN0QnNiLGVBQUssQ0FBQ3RiLEdBQUQsQ0FBTCxHQUFhMkQsS0FBYjtBQUNBK3ZCLHlCQUFlLEdBQUcsSUFBbEI7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFDRCxNQUFJSyxZQUFKLEVBQWtCO0FBQ2QsVUFBTU4sZUFBZSxHQUFHOXdCLHNEQUFLLENBQUM0SyxLQUFELENBQTdCO0FBQ0EsVUFBTTRtQixVQUFVLEdBQUdILGFBQWEsSUFBSTcxQixrREFBcEM7O0FBQ0EsU0FBSyxJQUFJbUIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3kwQixZQUFZLENBQUM3MEIsTUFBakMsRUFBeUNJLENBQUMsRUFBMUMsRUFBOEM7QUFDMUMsWUFBTVUsR0FBRyxHQUFHK3pCLFlBQVksQ0FBQ3owQixDQUFELENBQXhCO0FBQ0FpTyxXQUFLLENBQUN2TixHQUFELENBQUwsR0FBYTZ6QixnQkFBZ0IsQ0FBQzMxQixPQUFELEVBQVV1MUIsZUFBVixFQUEyQnp6QixHQUEzQixFQUFnQ20wQixVQUFVLENBQUNuMEIsR0FBRCxDQUExQyxFQUFpRDhMLFFBQWpELEVBQTJELENBQUN2SSxtREFBTSxDQUFDNHdCLFVBQUQsRUFBYW4wQixHQUFiLENBQWxFLENBQTdCO0FBQ0g7QUFDSjs7QUFDRCxTQUFPMHpCLGVBQVA7QUFDSDs7QUFDRCxTQUFTRyxnQkFBVCxDQUEwQjMxQixPQUExQixFQUFtQ3FQLEtBQW5DLEVBQTBDdk4sR0FBMUMsRUFBK0MyRCxLQUEvQyxFQUFzRG1JLFFBQXRELEVBQWdFc29CLFFBQWhFLEVBQTBFO0FBQ3RFLFFBQU05QyxHQUFHLEdBQUdwekIsT0FBTyxDQUFDOEIsR0FBRCxDQUFuQjs7QUFDQSxNQUFJc3hCLEdBQUcsSUFBSSxJQUFYLEVBQWlCO0FBQ2IsVUFBTStDLFVBQVUsR0FBRzl3QixtREFBTSxDQUFDK3RCLEdBQUQsRUFBTSxTQUFOLENBQXpCLENBRGEsQ0FFYjs7QUFDQSxRQUFJK0MsVUFBVSxJQUFJMXdCLEtBQUssS0FBSy9ELFNBQTVCLEVBQXVDO0FBQ25DLFlBQU1xa0IsWUFBWSxHQUFHcU4sR0FBRyxDQUFDck8sT0FBekI7O0FBQ0EsVUFBSXFPLEdBQUcsQ0FBQ3Z4QixJQUFKLEtBQWF3bUIsUUFBYixJQUF5QnhZLHVEQUFZLENBQUNrVyxZQUFELENBQXpDLEVBQXlEO0FBQ3JELGNBQU07QUFBRW1QO0FBQUYsWUFBb0J0bkIsUUFBMUI7O0FBQ0EsWUFBSTlMLEdBQUcsSUFBSW96QixhQUFYLEVBQTBCO0FBQ3RCenZCLGVBQUssR0FBR3l2QixhQUFhLENBQUNwekIsR0FBRCxDQUFyQjtBQUNILFNBRkQsTUFHSztBQUNEcXVCLDRCQUFrQixDQUFDdmlCLFFBQUQsQ0FBbEI7QUFDQW5JLGVBQUssR0FBR3l2QixhQUFhLENBQUNwekIsR0FBRCxDQUFiLEdBQXFCaWtCLFlBQVksQ0FBQ3ZlLElBQWIsQ0FBa0IsSUFBbEIsRUFBd0I2SCxLQUF4QixDQUE3QjtBQUNBOGdCLDRCQUFrQixDQUFDLElBQUQsQ0FBbEI7QUFDSDtBQUNKLE9BVkQsTUFXSztBQUNEMXFCLGFBQUssR0FBR3NnQixZQUFSO0FBQ0g7QUFDSixLQW5CWSxDQW9CYjs7O0FBQ0EsUUFBSXFOLEdBQUcsQ0FBQztBQUFFO0FBQUgsS0FBUCxFQUE2QjtBQUN6QixVQUFJOEMsUUFBUSxJQUFJLENBQUNDLFVBQWpCLEVBQTZCO0FBQ3pCMXdCLGFBQUssR0FBRyxLQUFSO0FBQ0gsT0FGRCxNQUdLLElBQUkydEIsR0FBRyxDQUFDO0FBQUU7QUFBSCxPQUFILEtBQ0ozdEIsS0FBSyxLQUFLLEVBQVYsSUFBZ0JBLEtBQUssS0FBSzZVLHNEQUFTLENBQUN4WSxHQUFELENBRC9CLENBQUosRUFDMkM7QUFDNUMyRCxhQUFLLEdBQUcsSUFBUjtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxTQUFPQSxLQUFQO0FBQ0g7O0FBQ0QsU0FBUzJ3QixxQkFBVCxDQUErQmplLElBQS9CLEVBQXFDcEssVUFBckMsRUFBaUQ4TSxPQUFPLEdBQUcsS0FBM0QsRUFBa0U7QUFDOUQsUUFBTUMsS0FBSyxHQUFHL00sVUFBVSxDQUFDc29CLFVBQXpCO0FBQ0EsUUFBTXJiLE1BQU0sR0FBR0YsS0FBSyxDQUFDOVksR0FBTixDQUFVbVcsSUFBVixDQUFmOztBQUNBLE1BQUk2QyxNQUFKLEVBQVk7QUFDUixXQUFPQSxNQUFQO0FBQ0g7O0FBQ0QsUUFBTTlhLEdBQUcsR0FBR2lZLElBQUksQ0FBQzlJLEtBQWpCO0FBQ0EsUUFBTTZMLFVBQVUsR0FBRyxFQUFuQjtBQUNBLFFBQU0yYSxZQUFZLEdBQUcsRUFBckIsQ0FSOEQsQ0FTOUQ7O0FBQ0EsTUFBSTFhLFVBQVUsR0FBRyxLQUFqQjs7QUFDQSxNQUFJQyxLQUFtQixJQUFJLENBQUN2TCx1REFBWSxDQUFDc0ksSUFBRCxDQUF4QyxFQUFnRDtBQUM1QyxVQUFNbWUsV0FBVyxHQUFJcDJCLEdBQUQsSUFBUztBQUN6QmliLGdCQUFVLEdBQUcsSUFBYjtBQUNBLFlBQU0sQ0FBQzlMLEtBQUQsRUFBUUUsSUFBUixJQUFnQjZtQixxQkFBcUIsQ0FBQ2wyQixHQUFELEVBQU02TixVQUFOLEVBQWtCLElBQWxCLENBQTNDO0FBQ0FwSCx5REFBTSxDQUFDdVUsVUFBRCxFQUFhN0wsS0FBYixDQUFOO0FBQ0EsVUFBSUUsSUFBSixFQUNJc21CLFlBQVksQ0FBQ2gxQixJQUFiLENBQWtCLEdBQUcwTyxJQUFyQjtBQUNQLEtBTkQ7O0FBT0EsUUFBSSxDQUFDc0wsT0FBRCxJQUFZOU0sVUFBVSxDQUFDd04sTUFBWCxDQUFrQnZhLE1BQWxDLEVBQTBDO0FBQ3RDK00sZ0JBQVUsQ0FBQ3dOLE1BQVgsQ0FBa0J6WSxPQUFsQixDQUEwQnd6QixXQUExQjtBQUNIOztBQUNELFFBQUluZSxJQUFJLENBQUNxRCxPQUFULEVBQWtCO0FBQ2Q4YSxpQkFBVyxDQUFDbmUsSUFBSSxDQUFDcUQsT0FBTixDQUFYO0FBQ0g7O0FBQ0QsUUFBSXJELElBQUksQ0FBQ29ELE1BQVQsRUFBaUI7QUFDYnBELFVBQUksQ0FBQ29ELE1BQUwsQ0FBWXpZLE9BQVosQ0FBb0J3ekIsV0FBcEI7QUFDSDtBQUNKOztBQUNELE1BQUksQ0FBQ3AyQixHQUFELElBQVEsQ0FBQ2liLFVBQWIsRUFBeUI7QUFDckJMLFNBQUssQ0FBQzdZLEdBQU4sQ0FBVWtXLElBQVYsRUFBZ0JvZSxrREFBaEI7QUFDQSxXQUFPQSxrREFBUDtBQUNIOztBQUNELE1BQUl4ekIsb0RBQU8sQ0FBQzdDLEdBQUQsQ0FBWCxFQUFrQjtBQUNkLFNBQUssSUFBSWtCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdsQixHQUFHLENBQUNjLE1BQXhCLEVBQWdDSSxDQUFDLEVBQWpDLEVBQXFDO0FBQ2pDLFVBQUsxQixLQUFELElBQTJDLENBQUNnUSxxREFBUSxDQUFDeFAsR0FBRyxDQUFDa0IsQ0FBRCxDQUFKLENBQXhELEVBQWtFO0FBQzlEb0YsWUFBSSxDQUFFLGdEQUFGLEVBQW1EdEcsR0FBRyxDQUFDa0IsQ0FBRCxDQUF0RCxDQUFKO0FBQ0g7O0FBQ0QsWUFBTW8xQixhQUFhLEdBQUcvYixxREFBUSxDQUFDdmEsR0FBRyxDQUFDa0IsQ0FBRCxDQUFKLENBQTlCOztBQUNBLFVBQUlxMUIsZ0JBQWdCLENBQUNELGFBQUQsQ0FBcEIsRUFBcUM7QUFDakN0YixrQkFBVSxDQUFDc2IsYUFBRCxDQUFWLEdBQTRCdjJCLGtEQUE1QjtBQUNIO0FBQ0o7QUFDSixHQVZELE1BV0ssSUFBSUMsR0FBSixFQUFTO0FBQ1YsUUFBS1IsS0FBRCxJQUEyQyxDQUFDZ29CLHFEQUFVLENBQUN4bkIsR0FBRCxDQUExRCxFQUFpRTtBQUM3RHNHLFVBQUksQ0FBRSx1QkFBRixFQUEwQnRHLEdBQTFCLENBQUo7QUFDSDs7QUFDRCxTQUFLLE1BQU00QixHQUFYLElBQWtCNUIsR0FBbEIsRUFBdUI7QUFDbkIsWUFBTXMyQixhQUFhLEdBQUcvYixxREFBUSxDQUFDM1ksR0FBRCxDQUE5Qjs7QUFDQSxVQUFJMjBCLGdCQUFnQixDQUFDRCxhQUFELENBQXBCLEVBQXFDO0FBQ2pDLGNBQU1wRCxHQUFHLEdBQUdsekIsR0FBRyxDQUFDNEIsR0FBRCxDQUFmO0FBQ0EsY0FBTTQwQixJQUFJLEdBQUl4YixVQUFVLENBQUNzYixhQUFELENBQVYsR0FDVnp6QixvREFBTyxDQUFDcXdCLEdBQUQsQ0FBUCxJQUFnQnZqQix1REFBWSxDQUFDdWpCLEdBQUQsQ0FBNUIsR0FBb0M7QUFBRXZ4QixjQUFJLEVBQUV1eEI7QUFBUixTQUFwQyxHQUFvREEsR0FEeEQ7O0FBRUEsWUFBSXNELElBQUosRUFBVTtBQUNOLGdCQUFNQyxZQUFZLEdBQUdDLFlBQVksQ0FBQzVyQixPQUFELEVBQVUwckIsSUFBSSxDQUFDNzBCLElBQWYsQ0FBakM7QUFDQSxnQkFBTWcxQixXQUFXLEdBQUdELFlBQVksQ0FBQ253QixNQUFELEVBQVNpd0IsSUFBSSxDQUFDNzBCLElBQWQsQ0FBaEM7QUFDQTYwQixjQUFJLENBQUM7QUFBRTtBQUFILFdBQUosR0FBMkJDLFlBQVksR0FBRyxDQUFDLENBQTNDO0FBQ0FELGNBQUksQ0FBQztBQUFFO0FBQUgsV0FBSixHQUNJRyxXQUFXLEdBQUcsQ0FBZCxJQUFtQkYsWUFBWSxHQUFHRSxXQUR0QyxDQUpNLENBTU47O0FBQ0EsY0FBSUYsWUFBWSxHQUFHLENBQUMsQ0FBaEIsSUFBcUJ0eEIsbURBQU0sQ0FBQ3F4QixJQUFELEVBQU8sU0FBUCxDQUEvQixFQUFrRDtBQUM5Q2Isd0JBQVksQ0FBQ2gxQixJQUFiLENBQWtCMjFCLGFBQWxCO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDSjs7QUFDRCxRQUFNN3hCLEdBQUcsR0FBRyxDQUFDdVcsVUFBRCxFQUFhMmEsWUFBYixDQUFaO0FBQ0EvYSxPQUFLLENBQUM3WSxHQUFOLENBQVVrVyxJQUFWLEVBQWdCeFQsR0FBaEI7QUFDQSxTQUFPQSxHQUFQO0FBQ0g7O0FBQ0QsU0FBUzh4QixnQkFBVCxDQUEwQjMwQixHQUExQixFQUErQjtBQUMzQixNQUFJQSxHQUFHLENBQUMsQ0FBRCxDQUFILEtBQVcsR0FBZixFQUFvQjtBQUNoQixXQUFPLElBQVA7QUFDSCxHQUZELE1BR0ssSUFBS3BDLElBQUwsRUFBNkM7QUFDOUM4RyxRQUFJLENBQUUsdUJBQXNCMUUsR0FBSSwyQkFBNUIsQ0FBSjtBQUNIOztBQUNELFNBQU8sS0FBUDtBQUNILEMsQ0FDRDtBQUNBOzs7QUFDQSxTQUFTZzFCLE9BQVQsQ0FBaUJDLElBQWpCLEVBQXVCO0FBQ25CLFFBQU1DLEtBQUssR0FBR0QsSUFBSSxJQUFJQSxJQUFJLENBQUNFLFFBQUwsR0FBZ0JELEtBQWhCLENBQXNCLG9CQUF0QixDQUF0QjtBQUNBLFNBQU9BLEtBQUssR0FBR0EsS0FBSyxDQUFDLENBQUQsQ0FBUixHQUFjLEVBQTFCO0FBQ0g7O0FBQ0QsU0FBU0UsVUFBVCxDQUFvQi9pQixDQUFwQixFQUF1QkMsQ0FBdkIsRUFBMEI7QUFDdEIsU0FBTzBpQixPQUFPLENBQUMzaUIsQ0FBRCxDQUFQLEtBQWUyaUIsT0FBTyxDQUFDMWlCLENBQUQsQ0FBN0I7QUFDSDs7QUFDRCxTQUFTd2lCLFlBQVQsQ0FBc0IvMEIsSUFBdEIsRUFBNEJzMUIsYUFBNUIsRUFBMkM7QUFDdkMsTUFBSXAwQixvREFBTyxDQUFDbzBCLGFBQUQsQ0FBWCxFQUE0QjtBQUN4QixXQUFPQSxhQUFhLENBQUNDLFNBQWQsQ0FBd0JDLENBQUMsSUFBSUgsVUFBVSxDQUFDRyxDQUFELEVBQUl4MUIsSUFBSixDQUF2QyxDQUFQO0FBQ0gsR0FGRCxNQUdLLElBQUlnTyx1REFBWSxDQUFDc25CLGFBQUQsQ0FBaEIsRUFBaUM7QUFDbEMsV0FBT0QsVUFBVSxDQUFDQyxhQUFELEVBQWdCdDFCLElBQWhCLENBQVYsR0FBa0MsQ0FBbEMsR0FBc0MsQ0FBQyxDQUE5QztBQUNIOztBQUNELFNBQU8sQ0FBQyxDQUFSO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7OztBQUNBLFNBQVN1ekIsYUFBVCxDQUF1QjVMLFFBQXZCLEVBQWlDbmEsS0FBakMsRUFBd0N6QixRQUF4QyxFQUFrRDtBQUM5QyxRQUFNMHBCLGNBQWMsR0FBRzd5QixzREFBSyxDQUFDNEssS0FBRCxDQUE1QjtBQUNBLFFBQU1yUCxPQUFPLEdBQUc0TixRQUFRLENBQUM2TCxZQUFULENBQXNCLENBQXRCLENBQWhCOztBQUNBLE9BQUssTUFBTTNYLEdBQVgsSUFBa0I5QixPQUFsQixFQUEyQjtBQUN2QixRQUFJb3pCLEdBQUcsR0FBR3B6QixPQUFPLENBQUM4QixHQUFELENBQWpCO0FBQ0EsUUFBSXN4QixHQUFHLElBQUksSUFBWCxFQUNJO0FBQ0ptRSxnQkFBWSxDQUFDejFCLEdBQUQsRUFBTXcxQixjQUFjLENBQUN4MUIsR0FBRCxDQUFwQixFQUEyQnN4QixHQUEzQixFQUFnQyxDQUFDL3RCLG1EQUFNLENBQUNta0IsUUFBRCxFQUFXMW5CLEdBQVgsQ0FBUCxJQUEwQixDQUFDdUQsbURBQU0sQ0FBQ21rQixRQUFELEVBQVdsUCxzREFBUyxDQUFDeFksR0FBRCxDQUFwQixDQUFqRSxDQUFaO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU3kxQixZQUFULENBQXNCem5CLElBQXRCLEVBQTRCckssS0FBNUIsRUFBbUNpeEIsSUFBbkMsRUFBeUNSLFFBQXpDLEVBQW1EO0FBQy9DLFFBQU07QUFBRXIwQixRQUFGO0FBQVEyMUIsWUFBUjtBQUFrQjdkO0FBQWxCLE1BQWdDK2MsSUFBdEMsQ0FEK0MsQ0FFL0M7O0FBQ0EsTUFBSWMsUUFBUSxJQUFJdEIsUUFBaEIsRUFBMEI7QUFDdEIxdkIsUUFBSSxDQUFDLDZCQUE2QnNKLElBQTdCLEdBQW9DLEdBQXJDLENBQUo7QUFDQTtBQUNILEdBTjhDLENBTy9DOzs7QUFDQSxNQUFJckssS0FBSyxJQUFJLElBQVQsSUFBaUIsQ0FBQ2l4QixJQUFJLENBQUNjLFFBQTNCLEVBQXFDO0FBQ2pDO0FBQ0gsR0FWOEMsQ0FXL0M7OztBQUNBLE1BQUkzMUIsSUFBSSxJQUFJLElBQVIsSUFBZ0JBLElBQUksS0FBSyxJQUE3QixFQUFtQztBQUMvQixRQUFJK1gsT0FBTyxHQUFHLEtBQWQ7QUFDQSxVQUFNNmQsS0FBSyxHQUFHMTBCLG9EQUFPLENBQUNsQixJQUFELENBQVAsR0FBZ0JBLElBQWhCLEdBQXVCLENBQUNBLElBQUQsQ0FBckM7QUFDQSxVQUFNczFCLGFBQWEsR0FBRyxFQUF0QixDQUgrQixDQUkvQjs7QUFDQSxTQUFLLElBQUkvMUIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3EyQixLQUFLLENBQUN6MkIsTUFBVixJQUFvQixDQUFDNFksT0FBckMsRUFBOEN4WSxDQUFDLEVBQS9DLEVBQW1EO0FBQy9DLFlBQU07QUFBRXMyQixhQUFGO0FBQVNDO0FBQVQsVUFBMEJDLFVBQVUsQ0FBQ255QixLQUFELEVBQVFneUIsS0FBSyxDQUFDcjJCLENBQUQsQ0FBYixDQUExQztBQUNBKzFCLG1CQUFhLENBQUN0MkIsSUFBZCxDQUFtQjgyQixZQUFZLElBQUksRUFBbkM7QUFDQS9kLGFBQU8sR0FBRzhkLEtBQVY7QUFDSDs7QUFDRCxRQUFJLENBQUM5ZCxPQUFMLEVBQWM7QUFDVnBULFVBQUksQ0FBQ3F4QixxQkFBcUIsQ0FBQy9uQixJQUFELEVBQU9ySyxLQUFQLEVBQWMweEIsYUFBZCxDQUF0QixDQUFKO0FBQ0E7QUFDSDtBQUNKLEdBMUI4QyxDQTJCL0M7OztBQUNBLE1BQUl4ZCxTQUFTLElBQUksQ0FBQ0EsU0FBUyxDQUFDbFUsS0FBRCxDQUEzQixFQUFvQztBQUNoQ2UsUUFBSSxDQUFDLDJEQUEyRHNKLElBQTNELEdBQWtFLElBQW5FLENBQUo7QUFDSDtBQUNKOztBQUNELE1BQU1nb0IsWUFBWSxHQUFHLGFBQWN4MEIsb0RBQU8sQ0FBQyw4Q0FBRCxDQUExQztBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTczBCLFVBQVQsQ0FBb0JueUIsS0FBcEIsRUFBMkI1RCxJQUEzQixFQUFpQztBQUM3QixNQUFJNjFCLEtBQUo7QUFDQSxRQUFNQyxZQUFZLEdBQUdiLE9BQU8sQ0FBQ2oxQixJQUFELENBQTVCOztBQUNBLE1BQUlpMkIsWUFBWSxDQUFDSCxZQUFELENBQWhCLEVBQWdDO0FBQzVCLFVBQU1OLENBQUMsR0FBRyxPQUFPNXhCLEtBQWpCO0FBQ0FpeUIsU0FBSyxHQUFHTCxDQUFDLEtBQUtNLFlBQVksQ0FBQ3RkLFdBQWIsRUFBZCxDQUY0QixDQUc1Qjs7QUFDQSxRQUFJLENBQUNxZCxLQUFELElBQVVMLENBQUMsS0FBSyxRQUFwQixFQUE4QjtBQUMxQkssV0FBSyxHQUFHanlCLEtBQUssWUFBWTVELElBQXpCO0FBQ0g7QUFDSixHQVBELE1BUUssSUFBSTgxQixZQUFZLEtBQUssUUFBckIsRUFBK0I7QUFDaENELFNBQUssR0FBR2hRLHFEQUFVLENBQUNqaUIsS0FBRCxDQUFsQjtBQUNILEdBRkksTUFHQSxJQUFJa3lCLFlBQVksS0FBSyxPQUFyQixFQUE4QjtBQUMvQkQsU0FBSyxHQUFHMzBCLG9EQUFPLENBQUMwQyxLQUFELENBQWY7QUFDSCxHQUZJLE1BR0E7QUFDRGl5QixTQUFLLEdBQUdqeUIsS0FBSyxZQUFZNUQsSUFBekI7QUFDSDs7QUFDRCxTQUFPO0FBQ0g2MUIsU0FERztBQUVIQztBQUZHLEdBQVA7QUFJSDtBQUNEO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU0UscUJBQVQsQ0FBK0IvbkIsSUFBL0IsRUFBcUNySyxLQUFyQyxFQUE0QzB4QixhQUE1QyxFQUEyRDtBQUN2RCxNQUFJdGYsT0FBTyxHQUFJLDZDQUE0Qy9ILElBQUssSUFBbEQsR0FDVCxhQUFZcW5CLGFBQWEsQ0FBQ3p6QixHQUFkLENBQWtCb0YsbURBQWxCLEVBQThCdUYsSUFBOUIsQ0FBbUMsSUFBbkMsQ0FBeUMsRUFEMUQ7QUFFQSxRQUFNc3BCLFlBQVksR0FBR1IsYUFBYSxDQUFDLENBQUQsQ0FBbEM7QUFDQSxRQUFNWSxZQUFZLEdBQUdydUIsc0RBQVMsQ0FBQ2pFLEtBQUQsQ0FBOUI7QUFDQSxRQUFNdXlCLGFBQWEsR0FBR0MsVUFBVSxDQUFDeHlCLEtBQUQsRUFBUWt5QixZQUFSLENBQWhDO0FBQ0EsUUFBTU8sYUFBYSxHQUFHRCxVQUFVLENBQUN4eUIsS0FBRCxFQUFRc3lCLFlBQVIsQ0FBaEMsQ0FOdUQsQ0FPdkQ7O0FBQ0EsTUFBSVosYUFBYSxDQUFDbjJCLE1BQWQsS0FBeUIsQ0FBekIsSUFDQW0zQixZQUFZLENBQUNSLFlBQUQsQ0FEWixJQUVBLENBQUNTLFNBQVMsQ0FBQ1QsWUFBRCxFQUFlSSxZQUFmLENBRmQsRUFFNEM7QUFDeENsZ0IsV0FBTyxJQUFLLGVBQWNtZ0IsYUFBYyxFQUF4QztBQUNIOztBQUNEbmdCLFNBQU8sSUFBSyxTQUFRa2dCLFlBQWEsR0FBakMsQ0FidUQsQ0FjdkQ7O0FBQ0EsTUFBSUksWUFBWSxDQUFDSixZQUFELENBQWhCLEVBQWdDO0FBQzVCbGdCLFdBQU8sSUFBSyxjQUFhcWdCLGFBQWMsR0FBdkM7QUFDSDs7QUFDRCxTQUFPcmdCLE9BQVA7QUFDSDtBQUNEO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU29nQixVQUFULENBQW9CeHlCLEtBQXBCLEVBQTJCNUQsSUFBM0IsRUFBaUM7QUFDN0IsTUFBSUEsSUFBSSxLQUFLLFFBQWIsRUFBdUI7QUFDbkIsV0FBUSxJQUFHNEQsS0FBTSxHQUFqQjtBQUNILEdBRkQsTUFHSyxJQUFJNUQsSUFBSSxLQUFLLFFBQWIsRUFBdUI7QUFDeEIsV0FBUSxHQUFFbUUsTUFBTSxDQUFDUCxLQUFELENBQVEsRUFBeEI7QUFDSCxHQUZJLE1BR0E7QUFDRCxXQUFRLEdBQUVBLEtBQU0sRUFBaEI7QUFDSDtBQUNKO0FBQ0Q7QUFDQTtBQUNBOzs7QUFDQSxTQUFTMHlCLFlBQVQsQ0FBc0J0MkIsSUFBdEIsRUFBNEI7QUFDeEIsUUFBTXcyQixhQUFhLEdBQUcsQ0FBQyxRQUFELEVBQVcsUUFBWCxFQUFxQixTQUFyQixDQUF0QjtBQUNBLFNBQU9BLGFBQWEsQ0FBQ3BhLElBQWQsQ0FBbUJxYSxJQUFJLElBQUl6MkIsSUFBSSxDQUFDd1ksV0FBTCxPQUF1QmllLElBQWxELENBQVA7QUFDSDtBQUNEO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU0YsU0FBVCxDQUFtQixHQUFHN3pCLElBQXRCLEVBQTRCO0FBQ3hCLFNBQU9BLElBQUksQ0FBQzBaLElBQUwsQ0FBVXFhLElBQUksSUFBSUEsSUFBSSxDQUFDamUsV0FBTCxPQUF1QixTQUF6QyxDQUFQO0FBQ0g7O0FBRUQsTUFBTWtlLGFBQWEsR0FBSXoyQixHQUFELElBQVNBLEdBQUcsQ0FBQyxDQUFELENBQUgsS0FBVyxHQUFYLElBQWtCQSxHQUFHLEtBQUssU0FBekQ7O0FBQ0EsTUFBTTAyQixrQkFBa0IsR0FBSS95QixLQUFELElBQVcxQyxvREFBTyxDQUFDMEMsS0FBRCxDQUFQLEdBQ2hDQSxLQUFLLENBQUMvQixHQUFOLENBQVVpYSxjQUFWLENBRGdDLEdBRWhDLENBQUNBLGNBQWMsQ0FBQ2xZLEtBQUQsQ0FBZixDQUZOOztBQUdBLE1BQU1nekIsYUFBYSxHQUFHLENBQUMzMkIsR0FBRCxFQUFNNDJCLE9BQU4sRUFBZXBjLEdBQWYsS0FBdUI7QUFDekMsUUFBTXBCLFVBQVUsR0FBR21CLE9BQU8sQ0FBRWhOLEtBQUQsSUFBVztBQUNsQyxRQUFLM1AsS0FBRCxJQUEyQ2ltQixlQUEvQyxFQUFnRTtBQUM1RG5mLFVBQUksQ0FBRSxTQUFRMUUsR0FBSSw0Q0FBYixHQUNBLHFEQURBLEdBRUEsOERBRkQsQ0FBSjtBQUdIOztBQUNELFdBQU8wMkIsa0JBQWtCLENBQUNFLE9BQU8sQ0FBQ3JwQixLQUFELENBQVIsQ0FBekI7QUFDSCxHQVB5QixFQU92QmlOLEdBUHVCLENBQTFCO0FBUUFwQixZQUFVLENBQUMyQixFQUFYLEdBQWdCLEtBQWhCO0FBQ0EsU0FBTzNCLFVBQVA7QUFDSCxDQVhEOztBQVlBLE1BQU15ZCxvQkFBb0IsR0FBRyxDQUFDQyxRQUFELEVBQVd6YixLQUFYLEVBQWtCdlAsUUFBbEIsS0FBK0I7QUFDeEQsUUFBTTBPLEdBQUcsR0FBR3NjLFFBQVEsQ0FBQ0MsSUFBckI7O0FBQ0EsT0FBSyxNQUFNLzJCLEdBQVgsSUFBa0I4MkIsUUFBbEIsRUFBNEI7QUFDeEIsUUFBSUwsYUFBYSxDQUFDejJCLEdBQUQsQ0FBakIsRUFDSTtBQUNKLFVBQU0yRCxLQUFLLEdBQUdtekIsUUFBUSxDQUFDOTJCLEdBQUQsQ0FBdEI7O0FBQ0EsUUFBSStOLHVEQUFZLENBQUNwSyxLQUFELENBQWhCLEVBQXlCO0FBQ3JCMFgsV0FBSyxDQUFDcmIsR0FBRCxDQUFMLEdBQWEyMkIsYUFBYSxDQUFDMzJCLEdBQUQsRUFBTTJELEtBQU4sRUFBYTZXLEdBQWIsQ0FBMUI7QUFDSCxLQUZELE1BR0ssSUFBSTdXLEtBQUssSUFBSSxJQUFiLEVBQW1CO0FBQ3BCLFVBQUsvRixJQUFMLEVBQ2U7QUFDWDhHLFlBQUksQ0FBRSw0Q0FBMkMxRSxHQUFJLEtBQWhELEdBQ0EsK0NBREQsQ0FBSjtBQUVIOztBQUNELFlBQU1vWixVQUFVLEdBQUdzZCxrQkFBa0IsQ0FBQy95QixLQUFELENBQXJDOztBQUNBMFgsV0FBSyxDQUFDcmIsR0FBRCxDQUFMLEdBQWEsTUFBTW9aLFVBQW5CO0FBQ0g7QUFDSjtBQUNKLENBbkJEOztBQW9CQSxNQUFNNGQsbUJBQW1CLEdBQUcsQ0FBQ2xyQixRQUFELEVBQVdrUixRQUFYLEtBQXdCO0FBQ2hELE1BQUtwZixLQUFELElBQ0EsQ0FBQzZyQixXQUFXLENBQUMzZCxRQUFRLENBQUNILEtBQVYsQ0FEWixJQUVBLENBQUUsS0FGTixFQUVlO0FBQ1hqSCxRQUFJLENBQUUsbURBQUQsR0FDQSwrQ0FERCxDQUFKO0FBRUg7O0FBQ0QsUUFBTTBVLFVBQVUsR0FBR3NkLGtCQUFrQixDQUFDMVosUUFBRCxDQUFyQzs7QUFDQWxSLFVBQVEsQ0FBQ3VQLEtBQVQsQ0FBZTRILE9BQWYsR0FBeUIsTUFBTTdKLFVBQS9CO0FBQ0gsQ0FURDs7QUFVQSxNQUFNNmQsU0FBUyxHQUFHLENBQUNuckIsUUFBRCxFQUFXa1IsUUFBWCxLQUF3QjtBQUN0QyxNQUFJbFIsUUFBUSxDQUFDSCxLQUFULENBQWVnUSxTQUFmLEdBQTJCO0FBQUc7QUFBbEMsSUFBd0Q7QUFDcEQsWUFBTTViLElBQUksR0FBR2lkLFFBQVEsQ0FBQ2thLENBQXRCOztBQUNBLFVBQUluM0IsSUFBSixFQUFVO0FBQ047QUFDQTtBQUNBK0wsZ0JBQVEsQ0FBQ3VQLEtBQVQsR0FBaUIxWSxzREFBSyxDQUFDcWEsUUFBRCxDQUF0QixDQUhNLENBSU47O0FBQ0FsVSx3REFBRyxDQUFDa1UsUUFBRCxFQUFXLEdBQVgsRUFBZ0JqZCxJQUFoQixDQUFIO0FBQ0gsT0FORCxNQU9LO0FBQ0Q4MkIsNEJBQW9CLENBQUM3WixRQUFELEVBQVlsUixRQUFRLENBQUN1UCxLQUFULEdBQWlCLEVBQTdCLENBQXBCO0FBQ0g7QUFDSixLQVpELE1BYUs7QUFDRHZQLFlBQVEsQ0FBQ3VQLEtBQVQsR0FBaUIsRUFBakI7O0FBQ0EsUUFBSTJCLFFBQUosRUFBYztBQUNWZ2EseUJBQW1CLENBQUNsckIsUUFBRCxFQUFXa1IsUUFBWCxDQUFuQjtBQUNIO0FBQ0o7O0FBQ0RsVSxrREFBRyxDQUFDZ0QsUUFBUSxDQUFDdVAsS0FBVixFQUFpQjhYLGlCQUFqQixFQUFvQyxDQUFwQyxDQUFIO0FBQ0gsQ0FyQkQ7O0FBc0JBLE1BQU1nRSxXQUFXLEdBQUcsQ0FBQ3JyQixRQUFELEVBQVdrUixRQUFYLEVBQXFCWSxTQUFyQixLQUFtQztBQUNuRCxRQUFNO0FBQUVqUyxTQUFGO0FBQVMwUDtBQUFULE1BQW1CdlAsUUFBekI7QUFDQSxNQUFJc3JCLGlCQUFpQixHQUFHLElBQXhCO0FBQ0EsTUFBSUMsd0JBQXdCLEdBQUdsNUIsa0RBQS9COztBQUNBLE1BQUl3TixLQUFLLENBQUNnUSxTQUFOLEdBQWtCO0FBQUc7QUFBekIsSUFBK0M7QUFDM0MsWUFBTTViLElBQUksR0FBR2lkLFFBQVEsQ0FBQ2thLENBQXRCOztBQUNBLFVBQUluM0IsSUFBSixFQUFVO0FBQ047QUFDQSxZQUFLbkMsS0FBRCxJQUEyQ2dWLGFBQS9DLEVBQThEO0FBQzFEO0FBQ0E7QUFDQS9OLDZEQUFNLENBQUN3VyxLQUFELEVBQVEyQixRQUFSLENBQU47QUFDSCxTQUpELE1BS0ssSUFBSVksU0FBUyxJQUFJN2QsSUFBSSxLQUFLO0FBQUU7QUFBNUIsVUFBMEM7QUFDM0M7QUFDQTtBQUNBcTNCLDZCQUFpQixHQUFHLEtBQXBCO0FBQ0gsV0FKSSxNQUtBO0FBQ0Q7QUFDQTtBQUNBdnlCLDZEQUFNLENBQUN3VyxLQUFELEVBQVEyQixRQUFSLENBQU4sQ0FIQyxDQUlEO0FBQ0E7QUFDQTtBQUNBOztBQUNBLGNBQUksQ0FBQ1ksU0FBRCxJQUFjN2QsSUFBSSxLQUFLO0FBQUU7QUFBN0IsWUFBMkM7QUFDdkMscUJBQU9zYixLQUFLLENBQUM2YixDQUFiO0FBQ0g7QUFDSjtBQUNKLE9BeEJELE1BeUJLO0FBQ0RFLHlCQUFpQixHQUFHLENBQUNwYSxRQUFRLENBQUNtQixPQUE5QjtBQUNBMFksNEJBQW9CLENBQUM3WixRQUFELEVBQVczQixLQUFYLENBQXBCO0FBQ0g7O0FBQ0RnYyw4QkFBd0IsR0FBR3JhLFFBQTNCO0FBQ0gsS0FoQ0QsTUFpQ0ssSUFBSUEsUUFBSixFQUFjO0FBQ2Y7QUFDQWdhLHVCQUFtQixDQUFDbHJCLFFBQUQsRUFBV2tSLFFBQVgsQ0FBbkI7QUFDQXFhLDRCQUF3QixHQUFHO0FBQUVwVSxhQUFPLEVBQUU7QUFBWCxLQUEzQjtBQUNILEdBekNrRCxDQTBDbkQ7OztBQUNBLE1BQUltVSxpQkFBSixFQUF1QjtBQUNuQixTQUFLLE1BQU1wM0IsR0FBWCxJQUFrQnFiLEtBQWxCLEVBQXlCO0FBQ3JCLFVBQUksQ0FBQ29iLGFBQWEsQ0FBQ3oyQixHQUFELENBQWQsSUFBdUIsRUFBRUEsR0FBRyxJQUFJcTNCLHdCQUFULENBQTNCLEVBQStEO0FBQzNELGVBQU9oYyxLQUFLLENBQUNyYixHQUFELENBQVo7QUFDSDtBQUNKO0FBQ0o7QUFDSixDQWxERDtBQW9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1zM0Isa0JBQWtCLEdBQUcsYUFBYzkxQixvREFBTyxDQUFDLHNFQUFELENBQWhEOztBQUNBLFNBQVMrMUIscUJBQVQsQ0FBK0J2cEIsSUFBL0IsRUFBcUM7QUFDakMsTUFBSXNwQixrQkFBa0IsQ0FBQ3RwQixJQUFELENBQXRCLEVBQThCO0FBQzFCdEosUUFBSSxDQUFDLCtEQUErRHNKLElBQWhFLENBQUo7QUFDSDtBQUNKO0FBQ0Q7QUFDQTtBQUNBOzs7QUFDQSxTQUFTd3BCLGNBQVQsQ0FBd0I3ckIsS0FBeEIsRUFBK0JrbEIsVUFBL0IsRUFBMkM7QUFDdkMsUUFBTTRHLGdCQUFnQixHQUFHM2Qsd0JBQXpCOztBQUNBLE1BQUkyZCxnQkFBZ0IsS0FBSyxJQUF6QixFQUErQjtBQUMxQjc1QixTQUFELElBQTJDOEcsSUFBSSxDQUFFLDBEQUFGLENBQS9DO0FBQ0EsV0FBT2lILEtBQVA7QUFDSDs7QUFDRCxRQUFNRyxRQUFRLEdBQUcyckIsZ0JBQWdCLENBQUNodkIsS0FBbEM7QUFDQSxRQUFNaXZCLFFBQVEsR0FBRy9yQixLQUFLLENBQUM4USxJQUFOLEtBQWU5USxLQUFLLENBQUM4USxJQUFOLEdBQWEsRUFBNUIsQ0FBakI7O0FBQ0EsT0FBSyxJQUFJbmQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3V4QixVQUFVLENBQUMzeEIsTUFBL0IsRUFBdUNJLENBQUMsRUFBeEMsRUFBNEM7QUFDeEMsUUFBSSxDQUFDcTRCLEdBQUQsRUFBTWgwQixLQUFOLEVBQWF5USxHQUFiLEVBQWtCd2pCLFNBQVMsR0FBR3o1QixrREFBOUIsSUFBMkMweUIsVUFBVSxDQUFDdnhCLENBQUQsQ0FBekQ7O0FBQ0EsUUFBSXlPLHVEQUFZLENBQUM0cEIsR0FBRCxDQUFoQixFQUF1QjtBQUNuQkEsU0FBRyxHQUFHO0FBQ0Y3SCxlQUFPLEVBQUU2SCxHQURQO0FBRUYzSCxlQUFPLEVBQUUySDtBQUZQLE9BQU47QUFJSDs7QUFDREQsWUFBUSxDQUFDMzRCLElBQVQsQ0FBYztBQUNWNDRCLFNBRFU7QUFFVjdyQixjQUZVO0FBR1ZuSSxXQUhVO0FBSVYvQyxjQUFRLEVBQUUsS0FBSyxDQUpMO0FBS1Z3VCxTQUxVO0FBTVZ3akI7QUFOVSxLQUFkO0FBUUg7O0FBQ0QsU0FBT2pzQixLQUFQO0FBQ0g7O0FBQ0QsU0FBU2tzQixtQkFBVCxDQUE2QmxzQixLQUE3QixFQUFvQytSLFNBQXBDLEVBQStDNVIsUUFBL0MsRUFBeURrQyxJQUF6RCxFQUErRDtBQUMzRCxRQUFNMHBCLFFBQVEsR0FBRy9yQixLQUFLLENBQUM4USxJQUF2QjtBQUNBLFFBQU1xYixXQUFXLEdBQUdwYSxTQUFTLElBQUlBLFNBQVMsQ0FBQ2pCLElBQTNDOztBQUNBLE9BQUssSUFBSW5kLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdvNEIsUUFBUSxDQUFDeDRCLE1BQTdCLEVBQXFDSSxDQUFDLEVBQXRDLEVBQTBDO0FBQ3RDLFVBQU15NEIsT0FBTyxHQUFHTCxRQUFRLENBQUNwNEIsQ0FBRCxDQUF4Qjs7QUFDQSxRQUFJdzRCLFdBQUosRUFBaUI7QUFDYkMsYUFBTyxDQUFDbjNCLFFBQVIsR0FBbUJrM0IsV0FBVyxDQUFDeDRCLENBQUQsQ0FBWCxDQUFlcUUsS0FBbEM7QUFDSDs7QUFDRCxRQUFJNlEsSUFBSSxHQUFHdWpCLE9BQU8sQ0FBQ0osR0FBUixDQUFZM3BCLElBQVosQ0FBWDs7QUFDQSxRQUFJd0csSUFBSixFQUFVO0FBQ047QUFDQTtBQUNBOVUsb0VBQWE7QUFDYjBPLGdDQUEwQixDQUFDb0csSUFBRCxFQUFPMUksUUFBUCxFQUFpQjtBQUFFO0FBQW5CLFFBQXlDLENBQy9ESCxLQUFLLENBQUMyUyxFQUR5RCxFQUUvRHlaLE9BRitELEVBRy9EcHNCLEtBSCtELEVBSS9EK1IsU0FKK0QsQ0FBekMsQ0FBMUI7QUFNQXplLG9FQUFhO0FBQ2hCO0FBQ0o7QUFDSjs7QUFFRCxTQUFTKzRCLGdCQUFULEdBQTRCO0FBQ3hCLFNBQU87QUFDSHRqQixPQUFHLEVBQUUsSUFERjtBQUVIeEksVUFBTSxFQUFFO0FBQ0orckIsaUJBQVcsRUFBRUMsMkNBRFQ7QUFFSkMsaUJBQVcsRUFBRSxLQUZUO0FBR0pDLHNCQUFnQixFQUFFLEVBSGQ7QUFJSmxHLDJCQUFxQixFQUFFLEVBSm5CO0FBS0psakIsa0JBQVksRUFBRXBQLFNBTFY7QUFNSnVNLGlCQUFXLEVBQUV2TSxTQU5UO0FBT0p5NEIscUJBQWUsRUFBRTtBQVBiLEtBRkw7QUFXSDVlLFVBQU0sRUFBRSxFQVhMO0FBWUhtWCxjQUFVLEVBQUUsRUFaVDtBQWFIQyxjQUFVLEVBQUUsRUFiVDtBQWNIL00sWUFBUSxFQUFFcGlCLE1BQU0sQ0FBQzhVLE1BQVAsQ0FBYyxJQUFkLENBZFA7QUFlSHliLGdCQUFZLEVBQUUsSUFBSTEwQixPQUFKLEVBZlg7QUFnQkhnM0IsY0FBVSxFQUFFLElBQUloM0IsT0FBSixFQWhCVDtBQWlCSDBiLGNBQVUsRUFBRSxJQUFJMWIsT0FBSjtBQWpCVCxHQUFQO0FBbUJIOztBQUNELElBQUlvQixHQUFHLEdBQUcsQ0FBVjs7QUFDQSxTQUFTMjVCLFlBQVQsQ0FBc0J4a0IsTUFBdEIsRUFBOEJ3TCxPQUE5QixFQUF1QztBQUNuQyxTQUFPLFNBQVNpWixTQUFULENBQW1CQyxhQUFuQixFQUFrQ0MsU0FBUyxHQUFHLElBQTlDLEVBQW9EO0FBQ3ZELFFBQUlBLFNBQVMsSUFBSSxJQUFiLElBQXFCLENBQUM3UyxxREFBVSxDQUFDNlMsU0FBRCxDQUFwQyxFQUFpRDtBQUM1Qzc2QixXQUFELElBQTJDOEcsSUFBSSxDQUFFLHFEQUFGLENBQS9DO0FBQ0ErekIsZUFBUyxHQUFHLElBQVo7QUFDSDs7QUFDRCxVQUFNQyxPQUFPLEdBQUdWLGdCQUFnQixFQUFoQztBQUNBLFVBQU1XLGdCQUFnQixHQUFHLElBQUlyNEIsR0FBSixFQUF6QjtBQUNBLFFBQUk4a0IsU0FBUyxHQUFHLEtBQWhCO0FBQ0EsVUFBTTFRLEdBQUcsR0FBSWdrQixPQUFPLENBQUNoa0IsR0FBUixHQUFjO0FBQ3ZCa2tCLFVBQUksRUFBRWo2QixHQUFHLEVBRGM7QUFFdkJrNkIsZ0JBQVUsRUFBRUwsYUFGVztBQUd2Qk0sWUFBTSxFQUFFTCxTQUhlO0FBSXZCTSxnQkFBVSxFQUFFLElBSlc7QUFLdkJDLGNBQVEsRUFBRU4sT0FMYTtBQU12Qk8sZUFBUyxFQUFFLElBTlk7QUFPdkJ0a0IsYUFQdUI7O0FBUXZCLFVBQUl6SSxNQUFKLEdBQWE7QUFDVCxlQUFPd3NCLE9BQU8sQ0FBQ3hzQixNQUFmO0FBQ0gsT0FWc0I7O0FBV3ZCLFVBQUlBLE1BQUosQ0FBVy9HLENBQVgsRUFBYztBQUNWLFlBQUt2SCxJQUFMLEVBQTZDO0FBQ3pDOEcsY0FBSSxDQUFFLG1FQUFGLENBQUo7QUFDSDtBQUNKLE9BZnNCOztBQWdCdkJ3MEIsU0FBRyxDQUFDQyxNQUFELEVBQVMsR0FBR2o3QixPQUFaLEVBQXFCO0FBQ3BCLFlBQUl5NkIsZ0JBQWdCLENBQUNwNEIsR0FBakIsQ0FBcUI0NEIsTUFBckIsQ0FBSixFQUFrQztBQUM3QnY3QixlQUFELElBQTJDOEcsSUFBSSxDQUFFLGdEQUFGLENBQS9DO0FBQ0gsU0FGRCxNQUdLLElBQUl5MEIsTUFBTSxJQUFJcHJCLHVEQUFZLENBQUNvckIsTUFBTSxDQUFDQyxPQUFSLENBQTFCLEVBQTRDO0FBQzdDVCwwQkFBZ0IsQ0FBQ240QixHQUFqQixDQUFxQjI0QixNQUFyQjtBQUNBQSxnQkFBTSxDQUFDQyxPQUFQLENBQWUxa0IsR0FBZixFQUFvQixHQUFHeFcsT0FBdkI7QUFDSCxTQUhJLE1BSUEsSUFBSTZQLHVEQUFZLENBQUNvckIsTUFBRCxDQUFoQixFQUEwQjtBQUMzQlIsMEJBQWdCLENBQUNuNEIsR0FBakIsQ0FBcUIyNEIsTUFBckI7QUFDQUEsZ0JBQU0sQ0FBQ3prQixHQUFELEVBQU0sR0FBR3hXLE9BQVQsQ0FBTjtBQUNILFNBSEksTUFJQSxJQUFLTixJQUFMLEVBQTZDO0FBQzlDOEcsY0FBSSxDQUFFLG9FQUFELEdBQ0EsV0FERCxDQUFKO0FBRUg7O0FBQ0QsZUFBT2dRLEdBQVA7QUFDSCxPQWpDc0I7O0FBa0N2QjJrQixXQUFLLENBQUNBLEtBQUQsRUFBUTtBQUNULFlBQUkvZixJQUFKLEVBQXlCO0FBQ3JCLGNBQUksQ0FBQ29mLE9BQU8sQ0FBQ2pmLE1BQVIsQ0FBZTVhLFFBQWYsQ0FBd0J3NkIsS0FBeEIsQ0FBTCxFQUFxQztBQUNqQ1gsbUJBQU8sQ0FBQ2pmLE1BQVIsQ0FBZTFhLElBQWYsQ0FBb0JzNkIsS0FBcEI7QUFDSCxXQUZELE1BR0ssSUFBS3o3QixJQUFMLEVBQTZDO0FBQzlDOEcsZ0JBQUksQ0FBQyxrREFDQTIwQixLQUFLLENBQUNyckIsSUFBTixHQUFjLEtBQUlxckIsS0FBSyxDQUFDcnJCLElBQUssRUFBN0IsR0FBaUMsRUFEakMsQ0FBRCxDQUFKO0FBRUg7QUFDSixTQVJELE1BU0ssRUFFSjs7QUFDRCxlQUFPMEcsR0FBUDtBQUNILE9BaERzQjs7QUFpRHZCM0ksZUFBUyxDQUFDaUMsSUFBRCxFQUFPakMsU0FBUCxFQUFrQjtBQUN2QixZQUFLbk8sSUFBTCxFQUE2QztBQUN6QzA3QiwrQkFBcUIsQ0FBQ3RyQixJQUFELEVBQU8wcUIsT0FBTyxDQUFDeHNCLE1BQWYsQ0FBckI7QUFDSDs7QUFDRCxZQUFJLENBQUNILFNBQUwsRUFBZ0I7QUFDWixpQkFBTzJzQixPQUFPLENBQUM5SCxVQUFSLENBQW1CNWlCLElBQW5CLENBQVA7QUFDSDs7QUFDRCxZQUFLcFEsS0FBRCxJQUEyQzg2QixPQUFPLENBQUM5SCxVQUFSLENBQW1CNWlCLElBQW5CLENBQS9DLEVBQXlFO0FBQ3JFdEosY0FBSSxDQUFFLGNBQWFzSixJQUFLLDhDQUFwQixDQUFKO0FBQ0g7O0FBQ0QwcUIsZUFBTyxDQUFDOUgsVUFBUixDQUFtQjVpQixJQUFuQixJQUEyQmpDLFNBQTNCO0FBQ0EsZUFBTzJJLEdBQVA7QUFDSCxPQTdEc0I7O0FBOER2QjZrQixlQUFTLENBQUN2ckIsSUFBRCxFQUFPdXJCLFNBQVAsRUFBa0I7QUFDdkIsWUFBSzM3QixJQUFMLEVBQTZDO0FBQ3pDMjVCLCtCQUFxQixDQUFDdnBCLElBQUQsQ0FBckI7QUFDSDs7QUFDRCxZQUFJLENBQUN1ckIsU0FBTCxFQUFnQjtBQUNaLGlCQUFPYixPQUFPLENBQUM3SCxVQUFSLENBQW1CN2lCLElBQW5CLENBQVA7QUFDSDs7QUFDRCxZQUFLcFEsS0FBRCxJQUEyQzg2QixPQUFPLENBQUM3SCxVQUFSLENBQW1CN2lCLElBQW5CLENBQS9DLEVBQXlFO0FBQ3JFdEosY0FBSSxDQUFFLGNBQWFzSixJQUFLLDhDQUFwQixDQUFKO0FBQ0g7O0FBQ0QwcUIsZUFBTyxDQUFDN0gsVUFBUixDQUFtQjdpQixJQUFuQixJQUEyQnVyQixTQUEzQjtBQUNBLGVBQU83a0IsR0FBUDtBQUNILE9BMUVzQjs7QUEyRXZCOGtCLFdBQUssQ0FBQ0MsYUFBRCxFQUFnQkMsU0FBaEIsRUFBMkJ6YSxLQUEzQixFQUFrQztBQUNuQyxZQUFJLENBQUNtRyxTQUFMLEVBQWdCO0FBQ1osZ0JBQU16WixLQUFLLEdBQUdtUixXQUFXLENBQUMwYixhQUFELEVBQWdCQyxTQUFoQixDQUF6QixDQURZLENBRVo7QUFDQTs7QUFDQTlzQixlQUFLLENBQUNNLFVBQU4sR0FBbUJ5c0IsT0FBbkIsQ0FKWSxDQUtaOztBQUNBLGNBQUs5NkIsSUFBTCxFQUE2QztBQUN6Qzg2QixtQkFBTyxDQUFDcmxCLE1BQVIsR0FBaUIsTUFBTTtBQUNuQlMsb0JBQU0sQ0FBQ3VJLFVBQVUsQ0FBQzFRLEtBQUQsQ0FBWCxFQUFvQjh0QixhQUFwQixFQUFtQ3hhLEtBQW5DLENBQU47QUFDSCxhQUZEO0FBR0g7O0FBQ0QsY0FBSXlhLFNBQVMsSUFBSXBhLE9BQWpCLEVBQTBCO0FBQ3RCQSxtQkFBTyxDQUFDM1QsS0FBRCxFQUFROHRCLGFBQVIsQ0FBUDtBQUNILFdBRkQsTUFHSztBQUNEM2xCLGtCQUFNLENBQUNuSSxLQUFELEVBQVE4dEIsYUFBUixFQUF1QnhhLEtBQXZCLENBQU47QUFDSDs7QUFDRG1HLG1CQUFTLEdBQUcsSUFBWjtBQUNBMVEsYUFBRyxDQUFDcWtCLFVBQUosR0FBaUJVLGFBQWpCO0FBQ0FBLHVCQUFhLENBQUNFLFdBQWQsR0FBNEJqbEIsR0FBNUI7O0FBQ0EsY0FBSzlXLElBQUwsRUFBc0U7QUFDbEU4VyxlQUFHLENBQUN1a0IsU0FBSixHQUFnQnR0QixLQUFLLENBQUNJLFNBQXRCO0FBQ0EwSSwyQkFBZSxDQUFDQyxHQUFELEVBQU1DLE9BQU4sQ0FBZjtBQUNIOztBQUNELGlCQUFPaEosS0FBSyxDQUFDSSxTQUFOLENBQWdCdEQsS0FBdkI7QUFDSCxTQXpCRCxNQTBCSyxJQUFLN0ssSUFBTCxFQUE2QztBQUM5QzhHLGNBQUksQ0FBRSxpQ0FBRCxHQUNBLG9FQURBLEdBRUEsa0VBRkEsR0FHQSwyREFIRCxDQUFKO0FBSUg7QUFDSixPQTVHc0I7O0FBNkd2QjhiLGFBQU8sR0FBRztBQUNOLFlBQUk0RSxTQUFKLEVBQWU7QUFDWHRSLGdCQUFNLENBQUMsSUFBRCxFQUFPWSxHQUFHLENBQUNxa0IsVUFBWCxDQUFOOztBQUNBLGNBQUtuN0IsSUFBTCxFQUFzRTtBQUNsRThXLGVBQUcsQ0FBQ3VrQixTQUFKLEdBQWdCLElBQWhCO0FBQ0EvakIsOEJBQWtCLENBQUNSLEdBQUQsQ0FBbEI7QUFDSDs7QUFDRCxpQkFBT0EsR0FBRyxDQUFDcWtCLFVBQUosQ0FBZVksV0FBdEI7QUFDSCxTQVBELE1BUUssSUFBSy83QixJQUFMLEVBQTZDO0FBQzlDOEcsY0FBSSxDQUFFLDRDQUFGLENBQUo7QUFDSDtBQUNKLE9BekhzQjs7QUEwSHZCa2YsYUFBTyxDQUFDNWpCLEdBQUQsRUFBTTJELEtBQU4sRUFBYTtBQUNoQixZQUFLL0YsS0FBRCxJQUEyQ29DLEdBQUcsSUFBSTA0QixPQUFPLENBQUM1VSxRQUE5RCxFQUF3RTtBQUNwRXBmLGNBQUksQ0FBRSwyQ0FBMENDLE1BQU0sQ0FBQzNFLEdBQUQsQ0FBTSxLQUF2RCxHQUNBLDRDQURELENBQUo7QUFFSCxTQUplLENBS2hCO0FBQ0E7OztBQUNBMDRCLGVBQU8sQ0FBQzVVLFFBQVIsQ0FBaUI5akIsR0FBakIsSUFBd0IyRCxLQUF4QjtBQUNBLGVBQU8rUSxHQUFQO0FBQ0g7O0FBbklzQixLQUEzQjtBQXFJQSxXQUFPQSxHQUFQO0FBQ0gsR0E5SUQ7QUErSUg7O0FBRUQsSUFBSWtsQixXQUFXLEdBQUcsS0FBbEI7O0FBQ0EsTUFBTUMsY0FBYyxHQUFJaGIsU0FBRCxJQUFlLE1BQU0yTyxJQUFOLENBQVczTyxTQUFTLENBQUNpYixZQUFyQixLQUFzQ2piLFNBQVMsQ0FBQ2tiLE9BQVYsS0FBc0IsZUFBbEc7O0FBQ0EsTUFBTUMsU0FBUyxHQUFJcFgsSUFBRCxJQUFVQSxJQUFJLENBQUNxWCxRQUFMLEtBQWtCO0FBQUU7QUFBaEQsQyxDQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNDLHdCQUFULENBQWtDL2EsaUJBQWxDLEVBQXFEO0FBQ2pELFFBQU07QUFBRWdiLE1BQUUsRUFBRUMsY0FBTjtBQUFzQi9wQixLQUFDLEVBQUV5UCxLQUF6QjtBQUFnQ0MsS0FBQyxFQUFFO0FBQUVzYSxlQUFGO0FBQWFDLGlCQUFiO0FBQTBCL1ksZ0JBQTFCO0FBQXNDQyxZQUF0QztBQUE4QytZLFlBQTlDO0FBQXNEQztBQUF0RDtBQUFuQyxNQUE2R3JiLGlCQUFuSDs7QUFDQSxRQUFNRyxPQUFPLEdBQUcsQ0FBQzNULEtBQUQsRUFBUWtULFNBQVIsS0FBc0I7QUFDbEMsUUFBSSxDQUFDQSxTQUFTLENBQUM0YixhQUFWLEVBQUwsRUFBZ0M7QUFDM0I3OEIsV0FBRCxJQUNJOEcsSUFBSSxDQUFFLGdFQUFELEdBQ0EsZ0NBREQsQ0FEUjtBQUdBb2IsV0FBSyxDQUFDLElBQUQsRUFBT25VLEtBQVAsRUFBY2tULFNBQWQsQ0FBTDtBQUNBM00sdUJBQWlCO0FBQ2pCO0FBQ0g7O0FBQ0QwbkIsZUFBVyxHQUFHLEtBQWQ7QUFDQS9XLGVBQVcsQ0FBQ2hFLFNBQVMsQ0FBQzZiLFVBQVgsRUFBdUIvdUIsS0FBdkIsRUFBOEIsSUFBOUIsRUFBb0MsSUFBcEMsRUFBMEMsSUFBMUMsQ0FBWDtBQUNBdUcscUJBQWlCOztBQUNqQixRQUFJMG5CLFdBQVcsSUFBSSxDQUFDLEtBQXBCLEVBQTJCO0FBQ3ZCO0FBQ0FuMUIsYUFBTyxDQUFDMEssS0FBUixDQUFlLDhDQUFmO0FBQ0g7QUFDSixHQWhCRDs7QUFpQkEsUUFBTTBULFdBQVcsR0FBRyxDQUFDRCxJQUFELEVBQU9qWCxLQUFQLEVBQWNvVCxlQUFkLEVBQStCQyxjQUEvQixFQUErQ0UsWUFBL0MsRUFBNkR0QixTQUFTLEdBQUcsS0FBekUsS0FBbUY7QUFDbkcsVUFBTStjLGVBQWUsR0FBR1gsU0FBUyxDQUFDcFgsSUFBRCxDQUFULElBQW1CQSxJQUFJLENBQUNySCxJQUFMLEtBQWMsR0FBekQ7O0FBQ0EsVUFBTXFmLFVBQVUsR0FBRyxNQUFNQyxjQUFjLENBQUNqWSxJQUFELEVBQU9qWCxLQUFQLEVBQWNvVCxlQUFkLEVBQStCQyxjQUEvQixFQUErQ0UsWUFBL0MsRUFBNkR5YixlQUE3RCxDQUF2Qzs7QUFDQSxVQUFNO0FBQUU1NkIsVUFBRjtBQUFRcUosU0FBUjtBQUFhdVM7QUFBYixRQUEyQmhRLEtBQWpDO0FBQ0EsVUFBTW12QixPQUFPLEdBQUdsWSxJQUFJLENBQUNxWCxRQUFyQjtBQUNBdHVCLFNBQUssQ0FBQzJTLEVBQU4sR0FBV3NFLElBQVg7QUFDQSxRQUFJbVksUUFBUSxHQUFHLElBQWY7O0FBQ0EsWUFBUWg3QixJQUFSO0FBQ0ksV0FBSytVLElBQUw7QUFDSSxZQUFJZ21CLE9BQU8sS0FBSztBQUFFO0FBQWxCLFVBQThCO0FBQzFCQyxvQkFBUSxHQUFHSCxVQUFVLEVBQXJCO0FBQ0gsV0FGRCxNQUdLO0FBQ0QsY0FBSWhZLElBQUksQ0FBQ3JILElBQUwsS0FBYzVQLEtBQUssQ0FBQ3FSLFFBQXhCLEVBQWtDO0FBQzlCNGMsdUJBQVcsR0FBRyxJQUFkO0FBQ0NoOEIsaUJBQUQsSUFDSThHLElBQUksQ0FBRSwwQkFBRCxHQUNBLGVBQWNtSixJQUFJLENBQUNDLFNBQUwsQ0FBZThVLElBQUksQ0FBQ3JILElBQXBCLENBQTBCLEVBRHhDLEdBRUEsZUFBYzFOLElBQUksQ0FBQ0MsU0FBTCxDQUFlbkMsS0FBSyxDQUFDcVIsUUFBckIsQ0FBK0IsRUFGOUMsQ0FEUjtBQUlBNEYsZ0JBQUksQ0FBQ3JILElBQUwsR0FBWTVQLEtBQUssQ0FBQ3FSLFFBQWxCO0FBQ0g7O0FBQ0QrZCxrQkFBUSxHQUFHVCxXQUFXLENBQUMxWCxJQUFELENBQXRCO0FBQ0g7O0FBQ0Q7O0FBQ0osV0FBSzVOLFNBQUw7QUFDSSxZQUFJOGxCLE9BQU8sS0FBSztBQUFFO0FBQWQsV0FBK0JILGVBQW5DLEVBQW9EO0FBQ2hESSxrQkFBUSxHQUFHSCxVQUFVLEVBQXJCO0FBQ0gsU0FGRCxNQUdLO0FBQ0RHLGtCQUFRLEdBQUdULFdBQVcsQ0FBQzFYLElBQUQsQ0FBdEI7QUFDSDs7QUFDRDs7QUFDSixXQUFLM04sTUFBTDtBQUNJLFlBQUk2bEIsT0FBTyxLQUFLO0FBQUU7QUFBbEIsVUFBaUM7QUFDN0JDLG9CQUFRLEdBQUdILFVBQVUsRUFBckI7QUFDSCxXQUZELE1BR0s7QUFDRDtBQUNBRyxrQkFBUSxHQUFHblksSUFBWCxDQUZDLENBR0Q7QUFDQTs7QUFDQSxnQkFBTW9ZLGtCQUFrQixHQUFHLENBQUNydkIsS0FBSyxDQUFDcVIsUUFBTixDQUFlOWQsTUFBM0M7O0FBQ0EsZUFBSyxJQUFJSSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcU0sS0FBSyxDQUFDc3ZCLFdBQTFCLEVBQXVDMzdCLENBQUMsRUFBeEMsRUFBNEM7QUFDeEMsZ0JBQUkwN0Isa0JBQUosRUFDSXJ2QixLQUFLLENBQUNxUixRQUFOLElBQWtCK2QsUUFBUSxDQUFDRyxTQUEzQjs7QUFDSixnQkFBSTU3QixDQUFDLEtBQUtxTSxLQUFLLENBQUNzdkIsV0FBTixHQUFvQixDQUE5QixFQUFpQztBQUM3QnR2QixtQkFBSyxDQUFDbVQsTUFBTixHQUFlaWMsUUFBZjtBQUNIOztBQUNEQSxvQkFBUSxHQUFHVCxXQUFXLENBQUNTLFFBQUQsQ0FBdEI7QUFDSDs7QUFDRCxpQkFBT0EsUUFBUDtBQUNIOztBQUNEOztBQUNKLFdBQUtsbUIsUUFBTDtBQUNJLFlBQUksQ0FBQzhsQixlQUFMLEVBQXNCO0FBQ2xCSSxrQkFBUSxHQUFHSCxVQUFVLEVBQXJCO0FBQ0gsU0FGRCxNQUdLO0FBQ0RHLGtCQUFRLEdBQUdJLGVBQWUsQ0FBQ3ZZLElBQUQsRUFBT2pYLEtBQVAsRUFBY29ULGVBQWQsRUFBK0JDLGNBQS9CLEVBQStDRSxZQUEvQyxFQUE2RHRCLFNBQTdELENBQTFCO0FBQ0g7O0FBQ0Q7O0FBQ0o7QUFDSSxZQUFJakMsU0FBUyxHQUFHO0FBQUU7QUFBbEIsVUFBaUM7QUFDN0IsZ0JBQUltZixPQUFPLEtBQUs7QUFBRTtBQUFkLGVBQ0FudkIsS0FBSyxDQUFDNUwsSUFBTixDQUFXd1ksV0FBWCxPQUNJcUssSUFBSSxDQUFDbVgsT0FBTCxDQUFheGhCLFdBQWIsRUFGUixFQUVvQztBQUNoQ3dpQixzQkFBUSxHQUFHSCxVQUFVLEVBQXJCO0FBQ0gsYUFKRCxNQUtLO0FBQ0RHLHNCQUFRLEdBQUdLLGNBQWMsQ0FBQ3hZLElBQUQsRUFBT2pYLEtBQVAsRUFBY29ULGVBQWQsRUFBK0JDLGNBQS9CLEVBQStDRSxZQUEvQyxFQUE2RHRCLFNBQTdELENBQXpCO0FBQ0g7QUFDSixXQVRELE1BVUssSUFBSWpDLFNBQVMsR0FBRztBQUFFO0FBQWxCLFVBQW1DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBaFEsaUJBQUssQ0FBQ3VULFlBQU4sR0FBcUJBLFlBQXJCO0FBQ0Esa0JBQU1MLFNBQVMsR0FBRzBDLFVBQVUsQ0FBQ3FCLElBQUQsQ0FBNUI7QUFDQXdYLDBCQUFjLENBQUN6dUIsS0FBRCxFQUFRa1QsU0FBUixFQUFtQixJQUFuQixFQUF5QkUsZUFBekIsRUFBMENDLGNBQTFDLEVBQTBENmEsY0FBYyxDQUFDaGIsU0FBRCxDQUF4RSxFQUFxRmpCLFNBQXJGLENBQWQsQ0FOb0MsQ0FPcEM7QUFDQTtBQUNBOztBQUNBbWQsb0JBQVEsR0FBR0osZUFBZSxHQUNwQlUsd0JBQXdCLENBQUN6WSxJQUFELENBREosR0FFcEIwWCxXQUFXLENBQUMxWCxJQUFELENBRmpCLENBVm9DLENBYXBDO0FBQ0E7QUFDQTtBQUNBOztBQUNBLGdCQUFJaUgsY0FBYyxDQUFDbGUsS0FBRCxDQUFsQixFQUEyQjtBQUN2QixrQkFBSTRTLE9BQUo7O0FBQ0Esa0JBQUlvYyxlQUFKLEVBQXFCO0FBQ2pCcGMsdUJBQU8sR0FBR3pCLFdBQVcsQ0FBQ2pJLFFBQUQsQ0FBckI7QUFDQTBKLHVCQUFPLENBQUNPLE1BQVIsR0FBaUJpYyxRQUFRLEdBQ25CQSxRQUFRLENBQUNPLGVBRFUsR0FFbkJ6YyxTQUFTLENBQUMwYyxTQUZoQjtBQUdILGVBTEQsTUFNSztBQUNEaGQsdUJBQU8sR0FDSHFFLElBQUksQ0FBQ3FYLFFBQUwsS0FBa0IsQ0FBbEIsR0FBc0J1QixlQUFlLENBQUMsRUFBRCxDQUFyQyxHQUE0QzFlLFdBQVcsQ0FBQyxLQUFELENBRDNEO0FBRUg7O0FBQ0R5QixxQkFBTyxDQUFDRCxFQUFSLEdBQWFzRSxJQUFiO0FBQ0FqWCxtQkFBSyxDQUFDSSxTQUFOLENBQWdCd1MsT0FBaEIsR0FBMEJBLE9BQTFCO0FBQ0g7QUFDSixXQWhDSSxNQWlDQSxJQUFJNUMsU0FBUyxHQUFHO0FBQUc7QUFBbkIsVUFBbUM7QUFDcEMsZ0JBQUltZixPQUFPLEtBQUs7QUFBRTtBQUFsQixjQUFpQztBQUM3QkMsd0JBQVEsR0FBR0gsVUFBVSxFQUFyQjtBQUNILGVBRkQsTUFHSztBQUNERyxzQkFBUSxHQUFHcHZCLEtBQUssQ0FBQzVMLElBQU4sQ0FBV3VmLE9BQVgsQ0FBbUJzRCxJQUFuQixFQUF5QmpYLEtBQXpCLEVBQWdDb1QsZUFBaEMsRUFBaURDLGNBQWpELEVBQWlFRSxZQUFqRSxFQUErRXRCLFNBQS9FLEVBQTBGdUIsaUJBQTFGLEVBQTZHc2MsZUFBN0csQ0FBWDtBQUNIO0FBQ0osV0FQSSxNQVFBLElBQUk5ZixTQUFTLEdBQUc7QUFBSTtBQUFwQixVQUFvQztBQUNyQ29mLG9CQUFRLEdBQUdwdkIsS0FBSyxDQUFDNUwsSUFBTixDQUFXdWYsT0FBWCxDQUFtQnNELElBQW5CLEVBQXlCalgsS0FBekIsRUFBZ0NvVCxlQUFoQyxFQUFpREMsY0FBakQsRUFBaUU2YSxjQUFjLENBQUN0WSxVQUFVLENBQUNxQixJQUFELENBQVgsQ0FBL0UsRUFBbUcxRCxZQUFuRyxFQUFpSHRCLFNBQWpILEVBQTRIdUIsaUJBQTVILEVBQStJMEQsV0FBL0ksQ0FBWDtBQUNILFdBRkksTUFHQSxJQUFLamxCLElBQUwsRUFBNkM7QUFDOUM4RyxjQUFJLENBQUMseUJBQUQsRUFBNEIzRSxJQUE1QixFQUFtQyxJQUFHLE9BQU9BLElBQUssR0FBbEQsQ0FBSjtBQUNIOztBQS9HVDs7QUFpSEEsUUFBSXFKLEdBQUcsSUFBSSxJQUFYLEVBQWlCO0FBQ2JzeUIsWUFBTSxDQUFDdHlCLEdBQUQsRUFBTSxJQUFOLEVBQVk0VixjQUFaLEVBQTRCclQsS0FBNUIsQ0FBTjtBQUNIOztBQUNELFdBQU9vdkIsUUFBUDtBQUNILEdBNUhEOztBQTZIQSxRQUFNSyxjQUFjLEdBQUcsQ0FBQzljLEVBQUQsRUFBSzNTLEtBQUwsRUFBWW9ULGVBQVosRUFBNkJDLGNBQTdCLEVBQTZDRSxZQUE3QyxFQUEyRHRCLFNBQTNELEtBQXlFO0FBQzVGQSxhQUFTLEdBQUdBLFNBQVMsSUFBSSxDQUFDLENBQUNqUyxLQUFLLENBQUNzUixlQUFqQztBQUNBLFVBQU07QUFBRWxkLFVBQUY7QUFBUXdOLFdBQVI7QUFBZTBPLGVBQWY7QUFBMEJOLGVBQTFCO0FBQXFDYztBQUFyQyxRQUE4QzlRLEtBQXBELENBRjRGLENBRzVGO0FBQ0E7O0FBQ0EsVUFBTWd3QixlQUFlLEdBQUk1N0IsSUFBSSxLQUFLLE9BQVQsSUFBb0IwYyxJQUFyQixJQUE4QjFjLElBQUksS0FBSyxRQUEvRCxDQUw0RixDQU01Rjs7QUFDQSxRQUFJNDdCLGVBQWUsSUFBSTFmLFNBQVMsS0FBSyxDQUFDO0FBQUU7QUFBeEMsTUFBdUQ7QUFDbkQsWUFBSVEsSUFBSixFQUFVO0FBQ05vYiw2QkFBbUIsQ0FBQ2xzQixLQUFELEVBQVEsSUFBUixFQUFjb1QsZUFBZCxFQUErQixTQUEvQixDQUFuQjtBQUNILFNBSGtELENBSW5EOzs7QUFDQSxZQUFJeFIsS0FBSixFQUFXO0FBQ1AsY0FBSW91QixlQUFlLElBQ2YsQ0FBQy9kLFNBREQsSUFFQzNCLFNBQVMsR0FBRztBQUFHO0FBQWYsYUFDR0EsU0FBUyxHQUFHO0FBQUc7QUFIdkIsWUFHOEM7QUFDMUMsaUJBQUssTUFBTWpjLEdBQVgsSUFBa0J1TixLQUFsQixFQUF5QjtBQUNyQixrQkFBS291QixlQUFlLElBQUkzN0IsR0FBRyxDQUFDNDdCLFFBQUosQ0FBYSxPQUFiLENBQXBCLElBQ0NoaUIsaURBQUksQ0FBQzVaLEdBQUQsQ0FBSixJQUFhLENBQUNpMEIsMkRBQWMsQ0FBQ2owQixHQUFELENBRGpDLEVBQ3lDO0FBQ3JDcTZCLHlCQUFTLENBQUMvYixFQUFELEVBQUt0ZSxHQUFMLEVBQVUsSUFBVixFQUFnQnVOLEtBQUssQ0FBQ3ZOLEdBQUQsQ0FBckIsQ0FBVDtBQUNIO0FBQ0o7QUFDSixXQVZELE1BV0ssSUFBSXVOLEtBQUssQ0FBQ3N1QixPQUFWLEVBQW1CO0FBQ3BCO0FBQ0E7QUFDQXhCLHFCQUFTLENBQUMvYixFQUFELEVBQUssU0FBTCxFQUFnQixJQUFoQixFQUFzQi9RLEtBQUssQ0FBQ3N1QixPQUE1QixDQUFUO0FBQ0g7QUFDSixTQXRCa0QsQ0F1Qm5EOzs7QUFDQSxZQUFJQyxVQUFKOztBQUNBLFlBQUtBLFVBQVUsR0FBR3Z1QixLQUFLLElBQUlBLEtBQUssQ0FBQ3d1QixrQkFBakMsRUFBc0Q7QUFDbER4UCx5QkFBZSxDQUFDdVAsVUFBRCxFQUFhL2MsZUFBYixFQUE4QnBULEtBQTlCLENBQWY7QUFDSDs7QUFDRCxZQUFJOFEsSUFBSixFQUFVO0FBQ05vYiw2QkFBbUIsQ0FBQ2xzQixLQUFELEVBQVEsSUFBUixFQUFjb1QsZUFBZCxFQUErQixhQUEvQixDQUFuQjtBQUNIOztBQUNELFlBQUksQ0FBQytjLFVBQVUsR0FBR3Z1QixLQUFLLElBQUlBLEtBQUssQ0FBQytlLGNBQTdCLEtBQWdEN1AsSUFBcEQsRUFBMEQ7QUFDdERpSCxpQ0FBdUIsQ0FBQyxNQUFNO0FBQzFCb1ksc0JBQVUsSUFBSXZQLGVBQWUsQ0FBQ3VQLFVBQUQsRUFBYS9jLGVBQWIsRUFBOEJwVCxLQUE5QixDQUE3QjtBQUNBOFEsZ0JBQUksSUFBSW9iLG1CQUFtQixDQUFDbHNCLEtBQUQsRUFBUSxJQUFSLEVBQWNvVCxlQUFkLEVBQStCLFNBQS9CLENBQTNCO0FBQ0gsV0FIc0IsRUFHcEJDLGNBSG9CLENBQXZCO0FBSUgsU0FwQ2tELENBcUNuRDs7O0FBQ0EsWUFBSXJELFNBQVMsR0FBRztBQUFHO0FBQWYsV0FDQTtBQUNBLFVBQUVwTyxLQUFLLEtBQUtBLEtBQUssQ0FBQ3l1QixTQUFOLElBQW1CenVCLEtBQUssQ0FBQzB1QixXQUE5QixDQUFQLENBRkosRUFFd0Q7QUFDcEQsY0FBSXAxQixJQUFJLEdBQUc0MEIsZUFBZSxDQUFDbmQsRUFBRSxDQUFDb2MsVUFBSixFQUFnQi91QixLQUFoQixFQUF1QjJTLEVBQXZCLEVBQTJCUyxlQUEzQixFQUE0Q0MsY0FBNUMsRUFBNERFLFlBQTVELEVBQTBFdEIsU0FBMUUsQ0FBMUI7QUFDQSxjQUFJdUQsU0FBUyxHQUFHLEtBQWhCOztBQUNBLGlCQUFPdGEsSUFBUCxFQUFhO0FBQ1QreUIsdUJBQVcsR0FBRyxJQUFkOztBQUNBLGdCQUFLaDhCLEtBQUQsSUFBMkMsQ0FBQ3VqQixTQUFoRCxFQUEyRDtBQUN2RHpjLGtCQUFJLENBQUUsbUNBQWtDaUgsS0FBSyxDQUFDNUwsSUFBSyxLQUE5QyxHQUNBLHFFQURELENBQUo7QUFFQW9oQix1QkFBUyxHQUFHLElBQVo7QUFDSCxhQU5RLENBT1Q7OztBQUNBLGtCQUFNelMsR0FBRyxHQUFHN0gsSUFBWjtBQUNBQSxnQkFBSSxHQUFHQSxJQUFJLENBQUN5ekIsV0FBWjtBQUNBOVksa0JBQU0sQ0FBQzlTLEdBQUQsQ0FBTjtBQUNIO0FBQ0osU0FqQkQsTUFrQkssSUFBSWlOLFNBQVMsR0FBRztBQUFFO0FBQWxCLFVBQXVDO0FBQ3hDLGdCQUFJMkMsRUFBRSxDQUFDMmQsV0FBSCxLQUFtQnR3QixLQUFLLENBQUNxUixRQUE3QixFQUF1QztBQUNuQzRjLHlCQUFXLEdBQUcsSUFBZDtBQUNDaDhCLG1CQUFELElBQ0k4RyxJQUFJLENBQUUsdUNBQXNDaUgsS0FBSyxDQUFDNUwsSUFBSyxNQUFsRCxHQUNBLGFBQVl1ZSxFQUFFLENBQUMyZCxXQUFZLElBRDNCLEdBRUEsYUFBWXR3QixLQUFLLENBQUNxUixRQUFTLEVBRjVCLENBRFI7QUFJQXNCLGdCQUFFLENBQUMyZCxXQUFILEdBQWlCdHdCLEtBQUssQ0FBQ3FSLFFBQXZCO0FBQ0g7QUFDSjtBQUNKOztBQUNELFdBQU9zQixFQUFFLENBQUNnYyxXQUFWO0FBQ0gsR0EzRUQ7O0FBNEVBLFFBQU1tQixlQUFlLEdBQUcsQ0FBQzdZLElBQUQsRUFBT3NaLFdBQVAsRUFBb0JyZCxTQUFwQixFQUErQkUsZUFBL0IsRUFBZ0RDLGNBQWhELEVBQWdFRSxZQUFoRSxFQUE4RXRCLFNBQTlFLEtBQTRGO0FBQ2hIQSxhQUFTLEdBQUdBLFNBQVMsSUFBSSxDQUFDLENBQUNzZSxXQUFXLENBQUNqZixlQUF2QztBQUNBLFVBQU1ELFFBQVEsR0FBR2tmLFdBQVcsQ0FBQ2xmLFFBQTdCO0FBQ0EsVUFBTXBhLENBQUMsR0FBR29hLFFBQVEsQ0FBQzlkLE1BQW5CO0FBQ0EsUUFBSWlpQixTQUFTLEdBQUcsS0FBaEI7O0FBQ0EsU0FBSyxJQUFJN2hCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdzRCxDQUFwQixFQUF1QnRELENBQUMsRUFBeEIsRUFBNEI7QUFDeEIsWUFBTXFNLEtBQUssR0FBR2lTLFNBQVMsR0FDakJaLFFBQVEsQ0FBQzFkLENBQUQsQ0FEUyxHQUVoQjBkLFFBQVEsQ0FBQzFkLENBQUQsQ0FBUixHQUFjdWMsY0FBYyxDQUFDbUIsUUFBUSxDQUFDMWQsQ0FBRCxDQUFULENBRm5DOztBQUdBLFVBQUlzakIsSUFBSixFQUFVO0FBQ05BLFlBQUksR0FBR0MsV0FBVyxDQUFDRCxJQUFELEVBQU9qWCxLQUFQLEVBQWNvVCxlQUFkLEVBQStCQyxjQUEvQixFQUErQ0UsWUFBL0MsRUFBNkR0QixTQUE3RCxDQUFsQjtBQUNILE9BRkQsTUFHSyxJQUFJalMsS0FBSyxDQUFDNUwsSUFBTixLQUFlK1UsSUFBZixJQUF1QixDQUFDbkosS0FBSyxDQUFDcVIsUUFBbEMsRUFBNEM7QUFDN0M7QUFDSCxPQUZJLE1BR0E7QUFDRDRjLG1CQUFXLEdBQUcsSUFBZDs7QUFDQSxZQUFLaDhCLEtBQUQsSUFBMkMsQ0FBQ3VqQixTQUFoRCxFQUEyRDtBQUN2RHpjLGNBQUksQ0FBRSxtQ0FBa0NtYSxTQUFTLENBQUNrYixPQUFWLENBQWtCeGhCLFdBQWxCLEVBQWdDLEtBQW5FLEdBQ0Esc0VBREQsQ0FBSjtBQUVBNEksbUJBQVMsR0FBRyxJQUFaO0FBQ0gsU0FOQSxDQU9EOzs7QUFDQXJCLGFBQUssQ0FBQyxJQUFELEVBQU9uVSxLQUFQLEVBQWNrVCxTQUFkLEVBQXlCLElBQXpCLEVBQStCRSxlQUEvQixFQUFnREMsY0FBaEQsRUFBZ0U2YSxjQUFjLENBQUNoYixTQUFELENBQTlFLEVBQTJGSyxZQUEzRixDQUFMO0FBQ0g7QUFDSjs7QUFDRCxXQUFPMEQsSUFBUDtBQUNILEdBM0JEOztBQTRCQSxRQUFNdVksZUFBZSxHQUFHLENBQUN2WSxJQUFELEVBQU9qWCxLQUFQLEVBQWNvVCxlQUFkLEVBQStCQyxjQUEvQixFQUErQ0UsWUFBL0MsRUFBNkR0QixTQUE3RCxLQUEyRTtBQUMvRixVQUFNO0FBQUVzQixrQkFBWSxFQUFFaWQ7QUFBaEIsUUFBeUN4d0IsS0FBL0M7O0FBQ0EsUUFBSXd3QixvQkFBSixFQUEwQjtBQUN0QmpkLGtCQUFZLEdBQUdBLFlBQVksR0FDckJBLFlBQVksQ0FBQ3ZDLE1BQWIsQ0FBb0J3ZixvQkFBcEIsQ0FEcUIsR0FFckJBLG9CQUZOO0FBR0g7O0FBQ0QsVUFBTXRkLFNBQVMsR0FBRzBDLFVBQVUsQ0FBQ3FCLElBQUQsQ0FBNUI7QUFDQSxVQUFNL2IsSUFBSSxHQUFHNDBCLGVBQWUsQ0FBQ25CLFdBQVcsQ0FBQzFYLElBQUQsQ0FBWixFQUFvQmpYLEtBQXBCLEVBQTJCa1QsU0FBM0IsRUFBc0NFLGVBQXRDLEVBQXVEQyxjQUF2RCxFQUF1RUUsWUFBdkUsRUFBcUZ0QixTQUFyRixDQUE1Qjs7QUFDQSxRQUFJL1csSUFBSSxJQUFJbXpCLFNBQVMsQ0FBQ256QixJQUFELENBQWpCLElBQTJCQSxJQUFJLENBQUMwVSxJQUFMLEtBQWMsR0FBN0MsRUFBa0Q7QUFDOUMsYUFBTytlLFdBQVcsQ0FBRTN1QixLQUFLLENBQUNtVCxNQUFOLEdBQWVqWSxJQUFqQixDQUFsQjtBQUNILEtBRkQsTUFHSztBQUNEO0FBQ0E7QUFDQSt5QixpQkFBVyxHQUFHLElBQWQsQ0FIQyxDQUlEOztBQUNBVyxZQUFNLENBQUU1dUIsS0FBSyxDQUFDbVQsTUFBTixHQUFlMGIsYUFBYSxDQUFFLEdBQUYsQ0FBOUIsRUFBc0MzYixTQUF0QyxFQUFpRGhZLElBQWpELENBQU47QUFDQSxhQUFPQSxJQUFQO0FBQ0g7QUFDSixHQXBCRDs7QUFxQkEsUUFBTWcwQixjQUFjLEdBQUcsQ0FBQ2pZLElBQUQsRUFBT2pYLEtBQVAsRUFBY29ULGVBQWQsRUFBK0JDLGNBQS9CLEVBQStDRSxZQUEvQyxFQUE2RGtkLFVBQTdELEtBQTRFO0FBQy9GeEMsZUFBVyxHQUFHLElBQWQ7QUFDQ2g4QixTQUFELElBQ0k4RyxJQUFJLENBQUUsMkNBQUYsRUFBOENpSCxLQUFLLENBQUM1TCxJQUFwRCxFQUEyRCwwQkFBM0QsRUFBc0Y2aUIsSUFBdEYsRUFBNEZBLElBQUksQ0FBQ3FYLFFBQUwsS0FBa0I7QUFBRTtBQUFwQixNQUN6RixRQUR5RixHQUUxRkQsU0FBUyxDQUFDcFgsSUFBRCxDQUFULElBQW1CQSxJQUFJLENBQUNySCxJQUFMLEtBQWMsR0FBakMsR0FDSyxxQkFETCxHQUVLLEVBSlAsQ0FEUjtBQU1BNVAsU0FBSyxDQUFDMlMsRUFBTixHQUFXLElBQVg7O0FBQ0EsUUFBSThkLFVBQUosRUFBZ0I7QUFDWjtBQUNBLFlBQU16ckIsR0FBRyxHQUFHMHFCLHdCQUF3QixDQUFDelksSUFBRCxDQUFwQzs7QUFDQSxhQUFPLElBQVAsRUFBYTtBQUNULGNBQU0vYixJQUFJLEdBQUd5ekIsV0FBVyxDQUFDMVgsSUFBRCxDQUF4Qjs7QUFDQSxZQUFJL2IsSUFBSSxJQUFJQSxJQUFJLEtBQUs4SixHQUFyQixFQUEwQjtBQUN0QjZRLGdCQUFNLENBQUMzYSxJQUFELENBQU47QUFDSCxTQUZELE1BR0s7QUFDRDtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxVQUFNQSxJQUFJLEdBQUd5ekIsV0FBVyxDQUFDMVgsSUFBRCxDQUF4QjtBQUNBLFVBQU0vRCxTQUFTLEdBQUcwQyxVQUFVLENBQUNxQixJQUFELENBQTVCO0FBQ0FwQixVQUFNLENBQUNvQixJQUFELENBQU47QUFDQTlDLFNBQUssQ0FBQyxJQUFELEVBQU9uVSxLQUFQLEVBQWNrVCxTQUFkLEVBQXlCaFksSUFBekIsRUFBK0JrWSxlQUEvQixFQUFnREMsY0FBaEQsRUFBZ0U2YSxjQUFjLENBQUNoYixTQUFELENBQTlFLEVBQTJGSyxZQUEzRixDQUFMO0FBQ0EsV0FBT3JZLElBQVA7QUFDSCxHQTNCRDs7QUE0QkEsUUFBTXcwQix3QkFBd0IsR0FBSXpZLElBQUQsSUFBVTtBQUN2QyxRQUFJc1MsS0FBSyxHQUFHLENBQVo7O0FBQ0EsV0FBT3RTLElBQVAsRUFBYTtBQUNUQSxVQUFJLEdBQUcwWCxXQUFXLENBQUMxWCxJQUFELENBQWxCOztBQUNBLFVBQUlBLElBQUksSUFBSW9YLFNBQVMsQ0FBQ3BYLElBQUQsQ0FBckIsRUFBNkI7QUFDekIsWUFBSUEsSUFBSSxDQUFDckgsSUFBTCxLQUFjLEdBQWxCLEVBQ0kyWixLQUFLOztBQUNULFlBQUl0UyxJQUFJLENBQUNySCxJQUFMLEtBQWMsR0FBbEIsRUFBdUI7QUFDbkIsY0FBSTJaLEtBQUssS0FBSyxDQUFkLEVBQWlCO0FBQ2IsbUJBQU9vRixXQUFXLENBQUMxWCxJQUFELENBQWxCO0FBQ0gsV0FGRCxNQUdLO0FBQ0RzUyxpQkFBSztBQUNSO0FBQ0o7QUFDSjtBQUNKOztBQUNELFdBQU90UyxJQUFQO0FBQ0gsR0FsQkQ7O0FBbUJBLFNBQU8sQ0FBQ3RELE9BQUQsRUFBVXVELFdBQVYsQ0FBUDtBQUNIOztBQUVELElBQUl3WixTQUFKO0FBQ0EsSUFBSUMsSUFBSjs7QUFDQSxTQUFTQyxZQUFULENBQXNCendCLFFBQXRCLEVBQWdDL0wsSUFBaEMsRUFBc0M7QUFDbEMsTUFBSStMLFFBQVEsQ0FBQ0csVUFBVCxDQUFvQkMsTUFBcEIsQ0FBMkJpc0IsV0FBM0IsSUFBMENxRSxXQUFXLEVBQXpELEVBQTZEO0FBQ3pERixRQUFJLENBQUNHLElBQUwsQ0FBVyxPQUFNMThCLElBQUssSUFBRytMLFFBQVEsQ0FBQ25OLEdBQUksRUFBdEM7QUFDSDs7QUFDRCxNQUFLZixJQUFMLEVBQXNFO0FBQ2xFMlgscUJBQWlCLENBQUN6SixRQUFELEVBQVcvTCxJQUFYLEVBQWlCczhCLFNBQVMsR0FBR0MsSUFBSSxDQUFDSSxHQUFMLEVBQUgsR0FBZ0JDLElBQUksQ0FBQ0QsR0FBTCxFQUExQyxDQUFqQjtBQUNIO0FBQ0o7O0FBQ0QsU0FBU0UsVUFBVCxDQUFvQjl3QixRQUFwQixFQUE4Qi9MLElBQTlCLEVBQW9DO0FBQ2hDLE1BQUkrTCxRQUFRLENBQUNHLFVBQVQsQ0FBb0JDLE1BQXBCLENBQTJCaXNCLFdBQTNCLElBQTBDcUUsV0FBVyxFQUF6RCxFQUE2RDtBQUN6RCxVQUFNSyxRQUFRLEdBQUksT0FBTTk4QixJQUFLLElBQUcrTCxRQUFRLENBQUNuTixHQUFJLEVBQTdDO0FBQ0EsVUFBTW0rQixNQUFNLEdBQUdELFFBQVEsR0FBSSxNQUEzQjtBQUNBUCxRQUFJLENBQUNHLElBQUwsQ0FBVUssTUFBVjtBQUNBUixRQUFJLENBQUNTLE9BQUwsQ0FBYyxJQUFHdndCLG1CQUFtQixDQUFDVixRQUFELEVBQVdBLFFBQVEsQ0FBQy9MLElBQXBCLENBQTBCLEtBQUlBLElBQUssRUFBdkUsRUFBMEU4OEIsUUFBMUUsRUFBb0ZDLE1BQXBGO0FBQ0FSLFFBQUksQ0FBQ1UsVUFBTCxDQUFnQkgsUUFBaEI7QUFDQVAsUUFBSSxDQUFDVSxVQUFMLENBQWdCRixNQUFoQjtBQUNIOztBQUNELE1BQUtsL0IsSUFBTCxFQUFzRTtBQUNsRTZYLG1CQUFlLENBQUMzSixRQUFELEVBQVcvTCxJQUFYLEVBQWlCczhCLFNBQVMsR0FBR0MsSUFBSSxDQUFDSSxHQUFMLEVBQUgsR0FBZ0JDLElBQUksQ0FBQ0QsR0FBTCxFQUExQyxDQUFmO0FBQ0g7QUFDSjs7QUFDRCxTQUFTRixXQUFULEdBQXVCO0FBQ25CLE1BQUlILFNBQVMsS0FBS3o4QixTQUFsQixFQUE2QjtBQUN6QixXQUFPeThCLFNBQVA7QUFDSDtBQUNEOzs7QUFDQSxNQUFJLE9BQU9ycEIsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsTUFBTSxDQUFDbWxCLFdBQTVDLEVBQXlEO0FBQ3JEa0UsYUFBUyxHQUFHLElBQVo7QUFDQUMsUUFBSSxHQUFHdHBCLE1BQU0sQ0FBQ21sQixXQUFkO0FBQ0gsR0FIRCxNQUlLO0FBQ0RrRSxhQUFTLEdBQUcsS0FBWjtBQUNIO0FBQ0Q7OztBQUNBLFNBQU9BLFNBQVA7QUFDSDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTWSxnQkFBVCxHQUE0QjtBQUN4QixNQUFJQyxRQUFRLEdBQUcsS0FBZjs7QUFDQSxNQUFJLEtBQUosRUFBOEMsRUFHN0M7O0FBQ0QsTUFBSSxLQUFKLEVBQWdELEVBRy9DOztBQUNELE1BQUt0L0IsS0FBRCxJQUEyQ3MvQixRQUEvQyxFQUF5RDtBQUNyRHo0QixXQUFPLENBQUNDLElBQVIsQ0FBYyxxRUFBRCxHQUNSLG9FQURRLEdBRVIsd0VBRlEsR0FHUiwyREFITDtBQUlIO0FBQ0o7O0FBRUQsTUFBTXk0QixpQkFBaUIsR0FBRztBQUN0Qjc3QixXQUFTLEVBQUUwUCxRQURXO0FBRXRCO0FBQ0E1UixjQUFZLEVBQUU7QUFIUSxDQUExQjs7QUFLQSxTQUFTZytCLHNCQUFULENBQWdDdHhCLFFBQWhDLEVBQTBDO0FBQ3RDLFNBQU87QUFDSHhLLGFBQVMsRUFBRTBQLFFBRFI7QUFFSDVSLGdCQUFZLEVBQUUsSUFGWDtBQUdIcUIsV0FBTyxFQUFFcUwsUUFBUSxDQUFDdXhCLEdBQVQsR0FBZWhwQixDQUFDLElBQUkrWCwyREFBYyxDQUFDdGdCLFFBQVEsQ0FBQ3V4QixHQUFWLEVBQWVocEIsQ0FBZixDQUFsQyxHQUFzRCxLQUFLLENBSGpFO0FBSUhoVCxhQUFTLEVBQUV5SyxRQUFRLENBQUN3eEIsR0FBVCxHQUFlanBCLENBQUMsSUFBSStYLDJEQUFjLENBQUN0Z0IsUUFBUSxDQUFDd3hCLEdBQVYsRUFBZWpwQixDQUFmLENBQWxDLEdBQXNELEtBQUs7QUFKbkUsR0FBUDtBQU1IOztBQUNELE1BQU04USxxQkFBcUIsR0FBR3pCLHVCQUE5Qjs7QUFFQSxNQUFNZ1ksTUFBTSxHQUFHLENBQUM2QixNQUFELEVBQVNDLFNBQVQsRUFBb0J4ZSxjQUFwQixFQUFvQ3JULEtBQXBDLEVBQTJDOHhCLFNBQVMsR0FBRyxLQUF2RCxLQUFpRTtBQUM1RSxNQUFJeDhCLG9EQUFPLENBQUNzOEIsTUFBRCxDQUFYLEVBQXFCO0FBQ2pCQSxVQUFNLENBQUN2OEIsT0FBUCxDQUFlLENBQUNpSSxDQUFELEVBQUkzSixDQUFKLEtBQVVvOEIsTUFBTSxDQUFDenlCLENBQUQsRUFBSXUwQixTQUFTLEtBQUt2OEIsb0RBQU8sQ0FBQ3U4QixTQUFELENBQVAsR0FBcUJBLFNBQVMsQ0FBQ2wrQixDQUFELENBQTlCLEdBQW9DaytCLFNBQXpDLENBQWIsRUFBa0V4ZSxjQUFsRSxFQUFrRnJULEtBQWxGLEVBQXlGOHhCLFNBQXpGLENBQS9CO0FBQ0E7QUFDSDs7QUFDRCxNQUFJNVQsY0FBYyxDQUFDbGUsS0FBRCxDQUFkLElBQXlCLENBQUM4eEIsU0FBOUIsRUFBeUM7QUFDckM7QUFDQTtBQUNBO0FBQ0g7O0FBQ0QsUUFBTUMsUUFBUSxHQUFHL3hCLEtBQUssQ0FBQ2dRLFNBQU4sR0FBa0I7QUFBRTtBQUFwQixJQUNYZ2lCLGNBQWMsQ0FBQ2h5QixLQUFLLENBQUNJLFNBQVAsQ0FBZCxJQUFtQ0osS0FBSyxDQUFDSSxTQUFOLENBQWdCdEQsS0FEeEMsR0FFWGtELEtBQUssQ0FBQzJTLEVBRlo7QUFHQSxRQUFNM2EsS0FBSyxHQUFHODVCLFNBQVMsR0FBRyxJQUFILEdBQVVDLFFBQWpDO0FBQ0EsUUFBTTtBQUFFcCtCLEtBQUMsRUFBRXMrQixLQUFMO0FBQVkzMEIsS0FBQyxFQUFFRztBQUFmLE1BQXVCbTBCLE1BQTdCOztBQUNBLE1BQUszL0IsS0FBRCxJQUEyQyxDQUFDZ2dDLEtBQWhELEVBQXVEO0FBQ25EbDVCLFFBQUksQ0FBRSxtRUFBRCxHQUNBLDhEQURELENBQUo7QUFFQTtBQUNIOztBQUNELFFBQU1tNUIsTUFBTSxHQUFHTCxTQUFTLElBQUlBLFNBQVMsQ0FBQ3YwQixDQUF0QztBQUNBLFFBQU02MEIsSUFBSSxHQUFHRixLQUFLLENBQUNFLElBQU4sS0FBZTMvQixrREFBZixHQUE0QnkvQixLQUFLLENBQUNFLElBQU4sR0FBYSxFQUF6QyxHQUErQ0YsS0FBSyxDQUFDRSxJQUFsRTtBQUNBLFFBQU10aUIsVUFBVSxHQUFHb2lCLEtBQUssQ0FBQ3BpQixVQUF6QixDQXRCNEUsQ0F1QjVFOztBQUNBLE1BQUlxaUIsTUFBTSxJQUFJLElBQVYsSUFBa0JBLE1BQU0sS0FBS3owQixHQUFqQyxFQUFzQztBQUNsQyxRQUFJd0UscURBQVEsQ0FBQ2l3QixNQUFELENBQVosRUFBc0I7QUFDbEJDLFVBQUksQ0FBQ0QsTUFBRCxDQUFKLEdBQWUsSUFBZjs7QUFDQSxVQUFJdDZCLG1EQUFNLENBQUNpWSxVQUFELEVBQWFxaUIsTUFBYixDQUFWLEVBQWdDO0FBQzVCcmlCLGtCQUFVLENBQUNxaUIsTUFBRCxDQUFWLEdBQXFCLElBQXJCO0FBQ0g7QUFDSixLQUxELE1BTUssSUFBSXA2QixzREFBSyxDQUFDbzZCLE1BQUQsQ0FBVCxFQUFtQjtBQUNwQkEsWUFBTSxDQUFDbDZCLEtBQVAsR0FBZSxJQUFmO0FBQ0g7QUFDSjs7QUFDRCxNQUFJaUsscURBQVEsQ0FBQ3hFLEdBQUQsQ0FBWixFQUFtQjtBQUNmLFVBQU0yMEIsS0FBSyxHQUFHLE1BQU07QUFDaEI7QUFDSUQsWUFBSSxDQUFDMTBCLEdBQUQsQ0FBSixHQUFZekYsS0FBWjtBQUNIOztBQUNELFVBQUlKLG1EQUFNLENBQUNpWSxVQUFELEVBQWFwUyxHQUFiLENBQVYsRUFBNkI7QUFDekJvUyxrQkFBVSxDQUFDcFMsR0FBRCxDQUFWLEdBQWtCekYsS0FBbEI7QUFDSDtBQUNKLEtBUEQsQ0FEZSxDQVNmO0FBQ0E7QUFDQTs7O0FBQ0EsUUFBSUEsS0FBSixFQUFXO0FBQ1BvNkIsV0FBSyxDQUFDNStCLEVBQU4sR0FBVyxDQUFDLENBQVo7QUFDQWdtQiwyQkFBcUIsQ0FBQzRZLEtBQUQsRUFBUS9lLGNBQVIsQ0FBckI7QUFDSCxLQUhELE1BSUs7QUFDRCtlLFdBQUs7QUFDUjtBQUNKLEdBbkJELE1Bb0JLLElBQUl0NkIsc0RBQUssQ0FBQzJGLEdBQUQsQ0FBVCxFQUFnQjtBQUNqQixVQUFNMjBCLEtBQUssR0FBRyxNQUFNO0FBQ2hCMzBCLFNBQUcsQ0FBQ3pGLEtBQUosR0FBWUEsS0FBWjtBQUNILEtBRkQ7O0FBR0EsUUFBSUEsS0FBSixFQUFXO0FBQ1BvNkIsV0FBSyxDQUFDNStCLEVBQU4sR0FBVyxDQUFDLENBQVo7QUFDQWdtQiwyQkFBcUIsQ0FBQzRZLEtBQUQsRUFBUS9lLGNBQVIsQ0FBckI7QUFDSCxLQUhELE1BSUs7QUFDRCtlLFdBQUs7QUFDUjtBQUNKLEdBWEksTUFZQSxJQUFJaHdCLHVEQUFZLENBQUMzRSxHQUFELENBQWhCLEVBQXVCO0FBQ3hCa0QseUJBQXFCLENBQUNsRCxHQUFELEVBQU13MEIsS0FBTixFQUFhO0FBQUc7QUFBaEIsTUFBb0MsQ0FBQ2o2QixLQUFELEVBQVFtNkIsSUFBUixDQUFwQyxDQUFyQjtBQUNILEdBRkksTUFHQSxJQUFLbGdDLElBQUwsRUFBNkM7QUFDOUM4RyxRQUFJLENBQUMsNEJBQUQsRUFBK0JmLEtBQS9CLEVBQXVDLElBQUcsT0FBT0EsS0FBTSxHQUF2RCxDQUFKO0FBQ0g7QUFDSixDQXpFRDtBQTBFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNxNkIsY0FBVCxDQUF3QjkvQixPQUF4QixFQUFpQztBQUM3QixTQUFPKy9CLGtCQUFrQixDQUFDLy9CLE9BQUQsQ0FBekI7QUFDSCxDLENBQ0Q7QUFDQTtBQUNBOzs7QUFDQSxTQUFTZ2dDLHVCQUFULENBQWlDaGdDLE9BQWpDLEVBQTBDO0FBQ3RDLFNBQU8rL0Isa0JBQWtCLENBQUMvL0IsT0FBRCxFQUFVZzhCLHdCQUFWLENBQXpCO0FBQ0gsQyxDQUNEOzs7QUFDQSxTQUFTK0Qsa0JBQVQsQ0FBNEIvL0IsT0FBNUIsRUFBcUNpZ0Msa0JBQXJDLEVBQXlEO0FBQ3JEO0FBQ0E7QUFDSWxCLG9CQUFnQjtBQUNuQjs7QUFDRCxNQUFLci9CLElBQUwsRUFBc0U7QUFDbEUsVUFBTWtDLE1BQU0sR0FBR3MrQiwwREFBYSxFQUE1QjtBQUNBdCtCLFVBQU0sQ0FBQ3UrQixPQUFQLEdBQWlCLElBQWpCO0FBQ0E5cEIsbUJBQWUsQ0FBQ3pVLE1BQU0sQ0FBQ3crQiw0QkFBUixDQUFmO0FBQ0g7O0FBQ0QsUUFBTTtBQUFFL0QsVUFBTSxFQUFFZ0UsVUFBVjtBQUFzQi9jLFVBQU0sRUFBRWdkLFVBQTlCO0FBQTBDbkUsYUFBUyxFQUFFb0UsYUFBckQ7QUFBb0VDLGtCQUFjLEVBQUVDLGtCQUFwRjtBQUF3RzNlLGlCQUFhLEVBQUU0ZSxpQkFBdkg7QUFBMElDLGNBQVUsRUFBRUMsY0FBdEo7QUFBc0t0RSxpQkFBYSxFQUFFdUUsaUJBQXJMO0FBQXdNQyxXQUFPLEVBQUVDLFdBQWpOO0FBQThOQyxrQkFBYyxFQUFFQyxrQkFBOU87QUFBa1E1ZCxjQUFVLEVBQUU2ZCxjQUE5UTtBQUE4UjlFLGVBQVcsRUFBRStFLGVBQTNTO0FBQTRUQyxjQUFVLEVBQUVDLGNBQWMsR0FBRy96Qiw2Q0FBelY7QUFBK1ZnMEIsYUFBUyxFQUFFQyxhQUExVztBQUF5WEMsdUJBQW1CLEVBQUVDO0FBQTlZLE1BQTBhemhDLE9BQWhiLENBVnFELENBV3JEO0FBQ0E7O0FBQ0EsUUFBTTRoQixLQUFLLEdBQUcsQ0FBQ25CLEVBQUQsRUFBS0MsRUFBTCxFQUFTQyxTQUFULEVBQW9CQyxNQUFNLEdBQUcsSUFBN0IsRUFBbUNDLGVBQWUsR0FBRyxJQUFyRCxFQUEyREMsY0FBYyxHQUFHLElBQTVFLEVBQWtGQyxLQUFLLEdBQUcsS0FBMUYsRUFBaUdDLFlBQVksR0FBRyxJQUFoSCxFQUFzSHRCLFNBQVMsR0FBRyxLQUFsSSxLQUE0STtBQUN0SjtBQUNBLFFBQUllLEVBQUUsSUFBSSxDQUFDbUMsZUFBZSxDQUFDbkMsRUFBRCxFQUFLQyxFQUFMLENBQTFCLEVBQW9DO0FBQ2hDRSxZQUFNLEdBQUc4Z0IsZUFBZSxDQUFDamhCLEVBQUQsQ0FBeEI7QUFDQTZCLGFBQU8sQ0FBQzdCLEVBQUQsRUFBS0ksZUFBTCxFQUFzQkMsY0FBdEIsRUFBc0MsSUFBdEMsQ0FBUDtBQUNBTCxRQUFFLEdBQUcsSUFBTDtBQUNIOztBQUNELFFBQUlDLEVBQUUsQ0FBQzNDLFNBQUgsS0FBaUIsQ0FBQztBQUFFO0FBQXhCLE1BQW9DO0FBQ2hDMkIsaUJBQVMsR0FBRyxLQUFaO0FBQ0FnQixVQUFFLENBQUMzQixlQUFILEdBQXFCLElBQXJCO0FBQ0g7O0FBQ0QsVUFBTTtBQUFFbGQsVUFBRjtBQUFRcUosU0FBUjtBQUFhdVM7QUFBYixRQUEyQmlELEVBQWpDOztBQUNBLFlBQVE3ZSxJQUFSO0FBQ0ksV0FBSytVLElBQUw7QUFDSStxQixtQkFBVyxDQUFDbGhCLEVBQUQsRUFBS0MsRUFBTCxFQUFTQyxTQUFULEVBQW9CQyxNQUFwQixDQUFYO0FBQ0E7O0FBQ0osV0FBSzlKLFNBQUw7QUFDSThxQiwwQkFBa0IsQ0FBQ25oQixFQUFELEVBQUtDLEVBQUwsRUFBU0MsU0FBVCxFQUFvQkMsTUFBcEIsQ0FBbEI7QUFDQTs7QUFDSixXQUFLN0osTUFBTDtBQUNJLFlBQUkwSixFQUFFLElBQUksSUFBVixFQUFnQjtBQUNab2hCLHlCQUFlLENBQUNuaEIsRUFBRCxFQUFLQyxTQUFMLEVBQWdCQyxNQUFoQixFQUF3QkcsS0FBeEIsQ0FBZjtBQUNILFNBRkQsTUFHSyxJQUFLcmhCLElBQUwsRUFBNkM7QUFDOUNvaUMseUJBQWUsQ0FBQ3JoQixFQUFELEVBQUtDLEVBQUwsRUFBU0MsU0FBVCxFQUFvQkksS0FBcEIsQ0FBZjtBQUNIOztBQUNEOztBQUNKLFdBQUtwSyxRQUFMO0FBQ0lvckIsdUJBQWUsQ0FBQ3RoQixFQUFELEVBQUtDLEVBQUwsRUFBU0MsU0FBVCxFQUFvQkMsTUFBcEIsRUFBNEJDLGVBQTVCLEVBQTZDQyxjQUE3QyxFQUE2REMsS0FBN0QsRUFBb0VDLFlBQXBFLEVBQWtGdEIsU0FBbEYsQ0FBZjtBQUNBOztBQUNKO0FBQ0ksWUFBSWpDLFNBQVMsR0FBRztBQUFFO0FBQWxCLFVBQWlDO0FBQzdCdWtCLDBCQUFjLENBQUN2aEIsRUFBRCxFQUFLQyxFQUFMLEVBQVNDLFNBQVQsRUFBb0JDLE1BQXBCLEVBQTRCQyxlQUE1QixFQUE2Q0MsY0FBN0MsRUFBNkRDLEtBQTdELEVBQW9FQyxZQUFwRSxFQUFrRnRCLFNBQWxGLENBQWQ7QUFDSCxXQUZELE1BR0ssSUFBSWpDLFNBQVMsR0FBRztBQUFFO0FBQWxCLFVBQW1DO0FBQ3BDd2tCLDRCQUFnQixDQUFDeGhCLEVBQUQsRUFBS0MsRUFBTCxFQUFTQyxTQUFULEVBQW9CQyxNQUFwQixFQUE0QkMsZUFBNUIsRUFBNkNDLGNBQTdDLEVBQTZEQyxLQUE3RCxFQUFvRUMsWUFBcEUsRUFBa0Z0QixTQUFsRixDQUFoQjtBQUNILFdBRkksTUFHQSxJQUFJakMsU0FBUyxHQUFHO0FBQUc7QUFBbkIsVUFBbUM7QUFDcEM1YixnQkFBSSxDQUFDbkMsT0FBTCxDQUFhK2dCLEVBQWIsRUFBaUJDLEVBQWpCLEVBQXFCQyxTQUFyQixFQUFnQ0MsTUFBaEMsRUFBd0NDLGVBQXhDLEVBQXlEQyxjQUF6RCxFQUF5RUMsS0FBekUsRUFBZ0ZDLFlBQWhGLEVBQThGdEIsU0FBOUYsRUFBeUd3aUIsU0FBekc7QUFDSCxXQUZJLE1BR0EsSUFBSXprQixTQUFTLEdBQUc7QUFBSTtBQUFwQixVQUFvQztBQUNyQzViLGdCQUFJLENBQUNuQyxPQUFMLENBQWErZ0IsRUFBYixFQUFpQkMsRUFBakIsRUFBcUJDLFNBQXJCLEVBQWdDQyxNQUFoQyxFQUF3Q0MsZUFBeEMsRUFBeURDLGNBQXpELEVBQXlFQyxLQUF6RSxFQUFnRkMsWUFBaEYsRUFBOEZ0QixTQUE5RixFQUF5R3dpQixTQUF6RztBQUNILFdBRkksTUFHQSxJQUFLeGlDLElBQUwsRUFBNkM7QUFDOUM4RyxjQUFJLENBQUMscUJBQUQsRUFBd0IzRSxJQUF4QixFQUErQixJQUFHLE9BQU9BLElBQUssR0FBOUMsQ0FBSjtBQUNIOztBQWpDVCxLQVpzSixDQStDdEo7OztBQUNBLFFBQUlxSixHQUFHLElBQUksSUFBUCxJQUFlMlYsZUFBbkIsRUFBb0M7QUFDaEMyYyxZQUFNLENBQUN0eUIsR0FBRCxFQUFNdVYsRUFBRSxJQUFJQSxFQUFFLENBQUN2VixHQUFmLEVBQW9CNFYsY0FBcEIsRUFBb0NKLEVBQUUsSUFBSUQsRUFBMUMsRUFBOEMsQ0FBQ0MsRUFBL0MsQ0FBTjtBQUNIO0FBQ0osR0FuREQ7O0FBb0RBLFFBQU1paEIsV0FBVyxHQUFHLENBQUNsaEIsRUFBRCxFQUFLQyxFQUFMLEVBQVNDLFNBQVQsRUFBb0JDLE1BQXBCLEtBQStCO0FBQy9DLFFBQUlILEVBQUUsSUFBSSxJQUFWLEVBQWdCO0FBQ1o0ZixnQkFBVSxDQUFFM2YsRUFBRSxDQUFDTixFQUFILEdBQVF3Z0IsY0FBYyxDQUFDbGdCLEVBQUUsQ0FBQzVCLFFBQUosQ0FBeEIsRUFBd0M2QixTQUF4QyxFQUFtREMsTUFBbkQsQ0FBVjtBQUNILEtBRkQsTUFHSztBQUNELFlBQU1SLEVBQUUsR0FBSU0sRUFBRSxDQUFDTixFQUFILEdBQVFLLEVBQUUsQ0FBQ0wsRUFBdkI7O0FBQ0EsVUFBSU0sRUFBRSxDQUFDNUIsUUFBSCxLQUFnQjJCLEVBQUUsQ0FBQzNCLFFBQXZCLEVBQWlDO0FBQzdCaWlCLG1CQUFXLENBQUMzZ0IsRUFBRCxFQUFLTSxFQUFFLENBQUM1QixRQUFSLENBQVg7QUFDSDtBQUNKO0FBQ0osR0FWRDs7QUFXQSxRQUFNOGlCLGtCQUFrQixHQUFHLENBQUNuaEIsRUFBRCxFQUFLQyxFQUFMLEVBQVNDLFNBQVQsRUFBb0JDLE1BQXBCLEtBQStCO0FBQ3RELFFBQUlILEVBQUUsSUFBSSxJQUFWLEVBQWdCO0FBQ1o0ZixnQkFBVSxDQUFFM2YsRUFBRSxDQUFDTixFQUFILEdBQVF5Z0IsaUJBQWlCLENBQUNuZ0IsRUFBRSxDQUFDNUIsUUFBSCxJQUFlLEVBQWhCLENBQTNCLEVBQWlENkIsU0FBakQsRUFBNERDLE1BQTVELENBQVY7QUFDSCxLQUZELE1BR0s7QUFDRDtBQUNBRixRQUFFLENBQUNOLEVBQUgsR0FBUUssRUFBRSxDQUFDTCxFQUFYO0FBQ0g7QUFDSixHQVJEOztBQVNBLFFBQU15aEIsZUFBZSxHQUFHLENBQUNuaEIsRUFBRCxFQUFLQyxTQUFMLEVBQWdCQyxNQUFoQixFQUF3QkcsS0FBeEIsS0FBa0M7QUFDdEQ7QUFDQTtBQUNBLFVBQU1vaEIsS0FBSyxHQUFHVix1QkFBdUIsQ0FBQy9nQixFQUFFLENBQUM1QixRQUFKLEVBQWM2QixTQUFkLEVBQXlCQyxNQUF6QixFQUFpQ0csS0FBakMsRUFDckM7QUFDQTtBQUNBO0FBQ0FMLE1BQUUsQ0FBQzBoQixXQUprQyxDQUFyQyxDQUhzRCxDQVF0RDs7QUFDQSxRQUFJLENBQUMxaEIsRUFBRSxDQUFDTixFQUFSLEVBQVk7QUFDUk0sUUFBRSxDQUFDMGhCLFdBQUgsR0FBaUJELEtBQWpCO0FBQ0g7O0FBQ0R6aEIsTUFBRSxDQUFDTixFQUFILEdBQVEraEIsS0FBSyxDQUFDLENBQUQsQ0FBYjtBQUNBemhCLE1BQUUsQ0FBQ0UsTUFBSCxHQUFZdWhCLEtBQUssQ0FBQ0EsS0FBSyxDQUFDbmhDLE1BQU4sR0FBZSxDQUFoQixDQUFqQjtBQUNILEdBZEQ7QUFlQTtBQUNKO0FBQ0E7OztBQUNJLFFBQU04Z0MsZUFBZSxHQUFHLENBQUNyaEIsRUFBRCxFQUFLQyxFQUFMLEVBQVNDLFNBQVQsRUFBb0JJLEtBQXBCLEtBQThCO0FBQ2xEO0FBQ0EsUUFBSUwsRUFBRSxDQUFDNUIsUUFBSCxLQUFnQjJCLEVBQUUsQ0FBQzNCLFFBQXZCLEVBQWlDO0FBQzdCLFlBQU04QixNQUFNLEdBQUd1Z0IsZUFBZSxDQUFDMWdCLEVBQUUsQ0FBQ0csTUFBSixDQUE5QixDQUQ2QixDQUU3Qjs7QUFDQXloQixzQkFBZ0IsQ0FBQzVoQixFQUFELENBQWhCO0FBQ0EsT0FBQ0MsRUFBRSxDQUFDTixFQUFKLEVBQVFNLEVBQUUsQ0FBQ0UsTUFBWCxJQUFxQjZnQix1QkFBdUIsQ0FBQy9nQixFQUFFLENBQUM1QixRQUFKLEVBQWM2QixTQUFkLEVBQXlCQyxNQUF6QixFQUFpQ0csS0FBakMsQ0FBNUM7QUFDSCxLQUxELE1BTUs7QUFDREwsUUFBRSxDQUFDTixFQUFILEdBQVFLLEVBQUUsQ0FBQ0wsRUFBWDtBQUNBTSxRQUFFLENBQUNFLE1BQUgsR0FBWUgsRUFBRSxDQUFDRyxNQUFmO0FBQ0g7QUFDSixHQVpEOztBQWFBLFFBQU0waEIsY0FBYyxHQUFHLENBQUM7QUFBRWxpQixNQUFGO0FBQU1RO0FBQU4sR0FBRCxFQUFpQkQsU0FBakIsRUFBNEJ5YixXQUE1QixLQUE0QztBQUMvRCxRQUFJenpCLElBQUo7O0FBQ0EsV0FBT3lYLEVBQUUsSUFBSUEsRUFBRSxLQUFLUSxNQUFwQixFQUE0QjtBQUN4QmpZLFVBQUksR0FBR3c0QixlQUFlLENBQUMvZ0IsRUFBRCxDQUF0QjtBQUNBaWdCLGdCQUFVLENBQUNqZ0IsRUFBRCxFQUFLTyxTQUFMLEVBQWdCeWIsV0FBaEIsQ0FBVjtBQUNBaGMsUUFBRSxHQUFHelgsSUFBTDtBQUNIOztBQUNEMDNCLGNBQVUsQ0FBQ3pmLE1BQUQsRUFBU0QsU0FBVCxFQUFvQnliLFdBQXBCLENBQVY7QUFDSCxHQVJEOztBQVNBLFFBQU1pRyxnQkFBZ0IsR0FBRyxDQUFDO0FBQUVqaUIsTUFBRjtBQUFNUTtBQUFOLEdBQUQsS0FBb0I7QUFDekMsUUFBSWpZLElBQUo7O0FBQ0EsV0FBT3lYLEVBQUUsSUFBSUEsRUFBRSxLQUFLUSxNQUFwQixFQUE0QjtBQUN4QmpZLFVBQUksR0FBR3c0QixlQUFlLENBQUMvZ0IsRUFBRCxDQUF0QjtBQUNBa2dCLGdCQUFVLENBQUNsZ0IsRUFBRCxDQUFWO0FBQ0FBLFFBQUUsR0FBR3pYLElBQUw7QUFDSDs7QUFDRDIzQixjQUFVLENBQUMxZixNQUFELENBQVY7QUFDSCxHQVJEOztBQVNBLFFBQU1vaEIsY0FBYyxHQUFHLENBQUN2aEIsRUFBRCxFQUFLQyxFQUFMLEVBQVNDLFNBQVQsRUFBb0JDLE1BQXBCLEVBQTRCQyxlQUE1QixFQUE2Q0MsY0FBN0MsRUFBNkRDLEtBQTdELEVBQW9FQyxZQUFwRSxFQUFrRnRCLFNBQWxGLEtBQWdHO0FBQ25IcUIsU0FBSyxHQUFHQSxLQUFLLElBQUlMLEVBQUUsQ0FBQzdlLElBQUgsS0FBWSxLQUE3Qjs7QUFDQSxRQUFJNGUsRUFBRSxJQUFJLElBQVYsRUFBZ0I7QUFDWjhoQixrQkFBWSxDQUFDN2hCLEVBQUQsRUFBS0MsU0FBTCxFQUFnQkMsTUFBaEIsRUFBd0JDLGVBQXhCLEVBQXlDQyxjQUF6QyxFQUF5REMsS0FBekQsRUFBZ0VDLFlBQWhFLEVBQThFdEIsU0FBOUUsQ0FBWjtBQUNILEtBRkQsTUFHSztBQUNEOGlCLGtCQUFZLENBQUMvaEIsRUFBRCxFQUFLQyxFQUFMLEVBQVNHLGVBQVQsRUFBMEJDLGNBQTFCLEVBQTBDQyxLQUExQyxFQUFpREMsWUFBakQsRUFBK0R0QixTQUEvRCxDQUFaO0FBQ0g7QUFDSixHQVJEOztBQVNBLFFBQU02aUIsWUFBWSxHQUFHLENBQUM5MEIsS0FBRCxFQUFRa1QsU0FBUixFQUFtQkMsTUFBbkIsRUFBMkJDLGVBQTNCLEVBQTRDQyxjQUE1QyxFQUE0REMsS0FBNUQsRUFBbUVDLFlBQW5FLEVBQWlGdEIsU0FBakYsS0FBK0Y7QUFDaEgsUUFBSVUsRUFBSjtBQUNBLFFBQUkrTixTQUFKO0FBQ0EsVUFBTTtBQUFFdHNCLFVBQUY7QUFBUXdOLFdBQVI7QUFBZW9PLGVBQWY7QUFBMEJpQixnQkFBMUI7QUFBc0NYLGVBQXRDO0FBQWlEUTtBQUFqRCxRQUEwRDlRLEtBQWhFOztBQUNBLFFBQUksS0FHZ0I7QUFBQztBQUhyQixNQUdvQyxFQUhwQyxNQVVLO0FBQ0QyUyxRQUFFLEdBQUczUyxLQUFLLENBQUMyUyxFQUFOLEdBQVdzZ0IsaUJBQWlCLENBQUNqekIsS0FBSyxDQUFDNUwsSUFBUCxFQUFha2YsS0FBYixFQUFvQjFSLEtBQUssSUFBSUEsS0FBSyxDQUFDb3pCLEVBQW5DLEVBQXVDcHpCLEtBQXZDLENBQWpDLENBREMsQ0FFRDtBQUNBOztBQUNBLFVBQUlvTyxTQUFTLEdBQUc7QUFBRTtBQUFsQixRQUF1QztBQUNuQ3dqQiw0QkFBa0IsQ0FBQzdnQixFQUFELEVBQUszUyxLQUFLLENBQUNxUixRQUFYLENBQWxCO0FBQ0gsU0FGRCxNQUdLLElBQUlyQixTQUFTLEdBQUc7QUFBRztBQUFuQixRQUF5QztBQUMxQ2lsQix1QkFBYSxDQUFDajFCLEtBQUssQ0FBQ3FSLFFBQVAsRUFBaUJzQixFQUFqQixFQUFxQixJQUFyQixFQUEyQlMsZUFBM0IsRUFBNENDLGNBQTVDLEVBQTREQyxLQUFLLElBQUlsZixJQUFJLEtBQUssZUFBOUUsRUFBK0ZtZixZQUEvRixFQUE2R3RCLFNBQVMsSUFBSSxDQUFDLENBQUNqUyxLQUFLLENBQUNzUixlQUFsSSxDQUFiO0FBQ0g7O0FBQ0QsVUFBSVIsSUFBSixFQUFVO0FBQ05vYiwyQkFBbUIsQ0FBQ2xzQixLQUFELEVBQVEsSUFBUixFQUFjb1QsZUFBZCxFQUErQixTQUEvQixDQUFuQjtBQUNILE9BWkEsQ0FhRDs7O0FBQ0EsVUFBSXhSLEtBQUosRUFBVztBQUNQLGFBQUssTUFBTXZOLEdBQVgsSUFBa0J1TixLQUFsQixFQUF5QjtBQUNyQixjQUFJLENBQUMwbUIsMkRBQWMsQ0FBQ2owQixHQUFELENBQW5CLEVBQTBCO0FBQ3RCeStCLHlCQUFhLENBQUNuZ0IsRUFBRCxFQUFLdGUsR0FBTCxFQUFVLElBQVYsRUFBZ0J1TixLQUFLLENBQUN2TixHQUFELENBQXJCLEVBQTRCaWYsS0FBNUIsRUFBbUN0VCxLQUFLLENBQUNxUixRQUF6QyxFQUFtRCtCLGVBQW5ELEVBQW9FQyxjQUFwRSxFQUFvRjZoQixlQUFwRixDQUFiO0FBQ0g7QUFDSjs7QUFDRCxZQUFLeFUsU0FBUyxHQUFHOWUsS0FBSyxDQUFDd3VCLGtCQUF2QixFQUE0QztBQUN4Q3hQLHlCQUFlLENBQUNGLFNBQUQsRUFBWXROLGVBQVosRUFBNkJwVCxLQUE3QixDQUFmO0FBQ0g7QUFDSixPQXZCQSxDQXdCRDs7O0FBQ0EyekIsZ0JBQVUsQ0FBQ2hoQixFQUFELEVBQUszUyxLQUFMLEVBQVlBLEtBQUssQ0FBQ20xQixPQUFsQixFQUEyQjVoQixZQUEzQixFQUF5Q0gsZUFBekMsQ0FBVjtBQUNIOztBQUNELFFBQUtuaEIsSUFBTCxFQUFzRTtBQUNsRThELFlBQU0sQ0FBQ3d2QixjQUFQLENBQXNCNVMsRUFBdEIsRUFBMEIsU0FBMUIsRUFBcUM7QUFDakMzYSxhQUFLLEVBQUVnSSxLQUQwQjtBQUVqQ3lsQixrQkFBVSxFQUFFO0FBRnFCLE9BQXJDO0FBSUExdkIsWUFBTSxDQUFDd3ZCLGNBQVAsQ0FBc0I1UyxFQUF0QixFQUEwQixzQkFBMUIsRUFBa0Q7QUFDOUMzYSxhQUFLLEVBQUVvYixlQUR1QztBQUU5Q3FTLGtCQUFVLEVBQUU7QUFGa0MsT0FBbEQ7QUFJSDs7QUFDRCxRQUFJM1UsSUFBSixFQUFVO0FBQ05vYix5QkFBbUIsQ0FBQ2xzQixLQUFELEVBQVEsSUFBUixFQUFjb1QsZUFBZCxFQUErQixhQUEvQixDQUFuQjtBQUNILEtBckQrRyxDQXNEaEg7QUFDQTs7O0FBQ0EsVUFBTWdpQix1QkFBdUIsR0FBRyxDQUFDLENBQUMvaEIsY0FBRCxJQUFvQkEsY0FBYyxJQUFJLENBQUNBLGNBQWMsQ0FBQ21CLGFBQXZELEtBQzVCdkQsVUFENEIsSUFFNUIsQ0FBQ0EsVUFBVSxDQUFDOEosU0FGaEI7O0FBR0EsUUFBSXFhLHVCQUFKLEVBQTZCO0FBQ3pCbmtCLGdCQUFVLENBQUNtTSxXQUFYLENBQXVCekssRUFBdkI7QUFDSDs7QUFDRGlnQixjQUFVLENBQUNqZ0IsRUFBRCxFQUFLTyxTQUFMLEVBQWdCQyxNQUFoQixDQUFWOztBQUNBLFFBQUksQ0FBQ3VOLFNBQVMsR0FBRzllLEtBQUssSUFBSUEsS0FBSyxDQUFDK2UsY0FBNUIsS0FDQXlVLHVCQURBLElBRUF0a0IsSUFGSixFQUVVO0FBQ04wSSwyQkFBcUIsQ0FBQyxNQUFNO0FBQ3hCa0gsaUJBQVMsSUFBSUUsZUFBZSxDQUFDRixTQUFELEVBQVl0TixlQUFaLEVBQTZCcFQsS0FBN0IsQ0FBNUI7QUFDQW8xQiwrQkFBdUIsSUFBSW5rQixVQUFVLENBQUNxTSxLQUFYLENBQWlCM0ssRUFBakIsQ0FBM0I7QUFDQTdCLFlBQUksSUFBSW9iLG1CQUFtQixDQUFDbHNCLEtBQUQsRUFBUSxJQUFSLEVBQWNvVCxlQUFkLEVBQStCLFNBQS9CLENBQTNCO0FBQ0gsT0FKb0IsRUFJbEJDLGNBSmtCLENBQXJCO0FBS0g7QUFDSixHQXhFRDs7QUF5RUEsUUFBTXNnQixVQUFVLEdBQUcsQ0FBQ2hoQixFQUFELEVBQUszUyxLQUFMLEVBQVltMUIsT0FBWixFQUFxQjVoQixZQUFyQixFQUFtQ0gsZUFBbkMsS0FBdUQ7QUFDdEUsUUFBSStoQixPQUFKLEVBQWE7QUFDVHZCLG9CQUFjLENBQUNqaEIsRUFBRCxFQUFLd2lCLE9BQUwsQ0FBZDtBQUNIOztBQUNELFFBQUk1aEIsWUFBSixFQUFrQjtBQUNkLFdBQUssSUFBSTVmLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc0ZixZQUFZLENBQUNoZ0IsTUFBakMsRUFBeUNJLENBQUMsRUFBMUMsRUFBOEM7QUFDMUNpZ0Msc0JBQWMsQ0FBQ2poQixFQUFELEVBQUtZLFlBQVksQ0FBQzVmLENBQUQsQ0FBakIsQ0FBZDtBQUNIO0FBQ0o7O0FBQ0QsUUFBSXlmLGVBQUosRUFBcUI7QUFDakIsVUFBSVIsT0FBTyxHQUFHUSxlQUFlLENBQUNSLE9BQTlCOztBQUNBLFVBQUszZ0IsS0FBRCxJQUNBMmdCLE9BQU8sQ0FBQ3RDLFNBQVIsR0FBb0IsQ0FEcEIsSUFFQXNDLE9BQU8sQ0FBQ3RDLFNBQVIsR0FBb0I7QUFBSztBQUY3QixRQUVzRDtBQUNsRHNDLGlCQUFPLEdBQ0hwQixnQkFBZ0IsQ0FBQ29CLE9BQU8sQ0FBQ3ZCLFFBQVQsQ0FBaEIsSUFBc0N1QixPQUQxQztBQUVIOztBQUNELFVBQUk1UyxLQUFLLEtBQUs0UyxPQUFkLEVBQXVCO0FBQ25CLGNBQU0yZCxXQUFXLEdBQUduZCxlQUFlLENBQUNwVCxLQUFwQztBQUNBMnpCLGtCQUFVLENBQUNoaEIsRUFBRCxFQUFLNGQsV0FBTCxFQUFrQkEsV0FBVyxDQUFDNEUsT0FBOUIsRUFBdUM1RSxXQUFXLENBQUNoZCxZQUFuRCxFQUFpRUgsZUFBZSxDQUFDaFMsTUFBakYsQ0FBVjtBQUNIO0FBQ0o7QUFDSixHQXRCRDs7QUF1QkEsUUFBTTZ6QixhQUFhLEdBQUcsQ0FBQzVqQixRQUFELEVBQVc2QixTQUFYLEVBQXNCQyxNQUF0QixFQUE4QkMsZUFBOUIsRUFBK0NDLGNBQS9DLEVBQStEQyxLQUEvRCxFQUFzRUMsWUFBdEUsRUFBb0Z0QixTQUFwRixFQUErRmxOLEtBQUssR0FBRyxDQUF2RyxLQUE2RztBQUMvSCxTQUFLLElBQUlwUixDQUFDLEdBQUdvUixLQUFiLEVBQW9CcFIsQ0FBQyxHQUFHMGQsUUFBUSxDQUFDOWQsTUFBakMsRUFBeUNJLENBQUMsRUFBMUMsRUFBOEM7QUFDMUMsWUFBTWllLEtBQUssR0FBSVAsUUFBUSxDQUFDMWQsQ0FBRCxDQUFSLEdBQWNzZSxTQUFTLEdBQ2hDb2pCLGNBQWMsQ0FBQ2hrQixRQUFRLENBQUMxZCxDQUFELENBQVQsQ0FEa0IsR0FFaEN1YyxjQUFjLENBQUNtQixRQUFRLENBQUMxZCxDQUFELENBQVQsQ0FGcEI7QUFHQXdnQixXQUFLLENBQUMsSUFBRCxFQUFPdkMsS0FBUCxFQUFjc0IsU0FBZCxFQUF5QkMsTUFBekIsRUFBaUNDLGVBQWpDLEVBQWtEQyxjQUFsRCxFQUFrRUMsS0FBbEUsRUFBeUVDLFlBQXpFLEVBQXVGdEIsU0FBdkYsQ0FBTDtBQUNIO0FBQ0osR0FQRDs7QUFRQSxRQUFNOGlCLFlBQVksR0FBRyxDQUFDL2hCLEVBQUQsRUFBS0MsRUFBTCxFQUFTRyxlQUFULEVBQTBCQyxjQUExQixFQUEwQ0MsS0FBMUMsRUFBaURDLFlBQWpELEVBQStEdEIsU0FBL0QsS0FBNkU7QUFDOUYsVUFBTVUsRUFBRSxHQUFJTSxFQUFFLENBQUNOLEVBQUgsR0FBUUssRUFBRSxDQUFDTCxFQUF2QjtBQUNBLFFBQUk7QUFBRXJDLGVBQUY7QUFBYWdCLHFCQUFiO0FBQThCUjtBQUE5QixRQUF1Q21DLEVBQTNDLENBRjhGLENBRzlGO0FBQ0E7O0FBQ0EzQyxhQUFTLElBQUkwQyxFQUFFLENBQUMxQyxTQUFILEdBQWU7QUFBRztBQUEvQjtBQUNBLFVBQU1nbEIsUUFBUSxHQUFHdGlCLEVBQUUsQ0FBQ3BSLEtBQUgsSUFBWXBQLGtEQUE3QjtBQUNBLFVBQU0raUMsUUFBUSxHQUFHdGlCLEVBQUUsQ0FBQ3JSLEtBQUgsSUFBWXBQLGtEQUE3QjtBQUNBLFFBQUlrdUIsU0FBSjs7QUFDQSxRQUFLQSxTQUFTLEdBQUc2VSxRQUFRLENBQUNDLG1CQUExQixFQUFnRDtBQUM1QzVVLHFCQUFlLENBQUNGLFNBQUQsRUFBWXROLGVBQVosRUFBNkJILEVBQTdCLEVBQWlDRCxFQUFqQyxDQUFmO0FBQ0g7O0FBQ0QsUUFBSWxDLElBQUosRUFBVTtBQUNOb2IseUJBQW1CLENBQUNqWixFQUFELEVBQUtELEVBQUwsRUFBU0ksZUFBVCxFQUEwQixjQUExQixDQUFuQjtBQUNIOztBQUNELFFBQUtuaEIsS0FBRCxJQUEyQ2dWLGFBQS9DLEVBQThEO0FBQzFEO0FBQ0FxSixlQUFTLEdBQUcsQ0FBWjtBQUNBMkIsZUFBUyxHQUFHLEtBQVo7QUFDQVgscUJBQWUsR0FBRyxJQUFsQjtBQUNIOztBQUNELFFBQUloQixTQUFTLEdBQUcsQ0FBaEIsRUFBbUI7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUlBLFNBQVMsR0FBRztBQUFHO0FBQW5CLFFBQXFDO0FBQ2pDO0FBQ0FtbEIsb0JBQVUsQ0FBQzlpQixFQUFELEVBQUtNLEVBQUwsRUFBU3FpQixRQUFULEVBQW1CQyxRQUFuQixFQUE2Qm5pQixlQUE3QixFQUE4Q0MsY0FBOUMsRUFBOERDLEtBQTlELENBQVY7QUFDSCxTQUhELE1BSUs7QUFDRDtBQUNBO0FBQ0EsWUFBSWhELFNBQVMsR0FBRztBQUFFO0FBQWxCLFVBQStCO0FBQzNCLGdCQUFJZ2xCLFFBQVEsQ0FBQ0ksS0FBVCxLQUFtQkgsUUFBUSxDQUFDRyxLQUFoQyxFQUF1QztBQUNuQzVDLDJCQUFhLENBQUNuZ0IsRUFBRCxFQUFLLE9BQUwsRUFBYyxJQUFkLEVBQW9CNGlCLFFBQVEsQ0FBQ0csS0FBN0IsRUFBb0NwaUIsS0FBcEMsQ0FBYjtBQUNIO0FBQ0osV0FQQSxDQVFEO0FBQ0E7OztBQUNBLFlBQUloRCxTQUFTLEdBQUc7QUFBRTtBQUFsQixVQUErQjtBQUMzQndpQix5QkFBYSxDQUFDbmdCLEVBQUQsRUFBSyxPQUFMLEVBQWMyaUIsUUFBUSxDQUFDSyxLQUF2QixFQUE4QkosUUFBUSxDQUFDSSxLQUF2QyxFQUE4Q3JpQixLQUE5QyxDQUFiO0FBQ0gsV0FaQSxDQWFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsWUFBSWhELFNBQVMsR0FBRztBQUFFO0FBQWxCLFVBQStCO0FBQzNCO0FBQ0Esa0JBQU0wWCxhQUFhLEdBQUcvVSxFQUFFLENBQUNWLFlBQXpCOztBQUNBLGlCQUFLLElBQUk1ZSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcTBCLGFBQWEsQ0FBQ3owQixNQUFsQyxFQUEwQ0ksQ0FBQyxFQUEzQyxFQUErQztBQUMzQyxvQkFBTVUsR0FBRyxHQUFHMnpCLGFBQWEsQ0FBQ3IwQixDQUFELENBQXpCO0FBQ0Esb0JBQU0yYSxJQUFJLEdBQUdnbkIsUUFBUSxDQUFDamhDLEdBQUQsQ0FBckI7QUFDQSxvQkFBTTZHLElBQUksR0FBR3E2QixRQUFRLENBQUNsaEMsR0FBRCxDQUFyQjs7QUFDQSxrQkFBSTZHLElBQUksS0FBS29ULElBQVQsSUFDQzBrQixrQkFBa0IsSUFBSUEsa0JBQWtCLENBQUNyZ0IsRUFBRCxFQUFLdGUsR0FBTCxDQUQ3QyxFQUN5RDtBQUNyRHkrQiw2QkFBYSxDQUFDbmdCLEVBQUQsRUFBS3RlLEdBQUwsRUFBVWlhLElBQVYsRUFBZ0JwVCxJQUFoQixFQUFzQm9ZLEtBQXRCLEVBQTZCTixFQUFFLENBQUMzQixRQUFoQyxFQUEwQytCLGVBQTFDLEVBQTJEQyxjQUEzRCxFQUEyRTZoQixlQUEzRSxDQUFiO0FBQ0g7QUFDSjtBQUNKO0FBQ0osT0F6Q2MsQ0EwQ2Y7QUFDQTs7O0FBQ0EsVUFBSTVrQixTQUFTLEdBQUc7QUFBRTtBQUFsQixRQUE4QjtBQUMxQixjQUFJMEMsRUFBRSxDQUFDM0IsUUFBSCxLQUFnQjRCLEVBQUUsQ0FBQzVCLFFBQXZCLEVBQWlDO0FBQzdCbWlCLDhCQUFrQixDQUFDN2dCLEVBQUQsRUFBS00sRUFBRSxDQUFDNUIsUUFBUixDQUFsQjtBQUNIO0FBQ0o7QUFDSixLQWpERCxNQWtESyxJQUFJLENBQUNZLFNBQUQsSUFBY1gsZUFBZSxJQUFJLElBQXJDLEVBQTJDO0FBQzVDO0FBQ0Fta0IsZ0JBQVUsQ0FBQzlpQixFQUFELEVBQUtNLEVBQUwsRUFBU3FpQixRQUFULEVBQW1CQyxRQUFuQixFQUE2Qm5pQixlQUE3QixFQUE4Q0MsY0FBOUMsRUFBOERDLEtBQTlELENBQVY7QUFDSDs7QUFDRCxVQUFNc2lCLGNBQWMsR0FBR3RpQixLQUFLLElBQUlMLEVBQUUsQ0FBQzdlLElBQUgsS0FBWSxlQUE1Qzs7QUFDQSxRQUFJa2QsZUFBSixFQUFxQjtBQUNqQnVrQix3QkFBa0IsQ0FBQzdpQixFQUFFLENBQUMxQixlQUFKLEVBQXFCQSxlQUFyQixFQUFzQ3FCLEVBQXRDLEVBQTBDUyxlQUExQyxFQUEyREMsY0FBM0QsRUFBMkV1aUIsY0FBM0UsRUFBMkZyaUIsWUFBM0YsQ0FBbEI7O0FBQ0EsVUFBS3RoQixLQUFELElBQTJDbWhCLGVBQTNDLElBQThEQSxlQUFlLENBQUNoZixJQUFoQixDQUFxQndULE9BQXZGLEVBQWdHO0FBQzVGa3VCLDhCQUFzQixDQUFDOWlCLEVBQUQsRUFBS0MsRUFBTCxDQUF0QjtBQUNIO0FBQ0osS0FMRCxNQU1LLElBQUksQ0FBQ2hCLFNBQUwsRUFBZ0I7QUFDakI7QUFDQThqQixtQkFBYSxDQUFDL2lCLEVBQUQsRUFBS0MsRUFBTCxFQUFTTixFQUFULEVBQWEsSUFBYixFQUFtQlMsZUFBbkIsRUFBb0NDLGNBQXBDLEVBQW9EdWlCLGNBQXBELEVBQW9FcmlCLFlBQXBFLEVBQWtGLEtBQWxGLENBQWI7QUFDSDs7QUFDRCxRQUFJLENBQUNtTixTQUFTLEdBQUc2VSxRQUFRLENBQUNTLGNBQXRCLEtBQXlDbGxCLElBQTdDLEVBQW1EO0FBQy9DMEksMkJBQXFCLENBQUMsTUFBTTtBQUN4QmtILGlCQUFTLElBQUlFLGVBQWUsQ0FBQ0YsU0FBRCxFQUFZdE4sZUFBWixFQUE2QkgsRUFBN0IsRUFBaUNELEVBQWpDLENBQTVCO0FBQ0FsQyxZQUFJLElBQUlvYixtQkFBbUIsQ0FBQ2paLEVBQUQsRUFBS0QsRUFBTCxFQUFTSSxlQUFULEVBQTBCLFNBQTFCLENBQTNCO0FBQ0gsT0FIb0IsRUFHbEJDLGNBSGtCLENBQXJCO0FBSUg7QUFDSixHQTVGRCxDQXZQcUQsQ0FvVnJEOzs7QUFDQSxRQUFNd2lCLGtCQUFrQixHQUFHLENBQUNJLFdBQUQsRUFBY0MsV0FBZCxFQUEyQkMsaUJBQTNCLEVBQThDL2lCLGVBQTlDLEVBQStEQyxjQUEvRCxFQUErRUMsS0FBL0UsRUFBc0ZDLFlBQXRGLEtBQXVHO0FBQzlILFNBQUssSUFBSTVmLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1aUMsV0FBVyxDQUFDM2lDLE1BQWhDLEVBQXdDSSxDQUFDLEVBQXpDLEVBQTZDO0FBQ3pDLFlBQU15aUMsUUFBUSxHQUFHSCxXQUFXLENBQUN0aUMsQ0FBRCxDQUE1QjtBQUNBLFlBQU0waUMsUUFBUSxHQUFHSCxXQUFXLENBQUN2aUMsQ0FBRCxDQUE1QixDQUZ5QyxDQUd6Qzs7QUFDQSxZQUFNdWYsU0FBUyxHQUNmO0FBQ0E7QUFDQWtqQixjQUFRLENBQUN6akIsRUFBVCxNQUNJO0FBQ0E7QUFDQ3lqQixjQUFRLENBQUNoaUMsSUFBVCxLQUFrQjhVLFFBQWxCLElBQ0c7QUFDQTtBQUNBLE9BQUNpTSxlQUFlLENBQUNpaEIsUUFBRCxFQUFXQyxRQUFYLENBSG5CLElBSUc7QUFDQUQsY0FBUSxDQUFDcG1CLFNBQVQsR0FBcUI7QUFBRTtBQUwxQixTQU1Hb21CLFFBQVEsQ0FBQ3BtQixTQUFULEdBQXFCO0FBQUc7QUFUaEMsVUFVTXlqQixjQUFjLENBQUMyQyxRQUFRLENBQUN6akIsRUFBVixDQVZwQixHQVdNO0FBQ0U7QUFDQXdqQix1QkFoQlI7QUFpQkFoaUIsV0FBSyxDQUFDaWlCLFFBQUQsRUFBV0MsUUFBWCxFQUFxQm5qQixTQUFyQixFQUFnQyxJQUFoQyxFQUFzQ0UsZUFBdEMsRUFBdURDLGNBQXZELEVBQXVFQyxLQUF2RSxFQUE4RUMsWUFBOUUsRUFBNEYsSUFBNUYsQ0FBTDtBQUNIO0FBQ0osR0F4QkQ7O0FBeUJBLFFBQU1raUIsVUFBVSxHQUFHLENBQUM5aUIsRUFBRCxFQUFLM1MsS0FBTCxFQUFZczFCLFFBQVosRUFBc0JDLFFBQXRCLEVBQWdDbmlCLGVBQWhDLEVBQWlEQyxjQUFqRCxFQUFpRUMsS0FBakUsS0FBMkU7QUFDMUYsUUFBSWdpQixRQUFRLEtBQUtDLFFBQWpCLEVBQTJCO0FBQ3ZCLFdBQUssTUFBTWxoQyxHQUFYLElBQWtCa2hDLFFBQWxCLEVBQTRCO0FBQ3hCO0FBQ0EsWUFBSWpOLDJEQUFjLENBQUNqMEIsR0FBRCxDQUFsQixFQUNJO0FBQ0osY0FBTTZHLElBQUksR0FBR3E2QixRQUFRLENBQUNsaEMsR0FBRCxDQUFyQjtBQUNBLGNBQU1pYSxJQUFJLEdBQUdnbkIsUUFBUSxDQUFDamhDLEdBQUQsQ0FBckI7O0FBQ0EsWUFBSTZHLElBQUksS0FBS29ULElBQVQsSUFDQzBrQixrQkFBa0IsSUFBSUEsa0JBQWtCLENBQUNyZ0IsRUFBRCxFQUFLdGUsR0FBTCxDQUQ3QyxFQUN5RDtBQUNyRHkrQix1QkFBYSxDQUFDbmdCLEVBQUQsRUFBS3RlLEdBQUwsRUFBVWlhLElBQVYsRUFBZ0JwVCxJQUFoQixFQUFzQm9ZLEtBQXRCLEVBQTZCdFQsS0FBSyxDQUFDcVIsUUFBbkMsRUFBNkMrQixlQUE3QyxFQUE4REMsY0FBOUQsRUFBOEU2aEIsZUFBOUUsQ0FBYjtBQUNIO0FBQ0o7O0FBQ0QsVUFBSUksUUFBUSxLQUFLOWlDLGtEQUFqQixFQUE0QjtBQUN4QixhQUFLLE1BQU02QixHQUFYLElBQWtCaWhDLFFBQWxCLEVBQTRCO0FBQ3hCLGNBQUksQ0FBQ2hOLDJEQUFjLENBQUNqMEIsR0FBRCxDQUFmLElBQXdCLEVBQUVBLEdBQUcsSUFBSWtoQyxRQUFULENBQTVCLEVBQWdEO0FBQzVDekMseUJBQWEsQ0FBQ25nQixFQUFELEVBQUt0ZSxHQUFMLEVBQVVpaEMsUUFBUSxDQUFDamhDLEdBQUQsQ0FBbEIsRUFBeUIsSUFBekIsRUFBK0JpZixLQUEvQixFQUFzQ3RULEtBQUssQ0FBQ3FSLFFBQTVDLEVBQXNEK0IsZUFBdEQsRUFBdUVDLGNBQXZFLEVBQXVGNmhCLGVBQXZGLENBQWI7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNKLEdBckJEOztBQXNCQSxRQUFNWixlQUFlLEdBQUcsQ0FBQ3RoQixFQUFELEVBQUtDLEVBQUwsRUFBU0MsU0FBVCxFQUFvQkMsTUFBcEIsRUFBNEJDLGVBQTVCLEVBQTZDQyxjQUE3QyxFQUE2REMsS0FBN0QsRUFBb0VDLFlBQXBFLEVBQWtGdEIsU0FBbEYsS0FBZ0c7QUFDcEgsVUFBTXFrQixtQkFBbUIsR0FBSXJqQixFQUFFLENBQUNOLEVBQUgsR0FBUUssRUFBRSxHQUFHQSxFQUFFLENBQUNMLEVBQU4sR0FBV3dnQixjQUFjLENBQUMsRUFBRCxDQUFoRTtBQUNBLFVBQU1vRCxpQkFBaUIsR0FBSXRqQixFQUFFLENBQUNFLE1BQUgsR0FBWUgsRUFBRSxHQUFHQSxFQUFFLENBQUNHLE1BQU4sR0FBZWdnQixjQUFjLENBQUMsRUFBRCxDQUF0RTtBQUNBLFFBQUk7QUFBRTdpQixlQUFGO0FBQWFnQixxQkFBYjtBQUE4QmlDLGtCQUFZLEVBQUVpZDtBQUE1QyxRQUFxRXZkLEVBQXpFOztBQUNBLFFBQUkzQixlQUFKLEVBQXFCO0FBQ2pCVyxlQUFTLEdBQUcsSUFBWjtBQUNILEtBTm1ILENBT3BIOzs7QUFDQSxRQUFJdWUsb0JBQUosRUFBMEI7QUFDdEJqZCxrQkFBWSxHQUFHQSxZQUFZLEdBQ3JCQSxZQUFZLENBQUN2QyxNQUFiLENBQW9Cd2Ysb0JBQXBCLENBRHFCLEdBRXJCQSxvQkFGTjtBQUdIOztBQUNELFFBQUt2K0IsS0FBRCxJQUEyQ2dWLGFBQS9DLEVBQThEO0FBQzFEO0FBQ0FxSixlQUFTLEdBQUcsQ0FBWjtBQUNBMkIsZUFBUyxHQUFHLEtBQVo7QUFDQVgscUJBQWUsR0FBRyxJQUFsQjtBQUNIOztBQUNELFFBQUkwQixFQUFFLElBQUksSUFBVixFQUFnQjtBQUNaNGYsZ0JBQVUsQ0FBQzBELG1CQUFELEVBQXNCcGpCLFNBQXRCLEVBQWlDQyxNQUFqQyxDQUFWO0FBQ0F5ZixnQkFBVSxDQUFDMkQsaUJBQUQsRUFBb0JyakIsU0FBcEIsRUFBK0JDLE1BQS9CLENBQVYsQ0FGWSxDQUdaO0FBQ0E7QUFDQTs7QUFDQThoQixtQkFBYSxDQUFDaGlCLEVBQUUsQ0FBQzVCLFFBQUosRUFBYzZCLFNBQWQsRUFBeUJxakIsaUJBQXpCLEVBQTRDbmpCLGVBQTVDLEVBQTZEQyxjQUE3RCxFQUE2RUMsS0FBN0UsRUFBb0ZDLFlBQXBGLEVBQWtHdEIsU0FBbEcsQ0FBYjtBQUNILEtBUEQsTUFRSztBQUNELFVBQUkzQixTQUFTLEdBQUcsQ0FBWixJQUNBQSxTQUFTLEdBQUc7QUFBRztBQURmLFNBRUFnQixlQUZBLElBR0E7QUFDQTtBQUNBMEIsUUFBRSxDQUFDMUIsZUFMUCxFQUt3QjtBQUNwQjtBQUNBO0FBQ0F1a0IsMEJBQWtCLENBQUM3aUIsRUFBRSxDQUFDMUIsZUFBSixFQUFxQkEsZUFBckIsRUFBc0M0QixTQUF0QyxFQUFpREUsZUFBakQsRUFBa0VDLGNBQWxFLEVBQWtGQyxLQUFsRixFQUF5RkMsWUFBekYsQ0FBbEI7O0FBQ0EsWUFBS3RoQixLQUFELElBQTJDbWhCLGVBQTNDLElBQThEQSxlQUFlLENBQUNoZixJQUFoQixDQUFxQndULE9BQXZGLEVBQWdHO0FBQzVGa3VCLGdDQUFzQixDQUFDOWlCLEVBQUQsRUFBS0MsRUFBTCxDQUF0QjtBQUNILFNBRkQsTUFHSyxLQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0FBLFVBQUUsQ0FBQzVlLEdBQUgsSUFBVSxJQUFWLElBQ0srZSxlQUFlLElBQUlILEVBQUUsS0FBS0csZUFBZSxDQUFDUixPQU4xQyxFQU1vRDtBQUNyRGtqQixnQ0FBc0IsQ0FBQzlpQixFQUFELEVBQUtDLEVBQUwsRUFBUztBQUFLO0FBQWQsV0FBdEI7QUFDSDtBQUNKLE9BckJELE1Bc0JLO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQThpQixxQkFBYSxDQUFDL2lCLEVBQUQsRUFBS0MsRUFBTCxFQUFTQyxTQUFULEVBQW9CcWpCLGlCQUFwQixFQUF1Q25qQixlQUF2QyxFQUF3REMsY0FBeEQsRUFBd0VDLEtBQXhFLEVBQStFQyxZQUEvRSxFQUE2RnRCLFNBQTdGLENBQWI7QUFDSDtBQUNKO0FBQ0osR0ExREQ7O0FBMkRBLFFBQU11aUIsZ0JBQWdCLEdBQUcsQ0FBQ3hoQixFQUFELEVBQUtDLEVBQUwsRUFBU0MsU0FBVCxFQUFvQkMsTUFBcEIsRUFBNEJDLGVBQTVCLEVBQTZDQyxjQUE3QyxFQUE2REMsS0FBN0QsRUFBb0VDLFlBQXBFLEVBQWtGdEIsU0FBbEYsS0FBZ0c7QUFDckhnQixNQUFFLENBQUNNLFlBQUgsR0FBa0JBLFlBQWxCOztBQUNBLFFBQUlQLEVBQUUsSUFBSSxJQUFWLEVBQWdCO0FBQ1osVUFBSUMsRUFBRSxDQUFDakQsU0FBSCxHQUFlO0FBQUk7QUFBdkIsUUFBbUQ7QUFDL0NvRCx5QkFBZSxDQUFDdkUsR0FBaEIsQ0FBb0IwUixRQUFwQixDQUE2QnROLEVBQTdCLEVBQWlDQyxTQUFqQyxFQUE0Q0MsTUFBNUMsRUFBb0RHLEtBQXBELEVBQTJEckIsU0FBM0Q7QUFDSCxTQUZELE1BR0s7QUFDRHdjLHNCQUFjLENBQUN4YixFQUFELEVBQUtDLFNBQUwsRUFBZ0JDLE1BQWhCLEVBQXdCQyxlQUF4QixFQUF5Q0MsY0FBekMsRUFBeURDLEtBQXpELEVBQWdFckIsU0FBaEUsQ0FBZDtBQUNIO0FBQ0osS0FQRCxNQVFLO0FBQ0R1a0IscUJBQWUsQ0FBQ3hqQixFQUFELEVBQUtDLEVBQUwsRUFBU2hCLFNBQVQsQ0FBZjtBQUNIO0FBQ0osR0FiRDs7QUFjQSxRQUFNd2MsY0FBYyxHQUFHLENBQUNnSSxZQUFELEVBQWV2akIsU0FBZixFQUEwQkMsTUFBMUIsRUFBa0NDLGVBQWxDLEVBQW1EQyxjQUFuRCxFQUFtRUMsS0FBbkUsRUFBMEVyQixTQUExRSxLQUF3RjtBQUMzRyxVQUFNOVIsUUFBUSxHQUFJczJCLFlBQVksQ0FBQ3IyQixTQUFiLEdBQXlCczJCLHVCQUF1QixDQUFDRCxZQUFELEVBQWVyakIsZUFBZixFQUFnQ0MsY0FBaEMsQ0FBbEU7O0FBQ0EsUUFBS3BoQixLQUFELElBQTJDa08sUUFBUSxDQUFDL0wsSUFBVCxDQUFjd1QsT0FBN0QsRUFBc0U7QUFDbEVELGlCQUFXLENBQUN4SCxRQUFELENBQVg7QUFDSDs7QUFDRCxRQUFLbE8sSUFBTCxFQUE2QztBQUN6QzhOLHdCQUFrQixDQUFDMDJCLFlBQUQsQ0FBbEI7QUFDQTdGLGtCQUFZLENBQUN6d0IsUUFBRCxFQUFZLE9BQVosQ0FBWjtBQUNILEtBUjBHLENBUzNHOzs7QUFDQSxRQUFJMmQsV0FBVyxDQUFDMlksWUFBRCxDQUFmLEVBQStCO0FBQzNCdDJCLGNBQVEsQ0FBQzBPLEdBQVQsQ0FBYXFSLFFBQWIsR0FBd0J1VSxTQUF4QjtBQUNILEtBWjBHLENBYTNHOzs7QUFDQTtBQUNJLFVBQUt4aUMsSUFBTCxFQUE2QztBQUN6QzIrQixvQkFBWSxDQUFDendCLFFBQUQsRUFBWSxNQUFaLENBQVo7QUFDSDs7QUFDRHcyQixvQkFBYyxDQUFDeDJCLFFBQUQsQ0FBZDs7QUFDQSxVQUFLbE8sSUFBTCxFQUE2QztBQUN6Q2cvQixrQkFBVSxDQUFDOXdCLFFBQUQsRUFBWSxNQUFaLENBQVY7QUFDSDtBQUNKLEtBdEIwRyxDQXVCM0c7QUFDQTs7QUFDQSxRQUFJQSxRQUFRLENBQUN1VyxRQUFiLEVBQXVCO0FBQ25CckQsb0JBQWMsSUFBSUEsY0FBYyxDQUFDaUQsV0FBZixDQUEyQm5XLFFBQTNCLEVBQXFDb1csaUJBQXJDLENBQWxCLENBRG1CLENBRW5CO0FBQ0E7O0FBQ0EsVUFBSSxDQUFDa2dCLFlBQVksQ0FBQzlqQixFQUFsQixFQUFzQjtBQUNsQixjQUFNb0UsV0FBVyxHQUFJNVcsUUFBUSxDQUFDeVMsT0FBVCxHQUFtQnpCLFdBQVcsQ0FBQzlILFNBQUQsQ0FBbkQ7QUFDQThxQiwwQkFBa0IsQ0FBQyxJQUFELEVBQU9wZCxXQUFQLEVBQW9CN0QsU0FBcEIsRUFBK0JDLE1BQS9CLENBQWxCO0FBQ0g7O0FBQ0Q7QUFDSDs7QUFDRG9ELHFCQUFpQixDQUFDcFcsUUFBRCxFQUFXczJCLFlBQVgsRUFBeUJ2akIsU0FBekIsRUFBb0NDLE1BQXBDLEVBQTRDRSxjQUE1QyxFQUE0REMsS0FBNUQsRUFBbUVyQixTQUFuRSxDQUFqQjs7QUFDQSxRQUFLaGdCLElBQUwsRUFBNkM7QUFDekNnTyx1QkFBaUI7QUFDakJneEIsZ0JBQVUsQ0FBQzl3QixRQUFELEVBQVksT0FBWixDQUFWO0FBQ0g7QUFDSixHQXhDRDs7QUF5Q0EsUUFBTXEyQixlQUFlLEdBQUcsQ0FBQ3hqQixFQUFELEVBQUtDLEVBQUwsRUFBU2hCLFNBQVQsS0FBdUI7QUFDM0MsVUFBTTlSLFFBQVEsR0FBSThTLEVBQUUsQ0FBQzdTLFNBQUgsR0FBZTRTLEVBQUUsQ0FBQzVTLFNBQXBDOztBQUNBLFFBQUkwUixxQkFBcUIsQ0FBQ2tCLEVBQUQsRUFBS0MsRUFBTCxFQUFTaEIsU0FBVCxDQUF6QixFQUE4QztBQUMxQyxVQUFJOVIsUUFBUSxDQUFDdVcsUUFBVCxJQUNBLENBQUN2VyxRQUFRLENBQUMwVyxhQURkLEVBQzZCO0FBQ3pCO0FBQ0E7QUFDQSxZQUFLNWtCLElBQUwsRUFBNkM7QUFDekM4Tiw0QkFBa0IsQ0FBQ2tULEVBQUQsQ0FBbEI7QUFDSDs7QUFDRDJqQixnQ0FBd0IsQ0FBQ3oyQixRQUFELEVBQVc4UyxFQUFYLEVBQWVoQixTQUFmLENBQXhCOztBQUNBLFlBQUtoZ0IsSUFBTCxFQUE2QztBQUN6Q2dPLDJCQUFpQjtBQUNwQjs7QUFDRDtBQUNILE9BWkQsTUFhSztBQUNEO0FBQ0FFLGdCQUFRLENBQUNqRixJQUFULEdBQWdCK1gsRUFBaEIsQ0FGQyxDQUdEO0FBQ0E7O0FBQ0F2TixxQkFBYSxDQUFDdkYsUUFBUSxDQUFDbUksTUFBVixDQUFiLENBTEMsQ0FNRDs7QUFDQW5JLGdCQUFRLENBQUNtSSxNQUFUO0FBQ0g7QUFDSixLQXZCRCxNQXdCSztBQUNEO0FBQ0EySyxRQUFFLENBQUM3UyxTQUFILEdBQWU0UyxFQUFFLENBQUM1UyxTQUFsQjtBQUNBNlMsUUFBRSxDQUFDTixFQUFILEdBQVFLLEVBQUUsQ0FBQ0wsRUFBWDtBQUNBeFMsY0FBUSxDQUFDSCxLQUFULEdBQWlCaVQsRUFBakI7QUFDSDtBQUNKLEdBaENEOztBQWlDQSxRQUFNc0QsaUJBQWlCLEdBQUcsQ0FBQ3BXLFFBQUQsRUFBV3MyQixZQUFYLEVBQXlCdmpCLFNBQXpCLEVBQW9DQyxNQUFwQyxFQUE0Q0UsY0FBNUMsRUFBNERDLEtBQTVELEVBQW1FckIsU0FBbkUsS0FBaUY7QUFDdkc7QUFDQTlSLFlBQVEsQ0FBQ21JLE1BQVQsR0FBa0JoVyx1REFBTSxDQUFDLFNBQVN1a0MsZUFBVCxHQUEyQjtBQUNoRCxVQUFJLENBQUMxMkIsUUFBUSxDQUFDc1osU0FBZCxFQUF5QjtBQUNyQixZQUFJaUgsU0FBSjtBQUNBLGNBQU07QUFBRS9OLFlBQUY7QUFBTS9RO0FBQU4sWUFBZ0I2MEIsWUFBdEI7QUFDQSxjQUFNO0FBQUVLLFlBQUY7QUFBTXJoQixXQUFOO0FBQVNyVTtBQUFULFlBQW9CakIsUUFBMUIsQ0FIcUIsQ0FJckI7O0FBQ0EsWUFBSTIyQixFQUFKLEVBQVE7QUFDSnJXLHFFQUFjLENBQUNxVyxFQUFELENBQWQ7QUFDSCxTQVBvQixDQVFyQjs7O0FBQ0EsWUFBS3BXLFNBQVMsR0FBRzllLEtBQUssSUFBSUEsS0FBSyxDQUFDd3VCLGtCQUFoQyxFQUFxRDtBQUNqRHhQLHlCQUFlLENBQUNGLFNBQUQsRUFBWXRmLE1BQVosRUFBb0JxMUIsWUFBcEIsQ0FBZjtBQUNIOztBQUNELFlBQUk5akIsRUFBRSxJQUFJdUUsV0FBVixFQUF1QjtBQUNuQjtBQUNBLGdCQUFNNmYsY0FBYyxHQUFHLE1BQU07QUFDekIsZ0JBQUs5a0MsSUFBTCxFQUE2QztBQUN6QzIrQiwwQkFBWSxDQUFDendCLFFBQUQsRUFBWSxRQUFaLENBQVo7QUFDSDs7QUFDREEsb0JBQVEsQ0FBQ3lTLE9BQVQsR0FBbUJyRCxtQkFBbUIsQ0FBQ3BQLFFBQUQsQ0FBdEM7O0FBQ0EsZ0JBQUtsTyxJQUFMLEVBQTZDO0FBQ3pDZy9CLHdCQUFVLENBQUM5d0IsUUFBRCxFQUFZLFFBQVosQ0FBVjtBQUNIOztBQUNELGdCQUFLbE8sSUFBTCxFQUE2QztBQUN6QzIrQiwwQkFBWSxDQUFDendCLFFBQUQsRUFBWSxTQUFaLENBQVo7QUFDSDs7QUFDRCtXLHVCQUFXLENBQUN2RSxFQUFELEVBQUt4UyxRQUFRLENBQUN5UyxPQUFkLEVBQXVCelMsUUFBdkIsRUFBaUNrVCxjQUFqQyxFQUFpRCxJQUFqRCxDQUFYOztBQUNBLGdCQUFLcGhCLElBQUwsRUFBNkM7QUFDekNnL0Isd0JBQVUsQ0FBQzl3QixRQUFELEVBQVksU0FBWixDQUFWO0FBQ0g7QUFDSixXQWZEOztBQWdCQSxjQUFJK2QsY0FBYyxDQUFDdVksWUFBRCxDQUFsQixFQUFrQztBQUM5QkEsd0JBQVksQ0FBQ3JpQyxJQUFiLENBQWtCK3BCLGFBQWxCLEdBQWtDeFosSUFBbEMsRUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFNLENBQUN4RSxRQUFRLENBQUMyVixXQUFWLElBQXlCaWhCLGNBQWMsRUFMN0M7QUFNSCxXQVBELE1BUUs7QUFDREEsMEJBQWM7QUFDakI7QUFDSixTQTdCRCxNQThCSztBQUNELGNBQUs5a0MsSUFBTCxFQUE2QztBQUN6QzIrQix3QkFBWSxDQUFDendCLFFBQUQsRUFBWSxRQUFaLENBQVo7QUFDSDs7QUFDRCxnQkFBTXlTLE9BQU8sR0FBSXpTLFFBQVEsQ0FBQ3lTLE9BQVQsR0FBbUJyRCxtQkFBbUIsQ0FBQ3BQLFFBQUQsQ0FBdkQ7O0FBQ0EsY0FBS2xPLElBQUwsRUFBNkM7QUFDekNnL0Isc0JBQVUsQ0FBQzl3QixRQUFELEVBQVksUUFBWixDQUFWO0FBQ0g7O0FBQ0QsY0FBS2xPLElBQUwsRUFBNkM7QUFDekMyK0Isd0JBQVksQ0FBQ3p3QixRQUFELEVBQVksT0FBWixDQUFaO0FBQ0g7O0FBQ0RnVSxlQUFLLENBQUMsSUFBRCxFQUFPdkIsT0FBUCxFQUFnQk0sU0FBaEIsRUFBMkJDLE1BQTNCLEVBQW1DaFQsUUFBbkMsRUFBNkNrVCxjQUE3QyxFQUE2REMsS0FBN0QsQ0FBTDs7QUFDQSxjQUFLcmhCLElBQUwsRUFBNkM7QUFDekNnL0Isc0JBQVUsQ0FBQzl3QixRQUFELEVBQVksT0FBWixDQUFWO0FBQ0g7O0FBQ0RzMkIsc0JBQVksQ0FBQzlqQixFQUFiLEdBQWtCQyxPQUFPLENBQUNELEVBQTFCO0FBQ0gsU0ExRG9CLENBMkRyQjs7O0FBQ0EsWUFBSThDLENBQUosRUFBTztBQUNIK0QsK0JBQXFCLENBQUMvRCxDQUFELEVBQUlwQyxjQUFKLENBQXJCO0FBQ0gsU0E5RG9CLENBK0RyQjs7O0FBQ0EsWUFBS3FOLFNBQVMsR0FBRzllLEtBQUssSUFBSUEsS0FBSyxDQUFDK2UsY0FBaEMsRUFBaUQ7QUFDN0MsZ0JBQU1xVyxrQkFBa0IsR0FBR1AsWUFBM0I7QUFDQWpkLCtCQUFxQixDQUFDLE1BQU1vSCxlQUFlLENBQUNGLFNBQUQsRUFBWXRmLE1BQVosRUFBb0I0MUIsa0JBQXBCLENBQXRCLEVBQStEM2pCLGNBQS9ELENBQXJCO0FBQ0gsU0FuRW9CLENBb0VyQjtBQUNBO0FBQ0E7OztBQUNBLFlBQUlvakIsWUFBWSxDQUFDem1CLFNBQWIsR0FBeUI7QUFBSTtBQUFqQyxVQUFvRTtBQUNoRTdQLG9CQUFRLENBQUN1RyxDQUFULElBQWM4UyxxQkFBcUIsQ0FBQ3JaLFFBQVEsQ0FBQ3VHLENBQVYsRUFBYTJNLGNBQWIsQ0FBbkM7QUFDSDs7QUFDRGxULGdCQUFRLENBQUNzWixTQUFULEdBQXFCLElBQXJCOztBQUNBLFlBQUt4bkIsSUFBTCxFQUFzRTtBQUNsRXVYLGdDQUFzQixDQUFDckosUUFBRCxDQUF0QjtBQUNILFNBN0VvQixDQThFckI7OztBQUNBczJCLG9CQUFZLEdBQUd2akIsU0FBUyxHQUFHQyxNQUFNLEdBQUcsSUFBcEM7QUFDSCxPQWhGRCxNQWlGSztBQUNEO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFBRWpZLGNBQUY7QUFBUSs3QixZQUFSO0FBQVlDLFdBQVo7QUFBZTkxQixnQkFBZjtBQUF1QnBCO0FBQXZCLFlBQWlDRyxRQUFyQztBQUNBLFlBQUlnM0IsVUFBVSxHQUFHajhCLElBQWpCO0FBQ0EsWUFBSXdsQixTQUFKOztBQUNBLFlBQUt6dUIsSUFBTCxFQUE2QztBQUN6QzhOLDRCQUFrQixDQUFDN0UsSUFBSSxJQUFJaUYsUUFBUSxDQUFDSCxLQUFsQixDQUFsQjtBQUNIOztBQUNELFlBQUk5RSxJQUFKLEVBQVU7QUFDTkEsY0FBSSxDQUFDeVgsRUFBTCxHQUFVM1MsS0FBSyxDQUFDMlMsRUFBaEI7QUFDQWlrQixrQ0FBd0IsQ0FBQ3oyQixRQUFELEVBQVdqRixJQUFYLEVBQWlCK1csU0FBakIsQ0FBeEI7QUFDSCxTQUhELE1BSUs7QUFDRC9XLGNBQUksR0FBRzhFLEtBQVA7QUFDSCxTQWhCQSxDQWlCRDs7O0FBQ0EsWUFBSWkzQixFQUFKLEVBQVE7QUFDSnhXLHFFQUFjLENBQUN3VyxFQUFELENBQWQ7QUFDSCxTQXBCQSxDQXFCRDs7O0FBQ0EsWUFBS3ZXLFNBQVMsR0FBR3hsQixJQUFJLENBQUMwRyxLQUFMLElBQWMxRyxJQUFJLENBQUMwRyxLQUFMLENBQVc0ekIsbUJBQTFDLEVBQWdFO0FBQzVENVUseUJBQWUsQ0FBQ0YsU0FBRCxFQUFZdGYsTUFBWixFQUFvQmxHLElBQXBCLEVBQTBCOEUsS0FBMUIsQ0FBZjtBQUNILFNBeEJBLENBeUJEOzs7QUFDQSxZQUFLL04sSUFBTCxFQUE2QztBQUN6QzIrQixzQkFBWSxDQUFDendCLFFBQUQsRUFBWSxRQUFaLENBQVo7QUFDSDs7QUFDRCxjQUFNaTNCLFFBQVEsR0FBRzduQixtQkFBbUIsQ0FBQ3BQLFFBQUQsQ0FBcEM7O0FBQ0EsWUFBS2xPLElBQUwsRUFBNkM7QUFDekNnL0Isb0JBQVUsQ0FBQzl3QixRQUFELEVBQVksUUFBWixDQUFWO0FBQ0g7O0FBQ0QsY0FBTWszQixRQUFRLEdBQUdsM0IsUUFBUSxDQUFDeVMsT0FBMUI7QUFDQXpTLGdCQUFRLENBQUN5UyxPQUFULEdBQW1Cd2tCLFFBQW5COztBQUNBLFlBQUtubEMsSUFBTCxFQUE2QztBQUN6QzIrQixzQkFBWSxDQUFDendCLFFBQUQsRUFBWSxPQUFaLENBQVo7QUFDSDs7QUFDRGdVLGFBQUssQ0FBQ2tqQixRQUFELEVBQVdELFFBQVgsRUFDTDtBQUNBM0Qsc0JBQWMsQ0FBQzRELFFBQVEsQ0FBQzFrQixFQUFWLENBRlQsRUFHTDtBQUNBc2hCLHVCQUFlLENBQUNvRCxRQUFELENBSlYsRUFJc0JsM0IsUUFKdEIsRUFJZ0NrVCxjQUpoQyxFQUlnREMsS0FKaEQsQ0FBTDs7QUFLQSxZQUFLcmhCLElBQUwsRUFBNkM7QUFDekNnL0Isb0JBQVUsQ0FBQzl3QixRQUFELEVBQVksT0FBWixDQUFWO0FBQ0g7O0FBQ0RqRixZQUFJLENBQUN5WCxFQUFMLEdBQVV5a0IsUUFBUSxDQUFDemtCLEVBQW5COztBQUNBLFlBQUl3a0IsVUFBVSxLQUFLLElBQW5CLEVBQXlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBemtCLHlCQUFlLENBQUN2UyxRQUFELEVBQVdpM0IsUUFBUSxDQUFDemtCLEVBQXBCLENBQWY7QUFDSCxTQXBEQSxDQXFERDs7O0FBQ0EsWUFBSXVrQixDQUFKLEVBQU87QUFDSDFkLCtCQUFxQixDQUFDMGQsQ0FBRCxFQUFJN2pCLGNBQUosQ0FBckI7QUFDSCxTQXhEQSxDQXlERDs7O0FBQ0EsWUFBS3FOLFNBQVMsR0FBR3hsQixJQUFJLENBQUMwRyxLQUFMLElBQWMxRyxJQUFJLENBQUMwRyxLQUFMLENBQVdvMEIsY0FBMUMsRUFBMkQ7QUFDdkR4YywrQkFBcUIsQ0FBQyxNQUFNb0gsZUFBZSxDQUFDRixTQUFELEVBQVl0ZixNQUFaLEVBQW9CbEcsSUFBcEIsRUFBMEI4RSxLQUExQixDQUF0QixFQUF3RHFULGNBQXhELENBQXJCO0FBQ0g7O0FBQ0QsWUFBS3BoQixJQUFMLEVBQXNFO0FBQ2xFeVgsa0NBQXdCLENBQUN2SixRQUFELENBQXhCO0FBQ0g7O0FBQ0QsWUFBS2xPLElBQUwsRUFBNkM7QUFDekNnTywyQkFBaUI7QUFDcEI7QUFDSjtBQUNKLEtBdEp1QixFQXNKcEJoTyxLQUFELEdBQTBDdy9CLHNCQUFzQixDQUFDdHhCLFFBQUQsQ0FBaEUsR0FBNkVxeEIsQ0F0SnhELENBQXhCOztBQXVKQSxRQUFLdi9CLElBQUwsRUFBNkM7QUFDekM7QUFDQWtPLGNBQVEsQ0FBQ21JLE1BQVQsQ0FBZ0J4QixhQUFoQixHQUFnQzNHLFFBQWhDO0FBQ0g7QUFDSixHQTdKRDs7QUE4SkEsUUFBTXkyQix3QkFBd0IsR0FBRyxDQUFDejJCLFFBQUQsRUFBVzZSLFNBQVgsRUFBc0JDLFNBQXRCLEtBQW9DO0FBQ2pFRCxhQUFTLENBQUM1UixTQUFWLEdBQXNCRCxRQUF0QjtBQUNBLFVBQU0rUixTQUFTLEdBQUcvUixRQUFRLENBQUNILEtBQVQsQ0FBZTRCLEtBQWpDO0FBQ0F6QixZQUFRLENBQUNILEtBQVQsR0FBaUJnUyxTQUFqQjtBQUNBN1IsWUFBUSxDQUFDakYsSUFBVCxHQUFnQixJQUFoQjtBQUNBMHNCLGVBQVcsQ0FBQ3puQixRQUFELEVBQVc2UixTQUFTLENBQUNwUSxLQUFyQixFQUE0QnNRLFNBQTVCLEVBQXVDRCxTQUF2QyxDQUFYO0FBQ0F1WixlQUFXLENBQUNyckIsUUFBRCxFQUFXNlIsU0FBUyxDQUFDWCxRQUFyQixFQUErQlksU0FBL0IsQ0FBWDtBQUNBbGUsa0VBQWEsR0FQb0QsQ0FRakU7QUFDQTs7QUFDQW9TLG9CQUFnQixDQUFDbFMsU0FBRCxFQUFZa00sUUFBUSxDQUFDbUksTUFBckIsQ0FBaEI7QUFDQWhWLGtFQUFhO0FBQ2hCLEdBWkQ7O0FBYUEsUUFBTXlpQyxhQUFhLEdBQUcsQ0FBQy9pQixFQUFELEVBQUtDLEVBQUwsRUFBU0MsU0FBVCxFQUFvQkMsTUFBcEIsRUFBNEJDLGVBQTVCLEVBQTZDQyxjQUE3QyxFQUE2REMsS0FBN0QsRUFBb0VDLFlBQXBFLEVBQWtGdEIsU0FBUyxHQUFHLEtBQTlGLEtBQXdHO0FBQzFILFVBQU1xbEIsRUFBRSxHQUFHdGtCLEVBQUUsSUFBSUEsRUFBRSxDQUFDM0IsUUFBcEI7QUFDQSxVQUFNa21CLGFBQWEsR0FBR3ZrQixFQUFFLEdBQUdBLEVBQUUsQ0FBQ2hELFNBQU4sR0FBa0IsQ0FBMUM7QUFDQSxVQUFNd25CLEVBQUUsR0FBR3ZrQixFQUFFLENBQUM1QixRQUFkO0FBQ0EsVUFBTTtBQUFFZixlQUFGO0FBQWFOO0FBQWIsUUFBMkJpRCxFQUFqQyxDQUowSCxDQUsxSDs7QUFDQSxRQUFJM0MsU0FBUyxHQUFHLENBQWhCLEVBQW1CO0FBQ2YsVUFBSUEsU0FBUyxHQUFHO0FBQUk7QUFBcEIsUUFBMEM7QUFDdEM7QUFDQTtBQUNBbW5CLDRCQUFrQixDQUFDSCxFQUFELEVBQUtFLEVBQUwsRUFBU3RrQixTQUFULEVBQW9CQyxNQUFwQixFQUE0QkMsZUFBNUIsRUFBNkNDLGNBQTdDLEVBQTZEQyxLQUE3RCxFQUFvRUMsWUFBcEUsRUFBa0Z0QixTQUFsRixDQUFsQjtBQUNBO0FBQ0gsU0FMRCxNQU1LLElBQUkzQixTQUFTLEdBQUc7QUFBSTtBQUFwQixRQUE0QztBQUM3QztBQUNBb25CLDhCQUFvQixDQUFDSixFQUFELEVBQUtFLEVBQUwsRUFBU3RrQixTQUFULEVBQW9CQyxNQUFwQixFQUE0QkMsZUFBNUIsRUFBNkNDLGNBQTdDLEVBQTZEQyxLQUE3RCxFQUFvRUMsWUFBcEUsRUFBa0Z0QixTQUFsRixDQUFwQjtBQUNBO0FBQ0g7QUFDSixLQWxCeUgsQ0FtQjFIOzs7QUFDQSxRQUFJakMsU0FBUyxHQUFHO0FBQUU7QUFBbEIsTUFBdUM7QUFDbkM7QUFDQSxZQUFJdW5CLGFBQWEsR0FBRztBQUFHO0FBQXZCLFVBQTZDO0FBQ3pDckMsMkJBQWUsQ0FBQ29DLEVBQUQsRUFBS2xrQixlQUFMLEVBQXNCQyxjQUF0QixDQUFmO0FBQ0g7O0FBQ0QsWUFBSW1rQixFQUFFLEtBQUtGLEVBQVgsRUFBZTtBQUNYOUQsNEJBQWtCLENBQUN0Z0IsU0FBRCxFQUFZc2tCLEVBQVosQ0FBbEI7QUFDSDtBQUNKLE9BUkQsTUFTSztBQUNELFVBQUlELGFBQWEsR0FBRztBQUFHO0FBQXZCLFFBQTZDO0FBQ3pDO0FBQ0EsY0FBSXZuQixTQUFTLEdBQUc7QUFBRztBQUFuQixZQUF5QztBQUNyQztBQUNBeW5CLGdDQUFrQixDQUFDSCxFQUFELEVBQUtFLEVBQUwsRUFBU3RrQixTQUFULEVBQW9CQyxNQUFwQixFQUE0QkMsZUFBNUIsRUFBNkNDLGNBQTdDLEVBQTZEQyxLQUE3RCxFQUFvRUMsWUFBcEUsRUFBa0Z0QixTQUFsRixDQUFsQjtBQUNILGFBSEQsTUFJSztBQUNEO0FBQ0FpakIsMkJBQWUsQ0FBQ29DLEVBQUQsRUFBS2xrQixlQUFMLEVBQXNCQyxjQUF0QixFQUFzQyxJQUF0QyxDQUFmO0FBQ0g7QUFDSixTQVZELE1BV0s7QUFDRDtBQUNBO0FBQ0EsWUFBSWtrQixhQUFhLEdBQUc7QUFBRTtBQUF0QixVQUEyQztBQUN2Qy9ELDhCQUFrQixDQUFDdGdCLFNBQUQsRUFBWSxFQUFaLENBQWxCO0FBQ0gsV0FMQSxDQU1EOzs7QUFDQSxZQUFJbEQsU0FBUyxHQUFHO0FBQUc7QUFBbkIsVUFBeUM7QUFDckNpbEIseUJBQWEsQ0FBQ3VDLEVBQUQsRUFBS3RrQixTQUFMLEVBQWdCQyxNQUFoQixFQUF3QkMsZUFBeEIsRUFBeUNDLGNBQXpDLEVBQXlEQyxLQUF6RCxFQUFnRUMsWUFBaEUsRUFBOEV0QixTQUE5RSxDQUFiO0FBQ0g7QUFDSjtBQUNKO0FBQ0osR0FyREQ7O0FBc0RBLFFBQU15bEIsb0JBQW9CLEdBQUcsQ0FBQ0osRUFBRCxFQUFLRSxFQUFMLEVBQVN0a0IsU0FBVCxFQUFvQkMsTUFBcEIsRUFBNEJDLGVBQTVCLEVBQTZDQyxjQUE3QyxFQUE2REMsS0FBN0QsRUFBb0VDLFlBQXBFLEVBQWtGdEIsU0FBbEYsS0FBZ0c7QUFDekhxbEIsTUFBRSxHQUFHQSxFQUFFLElBQUl4TyxrREFBWDtBQUNBME8sTUFBRSxHQUFHQSxFQUFFLElBQUkxTyxrREFBWDtBQUNBLFVBQU02TyxTQUFTLEdBQUdMLEVBQUUsQ0FBQy9qQyxNQUFyQjtBQUNBLFVBQU1xa0MsU0FBUyxHQUFHSixFQUFFLENBQUNqa0MsTUFBckI7QUFDQSxVQUFNc2tDLFlBQVksR0FBR0MsSUFBSSxDQUFDQyxHQUFMLENBQVNKLFNBQVQsRUFBb0JDLFNBQXBCLENBQXJCO0FBQ0EsUUFBSWprQyxDQUFKOztBQUNBLFNBQUtBLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR2trQyxZQUFoQixFQUE4QmxrQyxDQUFDLEVBQS9CLEVBQW1DO0FBQy9CLFlBQU1xa0MsU0FBUyxHQUFJUixFQUFFLENBQUM3akMsQ0FBRCxDQUFGLEdBQVFzZSxTQUFTLEdBQzlCb2pCLGNBQWMsQ0FBQ21DLEVBQUUsQ0FBQzdqQyxDQUFELENBQUgsQ0FEZ0IsR0FFOUJ1YyxjQUFjLENBQUNzbkIsRUFBRSxDQUFDN2pDLENBQUQsQ0FBSCxDQUZwQjtBQUdBd2dCLFdBQUssQ0FBQ21qQixFQUFFLENBQUMzakMsQ0FBRCxDQUFILEVBQVFxa0MsU0FBUixFQUFtQjlrQixTQUFuQixFQUE4QixJQUE5QixFQUFvQ0UsZUFBcEMsRUFBcURDLGNBQXJELEVBQXFFQyxLQUFyRSxFQUE0RUMsWUFBNUUsRUFBMEZ0QixTQUExRixDQUFMO0FBQ0g7O0FBQ0QsUUFBSTBsQixTQUFTLEdBQUdDLFNBQWhCLEVBQTJCO0FBQ3ZCO0FBQ0ExQyxxQkFBZSxDQUFDb0MsRUFBRCxFQUFLbGtCLGVBQUwsRUFBc0JDLGNBQXRCLEVBQXNDLElBQXRDLEVBQTRDLEtBQTVDLEVBQW1Ed2tCLFlBQW5ELENBQWY7QUFDSCxLQUhELE1BSUs7QUFDRDtBQUNBNUMsbUJBQWEsQ0FBQ3VDLEVBQUQsRUFBS3RrQixTQUFMLEVBQWdCQyxNQUFoQixFQUF3QkMsZUFBeEIsRUFBeUNDLGNBQXpDLEVBQXlEQyxLQUF6RCxFQUFnRUMsWUFBaEUsRUFBOEV0QixTQUE5RSxFQUF5RjRsQixZQUF6RixDQUFiO0FBQ0g7QUFDSixHQXJCRCxDQXh2QnFELENBOHdCckQ7OztBQUNBLFFBQU1KLGtCQUFrQixHQUFHLENBQUNILEVBQUQsRUFBS0UsRUFBTCxFQUFTdGtCLFNBQVQsRUFBb0Ira0IsWUFBcEIsRUFBa0M3a0IsZUFBbEMsRUFBbURDLGNBQW5ELEVBQW1FQyxLQUFuRSxFQUEwRUMsWUFBMUUsRUFBd0Z0QixTQUF4RixLQUFzRztBQUM3SCxRQUFJdGUsQ0FBQyxHQUFHLENBQVI7QUFDQSxVQUFNdWtDLEVBQUUsR0FBR1YsRUFBRSxDQUFDamtDLE1BQWQ7QUFDQSxRQUFJNGtDLEVBQUUsR0FBR2IsRUFBRSxDQUFDL2pDLE1BQUgsR0FBWSxDQUFyQixDQUg2SCxDQUdyRzs7QUFDeEIsUUFBSTZrQyxFQUFFLEdBQUdGLEVBQUUsR0FBRyxDQUFkLENBSjZILENBSTVHO0FBQ2pCO0FBQ0E7QUFDQTs7QUFDQSxXQUFPdmtDLENBQUMsSUFBSXdrQyxFQUFMLElBQVd4a0MsQ0FBQyxJQUFJeWtDLEVBQXZCLEVBQTJCO0FBQ3ZCLFlBQU1wbEIsRUFBRSxHQUFHc2tCLEVBQUUsQ0FBQzNqQyxDQUFELENBQWI7QUFDQSxZQUFNc2YsRUFBRSxHQUFJdWtCLEVBQUUsQ0FBQzdqQyxDQUFELENBQUYsR0FBUXNlLFNBQVMsR0FDdkJvakIsY0FBYyxDQUFDbUMsRUFBRSxDQUFDN2pDLENBQUQsQ0FBSCxDQURTLEdBRXZCdWMsY0FBYyxDQUFDc25CLEVBQUUsQ0FBQzdqQyxDQUFELENBQUgsQ0FGcEI7O0FBR0EsVUFBSXdoQixlQUFlLENBQUNuQyxFQUFELEVBQUtDLEVBQUwsQ0FBbkIsRUFBNkI7QUFDekJrQixhQUFLLENBQUNuQixFQUFELEVBQUtDLEVBQUwsRUFBU0MsU0FBVCxFQUFvQixJQUFwQixFQUEwQkUsZUFBMUIsRUFBMkNDLGNBQTNDLEVBQTJEQyxLQUEzRCxFQUFrRUMsWUFBbEUsRUFBZ0Z0QixTQUFoRixDQUFMO0FBQ0gsT0FGRCxNQUdLO0FBQ0Q7QUFDSDs7QUFDRHRlLE9BQUM7QUFDSixLQXBCNEgsQ0FxQjdIO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBT0EsQ0FBQyxJQUFJd2tDLEVBQUwsSUFBV3hrQyxDQUFDLElBQUl5a0MsRUFBdkIsRUFBMkI7QUFDdkIsWUFBTXBsQixFQUFFLEdBQUdza0IsRUFBRSxDQUFDYSxFQUFELENBQWI7QUFDQSxZQUFNbGxCLEVBQUUsR0FBSXVrQixFQUFFLENBQUNZLEVBQUQsQ0FBRixHQUFTbm1CLFNBQVMsR0FDeEJvakIsY0FBYyxDQUFDbUMsRUFBRSxDQUFDWSxFQUFELENBQUgsQ0FEVSxHQUV4QmxvQixjQUFjLENBQUNzbkIsRUFBRSxDQUFDWSxFQUFELENBQUgsQ0FGcEI7O0FBR0EsVUFBSWpqQixlQUFlLENBQUNuQyxFQUFELEVBQUtDLEVBQUwsQ0FBbkIsRUFBNkI7QUFDekJrQixhQUFLLENBQUNuQixFQUFELEVBQUtDLEVBQUwsRUFBU0MsU0FBVCxFQUFvQixJQUFwQixFQUEwQkUsZUFBMUIsRUFBMkNDLGNBQTNDLEVBQTJEQyxLQUEzRCxFQUFrRUMsWUFBbEUsRUFBZ0Z0QixTQUFoRixDQUFMO0FBQ0gsT0FGRCxNQUdLO0FBQ0Q7QUFDSDs7QUFDRGttQixRQUFFO0FBQ0ZDLFFBQUU7QUFDTCxLQXJDNEgsQ0FzQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxRQUFJemtDLENBQUMsR0FBR3drQyxFQUFSLEVBQVk7QUFDUixVQUFJeGtDLENBQUMsSUFBSXlrQyxFQUFULEVBQWE7QUFDVCxjQUFNQyxPQUFPLEdBQUdELEVBQUUsR0FBRyxDQUFyQjtBQUNBLGNBQU1qbEIsTUFBTSxHQUFHa2xCLE9BQU8sR0FBR0gsRUFBVixHQUFlVixFQUFFLENBQUNhLE9BQUQsQ0FBRixDQUFZMWxCLEVBQTNCLEdBQWdDc2xCLFlBQS9DOztBQUNBLGVBQU90a0MsQ0FBQyxJQUFJeWtDLEVBQVosRUFBZ0I7QUFDWmprQixlQUFLLENBQUMsSUFBRCxFQUFRcWpCLEVBQUUsQ0FBQzdqQyxDQUFELENBQUYsR0FBUXNlLFNBQVMsR0FDeEJvakIsY0FBYyxDQUFDbUMsRUFBRSxDQUFDN2pDLENBQUQsQ0FBSCxDQURVLEdBRXhCdWMsY0FBYyxDQUFDc25CLEVBQUUsQ0FBQzdqQyxDQUFELENBQUgsQ0FGZixFQUV5QnVmLFNBRnpCLEVBRW9DQyxNQUZwQyxFQUU0Q0MsZUFGNUMsRUFFNkRDLGNBRjdELEVBRTZFQyxLQUY3RSxFQUVvRkMsWUFGcEYsRUFFa0d0QixTQUZsRyxDQUFMO0FBR0F0ZSxXQUFDO0FBQ0o7QUFDSjtBQUNKLEtBWEQsQ0FZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQSxTQW1CSyxJQUFJQSxDQUFDLEdBQUd5a0MsRUFBUixFQUFZO0FBQ2IsZUFBT3prQyxDQUFDLElBQUl3a0MsRUFBWixFQUFnQjtBQUNadGpCLGlCQUFPLENBQUN5aUIsRUFBRSxDQUFDM2pDLENBQUQsQ0FBSCxFQUFReWYsZUFBUixFQUF5QkMsY0FBekIsRUFBeUMsSUFBekMsQ0FBUDtBQUNBMWYsV0FBQztBQUNKO0FBQ0osT0FMSSxDQU1MO0FBQ0E7QUFDQTtBQUNBO0FBVEssV0FVQTtBQUNELGdCQUFNMmtDLEVBQUUsR0FBRzNrQyxDQUFYLENBREMsQ0FDYTs7QUFDZCxnQkFBTTRrQyxFQUFFLEdBQUc1a0MsQ0FBWCxDQUZDLENBRWE7QUFDZDs7QUFDQSxnQkFBTTZrQyxnQkFBZ0IsR0FBRyxJQUFJL2pDLEdBQUosRUFBekI7O0FBQ0EsZUFBS2QsQ0FBQyxHQUFHNGtDLEVBQVQsRUFBYTVrQyxDQUFDLElBQUl5a0MsRUFBbEIsRUFBc0J6a0MsQ0FBQyxFQUF2QixFQUEyQjtBQUN2QixrQkFBTXFrQyxTQUFTLEdBQUlSLEVBQUUsQ0FBQzdqQyxDQUFELENBQUYsR0FBUXNlLFNBQVMsR0FDOUJvakIsY0FBYyxDQUFDbUMsRUFBRSxDQUFDN2pDLENBQUQsQ0FBSCxDQURnQixHQUU5QnVjLGNBQWMsQ0FBQ3NuQixFQUFFLENBQUM3akMsQ0FBRCxDQUFILENBRnBCOztBQUdBLGdCQUFJcWtDLFNBQVMsQ0FBQzNqQyxHQUFWLElBQWlCLElBQXJCLEVBQTJCO0FBQ3ZCLGtCQUFLcEMsS0FBRCxJQUEyQ3VtQyxnQkFBZ0IsQ0FBQzVqQyxHQUFqQixDQUFxQm9qQyxTQUFTLENBQUMzakMsR0FBL0IsQ0FBL0MsRUFBb0Y7QUFDaEYwRSxvQkFBSSxDQUFFLHFDQUFGLEVBQXdDbUosSUFBSSxDQUFDQyxTQUFMLENBQWU2MUIsU0FBUyxDQUFDM2pDLEdBQXpCLENBQXhDLEVBQXdFLDRCQUF4RSxDQUFKO0FBQ0g7O0FBQ0Rta0MsOEJBQWdCLENBQUNoa0MsR0FBakIsQ0FBcUJ3akMsU0FBUyxDQUFDM2pDLEdBQS9CLEVBQW9DVixDQUFwQztBQUNIO0FBQ0osV0FmQSxDQWdCRDtBQUNBOzs7QUFDQSxjQUFJOGtDLENBQUo7QUFDQSxjQUFJQyxPQUFPLEdBQUcsQ0FBZDtBQUNBLGdCQUFNQyxXQUFXLEdBQUdQLEVBQUUsR0FBR0csRUFBTCxHQUFVLENBQTlCO0FBQ0EsY0FBSUssS0FBSyxHQUFHLEtBQVosQ0FyQkMsQ0FzQkQ7O0FBQ0EsY0FBSUMsZ0JBQWdCLEdBQUcsQ0FBdkIsQ0F2QkMsQ0F3QkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxnQkFBTUMscUJBQXFCLEdBQUcsSUFBSWxpQyxLQUFKLENBQVUraEMsV0FBVixDQUE5Qjs7QUFDQSxlQUFLaGxDLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR2dsQyxXQUFoQixFQUE2QmhsQyxDQUFDLEVBQTlCLEVBQ0ltbEMscUJBQXFCLENBQUNubEMsQ0FBRCxDQUFyQixHQUEyQixDQUEzQjs7QUFDSixlQUFLQSxDQUFDLEdBQUcya0MsRUFBVCxFQUFhM2tDLENBQUMsSUFBSXdrQyxFQUFsQixFQUFzQnhrQyxDQUFDLEVBQXZCLEVBQTJCO0FBQ3ZCLGtCQUFNb2xDLFNBQVMsR0FBR3pCLEVBQUUsQ0FBQzNqQyxDQUFELENBQXBCOztBQUNBLGdCQUFJK2tDLE9BQU8sSUFBSUMsV0FBZixFQUE0QjtBQUN4QjtBQUNBOWpCLHFCQUFPLENBQUNra0IsU0FBRCxFQUFZM2xCLGVBQVosRUFBNkJDLGNBQTdCLEVBQTZDLElBQTdDLENBQVA7QUFDQTtBQUNIOztBQUNELGdCQUFJMmxCLFFBQUo7O0FBQ0EsZ0JBQUlELFNBQVMsQ0FBQzFrQyxHQUFWLElBQWlCLElBQXJCLEVBQTJCO0FBQ3ZCMmtDLHNCQUFRLEdBQUdSLGdCQUFnQixDQUFDamtDLEdBQWpCLENBQXFCd2tDLFNBQVMsQ0FBQzFrQyxHQUEvQixDQUFYO0FBQ0gsYUFGRCxNQUdLO0FBQ0Q7QUFDQSxtQkFBS29rQyxDQUFDLEdBQUdGLEVBQVQsRUFBYUUsQ0FBQyxJQUFJTCxFQUFsQixFQUFzQkssQ0FBQyxFQUF2QixFQUEyQjtBQUN2QixvQkFBSUsscUJBQXFCLENBQUNMLENBQUMsR0FBR0YsRUFBTCxDQUFyQixLQUFrQyxDQUFsQyxJQUNBcGpCLGVBQWUsQ0FBQzRqQixTQUFELEVBQVl2QixFQUFFLENBQUNpQixDQUFELENBQWQsQ0FEbkIsRUFDdUM7QUFDbkNPLDBCQUFRLEdBQUdQLENBQVg7QUFDQTtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxnQkFBSU8sUUFBUSxLQUFLL2tDLFNBQWpCLEVBQTRCO0FBQ3hCNGdCLHFCQUFPLENBQUNra0IsU0FBRCxFQUFZM2xCLGVBQVosRUFBNkJDLGNBQTdCLEVBQTZDLElBQTdDLENBQVA7QUFDSCxhQUZELE1BR0s7QUFDRHlsQixtQ0FBcUIsQ0FBQ0UsUUFBUSxHQUFHVCxFQUFaLENBQXJCLEdBQXVDNWtDLENBQUMsR0FBRyxDQUEzQzs7QUFDQSxrQkFBSXFsQyxRQUFRLElBQUlILGdCQUFoQixFQUFrQztBQUM5QkEsZ0NBQWdCLEdBQUdHLFFBQW5CO0FBQ0gsZUFGRCxNQUdLO0FBQ0RKLHFCQUFLLEdBQUcsSUFBUjtBQUNIOztBQUNEemtCLG1CQUFLLENBQUM0a0IsU0FBRCxFQUFZdkIsRUFBRSxDQUFDd0IsUUFBRCxDQUFkLEVBQTBCOWxCLFNBQTFCLEVBQXFDLElBQXJDLEVBQTJDRSxlQUEzQyxFQUE0REMsY0FBNUQsRUFBNEVDLEtBQTVFLEVBQW1GQyxZQUFuRixFQUFpR3RCLFNBQWpHLENBQUw7QUFDQXltQixxQkFBTztBQUNWO0FBQ0osV0FuRUEsQ0FvRUQ7QUFDQTs7O0FBQ0EsZ0JBQU1PLDBCQUEwQixHQUFHTCxLQUFLLEdBQ2xDTSxXQUFXLENBQUNKLHFCQUFELENBRHVCLEdBRWxDaFEsa0RBRk47QUFHQTJQLFdBQUMsR0FBR1EsMEJBQTBCLENBQUMxbEMsTUFBM0IsR0FBb0MsQ0FBeEMsQ0F6RUMsQ0EwRUQ7O0FBQ0EsZUFBS0ksQ0FBQyxHQUFHZ2xDLFdBQVcsR0FBRyxDQUF2QixFQUEwQmhsQyxDQUFDLElBQUksQ0FBL0IsRUFBa0NBLENBQUMsRUFBbkMsRUFBdUM7QUFDbkMsa0JBQU13bEMsU0FBUyxHQUFHWixFQUFFLEdBQUc1a0MsQ0FBdkI7QUFDQSxrQkFBTXFrQyxTQUFTLEdBQUdSLEVBQUUsQ0FBQzJCLFNBQUQsQ0FBcEI7QUFDQSxrQkFBTWhtQixNQUFNLEdBQUdnbUIsU0FBUyxHQUFHLENBQVosR0FBZ0JqQixFQUFoQixHQUFxQlYsRUFBRSxDQUFDMkIsU0FBUyxHQUFHLENBQWIsQ0FBRixDQUFrQnhtQixFQUF2QyxHQUE0Q3NsQixZQUEzRDs7QUFDQSxnQkFBSWEscUJBQXFCLENBQUNubEMsQ0FBRCxDQUFyQixLQUE2QixDQUFqQyxFQUFvQztBQUNoQztBQUNBd2dCLG1CQUFLLENBQUMsSUFBRCxFQUFPNmpCLFNBQVAsRUFBa0I5a0IsU0FBbEIsRUFBNkJDLE1BQTdCLEVBQXFDQyxlQUFyQyxFQUFzREMsY0FBdEQsRUFBc0VDLEtBQXRFLEVBQTZFQyxZQUE3RSxFQUEyRnRCLFNBQTNGLENBQUw7QUFDSCxhQUhELE1BSUssSUFBSTJtQixLQUFKLEVBQVc7QUFDWjtBQUNBO0FBQ0E7QUFDQSxrQkFBSUgsQ0FBQyxHQUFHLENBQUosSUFBUzlrQyxDQUFDLEtBQUtzbEMsMEJBQTBCLENBQUNSLENBQUQsQ0FBN0MsRUFBa0Q7QUFDOUMvaUIsb0JBQUksQ0FBQ3NpQixTQUFELEVBQVk5a0IsU0FBWixFQUF1QkMsTUFBdkIsRUFBK0I7QUFBRTtBQUFqQyxpQkFBSjtBQUNILGVBRkQsTUFHSztBQUNEc2xCLGlCQUFDO0FBQ0o7QUFDSjtBQUNKO0FBQ0o7QUFDSixHQTFLRDs7QUEyS0EsUUFBTS9pQixJQUFJLEdBQUcsQ0FBQzFWLEtBQUQsRUFBUWtULFNBQVIsRUFBbUJDLE1BQW5CLEVBQTJCaW1CLFFBQTNCLEVBQXFDL2xCLGNBQWMsR0FBRyxJQUF0RCxLQUErRDtBQUN4RSxVQUFNO0FBQUVWLFFBQUY7QUFBTXZlLFVBQU47QUFBWTZjLGdCQUFaO0FBQXdCSSxjQUF4QjtBQUFrQ3JCO0FBQWxDLFFBQWdEaFEsS0FBdEQ7O0FBQ0EsUUFBSWdRLFNBQVMsR0FBRztBQUFFO0FBQWxCLE1BQW1DO0FBQy9CMEYsWUFBSSxDQUFDMVYsS0FBSyxDQUFDSSxTQUFOLENBQWdCd1MsT0FBakIsRUFBMEJNLFNBQTFCLEVBQXFDQyxNQUFyQyxFQUE2Q2ltQixRQUE3QyxDQUFKO0FBQ0E7QUFDSDs7QUFDRCxRQUFJcHBCLFNBQVMsR0FBRztBQUFJO0FBQXBCLE1BQW9DO0FBQ2hDaFEsYUFBSyxDQUFDdVUsUUFBTixDQUFlbUIsSUFBZixDQUFvQnhDLFNBQXBCLEVBQStCQyxNQUEvQixFQUF1Q2ltQixRQUF2QztBQUNBO0FBQ0g7O0FBQ0QsUUFBSXBwQixTQUFTLEdBQUc7QUFBRztBQUFuQixNQUFtQztBQUMvQjViLFlBQUksQ0FBQ3NoQixJQUFMLENBQVUxVixLQUFWLEVBQWlCa1QsU0FBakIsRUFBNEJDLE1BQTVCLEVBQW9Dc2hCLFNBQXBDO0FBQ0E7QUFDSDs7QUFDRCxRQUFJcmdDLElBQUksS0FBSzhVLFFBQWIsRUFBdUI7QUFDbkIwcEIsZ0JBQVUsQ0FBQ2pnQixFQUFELEVBQUtPLFNBQUwsRUFBZ0JDLE1BQWhCLENBQVY7O0FBQ0EsV0FBSyxJQUFJeGYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzBkLFFBQVEsQ0FBQzlkLE1BQTdCLEVBQXFDSSxDQUFDLEVBQXRDLEVBQTBDO0FBQ3RDK2hCLFlBQUksQ0FBQ3JFLFFBQVEsQ0FBQzFkLENBQUQsQ0FBVCxFQUFjdWYsU0FBZCxFQUF5QkMsTUFBekIsRUFBaUNpbUIsUUFBakMsQ0FBSjtBQUNIOztBQUNEeEcsZ0JBQVUsQ0FBQzV5QixLQUFLLENBQUNtVCxNQUFQLEVBQWVELFNBQWYsRUFBMEJDLE1BQTFCLENBQVY7QUFDQTtBQUNIOztBQUNELFFBQUkvZSxJQUFJLEtBQUtrVixNQUFiLEVBQXFCO0FBQ2pCdXJCLG9CQUFjLENBQUM3MEIsS0FBRCxFQUFRa1QsU0FBUixFQUFtQkMsTUFBbkIsQ0FBZDtBQUNBO0FBQ0gsS0F6QnVFLENBMEJ4RTs7O0FBQ0EsVUFBTWttQixjQUFjLEdBQUdELFFBQVEsS0FBSztBQUFFO0FBQWYsT0FDbkJwcEIsU0FBUyxHQUFHO0FBQUU7QUFESyxPQUVuQmlCLFVBRko7O0FBR0EsUUFBSW9vQixjQUFKLEVBQW9CO0FBQ2hCLFVBQUlELFFBQVEsS0FBSztBQUFFO0FBQW5CLFFBQWdDO0FBQzVCbm9CLG9CQUFVLENBQUNtTSxXQUFYLENBQXVCekssRUFBdkI7QUFDQWlnQixvQkFBVSxDQUFDamdCLEVBQUQsRUFBS08sU0FBTCxFQUFnQkMsTUFBaEIsQ0FBVjtBQUNBcUcsK0JBQXFCLENBQUMsTUFBTXZJLFVBQVUsQ0FBQ3FNLEtBQVgsQ0FBaUIzSyxFQUFqQixDQUFQLEVBQTZCVSxjQUE3QixDQUFyQjtBQUNILFNBSkQsTUFLSztBQUNELGNBQU07QUFBRXVLLGVBQUY7QUFBU2pCLG9CQUFUO0FBQXFCekc7QUFBckIsWUFBb0NqRixVQUExQzs7QUFDQSxjQUFNNEUsTUFBTSxHQUFHLE1BQU0rYyxVQUFVLENBQUNqZ0IsRUFBRCxFQUFLTyxTQUFMLEVBQWdCQyxNQUFoQixDQUEvQjs7QUFDQSxjQUFNbW1CLFlBQVksR0FBRyxNQUFNO0FBQ3ZCMWIsZUFBSyxDQUFDakwsRUFBRCxFQUFLLE1BQU07QUFDWmtELGtCQUFNO0FBQ05LLHNCQUFVLElBQUlBLFVBQVUsRUFBeEI7QUFDSCxXQUhJLENBQUw7QUFJSCxTQUxEOztBQU1BLFlBQUl5RyxVQUFKLEVBQWdCO0FBQ1pBLG9CQUFVLENBQUNoSyxFQUFELEVBQUtrRCxNQUFMLEVBQWF5akIsWUFBYixDQUFWO0FBQ0gsU0FGRCxNQUdLO0FBQ0RBLHNCQUFZO0FBQ2Y7QUFDSjtBQUNKLEtBdEJELE1BdUJLO0FBQ0QxRyxnQkFBVSxDQUFDamdCLEVBQUQsRUFBS08sU0FBTCxFQUFnQkMsTUFBaEIsQ0FBVjtBQUNIO0FBQ0osR0F4REQ7O0FBeURBLFFBQU0wQixPQUFPLEdBQUcsQ0FBQzdVLEtBQUQsRUFBUW9ULGVBQVIsRUFBeUJDLGNBQXpCLEVBQXlDMkQsUUFBUSxHQUFHLEtBQXBELEVBQTJEL0UsU0FBUyxHQUFHLEtBQXZFLEtBQWlGO0FBQzdGLFVBQU07QUFBRTdkLFVBQUY7QUFBUXdOLFdBQVI7QUFBZW5FLFNBQWY7QUFBb0I0VCxjQUFwQjtBQUE4QkMscUJBQTlCO0FBQStDdEIsZUFBL0M7QUFBMERNLGVBQTFEO0FBQXFFUTtBQUFyRSxRQUE4RTlRLEtBQXBGLENBRDZGLENBRTdGOztBQUNBLFFBQUl2QyxHQUFHLElBQUksSUFBWCxFQUFpQjtBQUNic3lCLFlBQU0sQ0FBQ3R5QixHQUFELEVBQU0sSUFBTixFQUFZNFYsY0FBWixFQUE0QnJULEtBQTVCLEVBQW1DLElBQW5DLENBQU47QUFDSDs7QUFDRCxRQUFJZ1EsU0FBUyxHQUFHO0FBQUk7QUFBcEIsTUFBdUQ7QUFDbkRvRCx1QkFBZSxDQUFDdkUsR0FBaEIsQ0FBb0JnUyxVQUFwQixDQUErQjdnQixLQUEvQjtBQUNBO0FBQ0g7O0FBQ0QsVUFBTXU1QixnQkFBZ0IsR0FBR3ZwQixTQUFTLEdBQUc7QUFBRTtBQUFkLE9BQStCYyxJQUF4RDtBQUNBLFFBQUk0UCxTQUFKOztBQUNBLFFBQUtBLFNBQVMsR0FBRzllLEtBQUssSUFBSUEsS0FBSyxDQUFDNDNCLG9CQUFoQyxFQUF1RDtBQUNuRDVZLHFCQUFlLENBQUNGLFNBQUQsRUFBWXROLGVBQVosRUFBNkJwVCxLQUE3QixDQUFmO0FBQ0g7O0FBQ0QsUUFBSWdRLFNBQVMsR0FBRztBQUFFO0FBQWxCLE1BQW1DO0FBQy9CeXBCLHdCQUFnQixDQUFDejVCLEtBQUssQ0FBQ0ksU0FBUCxFQUFrQmlULGNBQWxCLEVBQWtDMkQsUUFBbEMsQ0FBaEI7QUFDSCxPQUZELE1BR0s7QUFDRCxVQUFJaEgsU0FBUyxHQUFHO0FBQUk7QUFBcEIsUUFBb0M7QUFDaENoUSxlQUFLLENBQUN1VSxRQUFOLENBQWVNLE9BQWYsQ0FBdUJ4QixjQUF2QixFQUF1QzJELFFBQXZDO0FBQ0E7QUFDSDs7QUFDRCxVQUFJdWlCLGdCQUFKLEVBQXNCO0FBQ2xCck4sMkJBQW1CLENBQUNsc0IsS0FBRCxFQUFRLElBQVIsRUFBY29ULGVBQWQsRUFBK0IsZUFBL0IsQ0FBbkI7QUFDSDs7QUFDRCxVQUFJcEQsU0FBUyxHQUFHO0FBQUc7QUFBbkIsUUFBbUM7QUFDL0JoUSxlQUFLLENBQUM1TCxJQUFOLENBQVd5aEIsTUFBWCxDQUFrQjdWLEtBQWxCLEVBQXlCb1QsZUFBekIsRUFBMENDLGNBQTFDLEVBQTBEcEIsU0FBMUQsRUFBcUV3aUIsU0FBckUsRUFBZ0Z6ZCxRQUFoRjtBQUNILFNBRkQsTUFHSyxJQUFJMUYsZUFBZSxNQUNwQjtBQUNDbGQsVUFBSSxLQUFLOFUsUUFBVCxJQUNJb0gsU0FBUyxHQUFHLENBQVosSUFBaUJBLFNBQVMsR0FBRztBQUFHO0FBSGpCLE9BQW5CLEVBRzZEO0FBQzlEO0FBQ0E0a0IsdUJBQWUsQ0FBQzVqQixlQUFELEVBQWtCOEIsZUFBbEIsRUFBbUNDLGNBQW5DLEVBQW1ELEtBQW5ELEVBQTBELElBQTFELENBQWY7QUFDSCxPQU5JLE1BT0EsSUFBS2pmLElBQUksS0FBSzhVLFFBQVQsS0FDTG9ILFNBQVMsR0FBRztBQUFJO0FBQWhCLFNBQ0dBLFNBQVMsR0FBRztBQUFJO0FBRmQsT0FBRCxJQUdKLENBQUMyQixTQUFELElBQWNqQyxTQUFTLEdBQUc7QUFBRztBQUg3QixRQUdvRDtBQUNyRGtsQix1QkFBZSxDQUFDN2pCLFFBQUQsRUFBVytCLGVBQVgsRUFBNEJDLGNBQTVCLENBQWY7QUFDSDs7QUFDRCxVQUFJMkQsUUFBSixFQUFjO0FBQ1ZuQixjQUFNLENBQUM3VixLQUFELENBQU47QUFDSDtBQUNKOztBQUNELFFBQUksQ0FBQzBnQixTQUFTLEdBQUc5ZSxLQUFLLElBQUlBLEtBQUssQ0FBQ21mLGdCQUE1QixLQUFpRHdZLGdCQUFyRCxFQUF1RTtBQUNuRS9mLDJCQUFxQixDQUFDLE1BQU07QUFDeEJrSCxpQkFBUyxJQUFJRSxlQUFlLENBQUNGLFNBQUQsRUFBWXROLGVBQVosRUFBNkJwVCxLQUE3QixDQUE1QjtBQUNBdTVCLHdCQUFnQixJQUNack4sbUJBQW1CLENBQUNsc0IsS0FBRCxFQUFRLElBQVIsRUFBY29ULGVBQWQsRUFBK0IsV0FBL0IsQ0FEdkI7QUFFSCxPQUpvQixFQUlsQkMsY0FKa0IsQ0FBckI7QUFLSDtBQUNKLEdBckREOztBQXNEQSxRQUFNd0MsTUFBTSxHQUFHN1YsS0FBSyxJQUFJO0FBQ3BCLFVBQU07QUFBRTVMLFVBQUY7QUFBUXVlLFFBQVI7QUFBWVEsWUFBWjtBQUFvQmxDO0FBQXBCLFFBQW1DalIsS0FBekM7O0FBQ0EsUUFBSTVMLElBQUksS0FBSzhVLFFBQWIsRUFBdUI7QUFDbkJ3d0Isb0JBQWMsQ0FBQy9tQixFQUFELEVBQUtRLE1BQUwsQ0FBZDtBQUNBO0FBQ0g7O0FBQ0QsUUFBSS9lLElBQUksS0FBS2tWLE1BQWIsRUFBcUI7QUFDakJzckIsc0JBQWdCLENBQUM1MEIsS0FBRCxDQUFoQjtBQUNBO0FBQ0g7O0FBQ0QsVUFBTTI1QixhQUFhLEdBQUcsTUFBTTtBQUN4QjlHLGdCQUFVLENBQUNsZ0IsRUFBRCxDQUFWOztBQUNBLFVBQUkxQixVQUFVLElBQUksQ0FBQ0EsVUFBVSxDQUFDOEosU0FBMUIsSUFBdUM5SixVQUFVLENBQUNpRixVQUF0RCxFQUFrRTtBQUM5RGpGLGtCQUFVLENBQUNpRixVQUFYO0FBQ0g7QUFDSixLQUxEOztBQU1BLFFBQUlsVyxLQUFLLENBQUNnUSxTQUFOLEdBQWtCO0FBQUU7QUFBcEIsT0FDQWlCLFVBREEsSUFFQSxDQUFDQSxVQUFVLENBQUM4SixTQUZoQixFQUUyQjtBQUN2QixZQUFNO0FBQUU2QyxhQUFGO0FBQVNqQjtBQUFULFVBQXdCMUwsVUFBOUI7O0FBQ0EsWUFBTXFvQixZQUFZLEdBQUcsTUFBTTFiLEtBQUssQ0FBQ2pMLEVBQUQsRUFBS2duQixhQUFMLENBQWhDOztBQUNBLFVBQUloZCxVQUFKLEVBQWdCO0FBQ1pBLGtCQUFVLENBQUMzYyxLQUFLLENBQUMyUyxFQUFQLEVBQVdnbkIsYUFBWCxFQUEwQkwsWUFBMUIsQ0FBVjtBQUNILE9BRkQsTUFHSztBQUNEQSxvQkFBWTtBQUNmO0FBQ0osS0FYRCxNQVlLO0FBQ0RLLG1CQUFhO0FBQ2hCO0FBQ0osR0EvQkQ7O0FBZ0NBLFFBQU1ELGNBQWMsR0FBRyxDQUFDMzJCLEdBQUQsRUFBTWlDLEdBQU4sS0FBYztBQUNqQztBQUNBO0FBQ0EsUUFBSTlKLElBQUo7O0FBQ0EsV0FBTzZILEdBQUcsS0FBS2lDLEdBQWYsRUFBb0I7QUFDaEI5SixVQUFJLEdBQUd3NEIsZUFBZSxDQUFDM3dCLEdBQUQsQ0FBdEI7QUFDQTh2QixnQkFBVSxDQUFDOXZCLEdBQUQsQ0FBVjtBQUNBQSxTQUFHLEdBQUc3SCxJQUFOO0FBQ0g7O0FBQ0QyM0IsY0FBVSxDQUFDN3RCLEdBQUQsQ0FBVjtBQUNILEdBVkQ7O0FBV0EsUUFBTXkwQixnQkFBZ0IsR0FBRyxDQUFDdDVCLFFBQUQsRUFBV2tULGNBQVgsRUFBMkIyRCxRQUEzQixLQUF3QztBQUM3RCxRQUFLL2tCLEtBQUQsSUFBMkNrTyxRQUFRLENBQUMvTCxJQUFULENBQWN3VCxPQUE3RCxFQUFzRTtBQUNsRUcsbUJBQWEsQ0FBQzVILFFBQUQsQ0FBYjtBQUNIOztBQUNELFVBQU07QUFBRXk1QixTQUFGO0FBQU96a0MsYUFBUDtBQUFnQm1ULFlBQWhCO0FBQXdCc0ssYUFBeEI7QUFBaUNnQztBQUFqQyxRQUF3Q3pVLFFBQTlDLENBSjZELENBSzdEOztBQUNBLFFBQUl5NUIsR0FBSixFQUFTO0FBQ0xuWixpRUFBYyxDQUFDbVosR0FBRCxDQUFkO0FBQ0g7O0FBQ0QsUUFBSXprQyxPQUFKLEVBQWE7QUFDVCxXQUFLLElBQUl4QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHd0IsT0FBTyxDQUFDNUIsTUFBNUIsRUFBb0NJLENBQUMsRUFBckMsRUFBeUM7QUFDckNmLDZEQUFJLENBQUN1QyxPQUFPLENBQUN4QixDQUFELENBQVIsQ0FBSjtBQUNIO0FBQ0osS0FiNEQsQ0FjN0Q7QUFDQTs7O0FBQ0EsUUFBSTJVLE1BQUosRUFBWTtBQUNSMVYsMkRBQUksQ0FBQzBWLE1BQUQsQ0FBSjtBQUNBdU0sYUFBTyxDQUFDakMsT0FBRCxFQUFVelMsUUFBVixFQUFvQmtULGNBQXBCLEVBQW9DMkQsUUFBcEMsQ0FBUDtBQUNILEtBbkI0RCxDQW9CN0Q7OztBQUNBLFFBQUlwQyxFQUFKLEVBQVE7QUFDSjRFLDJCQUFxQixDQUFDNUUsRUFBRCxFQUFLdkIsY0FBTCxDQUFyQjtBQUNIOztBQUNEbUcseUJBQXFCLENBQUMsTUFBTTtBQUN4QnJaLGNBQVEsQ0FBQzJWLFdBQVQsR0FBdUIsSUFBdkI7QUFDSCxLQUZvQixFQUVsQnpDLGNBRmtCLENBQXJCLENBeEI2RCxDQTJCN0Q7QUFDQTtBQUNBOztBQUNBLFFBQUlBLGNBQWMsSUFDZEEsY0FBYyxDQUFDbUIsYUFEZixJQUVBLENBQUNuQixjQUFjLENBQUN5QyxXQUZoQixJQUdBM1YsUUFBUSxDQUFDdVcsUUFIVCxJQUlBLENBQUN2VyxRQUFRLENBQUMwVyxhQUpWLElBS0ExVyxRQUFRLENBQUN5VyxVQUFULEtBQXdCdkQsY0FBYyxDQUFDK0IsU0FMM0MsRUFLc0Q7QUFDbEQvQixvQkFBYyxDQUFDM2YsSUFBZjs7QUFDQSxVQUFJMmYsY0FBYyxDQUFDM2YsSUFBZixLQUF3QixDQUE1QixFQUErQjtBQUMzQjJmLHNCQUFjLENBQUNoUCxPQUFmO0FBQ0g7QUFDSjs7QUFDRCxRQUFLcFMsSUFBTCxFQUFzRTtBQUNsRTBYLDhCQUF3QixDQUFDeEosUUFBRCxDQUF4QjtBQUNIO0FBQ0osR0E1Q0Q7O0FBNkNBLFFBQU0rMEIsZUFBZSxHQUFHLENBQUM3akIsUUFBRCxFQUFXK0IsZUFBWCxFQUE0QkMsY0FBNUIsRUFBNEMyRCxRQUFRLEdBQUcsS0FBdkQsRUFBOEQvRSxTQUFTLEdBQUcsS0FBMUUsRUFBaUZsTixLQUFLLEdBQUcsQ0FBekYsS0FBK0Y7QUFDbkgsU0FBSyxJQUFJcFIsQ0FBQyxHQUFHb1IsS0FBYixFQUFvQnBSLENBQUMsR0FBRzBkLFFBQVEsQ0FBQzlkLE1BQWpDLEVBQXlDSSxDQUFDLEVBQTFDLEVBQThDO0FBQzFDa2hCLGFBQU8sQ0FBQ3hELFFBQVEsQ0FBQzFkLENBQUQsQ0FBVCxFQUFjeWYsZUFBZCxFQUErQkMsY0FBL0IsRUFBK0MyRCxRQUEvQyxFQUF5RC9FLFNBQXpELENBQVA7QUFDSDtBQUNKLEdBSkQ7O0FBS0EsUUFBTWdpQixlQUFlLEdBQUdqMEIsS0FBSyxJQUFJO0FBQzdCLFFBQUlBLEtBQUssQ0FBQ2dRLFNBQU4sR0FBa0I7QUFBRTtBQUF4QixNQUF5QztBQUNyQyxlQUFPaWtCLGVBQWUsQ0FBQ2owQixLQUFLLENBQUNJLFNBQU4sQ0FBZ0J3UyxPQUFqQixDQUF0QjtBQUNIOztBQUNELFFBQUk1UyxLQUFLLENBQUNnUSxTQUFOLEdBQWtCO0FBQUk7QUFBMUIsTUFBMEM7QUFDdEMsZUFBT2hRLEtBQUssQ0FBQ3VVLFFBQU4sQ0FBZXJaLElBQWYsRUFBUDtBQUNIOztBQUNELFdBQU93NEIsZUFBZSxDQUFFMXpCLEtBQUssQ0FBQ21ULE1BQU4sSUFBZ0JuVCxLQUFLLENBQUMyUyxFQUF4QixDQUF0QjtBQUNILEdBUkQ7O0FBU0EsUUFBTXhLLE1BQU0sR0FBRyxDQUFDbkksS0FBRCxFQUFRa1QsU0FBUixFQUFtQkksS0FBbkIsS0FBNkI7QUFDeEMsUUFBSXRULEtBQUssSUFBSSxJQUFiLEVBQW1CO0FBQ2YsVUFBSWtULFNBQVMsQ0FBQzJtQixNQUFkLEVBQXNCO0FBQ2xCaGxCLGVBQU8sQ0FBQzNCLFNBQVMsQ0FBQzJtQixNQUFYLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLEVBQStCLElBQS9CLENBQVA7QUFDSDtBQUNKLEtBSkQsTUFLSztBQUNEMWxCLFdBQUssQ0FBQ2pCLFNBQVMsQ0FBQzJtQixNQUFWLElBQW9CLElBQXJCLEVBQTJCNzVCLEtBQTNCLEVBQWtDa1QsU0FBbEMsRUFBNkMsSUFBN0MsRUFBbUQsSUFBbkQsRUFBeUQsSUFBekQsRUFBK0RJLEtBQS9ELENBQUw7QUFDSDs7QUFDRC9NLHFCQUFpQjtBQUNqQjJNLGFBQVMsQ0FBQzJtQixNQUFWLEdBQW1CNzVCLEtBQW5CO0FBQ0gsR0FYRDs7QUFZQSxRQUFNeTBCLFNBQVMsR0FBRztBQUNkL3ZCLEtBQUMsRUFBRXlQLEtBRFc7QUFFZFMsTUFBRSxFQUFFQyxPQUZVO0FBR2RZLEtBQUMsRUFBRUMsSUFIVztBQUlkcFksS0FBQyxFQUFFdVksTUFKVztBQUtkMlksTUFBRSxFQUFFQyxjQUxVO0FBTWRxTCxNQUFFLEVBQUU3RSxhQU5VO0FBT2Q4RSxNQUFFLEVBQUVoRSxhQVBVO0FBUWRpRSxPQUFHLEVBQUVuRSxrQkFSUztBQVNkbGdCLEtBQUMsRUFBRXNlLGVBVFc7QUFVZDdmLEtBQUMsRUFBRTdoQjtBQVZXLEdBQWxCO0FBWUEsTUFBSW9oQixPQUFKO0FBQ0EsTUFBSXVELFdBQUo7O0FBQ0EsTUFBSXNiLGtCQUFKLEVBQXdCO0FBQ3BCLEtBQUM3ZSxPQUFELEVBQVV1RCxXQUFWLElBQXlCc2Isa0JBQWtCLENBQUNpQyxTQUFELENBQTNDO0FBQ0g7O0FBQ0QsU0FBTztBQUNIdHNCLFVBREc7QUFFSHdMLFdBRkc7QUFHSGlaLGFBQVMsRUFBRUQsWUFBWSxDQUFDeGtCLE1BQUQsRUFBU3dMLE9BQVQ7QUFIcEIsR0FBUDtBQUtIOztBQUNELFNBQVNpTixlQUFULENBQXlCL1gsSUFBekIsRUFBK0IxSSxRQUEvQixFQUF5Q0gsS0FBekMsRUFBZ0QrUixTQUFTLEdBQUcsSUFBNUQsRUFBa0U7QUFDOUR0UCw0QkFBMEIsQ0FBQ29HLElBQUQsRUFBTzFJLFFBQVAsRUFBaUI7QUFBRTtBQUFuQixJQUFxQyxDQUMzREgsS0FEMkQsRUFFM0QrUixTQUYyRCxDQUFyQyxDQUExQjtBQUlIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUytqQixzQkFBVCxDQUFnQzlpQixFQUFoQyxFQUFvQ0MsRUFBcEMsRUFBd0M1YixPQUFPLEdBQUcsS0FBbEQsRUFBeUQ7QUFDckQsUUFBTTRpQyxHQUFHLEdBQUdqbkIsRUFBRSxDQUFDM0IsUUFBZjtBQUNBLFFBQU02b0IsR0FBRyxHQUFHam5CLEVBQUUsQ0FBQzVCLFFBQWY7O0FBQ0EsTUFBSS9iLG9EQUFPLENBQUMya0MsR0FBRCxDQUFQLElBQWdCM2tDLG9EQUFPLENBQUM0a0MsR0FBRCxDQUEzQixFQUFrQztBQUM5QixTQUFLLElBQUl2bUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3NtQyxHQUFHLENBQUMxbUMsTUFBeEIsRUFBZ0NJLENBQUMsRUFBakMsRUFBcUM7QUFDakM7QUFDQTtBQUNBLFlBQU0yakMsRUFBRSxHQUFHMkMsR0FBRyxDQUFDdG1DLENBQUQsQ0FBZDtBQUNBLFVBQUk2akMsRUFBRSxHQUFHMEMsR0FBRyxDQUFDdm1DLENBQUQsQ0FBWjs7QUFDQSxVQUFJNmpDLEVBQUUsQ0FBQ3huQixTQUFILEdBQWU7QUFBRTtBQUFqQixTQUFrQyxDQUFDd25CLEVBQUUsQ0FBQ2xtQixlQUExQyxFQUEyRDtBQUN2RCxZQUFJa21CLEVBQUUsQ0FBQ2xuQixTQUFILElBQWdCLENBQWhCLElBQXFCa25CLEVBQUUsQ0FBQ2xuQixTQUFILEtBQWlCO0FBQUc7QUFBN0MsVUFBbUU7QUFDL0RrbkIsY0FBRSxHQUFHMEMsR0FBRyxDQUFDdm1DLENBQUQsQ0FBSCxHQUFTMGhDLGNBQWMsQ0FBQzZFLEdBQUcsQ0FBQ3ZtQyxDQUFELENBQUosQ0FBNUI7QUFDQTZqQyxjQUFFLENBQUM3a0IsRUFBSCxHQUFRMmtCLEVBQUUsQ0FBQzNrQixFQUFYO0FBQ0g7O0FBQ0QsWUFBSSxDQUFDdGIsT0FBTCxFQUNJeStCLHNCQUFzQixDQUFDd0IsRUFBRCxFQUFLRSxFQUFMLENBQXRCO0FBQ1AsT0FaZ0MsQ0FhakM7QUFDQTs7O0FBQ0EsVUFBS3ZsQyxLQUFELElBQTJDdWxDLEVBQUUsQ0FBQ3BqQyxJQUFILEtBQVlpVixTQUF2RCxJQUFvRSxDQUFDbXVCLEVBQUUsQ0FBQzdrQixFQUE1RSxFQUFnRjtBQUM1RTZrQixVQUFFLENBQUM3a0IsRUFBSCxHQUFRMmtCLEVBQUUsQ0FBQzNrQixFQUFYO0FBQ0g7QUFDSjtBQUNKO0FBQ0osQyxDQUNEOzs7QUFDQSxTQUFTdW1CLFdBQVQsQ0FBcUJuaUMsR0FBckIsRUFBMEI7QUFDdEIsUUFBTTJOLENBQUMsR0FBRzNOLEdBQUcsQ0FBQ2dMLEtBQUosRUFBVjtBQUNBLFFBQU12SixNQUFNLEdBQUcsQ0FBQyxDQUFELENBQWY7QUFDQSxNQUFJN0UsQ0FBSixFQUFPOGtDLENBQVAsRUFBVXZCLENBQVYsRUFBYTE5QixDQUFiLEVBQWdCc2UsQ0FBaEI7QUFDQSxRQUFNcWlCLEdBQUcsR0FBR3BqQyxHQUFHLENBQUN4RCxNQUFoQjs7QUFDQSxPQUFLSSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUd3bUMsR0FBaEIsRUFBcUJ4bUMsQ0FBQyxFQUF0QixFQUEwQjtBQUN0QixVQUFNeW1DLElBQUksR0FBR3JqQyxHQUFHLENBQUNwRCxDQUFELENBQWhCOztBQUNBLFFBQUl5bUMsSUFBSSxLQUFLLENBQWIsRUFBZ0I7QUFDWjNCLE9BQUMsR0FBR2pnQyxNQUFNLENBQUNBLE1BQU0sQ0FBQ2pGLE1BQVAsR0FBZ0IsQ0FBakIsQ0FBVjs7QUFDQSxVQUFJd0QsR0FBRyxDQUFDMGhDLENBQUQsQ0FBSCxHQUFTMkIsSUFBYixFQUFtQjtBQUNmMTFCLFNBQUMsQ0FBQy9RLENBQUQsQ0FBRCxHQUFPOGtDLENBQVA7QUFDQWpnQyxjQUFNLENBQUNwRixJQUFQLENBQVlPLENBQVo7QUFDQTtBQUNIOztBQUNEdWpDLE9BQUMsR0FBRyxDQUFKO0FBQ0ExOUIsT0FBQyxHQUFHaEIsTUFBTSxDQUFDakYsTUFBUCxHQUFnQixDQUFwQjs7QUFDQSxhQUFPMmpDLENBQUMsR0FBRzE5QixDQUFYLEVBQWM7QUFDVnNlLFNBQUMsR0FBSSxDQUFDb2YsQ0FBQyxHQUFHMTlCLENBQUwsSUFBVSxDQUFYLEdBQWdCLENBQXBCOztBQUNBLFlBQUl6QyxHQUFHLENBQUN5QixNQUFNLENBQUNzZixDQUFELENBQVAsQ0FBSCxHQUFpQnNpQixJQUFyQixFQUEyQjtBQUN2QmxELFdBQUMsR0FBR3BmLENBQUMsR0FBRyxDQUFSO0FBQ0gsU0FGRCxNQUdLO0FBQ0R0ZSxXQUFDLEdBQUdzZSxDQUFKO0FBQ0g7QUFDSjs7QUFDRCxVQUFJc2lCLElBQUksR0FBR3JqQyxHQUFHLENBQUN5QixNQUFNLENBQUMwK0IsQ0FBRCxDQUFQLENBQWQsRUFBMkI7QUFDdkIsWUFBSUEsQ0FBQyxHQUFHLENBQVIsRUFBVztBQUNQeHlCLFdBQUMsQ0FBQy9RLENBQUQsQ0FBRCxHQUFPNkUsTUFBTSxDQUFDMCtCLENBQUMsR0FBRyxDQUFMLENBQWI7QUFDSDs7QUFDRDErQixjQUFNLENBQUMwK0IsQ0FBRCxDQUFOLEdBQVl2akMsQ0FBWjtBQUNIO0FBQ0o7QUFDSjs7QUFDRHVqQyxHQUFDLEdBQUcxK0IsTUFBTSxDQUFDakYsTUFBWDtBQUNBaUcsR0FBQyxHQUFHaEIsTUFBTSxDQUFDMCtCLENBQUMsR0FBRyxDQUFMLENBQVY7O0FBQ0EsU0FBT0EsQ0FBQyxLQUFLLENBQWIsRUFBZ0I7QUFDWjErQixVQUFNLENBQUMwK0IsQ0FBRCxDQUFOLEdBQVkxOUIsQ0FBWjtBQUNBQSxLQUFDLEdBQUdrTCxDQUFDLENBQUNsTCxDQUFELENBQUw7QUFDSDs7QUFDRCxTQUFPaEIsTUFBUDtBQUNIOztBQUVELE1BQU02aEMsVUFBVSxHQUFJam1DLElBQUQsSUFBVUEsSUFBSSxDQUFDa21DLFlBQWxDOztBQUNBLE1BQU1DLGtCQUFrQixHQUFJMzRCLEtBQUQsSUFBV0EsS0FBSyxLQUFLQSxLQUFLLENBQUM0NEIsUUFBTixJQUFrQjU0QixLQUFLLENBQUM0NEIsUUFBTixLQUFtQixFQUExQyxDQUEzQzs7QUFDQSxNQUFNQyxXQUFXLEdBQUl0bUMsTUFBRCxJQUFZLE9BQU91bUMsVUFBUCxLQUFzQixXQUF0QixJQUFxQ3ZtQyxNQUFNLFlBQVl1bUMsVUFBdkY7O0FBQ0EsTUFBTUMsYUFBYSxHQUFHLENBQUMvNEIsS0FBRCxFQUFRZzVCLE1BQVIsS0FBbUI7QUFDckMsUUFBTUMsY0FBYyxHQUFHajVCLEtBQUssSUFBSUEsS0FBSyxDQUFDOGtCLEVBQXRDOztBQUNBLE1BQUl6a0IscURBQVEsQ0FBQzQ0QixjQUFELENBQVosRUFBOEI7QUFDMUIsUUFBSSxDQUFDRCxNQUFMLEVBQWE7QUFDUjNvQyxXQUFELElBQ0k4RyxJQUFJLENBQUUsaUVBQUQsR0FDQSx5Q0FERCxDQURSO0FBR0EsYUFBTyxJQUFQO0FBQ0gsS0FMRCxNQU1LO0FBQ0QsWUFBTTVFLE1BQU0sR0FBR3ltQyxNQUFNLENBQUNDLGNBQUQsQ0FBckI7O0FBQ0EsVUFBSSxDQUFDMW1DLE1BQUwsRUFBYTtBQUNSbEMsYUFBRCxJQUNJOEcsSUFBSSxDQUFFLG1EQUFrRDhoQyxjQUFlLEtBQWxFLEdBQ0EsdUVBREEsR0FFQSxrRUFGQSxHQUdBLDZEQUhELENBRFI7QUFLSDs7QUFDRCxhQUFPMW1DLE1BQVA7QUFDSDtBQUNKLEdBbEJELE1BbUJLO0FBQ0QsUUFBS2xDLEtBQUQsSUFBMkMsQ0FBQzRvQyxjQUE1QyxJQUE4RCxDQUFDTixrQkFBa0IsQ0FBQzM0QixLQUFELENBQXJGLEVBQThGO0FBQzFGN0ksVUFBSSxDQUFFLDRCQUEyQjhoQyxjQUFlLEVBQTVDLENBQUo7QUFDSDs7QUFDRCxXQUFPQSxjQUFQO0FBQ0g7QUFDSixDQTNCRDs7QUE0QkEsTUFBTUMsWUFBWSxHQUFHO0FBQ2pCUixjQUFZLEVBQUUsSUFERzs7QUFFakJyb0MsU0FBTyxDQUFDK2dCLEVBQUQsRUFBS0MsRUFBTCxFQUFTQyxTQUFULEVBQW9CQyxNQUFwQixFQUE0QkMsZUFBNUIsRUFBNkNDLGNBQTdDLEVBQTZEQyxLQUE3RCxFQUFvRUMsWUFBcEUsRUFBa0Z0QixTQUFsRixFQUE2RndpQixTQUE3RixFQUF3RztBQUMzRyxVQUFNO0FBQUVxRixRQUFFLEVBQUU3RSxhQUFOO0FBQXFCOEUsUUFBRSxFQUFFaEUsYUFBekI7QUFBd0NpRSxTQUFHLEVBQUVuRSxrQkFBN0M7QUFBaUV6aEIsT0FBQyxFQUFFO0FBQUV3YSxjQUFGO0FBQVVtTSxxQkFBVjtBQUF5QjdILGtCQUF6QjtBQUFxQ3JFO0FBQXJDO0FBQXBFLFFBQTZINEYsU0FBbkk7QUFDQSxVQUFNK0YsUUFBUSxHQUFHRCxrQkFBa0IsQ0FBQ3RuQixFQUFFLENBQUNyUixLQUFKLENBQW5DO0FBQ0EsUUFBSTtBQUFFb08sZUFBRjtBQUFhcUIsY0FBYjtBQUF1QkM7QUFBdkIsUUFBMkMyQixFQUEvQyxDQUgyRyxDQUkzRztBQUNBOztBQUNBLFFBQUtoaEIsS0FBRCxJQUEyQ2dWLGFBQS9DLEVBQThEO0FBQzFEZ0wsZUFBUyxHQUFHLEtBQVo7QUFDQVgscUJBQWUsR0FBRyxJQUFsQjtBQUNIOztBQUNELFFBQUkwQixFQUFFLElBQUksSUFBVixFQUFnQjtBQUNaO0FBQ0EsWUFBTStELFdBQVcsR0FBSTlELEVBQUUsQ0FBQ04sRUFBSCxHQUFTMWdCLEtBQUQsR0FDdkI0OEIsYUFBYSxDQUFDLGdCQUFELENBRFUsR0FFdkJxRSxDQUZOO0FBR0EsWUFBTThILFVBQVUsR0FBSS9uQixFQUFFLENBQUNFLE1BQUgsR0FBYWxoQixLQUFELEdBQzFCNDhCLGFBQWEsQ0FBQyxjQUFELENBRGEsR0FFMUJxRSxDQUZOO0FBR0F0RSxZQUFNLENBQUM3WCxXQUFELEVBQWM3RCxTQUFkLEVBQXlCQyxNQUF6QixDQUFOO0FBQ0F5YixZQUFNLENBQUNvTSxVQUFELEVBQWE5bkIsU0FBYixFQUF3QkMsTUFBeEIsQ0FBTjtBQUNBLFlBQU1oZixNQUFNLEdBQUk4ZSxFQUFFLENBQUM5ZSxNQUFILEdBQVl3bUMsYUFBYSxDQUFDMW5CLEVBQUUsQ0FBQ3JSLEtBQUosRUFBV201QixhQUFYLENBQXpDO0FBQ0EsWUFBTUUsWUFBWSxHQUFJaG9CLEVBQUUsQ0FBQ2dvQixZQUFILEdBQWtCL0gsVUFBVSxDQUFDLEVBQUQsQ0FBbEQ7O0FBQ0EsVUFBSS8rQixNQUFKLEVBQVk7QUFDUnk2QixjQUFNLENBQUNxTSxZQUFELEVBQWU5bUMsTUFBZixDQUFOLENBRFEsQ0FFUjs7QUFDQW1mLGFBQUssR0FBR0EsS0FBSyxJQUFJbW5CLFdBQVcsQ0FBQ3RtQyxNQUFELENBQTVCO0FBQ0gsT0FKRCxNQUtLLElBQUtsQyxLQUFELElBQTJDLENBQUN1b0MsUUFBaEQsRUFBMEQ7QUFDM0R6aEMsWUFBSSxDQUFDLG1DQUFELEVBQXNDNUUsTUFBdEMsRUFBK0MsSUFBRyxPQUFPQSxNQUFPLEdBQWhFLENBQUo7QUFDSDs7QUFDRCxZQUFNMDVCLEtBQUssR0FBRyxDQUFDM2EsU0FBRCxFQUFZQyxNQUFaLEtBQXVCO0FBQ2pDO0FBQ0E7QUFDQSxZQUFJbkQsU0FBUyxHQUFHO0FBQUc7QUFBbkIsVUFBeUM7QUFDckNpbEIseUJBQWEsQ0FBQzVqQixRQUFELEVBQVc2QixTQUFYLEVBQXNCQyxNQUF0QixFQUE4QkMsZUFBOUIsRUFBK0NDLGNBQS9DLEVBQStEQyxLQUEvRCxFQUFzRUMsWUFBdEUsRUFBb0Z0QixTQUFwRixDQUFiO0FBQ0g7QUFDSixPQU5EOztBQU9BLFVBQUl1b0IsUUFBSixFQUFjO0FBQ1YzTSxhQUFLLENBQUMzYSxTQUFELEVBQVk4bkIsVUFBWixDQUFMO0FBQ0gsT0FGRCxNQUdLLElBQUk3bUMsTUFBSixFQUFZO0FBQ2IwNUIsYUFBSyxDQUFDMTVCLE1BQUQsRUFBUzhtQyxZQUFULENBQUw7QUFDSDtBQUNKLEtBakNELE1Ba0NLO0FBQ0Q7QUFDQWhvQixRQUFFLENBQUNOLEVBQUgsR0FBUUssRUFBRSxDQUFDTCxFQUFYO0FBQ0EsWUFBTXFvQixVQUFVLEdBQUkvbkIsRUFBRSxDQUFDRSxNQUFILEdBQVlILEVBQUUsQ0FBQ0csTUFBbkM7QUFDQSxZQUFNaGYsTUFBTSxHQUFJOGUsRUFBRSxDQUFDOWUsTUFBSCxHQUFZNmUsRUFBRSxDQUFDN2UsTUFBL0I7QUFDQSxZQUFNOG1DLFlBQVksR0FBSWhvQixFQUFFLENBQUNnb0IsWUFBSCxHQUFrQmpvQixFQUFFLENBQUNpb0IsWUFBM0M7QUFDQSxZQUFNQyxXQUFXLEdBQUdYLGtCQUFrQixDQUFDdm5CLEVBQUUsQ0FBQ3BSLEtBQUosQ0FBdEM7QUFDQSxZQUFNdTVCLGdCQUFnQixHQUFHRCxXQUFXLEdBQUdob0IsU0FBSCxHQUFlL2UsTUFBbkQ7QUFDQSxZQUFNaW5DLGFBQWEsR0FBR0YsV0FBVyxHQUFHRixVQUFILEdBQWdCQyxZQUFqRDtBQUNBM25CLFdBQUssR0FBR0EsS0FBSyxJQUFJbW5CLFdBQVcsQ0FBQ3RtQyxNQUFELENBQTVCOztBQUNBLFVBQUltZCxlQUFKLEVBQXFCO0FBQ2pCO0FBQ0F1a0IsMEJBQWtCLENBQUM3aUIsRUFBRSxDQUFDMUIsZUFBSixFQUFxQkEsZUFBckIsRUFBc0M2cEIsZ0JBQXRDLEVBQXdEL25CLGVBQXhELEVBQXlFQyxjQUF6RSxFQUF5RkMsS0FBekYsRUFBZ0dDLFlBQWhHLENBQWxCLENBRmlCLENBR2pCO0FBQ0E7QUFDQTs7QUFDQXVpQiw4QkFBc0IsQ0FBQzlpQixFQUFELEVBQUtDLEVBQUwsRUFBUyxJQUFULENBQXRCO0FBQ0gsT0FQRCxNQVFLLElBQUksQ0FBQ2hCLFNBQUwsRUFBZ0I7QUFDakI4akIscUJBQWEsQ0FBQy9pQixFQUFELEVBQUtDLEVBQUwsRUFBU2tvQixnQkFBVCxFQUEyQkMsYUFBM0IsRUFBMENob0IsZUFBMUMsRUFBMkRDLGNBQTNELEVBQTJFQyxLQUEzRSxFQUFrRkMsWUFBbEYsRUFBZ0csS0FBaEcsQ0FBYjtBQUNIOztBQUNELFVBQUlpbkIsUUFBSixFQUFjO0FBQ1YsWUFBSSxDQUFDVSxXQUFMLEVBQWtCO0FBQ2Q7QUFDQTtBQUNBRyxzQkFBWSxDQUFDcG9CLEVBQUQsRUFBS0MsU0FBTCxFQUFnQjhuQixVQUFoQixFQUE0QnZHLFNBQTVCLEVBQXVDO0FBQUU7QUFBekMsV0FBWjtBQUNIO0FBQ0osT0FORCxNQU9LO0FBQ0Q7QUFDQSxZQUFJLENBQUN4aEIsRUFBRSxDQUFDclIsS0FBSCxJQUFZcVIsRUFBRSxDQUFDclIsS0FBSCxDQUFTOGtCLEVBQXRCLE9BQStCMVQsRUFBRSxDQUFDcFIsS0FBSCxJQUFZb1IsRUFBRSxDQUFDcFIsS0FBSCxDQUFTOGtCLEVBQXBELENBQUosRUFBNkQ7QUFDekQsZ0JBQU00VSxVQUFVLEdBQUlyb0IsRUFBRSxDQUFDOWUsTUFBSCxHQUFZd21DLGFBQWEsQ0FBQzFuQixFQUFFLENBQUNyUixLQUFKLEVBQVdtNUIsYUFBWCxDQUE3Qzs7QUFDQSxjQUFJTyxVQUFKLEVBQWdCO0FBQ1pELHdCQUFZLENBQUNwb0IsRUFBRCxFQUFLcW9CLFVBQUwsRUFBaUIsSUFBakIsRUFBdUI3RyxTQUF2QixFQUFrQztBQUFFO0FBQXBDLGFBQVo7QUFDSCxXQUZELE1BR0ssSUFBS3hpQyxJQUFMLEVBQTZDO0FBQzlDOEcsZ0JBQUksQ0FBQyxvQ0FBRCxFQUF1QzVFLE1BQXZDLEVBQWdELElBQUcsT0FBT0EsTUFBTyxHQUFqRSxDQUFKO0FBQ0g7QUFDSixTQVJELE1BU0ssSUFBSSttQyxXQUFKLEVBQWlCO0FBQ2xCO0FBQ0E7QUFDQUcsc0JBQVksQ0FBQ3BvQixFQUFELEVBQUs5ZSxNQUFMLEVBQWE4bUMsWUFBYixFQUEyQnhHLFNBQTNCLEVBQXNDO0FBQUU7QUFBeEMsV0FBWjtBQUNIO0FBQ0o7QUFDSjtBQUNKLEdBNUZnQjs7QUE2RmpCNWUsUUFBTSxDQUFDN1YsS0FBRCxFQUFRb1QsZUFBUixFQUF5QkMsY0FBekIsRUFBeUNwQixTQUF6QyxFQUFvRDtBQUFFMkMsTUFBRSxFQUFFQyxPQUFOO0FBQWVULEtBQUMsRUFBRTtBQUFFeUIsWUFBTSxFQUFFZ2Q7QUFBVjtBQUFsQixHQUFwRCxFQUFnRzdiLFFBQWhHLEVBQTBHO0FBQzVHLFVBQU07QUFBRWhILGVBQUY7QUFBYXFCLGNBQWI7QUFBdUI4QixZQUF2QjtBQUErQjhuQixrQkFBL0I7QUFBNkM5bUMsWUFBN0M7QUFBcUR5TjtBQUFyRCxRQUErRDVCLEtBQXJFOztBQUNBLFFBQUk3TCxNQUFKLEVBQVk7QUFDUjArQixnQkFBVSxDQUFDb0ksWUFBRCxDQUFWO0FBQ0gsS0FKMkcsQ0FLNUc7OztBQUNBLFFBQUlqa0IsUUFBUSxJQUFJLENBQUN1akIsa0JBQWtCLENBQUMzNEIsS0FBRCxDQUFuQyxFQUE0QztBQUN4Q2l4QixnQkFBVSxDQUFDMWYsTUFBRCxDQUFWOztBQUNBLFVBQUluRCxTQUFTLEdBQUc7QUFBRztBQUFuQixRQUF5QztBQUNyQyxlQUFLLElBQUlyYyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHMGQsUUFBUSxDQUFDOWQsTUFBN0IsRUFBcUNJLENBQUMsRUFBdEMsRUFBMEM7QUFDdEMsa0JBQU1pZSxLQUFLLEdBQUdQLFFBQVEsQ0FBQzFkLENBQUQsQ0FBdEI7QUFDQWtoQixtQkFBTyxDQUFDakQsS0FBRCxFQUFRd0IsZUFBUixFQUF5QkMsY0FBekIsRUFBeUMsSUFBekMsRUFBK0MsQ0FBQyxDQUFDekIsS0FBSyxDQUFDTixlQUF2RCxDQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0osR0E1R2dCOztBQTZHakJvRSxNQUFJLEVBQUUybEIsWUE3R1c7QUE4R2pCMW5CLFNBQU8sRUFBRTRuQjtBQTlHUSxDQUFyQjs7QUFnSEEsU0FBU0YsWUFBVCxDQUFzQnI3QixLQUF0QixFQUE2QmtULFNBQTdCLEVBQXdDK2tCLFlBQXhDLEVBQXNEO0FBQUU3akIsR0FBQyxFQUFFO0FBQUV3YTtBQUFGLEdBQUw7QUFBaUJuWixHQUFDLEVBQUVDO0FBQXBCLENBQXRELEVBQWtGMGpCLFFBQVEsR0FBRztBQUFFO0FBQS9GLEVBQThHO0FBQzFHO0FBQ0EsTUFBSUEsUUFBUSxLQUFLO0FBQUU7QUFBbkIsSUFBd0M7QUFDcEN4SyxZQUFNLENBQUM1dUIsS0FBSyxDQUFDaTdCLFlBQVAsRUFBcUIvbkIsU0FBckIsRUFBZ0Mra0IsWUFBaEMsQ0FBTjtBQUNIOztBQUNELFFBQU07QUFBRXRsQixNQUFGO0FBQU1RLFVBQU47QUFBY25ELGFBQWQ7QUFBeUJxQixZQUF6QjtBQUFtQ3pQO0FBQW5DLE1BQTZDNUIsS0FBbkQ7QUFDQSxRQUFNdzdCLFNBQVMsR0FBR3BDLFFBQVEsS0FBSztBQUFFO0FBQWpDLEdBTjBHLENBTzFHOztBQUNBLE1BQUlvQyxTQUFKLEVBQWU7QUFDWDVNLFVBQU0sQ0FBQ2pjLEVBQUQsRUFBS08sU0FBTCxFQUFnQitrQixZQUFoQixDQUFOO0FBQ0gsR0FWeUcsQ0FXMUc7QUFDQTtBQUNBOzs7QUFDQSxNQUFJLENBQUN1RCxTQUFELElBQWNqQixrQkFBa0IsQ0FBQzM0QixLQUFELENBQXBDLEVBQTZDO0FBQ3pDO0FBQ0EsUUFBSW9PLFNBQVMsR0FBRztBQUFHO0FBQW5CLE1BQXlDO0FBQ3JDLGFBQUssSUFBSXJjLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcwZCxRQUFRLENBQUM5ZCxNQUE3QixFQUFxQ0ksQ0FBQyxFQUF0QyxFQUEwQztBQUN0QytoQixjQUFJLENBQUNyRSxRQUFRLENBQUMxZCxDQUFELENBQVQsRUFBY3VmLFNBQWQsRUFBeUIra0IsWUFBekIsRUFBdUM7QUFBRTtBQUF6QyxXQUFKO0FBQ0g7QUFDSjtBQUNKLEdBckJ5RyxDQXNCMUc7OztBQUNBLE1BQUl1RCxTQUFKLEVBQWU7QUFDWDVNLFVBQU0sQ0FBQ3piLE1BQUQsRUFBU0QsU0FBVCxFQUFvQitrQixZQUFwQixDQUFOO0FBQ0g7QUFDSjs7QUFDRCxTQUFTc0QsZUFBVCxDQUF5QnRrQixJQUF6QixFQUErQmpYLEtBQS9CLEVBQXNDb1QsZUFBdEMsRUFBdURDLGNBQXZELEVBQXVFRSxZQUF2RSxFQUFxRnRCLFNBQXJGLEVBQWdHO0FBQUVtQyxHQUFDLEVBQUU7QUFBRXVhLGVBQUY7QUFBZS9ZLGNBQWY7QUFBMkJtbEI7QUFBM0I7QUFBTCxDQUFoRyxFQUFtSmpMLGVBQW5KLEVBQW9LO0FBQ2hLLFFBQU0zN0IsTUFBTSxHQUFJNkwsS0FBSyxDQUFDN0wsTUFBTixHQUFld21DLGFBQWEsQ0FBQzM2QixLQUFLLENBQUM0QixLQUFQLEVBQWNtNUIsYUFBZCxDQUE1Qzs7QUFDQSxNQUFJNW1DLE1BQUosRUFBWTtBQUNSO0FBQ0E7QUFDQSxVQUFNc25DLFVBQVUsR0FBR3RuQyxNQUFNLENBQUN1bkMsSUFBUCxJQUFldm5DLE1BQU0sQ0FBQzQ2QixVQUF6Qzs7QUFDQSxRQUFJL3VCLEtBQUssQ0FBQ2dRLFNBQU4sR0FBa0I7QUFBRztBQUF6QixNQUErQztBQUMzQyxZQUFJdXFCLGtCQUFrQixDQUFDdjZCLEtBQUssQ0FBQzRCLEtBQVAsQ0FBdEIsRUFBcUM7QUFDakM1QixlQUFLLENBQUNtVCxNQUFOLEdBQWUyYyxlQUFlLENBQUNuQixXQUFXLENBQUMxWCxJQUFELENBQVosRUFBb0JqWCxLQUFwQixFQUEyQjRWLFVBQVUsQ0FBQ3FCLElBQUQsQ0FBckMsRUFBNkM3RCxlQUE3QyxFQUE4REMsY0FBOUQsRUFBOEVFLFlBQTlFLEVBQTRGdEIsU0FBNUYsQ0FBOUI7QUFDQWpTLGVBQUssQ0FBQ2k3QixZQUFOLEdBQXFCUSxVQUFyQjtBQUNILFNBSEQsTUFJSztBQUNEejdCLGVBQUssQ0FBQ21ULE1BQU4sR0FBZXdiLFdBQVcsQ0FBQzFYLElBQUQsQ0FBMUI7QUFDQWpYLGVBQUssQ0FBQ2k3QixZQUFOLEdBQXFCbkwsZUFBZSxDQUFDMkwsVUFBRCxFQUFhejdCLEtBQWIsRUFBb0I3TCxNQUFwQixFQUE0QmlmLGVBQTVCLEVBQTZDQyxjQUE3QyxFQUE2REUsWUFBN0QsRUFBMkV0QixTQUEzRSxDQUFwQztBQUNIOztBQUNEOWQsY0FBTSxDQUFDdW5DLElBQVAsR0FDSTE3QixLQUFLLENBQUNpN0IsWUFBTixJQUFzQnRNLFdBQVcsQ0FBQzN1QixLQUFLLENBQUNpN0IsWUFBUCxDQURyQztBQUVIO0FBQ0o7O0FBQ0QsU0FBT2o3QixLQUFLLENBQUNtVCxNQUFOLElBQWdCd2IsV0FBVyxDQUFDM3VCLEtBQUssQ0FBQ21ULE1BQVAsQ0FBbEM7QUFDSCxDLENBQ0Q7OztBQUNBLE1BQU13b0IsUUFBUSxHQUFHYixZQUFqQjtBQUVBLE1BQU1jLFVBQVUsR0FBRyxZQUFuQjtBQUNBLE1BQU1DLFVBQVUsR0FBRyxZQUFuQjtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTQyxnQkFBVCxDQUEwQno1QixJQUExQixFQUFnQzA1QixrQkFBaEMsRUFBb0Q7QUFDaEQsU0FBT0MsWUFBWSxDQUFDSixVQUFELEVBQWF2NUIsSUFBYixFQUFtQixJQUFuQixFQUF5QjA1QixrQkFBekIsQ0FBWixJQUE0RDE1QixJQUFuRTtBQUNIOztBQUNELE1BQU00NUIsc0JBQXNCLEdBQUdqcUMsTUFBTSxFQUFyQztBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTa3FDLHVCQUFULENBQWlDOTdCLFNBQWpDLEVBQTRDO0FBQ3hDLE1BQUk2QixxREFBUSxDQUFDN0IsU0FBRCxDQUFaLEVBQXlCO0FBQ3JCLFdBQU80N0IsWUFBWSxDQUFDSixVQUFELEVBQWF4N0IsU0FBYixFQUF3QixLQUF4QixDQUFaLElBQThDQSxTQUFyRDtBQUNILEdBRkQsTUFHSztBQUNEO0FBQ0EsV0FBUUEsU0FBUyxJQUFJNjdCLHNCQUFyQjtBQUNIO0FBQ0o7QUFDRDtBQUNBO0FBQ0E7OztBQUNBLFNBQVNFLGdCQUFULENBQTBCOTVCLElBQTFCLEVBQWdDO0FBQzVCLFNBQU8yNUIsWUFBWSxDQUFDSCxVQUFELEVBQWF4NUIsSUFBYixDQUFuQjtBQUNILEMsQ0FDRDs7O0FBQ0EsU0FBUzI1QixZQUFULENBQXNCNW5DLElBQXRCLEVBQTRCaU8sSUFBNUIsRUFBa0MrNUIsV0FBVyxHQUFHLElBQWhELEVBQXNETCxrQkFBa0IsR0FBRyxLQUEzRSxFQUFrRjtBQUM5RSxRQUFNNTdCLFFBQVEsR0FBR2dPLHdCQUF3QixJQUFJK0osZUFBN0M7O0FBQ0EsTUFBSS9YLFFBQUosRUFBYztBQUNWLFVBQU1xUCxTQUFTLEdBQUdyUCxRQUFRLENBQUMvTCxJQUEzQixDQURVLENBRVY7O0FBQ0EsUUFBSUEsSUFBSSxLQUFLd25DLFVBQWIsRUFBeUI7QUFDckIsWUFBTVMsUUFBUSxHQUFHcjFCLGdCQUFnQixDQUFDd0ksU0FBRCxDQUFqQzs7QUFDQSxVQUFJNnNCLFFBQVEsS0FDUEEsUUFBUSxLQUFLaDZCLElBQWIsSUFDR2c2QixRQUFRLEtBQUtydkIscURBQVEsQ0FBQzNLLElBQUQsQ0FEeEIsSUFFR2c2QixRQUFRLEtBQUtoaEMsdURBQVUsQ0FBQzJSLHFEQUFRLENBQUMzSyxJQUFELENBQVQsQ0FIbkIsQ0FBWixFQUdrRDtBQUM5QyxlQUFPbU4sU0FBUDtBQUNIO0FBQ0o7O0FBQ0QsVUFBTXRZLEdBQUcsR0FDVDtBQUNBO0FBQ0FtTixXQUFPLENBQUNsRSxRQUFRLENBQUMvTCxJQUFELENBQVIsSUFBa0JvYixTQUFTLENBQUNwYixJQUFELENBQTVCLEVBQW9DaU8sSUFBcEMsQ0FBUCxJQUNJO0FBQ0FnQyxXQUFPLENBQUNsRSxRQUFRLENBQUNHLFVBQVQsQ0FBb0JsTSxJQUFwQixDQUFELEVBQTRCaU8sSUFBNUIsQ0FMWDs7QUFNQSxRQUFJLENBQUNuTCxHQUFELElBQVE2a0Msa0JBQVosRUFBZ0M7QUFDNUI7QUFDQSxhQUFPdnNCLFNBQVA7QUFDSDs7QUFDRCxRQUFLdmQsS0FBRCxJQUEyQ21xQyxXQUEzQyxJQUEwRCxDQUFDbGxDLEdBQS9ELEVBQW9FO0FBQ2hFNkIsVUFBSSxDQUFFLHFCQUFvQjNFLElBQUksQ0FBQzJOLEtBQUwsQ0FBVyxDQUFYLEVBQWMsQ0FBQyxDQUFmLENBQWtCLEtBQUlNLElBQUssRUFBakQsQ0FBSjtBQUNIOztBQUNELFdBQU9uTCxHQUFQO0FBQ0gsR0ExQkQsTUEyQkssSUFBS2pGLElBQUwsRUFBNkM7QUFDOUM4RyxRQUFJLENBQUUsVUFBU3NDLHVEQUFVLENBQUNqSCxJQUFJLENBQUMyTixLQUFMLENBQVcsQ0FBWCxFQUFjLENBQUMsQ0FBZixDQUFELENBQW9CLEdBQXhDLEdBQ0EsMENBREQsQ0FBSjtBQUVIO0FBQ0o7O0FBQ0QsU0FBU3NDLE9BQVQsQ0FBaUJpNEIsUUFBakIsRUFBMkJqNkIsSUFBM0IsRUFBaUM7QUFDN0IsU0FBUWk2QixRQUFRLEtBQ1hBLFFBQVEsQ0FBQ2o2QixJQUFELENBQVIsSUFDR2k2QixRQUFRLENBQUN0dkIscURBQVEsQ0FBQzNLLElBQUQsQ0FBVCxDQURYLElBRUdpNkIsUUFBUSxDQUFDamhDLHVEQUFVLENBQUMyUixxREFBUSxDQUFDM0ssSUFBRCxDQUFULENBQVgsQ0FIQSxDQUFoQjtBQUlIOztBQUVELE1BQU02RyxRQUFRLEdBQUdsWCxNQUFNLENBQUVDLEtBQUQsR0FBMEMsVUFBMUMsR0FBdURnQyxDQUF4RCxDQUF2QjtBQUNBLE1BQU1rVixJQUFJLEdBQUduWCxNQUFNLENBQUVDLEtBQUQsR0FBMEMsTUFBMUMsR0FBbURnQyxDQUFwRCxDQUFuQjtBQUNBLE1BQU1vVixTQUFTLEdBQUdyWCxNQUFNLENBQUVDLEtBQUQsR0FBMEMsU0FBMUMsR0FBc0RnQyxDQUF2RCxDQUF4QjtBQUNBLE1BQU1xVixNQUFNLEdBQUd0WCxNQUFNLENBQUVDLEtBQUQsR0FBMEMsUUFBMUMsR0FBcURnQyxDQUF0RCxDQUFyQixDLENBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNaWQsVUFBVSxHQUFHLEVBQW5CO0FBQ0EsSUFBSXlHLFlBQVksR0FBRyxJQUFuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFNBQVNELFNBQVQsQ0FBbUI2a0IsZUFBZSxHQUFHLEtBQXJDLEVBQTRDO0FBQ3hDcnJCLFlBQVUsQ0FBQzlkLElBQVgsQ0FBaUJ1a0IsWUFBWSxHQUFHNGtCLGVBQWUsR0FBRyxJQUFILEdBQVUsRUFBekQ7QUFDSDs7QUFDRCxTQUFTM2tCLFVBQVQsR0FBc0I7QUFDbEIxRyxZQUFVLENBQUM3ZCxHQUFYO0FBQ0Fza0IsY0FBWSxHQUFHekcsVUFBVSxDQUFDQSxVQUFVLENBQUMzZCxNQUFYLEdBQW9CLENBQXJCLENBQVYsSUFBcUMsSUFBcEQ7QUFDSCxDLENBQ0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLElBQUlpcEMsa0JBQWtCLEdBQUcsQ0FBekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTdHRCLGdCQUFULENBQTBCbFgsS0FBMUIsRUFBaUM7QUFDN0J3a0Msb0JBQWtCLElBQUl4a0MsS0FBdEI7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTeWtDLFdBQVQsQ0FBcUJyb0MsSUFBckIsRUFBMkJ3TixLQUEzQixFQUFrQ3lQLFFBQWxDLEVBQTRDZixTQUE1QyxFQUF1RGlDLFlBQXZELEVBQXFFO0FBQ2pFLFFBQU12UyxLQUFLLEdBQUdtUixXQUFXLENBQUMvYyxJQUFELEVBQU93TixLQUFQLEVBQWN5UCxRQUFkLEVBQXdCZixTQUF4QixFQUFtQ2lDLFlBQW5DLEVBQWlEO0FBQUs7QUFBdEQsR0FBekIsQ0FEaUUsQ0FFakU7O0FBQ0F2UyxPQUFLLENBQUNzUixlQUFOLEdBQ0lrckIsa0JBQWtCLEdBQUcsQ0FBckIsR0FBeUI3a0IsWUFBWSxJQUFJbVIsa0RBQXpDLEdBQXFELElBRHpELENBSGlFLENBS2pFOztBQUNBbFIsWUFBVSxHQU51RCxDQU9qRTtBQUNBOztBQUNBLE1BQUk0a0Isa0JBQWtCLEdBQUcsQ0FBckIsSUFBMEI3a0IsWUFBOUIsRUFBNEM7QUFDeENBLGdCQUFZLENBQUN2a0IsSUFBYixDQUFrQjRNLEtBQWxCO0FBQ0g7O0FBQ0QsU0FBT0EsS0FBUDtBQUNIOztBQUNELFNBQVM2UixPQUFULENBQWlCN1osS0FBakIsRUFBd0I7QUFDcEIsU0FBT0EsS0FBSyxHQUFHQSxLQUFLLENBQUMwa0MsV0FBTixLQUFzQixJQUF6QixHQUFnQyxLQUE1QztBQUNIOztBQUNELFNBQVN2bkIsZUFBVCxDQUF5Qm5DLEVBQXpCLEVBQTZCQyxFQUE3QixFQUFpQztBQUM3QixNQUFLaGhCLEtBQUQsSUFDQWdoQixFQUFFLENBQUNqRCxTQUFILEdBQWU7QUFBRTtBQURqQixLQUVBOUksa0JBQWtCLENBQUN0UyxHQUFuQixDQUF1QnFlLEVBQUUsQ0FBQzdlLElBQTFCLENBRkosRUFFcUM7QUFDakM7QUFDQSxXQUFPLEtBQVA7QUFDSDs7QUFDRCxTQUFPNGUsRUFBRSxDQUFDNWUsSUFBSCxLQUFZNmUsRUFBRSxDQUFDN2UsSUFBZixJQUF1QjRlLEVBQUUsQ0FBQzNlLEdBQUgsS0FBVzRlLEVBQUUsQ0FBQzVlLEdBQTVDO0FBQ0g7O0FBQ0QsSUFBSXNvQyxvQkFBSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTQyxrQkFBVCxDQUE0QkMsV0FBNUIsRUFBeUM7QUFDckNGLHNCQUFvQixHQUFHRSxXQUF2QjtBQUNIOztBQUNELE1BQU1DLDRCQUE0QixHQUFHLENBQUMsR0FBR2htQyxJQUFKLEtBQWE7QUFDOUMsU0FBT2ltQyxZQUFZLENBQUMsSUFBSUosb0JBQW9CLEdBQ3RDQSxvQkFBb0IsQ0FBQzdsQyxJQUFELEVBQU9xWCx3QkFBUCxDQURrQixHQUV0Q3JYLElBRmMsQ0FBRCxDQUFuQjtBQUdILENBSkQ7O0FBS0EsTUFBTTB3QixpQkFBaUIsR0FBSSxhQUEzQjs7QUFDQSxNQUFNd1YsWUFBWSxHQUFHLENBQUM7QUFBRTNvQztBQUFGLENBQUQsS0FBYUEsR0FBRyxJQUFJLElBQVAsR0FBY0EsR0FBZCxHQUFvQixJQUF0RDs7QUFDQSxNQUFNNG9DLFlBQVksR0FBRyxDQUFDO0FBQUV4L0I7QUFBRixDQUFELEtBQWE7QUFDOUIsU0FBUUEsR0FBRyxJQUFJLElBQVAsR0FDRndFLHFEQUFRLENBQUN4RSxHQUFELENBQVIsSUFBaUIzRixzREFBSyxDQUFDMkYsR0FBRCxDQUF0QixJQUErQjJFLHVEQUFZLENBQUMzRSxHQUFELENBQTNDLEdBQ0k7QUFBRTlKLEtBQUMsRUFBRXdhLHdCQUFMO0FBQStCN1EsS0FBQyxFQUFFRztBQUFsQyxHQURKLEdBRUlBLEdBSEYsR0FJRixJQUpOO0FBS0gsQ0FORDs7QUFPQSxNQUFNMFQsV0FBVyxHQUFLbGYsS0FBRCxHQUNmNnFDLDRCQURlLEdBRWZDLENBRk47O0FBR0EsU0FBU0EsWUFBVCxDQUFzQjNvQyxJQUF0QixFQUE0QndOLEtBQUssR0FBRyxJQUFwQyxFQUEwQ3lQLFFBQVEsR0FBRyxJQUFyRCxFQUEyRGYsU0FBUyxHQUFHLENBQXZFLEVBQTBFaUMsWUFBWSxHQUFHLElBQXpGLEVBQStGMnFCLFdBQVcsR0FBRyxLQUE3RyxFQUFvSDtBQUNoSCxNQUFJLENBQUM5b0MsSUFBRCxJQUFTQSxJQUFJLEtBQUs2bkMsc0JBQXRCLEVBQThDO0FBQzFDLFFBQUtocUMsS0FBRCxJQUEyQyxDQUFDbUMsSUFBaEQsRUFBc0Q7QUFDbEQyRSxVQUFJLENBQUUsMkNBQTBDM0UsSUFBSyxHQUFqRCxDQUFKO0FBQ0g7O0FBQ0RBLFFBQUksR0FBR2lWLFNBQVA7QUFDSDs7QUFDRCxNQUFJd0ksT0FBTyxDQUFDemQsSUFBRCxDQUFYLEVBQW1CO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsVUFBTStvQyxNQUFNLEdBQUd6c0IsVUFBVSxDQUFDdGMsSUFBRCxFQUFPd04sS0FBUCxFQUFjO0FBQUs7QUFBbkIsS0FBekI7O0FBQ0EsUUFBSXlQLFFBQUosRUFBYztBQUNWK3JCLHVCQUFpQixDQUFDRCxNQUFELEVBQVM5ckIsUUFBVCxDQUFqQjtBQUNIOztBQUNELFdBQU84ckIsTUFBUDtBQUNILEdBaEIrRyxDQWlCaEg7OztBQUNBLE1BQUluMUIsZ0JBQWdCLENBQUM1VCxJQUFELENBQXBCLEVBQTRCO0FBQ3hCQSxRQUFJLEdBQUdBLElBQUksQ0FBQzZULFNBQVo7QUFDSCxHQXBCK0csQ0FxQmhIOzs7QUFDQSxNQUFJckcsS0FBSixFQUFXO0FBQ1A7QUFDQSxRQUFJM0Usd0RBQU8sQ0FBQzJFLEtBQUQsQ0FBUCxJQUFrQjRsQixpQkFBaUIsSUFBSTVsQixLQUEzQyxFQUFrRDtBQUM5Q0EsV0FBSyxHQUFHMUksbURBQU0sQ0FBQyxFQUFELEVBQUswSSxLQUFMLENBQWQ7QUFDSDs7QUFDRCxRQUFJO0FBQUU4ekIsV0FBSyxFQUFFMkgsS0FBVDtBQUFnQjFIO0FBQWhCLFFBQTBCL3pCLEtBQTlCOztBQUNBLFFBQUl5N0IsS0FBSyxJQUFJLENBQUNwN0IscURBQVEsQ0FBQ283QixLQUFELENBQXRCLEVBQStCO0FBQzNCejdCLFdBQUssQ0FBQzh6QixLQUFOLEdBQWM0SCwyREFBYyxDQUFDRCxLQUFELENBQTVCO0FBQ0g7O0FBQ0QsUUFBSXBqQixxREFBVSxDQUFDMGIsS0FBRCxDQUFkLEVBQXVCO0FBQ25CO0FBQ0E7QUFDQSxVQUFJMTRCLHdEQUFPLENBQUMwNEIsS0FBRCxDQUFQLElBQWtCLENBQUNyZ0Msb0RBQU8sQ0FBQ3FnQyxLQUFELENBQTlCLEVBQXVDO0FBQ25DQSxhQUFLLEdBQUd6OEIsbURBQU0sQ0FBQyxFQUFELEVBQUt5OEIsS0FBTCxDQUFkO0FBQ0g7O0FBQ0QvekIsV0FBSyxDQUFDK3pCLEtBQU4sR0FBYzRILDJEQUFjLENBQUM1SCxLQUFELENBQTVCO0FBQ0g7QUFDSixHQXZDK0csQ0F3Q2hIOzs7QUFDQSxRQUFNM2xCLFNBQVMsR0FBRy9OLHFEQUFRLENBQUM3TixJQUFELENBQVIsR0FDWjtBQUFFO0FBRFUsSUFFWnllLFVBQVUsQ0FBQ3plLElBQUQsQ0FBVixHQUNJO0FBQUk7QUFEUixJQUVJaW1DLFVBQVUsQ0FBQ2ptQyxJQUFELENBQVYsR0FDSTtBQUFHO0FBRFAsSUFFSTZsQixxREFBVSxDQUFDN2xCLElBQUQsQ0FBVixHQUNJO0FBQUU7QUFETixJQUVJZ08sdURBQVksQ0FBQ2hPLElBQUQsQ0FBWixHQUNJO0FBQUU7QUFETixJQUVJLENBVnRCOztBQVdBLE1BQUtuQyxLQUFELElBQTJDK2QsU0FBUyxHQUFHO0FBQUU7QUFBekQsS0FBcUYvUyx3REFBTyxDQUFDN0ksSUFBRCxDQUFoRyxFQUF3RztBQUNwR0EsUUFBSSxHQUFHNEMsc0RBQUssQ0FBQzVDLElBQUQsQ0FBWjtBQUNBMkUsUUFBSSxDQUFFLHNFQUFELEdBQ0EscUVBREEsR0FFQSxpRUFGQSxHQUdBLHFCQUhELEVBR3dCLHNDQUh4QixFQUcrRDNFLElBSC9ELENBQUo7QUFJSDs7QUFDRCxRQUFNNEwsS0FBSyxHQUFHO0FBQ1YwOEIsZUFBVyxFQUFFLElBREg7QUFFVmMsWUFBUSxFQUFFLElBRkE7QUFHVnBwQyxRQUhVO0FBSVZ3TixTQUpVO0FBS1Z2TixPQUFHLEVBQUV1TixLQUFLLElBQUlvN0IsWUFBWSxDQUFDcDdCLEtBQUQsQ0FMaEI7QUFNVm5FLE9BQUcsRUFBRW1FLEtBQUssSUFBSXE3QixZQUFZLENBQUNyN0IsS0FBRCxDQU5oQjtBQU9WdXpCLFdBQU8sRUFBRS9tQixjQVBDO0FBUVZtRixnQkFBWSxFQUFFLElBUko7QUFTVmxDLFlBQVEsRUFBRSxJQVRBO0FBVVZqUixhQUFTLEVBQUUsSUFWRDtBQVdWbVUsWUFBUSxFQUFFLElBWEE7QUFZVkUsYUFBUyxFQUFFLElBWkQ7QUFhVkMsY0FBVSxFQUFFLElBYkY7QUFjVjVELFFBQUksRUFBRSxJQWRJO0FBZVZHLGNBQVUsRUFBRSxJQWZGO0FBZ0JWMEIsTUFBRSxFQUFFLElBaEJNO0FBaUJWUSxVQUFNLEVBQUUsSUFqQkU7QUFrQlZoZixVQUFNLEVBQUUsSUFsQkU7QUFtQlY4bUMsZ0JBQVksRUFBRSxJQW5CSjtBQW9CVmpyQixhQXBCVTtBQXFCVk0sYUFyQlU7QUFzQlZpQyxnQkF0QlU7QUF1QlZqQixtQkFBZSxFQUFFLElBdkJQO0FBd0JWaFIsY0FBVSxFQUFFO0FBeEJGLEdBQWQsQ0EzRGdILENBcUZoSDs7QUFDQSxNQUFLck8sS0FBRCxJQUEyQytOLEtBQUssQ0FBQzNMLEdBQU4sS0FBYzJMLEtBQUssQ0FBQzNMLEdBQW5FLEVBQXdFO0FBQ3BFMEUsUUFBSSxDQUFFLG1EQUFGLEVBQXNEaUgsS0FBSyxDQUFDNUwsSUFBNUQsQ0FBSjtBQUNIOztBQUNEZ3BDLG1CQUFpQixDQUFDcDlCLEtBQUQsRUFBUXFSLFFBQVIsQ0FBakIsQ0F6RmdILENBMEZoSDs7QUFDQSxNQUFJckIsU0FBUyxHQUFHO0FBQUk7QUFBcEIsSUFBb0M7QUFDaEM1YixVQUFJLENBQUMwZixTQUFMLENBQWU5VCxLQUFmO0FBQ0g7O0FBQ0QsTUFBSXc4QixrQkFBa0IsR0FBRyxDQUFyQixJQUNBO0FBQ0EsR0FBQ1UsV0FGRCxJQUdBO0FBQ0F2bEIsY0FKQSxNQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0NySCxXQUFTLEdBQUcsQ0FBWixJQUFpQk4sU0FBUyxHQUFHO0FBQUU7QUFUaEMsT0FVQTtBQUNBO0FBQ0FNLFdBQVMsS0FBSztBQUFHO0FBWnJCLElBWTJDO0FBQ3ZDcUgsa0JBQVksQ0FBQ3ZrQixJQUFiLENBQWtCNE0sS0FBbEI7QUFDSDs7QUFDRCxTQUFPQSxLQUFQO0FBQ0g7O0FBQ0QsU0FBUzBRLFVBQVQsQ0FBb0IxUSxLQUFwQixFQUEyQnk5QixVQUEzQixFQUF1Q0MsUUFBUSxHQUFHLEtBQWxELEVBQXlEO0FBQ3JEO0FBQ0E7QUFDQSxRQUFNO0FBQUU5N0IsU0FBRjtBQUFTbkUsT0FBVDtBQUFjNlMsYUFBZDtBQUF5QmU7QUFBekIsTUFBc0NyUixLQUE1QztBQUNBLFFBQU0yOUIsV0FBVyxHQUFHRixVQUFVLEdBQUdHLFVBQVUsQ0FBQ2g4QixLQUFLLElBQUksRUFBVixFQUFjNjdCLFVBQWQsQ0FBYixHQUF5Qzc3QixLQUF2RTtBQUNBLFFBQU11N0IsTUFBTSxHQUFHO0FBQ1hULGVBQVcsRUFBRSxJQURGO0FBRVhjLFlBQVEsRUFBRSxJQUZDO0FBR1hwcEMsUUFBSSxFQUFFNEwsS0FBSyxDQUFDNUwsSUFIRDtBQUlYd04sU0FBSyxFQUFFKzdCLFdBSkk7QUFLWHRwQyxPQUFHLEVBQUVzcEMsV0FBVyxJQUFJWCxZQUFZLENBQUNXLFdBQUQsQ0FMckI7QUFNWGxnQyxPQUFHLEVBQUVnZ0MsVUFBVSxJQUFJQSxVQUFVLENBQUNoZ0MsR0FBekIsR0FDQztBQUNFO0FBQ0E7QUFDQWlnQyxZQUFRLElBQUlqZ0MsR0FBWixHQUNNbkksb0RBQU8sQ0FBQ21JLEdBQUQsQ0FBUCxHQUNJQSxHQUFHLENBQUN1VCxNQUFKLENBQVdpc0IsWUFBWSxDQUFDUSxVQUFELENBQXZCLENBREosR0FFSSxDQUFDaGdDLEdBQUQsRUFBTXcvQixZQUFZLENBQUNRLFVBQUQsQ0FBbEIsQ0FIVixHQUlNUixZQUFZLENBQUNRLFVBQUQsQ0FSckIsR0FTQ2hnQyxHQWZLO0FBZ0JYMDNCLFdBQU8sRUFBRW4xQixLQUFLLENBQUNtMUIsT0FoQko7QUFpQlg1aEIsZ0JBQVksRUFBRXZULEtBQUssQ0FBQ3VULFlBakJUO0FBa0JYbEMsWUFBUSxFQUFHcGYsS0FBRCxJQUEyQ3FlLFNBQVMsS0FBSyxDQUFDO0FBQUU7QUFBNUQsT0FBNkVoYixvREFBTyxDQUFDK2IsUUFBRCxDQUFwRixHQUNKQSxRQUFRLENBQUNwYixHQUFULENBQWE0bkMsY0FBYixDQURJLEdBRUp4c0IsUUFwQks7QUFxQlhsZCxVQUFNLEVBQUU2TCxLQUFLLENBQUM3TCxNQXJCSDtBQXNCWDhtQyxnQkFBWSxFQUFFajdCLEtBQUssQ0FBQ2k3QixZQXRCVDtBQXVCWDNMLGVBQVcsRUFBRXR2QixLQUFLLENBQUNzdkIsV0F2QlI7QUF3QlhxRixlQUFXLEVBQUUzMEIsS0FBSyxDQUFDMjBCLFdBeEJSO0FBeUJYM2tCLGFBQVMsRUFBRWhRLEtBQUssQ0FBQ2dRLFNBekJOO0FBMEJYO0FBQ0E7QUFDQTtBQUNBO0FBQ0FNLGFBQVMsRUFBRW10QixVQUFVLElBQUl6OUIsS0FBSyxDQUFDNUwsSUFBTixLQUFlOFUsUUFBN0IsR0FDTG9ILFNBQVMsS0FBSyxDQUFDLENBQWYsQ0FBaUI7QUFBakIsTUFDSTtBQUFHO0FBRFAsTUFFSUEsU0FBUyxHQUFHO0FBQUc7QUFIZCxNQUlMQSxTQWxDSztBQW1DWGlDLGdCQUFZLEVBQUV2UyxLQUFLLENBQUN1UyxZQW5DVDtBQW9DWGpCLG1CQUFlLEVBQUV0UixLQUFLLENBQUNzUixlQXBDWjtBQXFDWGhSLGNBQVUsRUFBRU4sS0FBSyxDQUFDTSxVQXJDUDtBQXNDWHdRLFFBQUksRUFBRTlRLEtBQUssQ0FBQzhRLElBdENEO0FBdUNYRyxjQUFVLEVBQUVqUixLQUFLLENBQUNpUixVQXZDUDtBQXdDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBN1EsYUFBUyxFQUFFSixLQUFLLENBQUNJLFNBNUNOO0FBNkNYbVUsWUFBUSxFQUFFdlUsS0FBSyxDQUFDdVUsUUE3Q0w7QUE4Q1hFLGFBQVMsRUFBRXpVLEtBQUssQ0FBQ3lVLFNBQU4sSUFBbUIvRCxVQUFVLENBQUMxUSxLQUFLLENBQUN5VSxTQUFQLENBOUM3QjtBQStDWEMsY0FBVSxFQUFFMVUsS0FBSyxDQUFDMFUsVUFBTixJQUFvQmhFLFVBQVUsQ0FBQzFRLEtBQUssQ0FBQzBVLFVBQVAsQ0EvQy9CO0FBZ0RYL0IsTUFBRSxFQUFFM1MsS0FBSyxDQUFDMlMsRUFoREM7QUFpRFhRLFVBQU0sRUFBRW5ULEtBQUssQ0FBQ21UO0FBakRILEdBQWY7QUFtREEsU0FBT2dxQixNQUFQO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU1UsY0FBVCxDQUF3Qjc5QixLQUF4QixFQUErQjtBQUMzQixRQUFNbTlCLE1BQU0sR0FBR3pzQixVQUFVLENBQUMxUSxLQUFELENBQXpCOztBQUNBLE1BQUkxSyxvREFBTyxDQUFDMEssS0FBSyxDQUFDcVIsUUFBUCxDQUFYLEVBQTZCO0FBQ3pCOHJCLFVBQU0sQ0FBQzlyQixRQUFQLEdBQWtCclIsS0FBSyxDQUFDcVIsUUFBTixDQUFlcGIsR0FBZixDQUFtQjRuQyxjQUFuQixDQUFsQjtBQUNIOztBQUNELFNBQU9WLE1BQVA7QUFDSDtBQUNEO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU3ROLGVBQVQsQ0FBeUJpTyxJQUFJLEdBQUcsR0FBaEMsRUFBcUNDLElBQUksR0FBRyxDQUE1QyxFQUErQztBQUMzQyxTQUFPNXNCLFdBQVcsQ0FBQ2hJLElBQUQsRUFBTyxJQUFQLEVBQWEyMEIsSUFBYixFQUFtQkMsSUFBbkIsQ0FBbEI7QUFDSDtBQUNEO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU0MsaUJBQVQsQ0FBMkJDLE9BQTNCLEVBQW9DQyxhQUFwQyxFQUFtRDtBQUMvQztBQUNBO0FBQ0EsUUFBTWwrQixLQUFLLEdBQUdtUixXQUFXLENBQUM3SCxNQUFELEVBQVMsSUFBVCxFQUFlMjBCLE9BQWYsQ0FBekI7QUFDQWorQixPQUFLLENBQUNzdkIsV0FBTixHQUFvQjRPLGFBQXBCO0FBQ0EsU0FBT2wrQixLQUFQO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7OztBQUNBLFNBQVNtK0Isa0JBQVQsQ0FBNEJMLElBQUksR0FBRyxFQUFuQyxFQUNBO0FBQ0E7QUFDQU0sT0FBTyxHQUFHLEtBSFYsRUFHaUI7QUFDYixTQUFPQSxPQUFPLElBQ1AxbUIsU0FBUyxJQUFJK2tCLFdBQVcsQ0FBQ3B6QixTQUFELEVBQVksSUFBWixFQUFrQnkwQixJQUFsQixDQURqQixJQUVSM3NCLFdBQVcsQ0FBQzlILFNBQUQsRUFBWSxJQUFaLEVBQWtCeTBCLElBQWxCLENBRmpCO0FBR0g7O0FBQ0QsU0FBUzV0QixjQUFULENBQXdCMEIsS0FBeEIsRUFBK0I7QUFDM0IsTUFBSUEsS0FBSyxJQUFJLElBQVQsSUFBaUIsT0FBT0EsS0FBUCxLQUFpQixTQUF0QyxFQUFpRDtBQUM3QztBQUNBLFdBQU9ULFdBQVcsQ0FBQzlILFNBQUQsQ0FBbEI7QUFDSCxHQUhELE1BSUssSUFBSS9ULG9EQUFPLENBQUNzYyxLQUFELENBQVgsRUFBb0I7QUFDckI7QUFDQSxXQUFPVCxXQUFXLENBQUNqSSxRQUFELEVBQVcsSUFBWCxFQUNsQjtBQUNBMEksU0FBSyxDQUFDN1AsS0FBTixFQUZrQixDQUFsQjtBQUdILEdBTEksTUFNQSxJQUFJLE9BQU82UCxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQ2hDO0FBQ0E7QUFDQSxXQUFPeWpCLGNBQWMsQ0FBQ3pqQixLQUFELENBQXJCO0FBQ0gsR0FKSSxNQUtBO0FBQ0Q7QUFDQSxXQUFPVCxXQUFXLENBQUNoSSxJQUFELEVBQU8sSUFBUCxFQUFhblEsTUFBTSxDQUFDNFksS0FBRCxDQUFuQixDQUFsQjtBQUNIO0FBQ0osQyxDQUNEOzs7QUFDQSxTQUFTeWpCLGNBQVQsQ0FBd0J6akIsS0FBeEIsRUFBK0I7QUFDM0IsU0FBT0EsS0FBSyxDQUFDZSxFQUFOLEtBQWEsSUFBYixHQUFvQmYsS0FBcEIsR0FBNEJsQixVQUFVLENBQUNrQixLQUFELENBQTdDO0FBQ0g7O0FBQ0QsU0FBU3dyQixpQkFBVCxDQUEyQnA5QixLQUEzQixFQUFrQ3FSLFFBQWxDLEVBQTRDO0FBQ3hDLE1BQUlqZCxJQUFJLEdBQUcsQ0FBWDtBQUNBLFFBQU07QUFBRTRiO0FBQUYsTUFBZ0JoUSxLQUF0Qjs7QUFDQSxNQUFJcVIsUUFBUSxJQUFJLElBQWhCLEVBQXNCO0FBQ2xCQSxZQUFRLEdBQUcsSUFBWDtBQUNILEdBRkQsTUFHSyxJQUFJL2Isb0RBQU8sQ0FBQytiLFFBQUQsQ0FBWCxFQUF1QjtBQUN4QmpkLFFBQUksR0FBRztBQUFHO0FBQVY7QUFDSCxHQUZJLE1BR0EsSUFBSSxPQUFPaWQsUUFBUCxLQUFvQixRQUF4QixFQUFrQztBQUNuQyxRQUFJckIsU0FBUyxHQUFHO0FBQUU7QUFBZCxPQUErQkEsU0FBUyxHQUFHO0FBQUc7QUFBbEQsTUFBa0U7QUFDOUQ7QUFDQSxjQUFNcXVCLElBQUksR0FBR2h0QixRQUFRLENBQUNpRyxPQUF0Qjs7QUFDQSxZQUFJK21CLElBQUosRUFBVTtBQUNOO0FBQ0FBLGNBQUksQ0FBQ2p2QixFQUFMLEtBQVlpdkIsSUFBSSxDQUFDcHZCLEVBQUwsR0FBVSxLQUF0QjtBQUNBbXVCLDJCQUFpQixDQUFDcDlCLEtBQUQsRUFBUXErQixJQUFJLEVBQVosQ0FBakI7QUFDQUEsY0FBSSxDQUFDanZCLEVBQUwsS0FBWWl2QixJQUFJLENBQUNwdkIsRUFBTCxHQUFVLElBQXRCO0FBQ0g7O0FBQ0Q7QUFDSCxPQVZELE1BV0s7QUFDRDdhLFVBQUksR0FBRztBQUFHO0FBQVY7QUFDQSxZQUFNa3FDLFFBQVEsR0FBR2p0QixRQUFRLENBQUNrYSxDQUExQjs7QUFDQSxVQUFJLENBQUMrUyxRQUFELElBQWEsRUFBRTlXLGlCQUFpQixJQUFJblcsUUFBdkIsQ0FBakIsRUFBbUQ7QUFDL0NBLGdCQUFRLENBQUMrWixJQUFULEdBQWdCamQsd0JBQWhCO0FBQ0gsT0FGRCxNQUdLLElBQUltd0IsUUFBUSxLQUFLO0FBQUU7QUFBZixTQUFrQ253Qix3QkFBdEMsRUFBZ0U7QUFDakU7QUFDQTtBQUNBLFlBQUlBLHdCQUF3QixDQUFDdUIsS0FBekIsQ0FBK0I2YixDQUEvQixLQUFxQztBQUFFO0FBQTNDLFVBQXlEO0FBQ3JEbGEsb0JBQVEsQ0FBQ2thLENBQVQsR0FBYTtBQUFFO0FBQWY7QUFDSCxXQUZELE1BR0s7QUFDRGxhLGtCQUFRLENBQUNrYSxDQUFULEdBQWE7QUFBRTtBQUFmO0FBQ0F2ckIsZUFBSyxDQUFDc1EsU0FBTixJQUFtQjtBQUFLO0FBQXhCO0FBQ0g7QUFDSjtBQUNKO0FBQ0osR0E5QkksTUErQkEsSUFBSWxPLHVEQUFZLENBQUNpUCxRQUFELENBQWhCLEVBQTRCO0FBQzdCQSxZQUFRLEdBQUc7QUFBRWlHLGFBQU8sRUFBRWpHLFFBQVg7QUFBcUIrWixVQUFJLEVBQUVqZDtBQUEzQixLQUFYO0FBQ0EvWixRQUFJLEdBQUc7QUFBRztBQUFWO0FBQ0gsR0FISSxNQUlBO0FBQ0RpZCxZQUFRLEdBQUdyWSxNQUFNLENBQUNxWSxRQUFELENBQWpCLENBREMsQ0FFRDs7QUFDQSxRQUFJckIsU0FBUyxHQUFHO0FBQUc7QUFBbkIsTUFBbUM7QUFDL0I1YixZQUFJLEdBQUc7QUFBRztBQUFWO0FBQ0FpZCxnQkFBUSxHQUFHLENBQUN3ZSxlQUFlLENBQUN4ZSxRQUFELENBQWhCLENBQVg7QUFDSCxPQUhELE1BSUs7QUFDRGpkLFVBQUksR0FBRztBQUFFO0FBQVQ7QUFDSDtBQUNKOztBQUNENEwsT0FBSyxDQUFDcVIsUUFBTixHQUFpQkEsUUFBakI7QUFDQXJSLE9BQUssQ0FBQ2dRLFNBQU4sSUFBbUI1YixJQUFuQjtBQUNIOztBQUNELFNBQVN3cEMsVUFBVCxDQUFvQixHQUFHOW1DLElBQXZCLEVBQTZCO0FBQ3pCLFFBQU1pSSxHQUFHLEdBQUc3RixtREFBTSxDQUFDLEVBQUQsRUFBS3BDLElBQUksQ0FBQyxDQUFELENBQVQsQ0FBbEI7O0FBQ0EsT0FBSyxJQUFJbkQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR21ELElBQUksQ0FBQ3ZELE1BQXpCLEVBQWlDSSxDQUFDLEVBQWxDLEVBQXNDO0FBQ2xDLFVBQU00cUMsT0FBTyxHQUFHem5DLElBQUksQ0FBQ25ELENBQUQsQ0FBcEI7O0FBQ0EsU0FBSyxNQUFNVSxHQUFYLElBQWtCa3FDLE9BQWxCLEVBQTJCO0FBQ3ZCLFVBQUlscUMsR0FBRyxLQUFLLE9BQVosRUFBcUI7QUFDakIsWUFBSTBLLEdBQUcsQ0FBQzIyQixLQUFKLEtBQWM2SSxPQUFPLENBQUM3SSxLQUExQixFQUFpQztBQUM3QjMyQixhQUFHLENBQUMyMkIsS0FBSixHQUFZNEgsMkRBQWMsQ0FBQyxDQUFDditCLEdBQUcsQ0FBQzIyQixLQUFMLEVBQVk2SSxPQUFPLENBQUM3SSxLQUFwQixDQUFELENBQTFCO0FBQ0g7QUFDSixPQUpELE1BS0ssSUFBSXJoQyxHQUFHLEtBQUssT0FBWixFQUFxQjtBQUN0QjBLLFdBQUcsQ0FBQzQyQixLQUFKLEdBQVk0SCwyREFBYyxDQUFDLENBQUN4K0IsR0FBRyxDQUFDNDJCLEtBQUwsRUFBWTRJLE9BQU8sQ0FBQzVJLEtBQXBCLENBQUQsQ0FBMUI7QUFDSCxPQUZJLE1BR0EsSUFBSTFuQixpREFBSSxDQUFDNVosR0FBRCxDQUFSLEVBQWU7QUFDaEIsY0FBTW1xQyxRQUFRLEdBQUd6L0IsR0FBRyxDQUFDMUssR0FBRCxDQUFwQjtBQUNBLGNBQU1vcUMsUUFBUSxHQUFHRixPQUFPLENBQUNscUMsR0FBRCxDQUF4Qjs7QUFDQSxZQUFJbXFDLFFBQVEsS0FBS0MsUUFBakIsRUFBMkI7QUFDdkIxL0IsYUFBRyxDQUFDMUssR0FBRCxDQUFILEdBQVdtcUMsUUFBUSxHQUNiLEdBQUd4dEIsTUFBSCxDQUFVd3RCLFFBQVYsRUFBb0JDLFFBQXBCLENBRGEsR0FFYkEsUUFGTjtBQUdIO0FBQ0osT0FSSSxNQVNBLElBQUlwcUMsR0FBRyxLQUFLLEVBQVosRUFBZ0I7QUFDakIwSyxXQUFHLENBQUMxSyxHQUFELENBQUgsR0FBV2txQyxPQUFPLENBQUNscUMsR0FBRCxDQUFsQjtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxTQUFPMEssR0FBUDtBQUNIO0FBRUQ7QUFDQTtBQUNBOzs7QUFDQSxTQUFTMi9CLFVBQVQsQ0FBb0I3bEIsTUFBcEIsRUFBNEI4bEIsVUFBNUIsRUFBd0M7QUFDcEMsTUFBSTUvQixHQUFKOztBQUNBLE1BQUl6SixvREFBTyxDQUFDdWpCLE1BQUQsQ0FBUCxJQUFtQjVXLHFEQUFRLENBQUM0VyxNQUFELENBQS9CLEVBQXlDO0FBQ3JDOVosT0FBRyxHQUFHLElBQUluSSxLQUFKLENBQVVpaUIsTUFBTSxDQUFDdGxCLE1BQWpCLENBQU47O0FBQ0EsU0FBSyxJQUFJSSxDQUFDLEdBQUcsQ0FBUixFQUFXc0QsQ0FBQyxHQUFHNGhCLE1BQU0sQ0FBQ3RsQixNQUEzQixFQUFtQ0ksQ0FBQyxHQUFHc0QsQ0FBdkMsRUFBMEN0RCxDQUFDLEVBQTNDLEVBQStDO0FBQzNDb0wsU0FBRyxDQUFDcEwsQ0FBRCxDQUFILEdBQVNnckMsVUFBVSxDQUFDOWxCLE1BQU0sQ0FBQ2xsQixDQUFELENBQVAsRUFBWUEsQ0FBWixDQUFuQjtBQUNIO0FBQ0osR0FMRCxNQU1LLElBQUksT0FBT2tsQixNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQ2pDLFFBQUs1bUIsS0FBRCxJQUEyQyxDQUFDc0csTUFBTSxDQUFDcW1DLFNBQVAsQ0FBaUIvbEIsTUFBakIsQ0FBaEQsRUFBMEU7QUFDdEU5ZixVQUFJLENBQUUsbURBQWtEOGYsTUFBTyxHQUEzRCxDQUFKO0FBQ0EsYUFBTyxFQUFQO0FBQ0g7O0FBQ0Q5WixPQUFHLEdBQUcsSUFBSW5JLEtBQUosQ0FBVWlpQixNQUFWLENBQU47O0FBQ0EsU0FBSyxJQUFJbGxCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdrbEIsTUFBcEIsRUFBNEJsbEIsQ0FBQyxFQUE3QixFQUFpQztBQUM3Qm9MLFNBQUcsQ0FBQ3BMLENBQUQsQ0FBSCxHQUFTZ3JDLFVBQVUsQ0FBQ2hyQyxDQUFDLEdBQUcsQ0FBTCxFQUFRQSxDQUFSLENBQW5CO0FBQ0g7QUFDSixHQVRJLE1BVUEsSUFBSXNtQixxREFBVSxDQUFDcEIsTUFBRCxDQUFkLEVBQXdCO0FBQ3pCLFFBQUlBLE1BQU0sQ0FBQzdtQixNQUFNLENBQUMrSSxRQUFSLENBQVYsRUFBNkI7QUFDekJnRSxTQUFHLEdBQUduSSxLQUFLLENBQUN3UixJQUFOLENBQVd5USxNQUFYLEVBQW1COGxCLFVBQW5CLENBQU47QUFDSCxLQUZELE1BR0s7QUFDRCxZQUFNNzhCLElBQUksR0FBRy9MLE1BQU0sQ0FBQytMLElBQVAsQ0FBWStXLE1BQVosQ0FBYjtBQUNBOVosU0FBRyxHQUFHLElBQUluSSxLQUFKLENBQVVrTCxJQUFJLENBQUN2TyxNQUFmLENBQU47O0FBQ0EsV0FBSyxJQUFJSSxDQUFDLEdBQUcsQ0FBUixFQUFXc0QsQ0FBQyxHQUFHNkssSUFBSSxDQUFDdk8sTUFBekIsRUFBaUNJLENBQUMsR0FBR3NELENBQXJDLEVBQXdDdEQsQ0FBQyxFQUF6QyxFQUE2QztBQUN6QyxjQUFNVSxHQUFHLEdBQUd5TixJQUFJLENBQUNuTyxDQUFELENBQWhCO0FBQ0FvTCxXQUFHLENBQUNwTCxDQUFELENBQUgsR0FBU2dyQyxVQUFVLENBQUM5bEIsTUFBTSxDQUFDeGtCLEdBQUQsQ0FBUCxFQUFjQSxHQUFkLEVBQW1CVixDQUFuQixDQUFuQjtBQUNIO0FBQ0o7QUFDSixHQVpJLE1BYUE7QUFDRG9MLE9BQUcsR0FBRyxFQUFOO0FBQ0g7O0FBQ0QsU0FBT0EsR0FBUDtBQUNIO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVM4L0IsV0FBVCxDQUFxQm52QixLQUFyQixFQUE0Qm92QixZQUE1QixFQUEwQztBQUN0QyxPQUFLLElBQUluckMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR21yQyxZQUFZLENBQUN2ckMsTUFBakMsRUFBeUNJLENBQUMsRUFBMUMsRUFBOEM7QUFDMUMsVUFBTTBxQyxJQUFJLEdBQUdTLFlBQVksQ0FBQ25yQyxDQUFELENBQXpCLENBRDBDLENBRTFDOztBQUNBLFFBQUkyQixvREFBTyxDQUFDK29DLElBQUQsQ0FBWCxFQUFtQjtBQUNmLFdBQUssSUFBSTVGLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc0RixJQUFJLENBQUM5cUMsTUFBekIsRUFBaUNrbEMsQ0FBQyxFQUFsQyxFQUFzQztBQUNsQy9vQixhQUFLLENBQUMydUIsSUFBSSxDQUFDNUYsQ0FBRCxDQUFKLENBQVFwMkIsSUFBVCxDQUFMLEdBQXNCZzhCLElBQUksQ0FBQzVGLENBQUQsQ0FBSixDQUFRcm1DLEVBQTlCO0FBQ0g7QUFDSixLQUpELE1BS0ssSUFBSWlzQyxJQUFKLEVBQVU7QUFDWDtBQUNBM3VCLFdBQUssQ0FBQzJ1QixJQUFJLENBQUNoOEIsSUFBTixDQUFMLEdBQW1CZzhCLElBQUksQ0FBQ2pzQyxFQUF4QjtBQUNIO0FBQ0o7O0FBQ0QsU0FBT3NkLEtBQVA7QUFDSDtBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTcXZCLFVBQVQsQ0FBb0JydkIsS0FBcEIsRUFBMkJyTixJQUEzQixFQUFpQ1QsS0FBSyxHQUFHLEVBQXpDLEVBQ0E7QUFDQTtBQUNBMlQsUUFIQSxFQUdVeXBCLFNBSFYsRUFHcUI7QUFDakIsTUFBSVgsSUFBSSxHQUFHM3VCLEtBQUssQ0FBQ3JOLElBQUQsQ0FBaEI7O0FBQ0EsTUFBS3BRLEtBQUQsSUFBMkNvc0MsSUFBM0MsSUFBbURBLElBQUksQ0FBQzlxQyxNQUFMLEdBQWMsQ0FBckUsRUFBd0U7QUFDcEV3RixRQUFJLENBQUUscUVBQUQsR0FDQSx1RUFEQSxHQUVBLGtCQUZELENBQUo7O0FBR0FzbEMsUUFBSSxHQUFHLE1BQU0sRUFBYjtBQUNILEdBUGdCLENBUWpCO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFJQSxJQUFJLElBQUlBLElBQUksQ0FBQ2p2QixFQUFqQixFQUFxQjtBQUNqQml2QixRQUFJLENBQUNwdkIsRUFBTCxHQUFVLEtBQVY7QUFDSDs7QUFDRHlJLFdBQVM7QUFDVCxRQUFNdW5CLGdCQUFnQixHQUFHWixJQUFJLElBQUlhLGdCQUFnQixDQUFDYixJQUFJLENBQUN6OEIsS0FBRCxDQUFMLENBQWpEO0FBQ0EsUUFBTXU5QixRQUFRLEdBQUcxQyxXQUFXLENBQUN2ekIsUUFBRCxFQUFXO0FBQUU3VSxPQUFHLEVBQUV1TixLQUFLLENBQUN2TixHQUFOLElBQWMsSUFBR2dPLElBQUs7QUFBN0IsR0FBWCxFQUE2QzQ4QixnQkFBZ0IsS0FBSzFwQixRQUFRLEdBQUdBLFFBQVEsRUFBWCxHQUFnQixFQUE3QixDQUE3RCxFQUErRjBwQixnQkFBZ0IsSUFBSXZ2QixLQUFLLENBQUM2YixDQUFOLEtBQVk7QUFBRTtBQUFsQyxJQUNySDtBQUFHO0FBRGtILElBRXJILENBQUM7QUFBRTtBQUZtQixHQUE1Qjs7QUFHQSxNQUFJLENBQUN5VCxTQUFELElBQWNHLFFBQVEsQ0FBQ2hLLE9BQTNCLEVBQW9DO0FBQ2hDZ0ssWUFBUSxDQUFDNXJCLFlBQVQsR0FBd0IsQ0FBQzRyQixRQUFRLENBQUNoSyxPQUFULEdBQW1CLElBQXBCLENBQXhCO0FBQ0g7O0FBQ0QsTUFBSWtKLElBQUksSUFBSUEsSUFBSSxDQUFDanZCLEVBQWpCLEVBQXFCO0FBQ2pCaXZCLFFBQUksQ0FBQ3B2QixFQUFMLEdBQVUsSUFBVjtBQUNIOztBQUNELFNBQU9rd0IsUUFBUDtBQUNIOztBQUNELFNBQVNELGdCQUFULENBQTBCRSxNQUExQixFQUFrQztBQUM5QixTQUFPQSxNQUFNLENBQUM1dUIsSUFBUCxDQUFZb0IsS0FBSyxJQUFJO0FBQ3hCLFFBQUksQ0FBQ0MsT0FBTyxDQUFDRCxLQUFELENBQVosRUFDSSxPQUFPLElBQVA7QUFDSixRQUFJQSxLQUFLLENBQUN4ZCxJQUFOLEtBQWVpVixTQUFuQixFQUNJLE9BQU8sS0FBUDtBQUNKLFFBQUl1SSxLQUFLLENBQUN4ZCxJQUFOLEtBQWU4VSxRQUFmLElBQ0EsQ0FBQ2cyQixnQkFBZ0IsQ0FBQ3R0QixLQUFLLENBQUNQLFFBQVAsQ0FEckIsRUFFSSxPQUFPLEtBQVA7QUFDSixXQUFPLElBQVA7QUFDSCxHQVRNLElBVUQrdEIsTUFWQyxHQVdELElBWE47QUFZSDtBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTQyxVQUFULENBQW9CQyxHQUFwQixFQUF5QjtBQUNyQixRQUFNdmdDLEdBQUcsR0FBRyxFQUFaOztBQUNBLE1BQUs5TSxLQUFELElBQTJDLENBQUNnb0IscURBQVUsQ0FBQ3FsQixHQUFELENBQTFELEVBQWlFO0FBQzdEdm1DLFFBQUksQ0FBRSxnREFBRixDQUFKO0FBQ0EsV0FBT2dHLEdBQVA7QUFDSDs7QUFDRCxPQUFLLE1BQU0xSyxHQUFYLElBQWtCaXJDLEdBQWxCLEVBQXVCO0FBQ25CdmdDLE9BQUcsQ0FBQ2tOLHlEQUFZLENBQUM1WCxHQUFELENBQWIsQ0FBSCxHQUF5QmlyQyxHQUFHLENBQUNqckMsR0FBRCxDQUE1QjtBQUNIOztBQUNELFNBQU8wSyxHQUFQO0FBQ0g7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNd2dDLGlCQUFpQixHQUFJNXJDLENBQUQsSUFBTztBQUM3QixNQUFJLENBQUNBLENBQUwsRUFDSSxPQUFPLElBQVA7QUFDSixNQUFJNnJDLG1CQUFtQixDQUFDN3JDLENBQUQsQ0FBdkIsRUFDSSxPQUFPcStCLGNBQWMsQ0FBQ3IrQixDQUFELENBQWQsSUFBcUJBLENBQUMsQ0FBQ21KLEtBQTlCO0FBQ0osU0FBT3lpQyxpQkFBaUIsQ0FBQzVyQyxDQUFDLENBQUN5TixNQUFILENBQXhCO0FBQ0gsQ0FORDs7QUFPQSxNQUFNcStCLG1CQUFtQixHQUFHdm1DLG1EQUFNLENBQUNuRCxNQUFNLENBQUM4VSxNQUFQLENBQWMsSUFBZCxDQUFELEVBQXNCO0FBQ3BENjBCLEdBQUMsRUFBRS9yQyxDQUFDLElBQUlBLENBRDRDO0FBRXBEZ3NDLEtBQUcsRUFBRWhzQyxDQUFDLElBQUlBLENBQUMsQ0FBQ3FNLEtBQUYsQ0FBUTJTLEVBRmtDO0FBR3BEaXRCLE9BQUssRUFBRWpzQyxDQUFDLElBQUlBLENBQUMsQ0FBQ2ljLElBSHNDO0FBSXBEaXdCLFFBQU0sRUFBRWxzQyxDQUFDLElBQU0xQixLQUFELEdBQTBDdUssZ0VBQWUsQ0FBQzdJLENBQUMsQ0FBQ2lPLEtBQUgsQ0FBekQsR0FBcUVqTyxDQUovQjtBQUtwRG1zQyxRQUFNLEVBQUVuc0MsQ0FBQyxJQUFNMUIsS0FBRCxHQUEwQ3VLLGdFQUFlLENBQUM3SSxDQUFDLENBQUNnYyxLQUFILENBQXpELEdBQXFFaGMsQ0FML0I7QUFNcERvc0MsUUFBTSxFQUFFcHNDLENBQUMsSUFBTTFCLEtBQUQsR0FBMEN1SyxnRUFBZSxDQUFDN0ksQ0FBQyxDQUFDK2IsS0FBSCxDQUF6RCxHQUFxRS9iLENBTi9CO0FBT3BEcXNDLE9BQUssRUFBRXJzQyxDQUFDLElBQU0xQixLQUFELEdBQTBDdUssZ0VBQWUsQ0FBQzdJLENBQUMsQ0FBQ3crQixJQUFILENBQXpELEdBQW9FeCtCLENBUDdCO0FBUXBEc3NDLFNBQU8sRUFBRXRzQyxDQUFDLElBQUk0ckMsaUJBQWlCLENBQUM1ckMsQ0FBQyxDQUFDeU4sTUFBSCxDQVJxQjtBQVNwRDgrQixPQUFLLEVBQUV2c0MsQ0FBQyxJQUFJNHJDLGlCQUFpQixDQUFDNXJDLENBQUMsQ0FBQ3ljLElBQUgsQ0FUdUI7QUFVcEQrdkIsT0FBSyxFQUFFeHNDLENBQUMsSUFBSUEsQ0FBQyxDQUFDc1YsSUFWc0M7QUFXcERtM0IsVUFBUSxFQUFFenNDLENBQUMsSUFBS2dhLEtBQW1CLEdBQUc4VixvQkFBb0IsQ0FBQzl2QixDQUFELENBQXZCLEdBQTZCQSxDQVhaO0FBWXBEMHNDLGNBQVksRUFBRTFzQyxDQUFDLElBQUksTUFBTTBSLFFBQVEsQ0FBQzFSLENBQUMsQ0FBQzJVLE1BQUgsQ0FabUI7QUFhcERnNEIsV0FBUyxFQUFFM3NDLENBQUMsSUFBSThRLFFBQVEsQ0FBQ0csSUFBVCxDQUFjalIsQ0FBQyxDQUFDbUosS0FBaEIsQ0Fib0M7QUFjcER5akMsUUFBTSxFQUFFNXNDLENBQUMsSUFBS2dhLEtBQW1CLEdBQUdnTSxhQUFhLENBQUMvVSxJQUFkLENBQW1CalIsQ0FBbkIsQ0FBSCxHQUEyQmtNLENBQUlBO0FBZFosQ0FBdEIsQ0FBbEM7QUFnQkEsTUFBTTJnQywyQkFBMkIsR0FBRztBQUNoQ2pzQyxLQUFHLENBQUM7QUFBRWczQixLQUFDLEVBQUVwckI7QUFBTCxHQUFELEVBQWtCOUwsR0FBbEIsRUFBdUI7QUFDdEIsVUFBTTtBQUFFd2EsU0FBRjtBQUFPZ0IsZ0JBQVA7QUFBbUJELFVBQW5CO0FBQXlCaE8sV0FBekI7QUFBZ0M2K0IsaUJBQWhDO0FBQTZDcnNDLFVBQTdDO0FBQW1Ea007QUFBbkQsUUFBa0VILFFBQXhFLENBRHNCLENBRXRCOztBQUNBLFFBQUtsTyxLQUFELElBQTJDb0MsR0FBRyxLQUFLLFNBQXZELEVBQWtFO0FBQzlELGFBQU8sSUFBUDtBQUNILEtBTHFCLENBTXRCO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxRQUFLcEMsS0FBRCxJQUNBNGQsVUFBVSxLQUFLcmQsa0RBRGYsSUFFQXFkLFVBQVUsQ0FBQzZ3QixlQUZYLElBR0E5b0MsbURBQU0sQ0FBQ2lZLFVBQUQsRUFBYXhiLEdBQWIsQ0FIVixFQUc2QjtBQUN6QixhQUFPd2IsVUFBVSxDQUFDeGIsR0FBRCxDQUFqQjtBQUNILEtBZnFCLENBZ0J0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFFBQUlzc0MsZUFBSjs7QUFDQSxRQUFJdHNDLEdBQUcsQ0FBQyxDQUFELENBQUgsS0FBVyxHQUFmLEVBQW9CO0FBQ2hCLFlBQU1zaEIsQ0FBQyxHQUFHOHFCLFdBQVcsQ0FBQ3BzQyxHQUFELENBQXJCOztBQUNBLFVBQUlzaEIsQ0FBQyxLQUFLMWhCLFNBQVYsRUFBcUI7QUFDakIsZ0JBQVEwaEIsQ0FBUjtBQUNJLGVBQUs7QUFBRTtBQUFQO0FBQ0ksbUJBQU85RixVQUFVLENBQUN4YixHQUFELENBQWpCOztBQUNKLGVBQUs7QUFBRTtBQUFQO0FBQ0ksbUJBQU91YixJQUFJLENBQUN2YixHQUFELENBQVg7O0FBQ0osZUFBSztBQUFFO0FBQVA7QUFDSSxtQkFBT3dhLEdBQUcsQ0FBQ3hhLEdBQUQsQ0FBVjs7QUFDSixlQUFLO0FBQUU7QUFBUDtBQUNJLG1CQUFPdU4sS0FBSyxDQUFDdk4sR0FBRCxDQUFaO0FBQ0o7QUFUSjtBQVdILE9BWkQsTUFhSyxJQUFJd2IsVUFBVSxLQUFLcmQsa0RBQWYsSUFBNEJvRixtREFBTSxDQUFDaVksVUFBRCxFQUFheGIsR0FBYixDQUF0QyxFQUF5RDtBQUMxRG9zQyxtQkFBVyxDQUFDcHNDLEdBQUQsQ0FBWCxHQUFtQjtBQUFFO0FBQXJCO0FBQ0EsZUFBT3diLFVBQVUsQ0FBQ3hiLEdBQUQsQ0FBakI7QUFDSCxPQUhJLE1BSUEsSUFBSXViLElBQUksS0FBS3BkLGtEQUFULElBQXNCb0YsbURBQU0sQ0FBQ2dZLElBQUQsRUFBT3ZiLEdBQVAsQ0FBaEMsRUFBNkM7QUFDOUNvc0MsbUJBQVcsQ0FBQ3BzQyxHQUFELENBQVgsR0FBbUI7QUFBRTtBQUFyQjtBQUNBLGVBQU91YixJQUFJLENBQUN2YixHQUFELENBQVg7QUFDSCxPQUhJLE1BSUEsS0FDTDtBQUNBO0FBQ0EsT0FBQ3NzQyxlQUFlLEdBQUd4Z0MsUUFBUSxDQUFDNkwsWUFBVCxDQUFzQixDQUF0QixDQUFuQixLQUNJcFUsbURBQU0sQ0FBQytvQyxlQUFELEVBQWtCdHNDLEdBQWxCLENBSkwsRUFJNkI7QUFDOUJvc0MsbUJBQVcsQ0FBQ3BzQyxHQUFELENBQVgsR0FBbUI7QUFBRTtBQUFyQjtBQUNBLGVBQU91TixLQUFLLENBQUN2TixHQUFELENBQVo7QUFDSCxPQVBJLE1BUUEsSUFBSXdhLEdBQUcsS0FBS3JjLGtEQUFSLElBQXFCb0YsbURBQU0sQ0FBQ2lYLEdBQUQsRUFBTXhhLEdBQU4sQ0FBL0IsRUFBMkM7QUFDNUNvc0MsbUJBQVcsQ0FBQ3BzQyxHQUFELENBQVgsR0FBbUI7QUFBRTtBQUFyQjtBQUNBLGVBQU93YSxHQUFHLENBQUN4YSxHQUFELENBQVY7QUFDSCxPQUhJLE1BSUEsSUFBSSxVQUF3Qmt2QixpQkFBNUIsRUFBK0M7QUFDaERrZCxtQkFBVyxDQUFDcHNDLEdBQUQsQ0FBWCxHQUFtQjtBQUFFO0FBQXJCO0FBQ0g7QUFDSjs7QUFDRCxVQUFNdXNDLFlBQVksR0FBR25CLG1CQUFtQixDQUFDcHJDLEdBQUQsQ0FBeEM7QUFDQSxRQUFJd3NDLFNBQUosRUFBZXBVLGdCQUFmLENBL0RzQixDQWdFdEI7O0FBQ0EsUUFBSW1VLFlBQUosRUFBa0I7QUFDZCxVQUFJdnNDLEdBQUcsS0FBSyxRQUFaLEVBQXNCO0FBQ2xCSCw4REFBSyxDQUFDaU0sUUFBRCxFQUFXO0FBQU07QUFBakIsVUFBNEI5TCxHQUE1QixDQUFMO0FBQ0NwQyxhQUFELElBQTJDcWQsaUJBQWlCLEVBQTVEO0FBQ0g7O0FBQ0QsYUFBT3N4QixZQUFZLENBQUN6Z0MsUUFBRCxDQUFuQjtBQUNILEtBTkQsTUFPSyxLQUNMO0FBQ0EsS0FBQzBnQyxTQUFTLEdBQUd6c0MsSUFBSSxDQUFDMHNDLFlBQWxCLE1BQ0tELFNBQVMsR0FBR0EsU0FBUyxDQUFDeHNDLEdBQUQsQ0FEMUIsQ0FGSyxFQUc2QjtBQUM5QixhQUFPd3NDLFNBQVA7QUFDSCxLQUxJLE1BTUEsSUFBSWh5QixHQUFHLEtBQUtyYyxrREFBUixJQUFxQm9GLG1EQUFNLENBQUNpWCxHQUFELEVBQU14YSxHQUFOLENBQS9CLEVBQTJDO0FBQzVDO0FBQ0Fvc0MsaUJBQVcsQ0FBQ3BzQyxHQUFELENBQVgsR0FBbUI7QUFBRTtBQUFyQjtBQUNBLGFBQU93YSxHQUFHLENBQUN4YSxHQUFELENBQVY7QUFDSCxLQUpJLE1BS0EsS0FDTDtBQUNFbzRCLG9CQUFnQixHQUFHbnNCLFVBQVUsQ0FBQ0MsTUFBWCxDQUFrQmtzQixnQkFBdEMsRUFDRzcwQixtREFBTSxDQUFDNjBCLGdCQUFELEVBQW1CcDRCLEdBQW5CLENBSEwsRUFHK0I7QUFDaEM7QUFDSSxlQUFPbzRCLGdCQUFnQixDQUFDcDRCLEdBQUQsQ0FBdkI7QUFDSDtBQUNKLEtBUEksTUFRQSxJQUFLcEMsS0FBRCxJQUNMa2Msd0JBREssS0FFSixDQUFDbE0scURBQVEsQ0FBQzVOLEdBQUQsQ0FBVCxJQUNHO0FBQ0E7QUFDQUEsT0FBRyxDQUFDc1IsT0FBSixDQUFZLEtBQVosTUFBdUIsQ0FMdEIsQ0FBSixFQUs4QjtBQUMvQixVQUFJaUssSUFBSSxLQUFLcGQsa0RBQVQsS0FDQzZCLEdBQUcsQ0FBQyxDQUFELENBQUgsS0FBVyxHQUFYLElBQWtCQSxHQUFHLENBQUMsQ0FBRCxDQUFILEtBQVcsR0FEOUIsS0FFQXVELG1EQUFNLENBQUNnWSxJQUFELEVBQU92YixHQUFQLENBRlYsRUFFdUI7QUFDbkIwRSxZQUFJLENBQUUsWUFBV21KLElBQUksQ0FBQ0MsU0FBTCxDQUFlOU4sR0FBZixDQUFvQixnRUFBaEMsR0FDQSxrRUFERCxDQUFKO0FBRUgsT0FMRCxNQU1LLElBQUk4TCxRQUFRLEtBQUtnTyx3QkFBakIsRUFBMkM7QUFDNUNwVixZQUFJLENBQUUsWUFBV21KLElBQUksQ0FBQ0MsU0FBTCxDQUFlOU4sR0FBZixDQUFvQiw4QkFBaEMsR0FDQSxpQ0FERCxDQUFKO0FBRUg7QUFDSjtBQUNKLEdBN0crQjs7QUE4R2hDRyxLQUFHLENBQUM7QUFBRSsyQixLQUFDLEVBQUVwckI7QUFBTCxHQUFELEVBQWtCOUwsR0FBbEIsRUFBdUIyRCxLQUF2QixFQUE4QjtBQUM3QixVQUFNO0FBQUU0WCxVQUFGO0FBQVFDLGdCQUFSO0FBQW9CaEI7QUFBcEIsUUFBNEIxTyxRQUFsQzs7QUFDQSxRQUFJMFAsVUFBVSxLQUFLcmQsa0RBQWYsSUFBNEJvRixtREFBTSxDQUFDaVksVUFBRCxFQUFheGIsR0FBYixDQUF0QyxFQUF5RDtBQUNyRHdiLGdCQUFVLENBQUN4YixHQUFELENBQVYsR0FBa0IyRCxLQUFsQjtBQUNILEtBRkQsTUFHSyxJQUFJNFgsSUFBSSxLQUFLcGQsa0RBQVQsSUFBc0JvRixtREFBTSxDQUFDZ1ksSUFBRCxFQUFPdmIsR0FBUCxDQUFoQyxFQUE2QztBQUM5Q3ViLFVBQUksQ0FBQ3ZiLEdBQUQsQ0FBSixHQUFZMkQsS0FBWjtBQUNILEtBRkksTUFHQSxJQUFJSixtREFBTSxDQUFDdUksUUFBUSxDQUFDeUIsS0FBVixFQUFpQnZOLEdBQWpCLENBQVYsRUFBaUM7QUFDakNwQyxXQUFELElBQ0k4RyxJQUFJLENBQUUsOEJBQTZCMUUsR0FBSSx3QkFBbkMsRUFBNEQ4TCxRQUE1RCxDQURSO0FBRUEsYUFBTyxLQUFQO0FBQ0g7O0FBQ0QsUUFBSTlMLEdBQUcsQ0FBQyxDQUFELENBQUgsS0FBVyxHQUFYLElBQWtCQSxHQUFHLENBQUMwTixLQUFKLENBQVUsQ0FBVixLQUFnQjVCLFFBQXRDLEVBQWdEO0FBQzNDbE8sV0FBRCxJQUNJOEcsSUFBSSxDQUFFLHlDQUF3QzFFLEdBQUksS0FBN0MsR0FDQSx1REFERCxFQUN5RDhMLFFBRHpELENBRFI7QUFHQSxhQUFPLEtBQVA7QUFDSCxLQUxELE1BTUs7QUFDRCxVQUFLbE8sS0FBRCxJQUEyQ29DLEdBQUcsSUFBSThMLFFBQVEsQ0FBQ0csVUFBVCxDQUFvQkMsTUFBcEIsQ0FBMkJrc0IsZ0JBQWpGLEVBQW1HO0FBQy9GMTJCLGNBQU0sQ0FBQ3d2QixjQUFQLENBQXNCMVcsR0FBdEIsRUFBMkJ4YSxHQUEzQixFQUFnQztBQUM1Qm94QixvQkFBVSxFQUFFLElBRGdCO0FBRTVCRCxzQkFBWSxFQUFFLElBRmM7QUFHNUJ4dEI7QUFINEIsU0FBaEM7QUFLSCxPQU5ELE1BT0s7QUFDRDZXLFdBQUcsQ0FBQ3hhLEdBQUQsQ0FBSCxHQUFXMkQsS0FBWDtBQUNIO0FBQ0o7O0FBQ0QsV0FBTyxJQUFQO0FBQ0gsR0E5SStCOztBQStJaENwRCxLQUFHLENBQUM7QUFBRTIyQixLQUFDLEVBQUU7QUFBRTNiLFVBQUY7QUFBUUMsZ0JBQVI7QUFBb0I0d0IsaUJBQXBCO0FBQWlDNXhCLFNBQWpDO0FBQXNDdk8sZ0JBQXRDO0FBQWtEMEw7QUFBbEQ7QUFBTCxHQUFELEVBQTBFM1gsR0FBMUUsRUFBK0U7QUFDOUUsUUFBSXNzQyxlQUFKO0FBQ0EsV0FBUUYsV0FBVyxDQUFDcHNDLEdBQUQsQ0FBWCxLQUFxQkosU0FBckIsSUFDSDJiLElBQUksS0FBS3BkLGtEQUFULElBQXNCb0YsbURBQU0sQ0FBQ2dZLElBQUQsRUFBT3ZiLEdBQVAsQ0FEekIsSUFFSHdiLFVBQVUsS0FBS3JkLGtEQUFmLElBQTRCb0YsbURBQU0sQ0FBQ2lZLFVBQUQsRUFBYXhiLEdBQWIsQ0FGL0IsSUFHSCxDQUFDc3NDLGVBQWUsR0FBRzMwQixZQUFZLENBQUMsQ0FBRCxDQUEvQixLQUF1Q3BVLG1EQUFNLENBQUMrb0MsZUFBRCxFQUFrQnRzQyxHQUFsQixDQUgxQyxJQUlKdUQsbURBQU0sQ0FBQ2lYLEdBQUQsRUFBTXhhLEdBQU4sQ0FKRixJQUtKdUQsbURBQU0sQ0FBQzZuQyxtQkFBRCxFQUFzQnByQyxHQUF0QixDQUxGLElBTUp1RCxtREFBTSxDQUFDMEksVUFBVSxDQUFDQyxNQUFYLENBQWtCa3NCLGdCQUFuQixFQUFxQ3A0QixHQUFyQyxDQU5WO0FBT0g7O0FBeEorQixDQUFwQzs7QUEwSkEsSUFBS3BDLElBQUwsRUFBdUQ7QUFDbkR1dUMsNkJBQTJCLENBQUM3bkMsT0FBNUIsR0FBdUN4RSxNQUFELElBQVk7QUFDOUM0RSxRQUFJLENBQUUsMkVBQUQsR0FDQSwwRUFERCxDQUFKO0FBRUEsV0FBT2xCLE9BQU8sQ0FBQ2MsT0FBUixDQUFnQnhFLE1BQWhCLENBQVA7QUFDSCxHQUpEO0FBS0g7O0FBQ0QsTUFBTTRzQywwQ0FBMEMsR0FBRzduQyxtREFBTSxDQUFDLEVBQUQsRUFBS3NuQywyQkFBTCxFQUFrQztBQUN2RmpzQyxLQUFHLENBQUNKLE1BQUQsRUFBU0UsR0FBVCxFQUFjO0FBQ2I7QUFDQSxRQUFJQSxHQUFHLEtBQUtyQyxNQUFNLENBQUNndkMsV0FBbkIsRUFBZ0M7QUFDNUI7QUFDSDs7QUFDRCxXQUFPUiwyQkFBMkIsQ0FBQ2pzQyxHQUE1QixDQUFnQ0osTUFBaEMsRUFBd0NFLEdBQXhDLEVBQTZDRixNQUE3QyxDQUFQO0FBQ0gsR0FQc0Y7O0FBUXZGUyxLQUFHLENBQUMyMkIsQ0FBRCxFQUFJbDNCLEdBQUosRUFBUztBQUNSLFVBQU1PLEdBQUcsR0FBR1AsR0FBRyxDQUFDLENBQUQsQ0FBSCxLQUFXLEdBQVgsSUFBa0IsQ0FBQzRzQyxrRUFBcUIsQ0FBQzVzQyxHQUFELENBQXBEOztBQUNBLFFBQUtwQyxLQUFELElBQTJDLENBQUMyQyxHQUE1QyxJQUFtRDRyQywyQkFBMkIsQ0FBQzVyQyxHQUE1QixDQUFnQzIyQixDQUFoQyxFQUFtQ2wzQixHQUFuQyxDQUF2RCxFQUFnRztBQUM1RjBFLFVBQUksQ0FBRSxZQUFXbUosSUFBSSxDQUFDQyxTQUFMLENBQWU5TixHQUFmLENBQW9CLHdFQUFqQyxDQUFKO0FBQ0g7O0FBQ0QsV0FBT08sR0FBUDtBQUNIOztBQWRzRixDQUFsQyxDQUF6RCxDLENBZ0JBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTc3NDLG1CQUFULENBQTZCL2dDLFFBQTdCLEVBQXVDO0FBQ25DLFFBQU1oTSxNQUFNLEdBQUcsRUFBZixDQURtQyxDQUVuQzs7QUFDQTRCLFFBQU0sQ0FBQ3d2QixjQUFQLENBQXNCcHhCLE1BQXRCLEVBQStCLEdBQS9CLEVBQW1DO0FBQy9CcXhCLGdCQUFZLEVBQUUsSUFEaUI7QUFFL0JDLGNBQVUsRUFBRSxLQUZtQjtBQUcvQmx4QixPQUFHLEVBQUUsTUFBTTRMO0FBSG9CLEdBQW5DLEVBSG1DLENBUW5DOztBQUNBcEssUUFBTSxDQUFDK0wsSUFBUCxDQUFZMjlCLG1CQUFaLEVBQWlDcHFDLE9BQWpDLENBQXlDaEIsR0FBRyxJQUFJO0FBQzVDMEIsVUFBTSxDQUFDd3ZCLGNBQVAsQ0FBc0JweEIsTUFBdEIsRUFBOEJFLEdBQTlCLEVBQW1DO0FBQy9CbXhCLGtCQUFZLEVBQUUsSUFEaUI7QUFFL0JDLGdCQUFVLEVBQUUsS0FGbUI7QUFHL0JseEIsU0FBRyxFQUFFLE1BQU1rckMsbUJBQW1CLENBQUNwckMsR0FBRCxDQUFuQixDQUF5QjhMLFFBQXpCLENBSG9CO0FBSS9CO0FBQ0E7QUFDQTNMLFNBQUcsRUFBRXFMLDZDQUFJQTtBQU5zQixLQUFuQztBQVFILEdBVEQ7QUFVQSxTQUFPMUwsTUFBUDtBQUNILEMsQ0FDRDs7O0FBQ0EsU0FBU2d0QywwQkFBVCxDQUFvQ2hoQyxRQUFwQyxFQUE4QztBQUMxQyxRQUFNO0FBQUUwTyxPQUFGO0FBQU83QyxnQkFBWSxFQUFFLENBQUNBLFlBQUQ7QUFBckIsTUFBd0M3TCxRQUE5Qzs7QUFDQSxNQUFJNkwsWUFBSixFQUFrQjtBQUNkalcsVUFBTSxDQUFDK0wsSUFBUCxDQUFZa0ssWUFBWixFQUEwQjNXLE9BQTFCLENBQWtDaEIsR0FBRyxJQUFJO0FBQ3JDMEIsWUFBTSxDQUFDd3ZCLGNBQVAsQ0FBc0IxVyxHQUF0QixFQUEyQnhhLEdBQTNCLEVBQWdDO0FBQzVCb3hCLGtCQUFVLEVBQUUsSUFEZ0I7QUFFNUJELG9CQUFZLEVBQUUsSUFGYztBQUc1Qmp4QixXQUFHLEVBQUUsTUFBTTRMLFFBQVEsQ0FBQ3lCLEtBQVQsQ0FBZXZOLEdBQWYsQ0FIaUI7QUFJNUJHLFdBQUcsRUFBRXFMLDZDQUFJQTtBQUptQixPQUFoQztBQU1ILEtBUEQ7QUFRSDtBQUNKLEMsQ0FDRDs7O0FBQ0EsU0FBU3VoQywrQkFBVCxDQUF5Q2poQyxRQUF6QyxFQUFtRDtBQUMvQyxRQUFNO0FBQUUwTyxPQUFGO0FBQU9nQjtBQUFQLE1BQXNCMVAsUUFBNUI7QUFDQXBLLFFBQU0sQ0FBQytMLElBQVAsQ0FBWTlLLHNEQUFLLENBQUM2WSxVQUFELENBQWpCLEVBQStCeGEsT0FBL0IsQ0FBdUNoQixHQUFHLElBQUk7QUFDMUMsUUFBSSxDQUFDd2IsVUFBVSxDQUFDNndCLGVBQVosS0FBZ0Nyc0MsR0FBRyxDQUFDLENBQUQsQ0FBSCxLQUFXLEdBQVgsSUFBa0JBLEdBQUcsQ0FBQyxDQUFELENBQUgsS0FBVyxHQUE3RCxDQUFKLEVBQXVFO0FBQ25FMEUsVUFBSSxDQUFFLDJCQUEwQm1KLElBQUksQ0FBQ0MsU0FBTCxDQUFlOU4sR0FBZixDQUFvQixvQ0FBL0MsR0FDQSxnREFERCxDQUFKO0FBRUE7QUFDSDs7QUFDRDBCLFVBQU0sQ0FBQ3d2QixjQUFQLENBQXNCMVcsR0FBdEIsRUFBMkJ4YSxHQUEzQixFQUFnQztBQUM1Qm94QixnQkFBVSxFQUFFLElBRGdCO0FBRTVCRCxrQkFBWSxFQUFFLElBRmM7QUFHNUJqeEIsU0FBRyxFQUFFLE1BQU1zYixVQUFVLENBQUN4YixHQUFELENBSE87QUFJNUJHLFNBQUcsRUFBRXFMLDZDQUFJQTtBQUptQixLQUFoQztBQU1ILEdBWkQ7QUFhSDs7QUFFRCxNQUFNd2hDLGVBQWUsR0FBR2hWLGdCQUFnQixFQUF4QztBQUNBLElBQUlpVixLQUFLLEdBQUcsQ0FBWjs7QUFDQSxTQUFTNUssdUJBQVQsQ0FBaUMxMkIsS0FBakMsRUFBd0NvQixNQUF4QyxFQUFnRG1ULFFBQWhELEVBQTBEO0FBQ3RELFFBQU1uZ0IsSUFBSSxHQUFHNEwsS0FBSyxDQUFDNUwsSUFBbkIsQ0FEc0QsQ0FFdEQ7O0FBQ0EsUUFBTWtNLFVBQVUsR0FBRyxDQUFDYyxNQUFNLEdBQUdBLE1BQU0sQ0FBQ2QsVUFBVixHQUF1Qk4sS0FBSyxDQUFDTSxVQUFwQyxLQUFtRCtnQyxlQUF0RTtBQUNBLFFBQU1saEMsUUFBUSxHQUFHO0FBQ2JuTixPQUFHLEVBQUVzdUMsS0FBSyxFQURHO0FBRWJ0aEMsU0FGYTtBQUdiNUwsUUFIYTtBQUliZ04sVUFKYTtBQUtiZCxjQUxhO0FBTWI4UCxRQUFJLEVBQUUsSUFOTztBQU9ibFYsUUFBSSxFQUFFLElBUE87QUFRYjBYLFdBQU8sRUFBRSxJQVJJO0FBU2J0SyxVQUFNLEVBQUUsSUFUSztBQVViSCxVQUFNLEVBQUUsSUFWSztBQVdickwsU0FBSyxFQUFFLElBWE07QUFZYmtwQixXQUFPLEVBQUUsSUFaSTtBQWFidWIsZUFBVyxFQUFFLElBYkE7QUFjYjl4QixhQUFTLEVBQUUsSUFkRTtBQWVidGEsV0FBTyxFQUFFLElBZkk7QUFnQmJnakIsWUFBUSxFQUFFL1csTUFBTSxHQUFHQSxNQUFNLENBQUMrVyxRQUFWLEdBQXFCcGlCLE1BQU0sQ0FBQzhVLE1BQVAsQ0FBY3ZLLFVBQVUsQ0FBQzZYLFFBQXpCLENBaEJ4QjtBQWlCYnNvQixlQUFXLEVBQUUsSUFqQkE7QUFrQmJwNEIsZUFBVyxFQUFFLEVBbEJBO0FBbUJiO0FBQ0E0YyxjQUFVLEVBQUUsSUFwQkM7QUFxQmJDLGNBQVUsRUFBRSxJQXJCQztBQXNCYjtBQUNBbFosZ0JBQVksRUFBRTJjLHFCQUFxQixDQUFDdjBCLElBQUQsRUFBT2tNLFVBQVAsQ0F2QnRCO0FBd0JieUwsZ0JBQVksRUFBRW9CLHFCQUFxQixDQUFDL1ksSUFBRCxFQUFPa00sVUFBUCxDQXhCdEI7QUF5QmI7QUFDQTJJLFFBQUksRUFBRSxJQTFCTztBQTJCYmlFLFdBQU8sRUFBRSxJQTNCSTtBQTRCYjtBQUNBdWEsaUJBQWEsRUFBRWoxQixrREE3QkY7QUE4QmI7QUFDQXNkLGdCQUFZLEVBQUUxYixJQUFJLENBQUMwYixZQS9CTjtBQWdDYjtBQUNBakIsT0FBRyxFQUFFcmMsa0RBakNRO0FBa0Nib2QsUUFBSSxFQUFFcGQsa0RBbENPO0FBbUNib1AsU0FBSyxFQUFFcFAsa0RBbkNNO0FBb0NibWQsU0FBSyxFQUFFbmQsa0RBcENNO0FBcUNia2QsU0FBSyxFQUFFbGQsa0RBckNNO0FBc0NiMi9CLFFBQUksRUFBRTMvQixrREF0Q087QUF1Q2JxZCxjQUFVLEVBQUVyZCxrREF2Q0M7QUF3Q2JndkMsZ0JBQVksRUFBRSxJQXhDRDtBQXlDYjtBQUNBanRCLFlBMUNhO0FBMkNicUMsY0FBVSxFQUFFckMsUUFBUSxHQUFHQSxRQUFRLENBQUNhLFNBQVosR0FBd0IsQ0EzQy9CO0FBNENic0IsWUFBUSxFQUFFLElBNUNHO0FBNkNiRyxpQkFBYSxFQUFFLEtBN0NGO0FBOENiO0FBQ0E7QUFDQTRDLGFBQVMsRUFBRSxLQWhERTtBQWlEYjNELGVBQVcsRUFBRSxLQWpEQTtBQWtEYjBLLGlCQUFhLEVBQUUsS0FsREY7QUFtRGJpaEIsTUFBRSxFQUFFLElBbkRTO0FBb0RiM3BCLEtBQUMsRUFBRSxJQXBEVTtBQXFEYmdmLE1BQUUsRUFBRSxJQXJEUztBQXNEYnJoQixLQUFDLEVBQUUsSUF0RFU7QUF1RGJ3aEIsTUFBRSxFQUFFLElBdkRTO0FBd0RiQyxLQUFDLEVBQUUsSUF4RFU7QUF5RGJ0aUIsTUFBRSxFQUFFLElBekRTO0FBMERiZ2xCLE9BQUcsRUFBRSxJQTFEUTtBQTJEYjlZLE1BQUUsRUFBRSxJQTNEUztBQTREYnBhLEtBQUMsRUFBRSxJQTVEVTtBQTZEYmlyQixPQUFHLEVBQUUsSUE3RFE7QUE4RGJELE9BQUcsRUFBRSxJQTlEUTtBQStEYnZ1QixNQUFFLEVBQUUsSUEvRFM7QUFnRWJ1K0IsTUFBRSxFQUFFO0FBaEVTLEdBQWpCOztBQWtFQSxNQUFLenZDLElBQUwsRUFBNkM7QUFDekNrTyxZQUFRLENBQUMwTyxHQUFULEdBQWVxeUIsbUJBQW1CLENBQUMvZ0MsUUFBRCxDQUFsQztBQUNILEdBRkQsTUFHSyxFQUVKOztBQUNEQSxVQUFRLENBQUNpUSxJQUFULEdBQWdCaFAsTUFBTSxHQUFHQSxNQUFNLENBQUNnUCxJQUFWLEdBQWlCalEsUUFBdkM7QUFDQUEsVUFBUSxDQUFDOEksSUFBVCxHQUFnQkEsSUFBSSxDQUFDckUsSUFBTCxDQUFVLElBQVYsRUFBZ0J6RSxRQUFoQixDQUFoQjtBQUNBLFNBQU9BLFFBQVA7QUFDSDs7QUFDRCxJQUFJK1gsZUFBZSxHQUFHLElBQXRCOztBQUNBLE1BQU1sTixrQkFBa0IsR0FBRyxNQUFNa04sZUFBZSxJQUFJL0osd0JBQXBEOztBQUNBLE1BQU11VSxrQkFBa0IsR0FBSXZpQixRQUFELElBQWM7QUFDckMrWCxpQkFBZSxHQUFHL1gsUUFBbEI7QUFDSCxDQUZEOztBQUdBLE1BQU13aEMsWUFBWSxHQUFHLGFBQWM5ckMsb0RBQU8sQ0FBQyxnQkFBRCxDQUExQzs7QUFDQSxTQUFTODNCLHFCQUFULENBQStCdHJCLElBQS9CLEVBQXFDOUIsTUFBckMsRUFBNkM7QUFDekMsUUFBTXFoQyxjQUFjLEdBQUdyaEMsTUFBTSxDQUFDK3JCLFdBQVAsSUFBc0JDLDJDQUE3Qzs7QUFDQSxNQUFJb1YsWUFBWSxDQUFDdC9CLElBQUQsQ0FBWixJQUFzQnUvQixjQUFjLENBQUN2L0IsSUFBRCxDQUF4QyxFQUFnRDtBQUM1Q3RKLFFBQUksQ0FBQyxvRUFBb0VzSixJQUFyRSxDQUFKO0FBQ0g7QUFDSjs7QUFDRCxTQUFTbTlCLG1CQUFULENBQTZCci9CLFFBQTdCLEVBQXVDO0FBQ25DLFNBQU9BLFFBQVEsQ0FBQ0gsS0FBVCxDQUFlZ1EsU0FBZixHQUEyQjtBQUFFO0FBQXBDO0FBQ0g7O0FBQ0QsSUFBSStTLHFCQUFxQixHQUFHLEtBQTVCOztBQUNBLFNBQVM0VCxjQUFULENBQXdCeDJCLFFBQXhCLEVBQWtDb25CLEtBQUssR0FBRyxLQUExQyxFQUFpRDtBQUM3Q3hFLHVCQUFxQixHQUFHd0UsS0FBeEI7QUFDQSxRQUFNO0FBQUUzbEIsU0FBRjtBQUFTeVA7QUFBVCxNQUFzQmxSLFFBQVEsQ0FBQ0gsS0FBckM7QUFDQSxRQUFNc25CLFVBQVUsR0FBR2tZLG1CQUFtQixDQUFDci9CLFFBQUQsQ0FBdEM7QUFDQWtuQixXQUFTLENBQUNsbkIsUUFBRCxFQUFXeUIsS0FBWCxFQUFrQjBsQixVQUFsQixFQUE4QkMsS0FBOUIsQ0FBVDtBQUNBK0QsV0FBUyxDQUFDbnJCLFFBQUQsRUFBV2tSLFFBQVgsQ0FBVDtBQUNBLFFBQU13d0IsV0FBVyxHQUFHdmEsVUFBVSxHQUN4QndhLHNCQUFzQixDQUFDM2hDLFFBQUQsRUFBV29uQixLQUFYLENBREUsR0FFeEJ0ekIsU0FGTjtBQUdBOHVCLHVCQUFxQixHQUFHLEtBQXhCO0FBQ0EsU0FBTzhlLFdBQVA7QUFDSDs7QUFDRCxTQUFTQyxzQkFBVCxDQUFnQzNoQyxRQUFoQyxFQUEwQ29uQixLQUExQyxFQUFpRDtBQUM3QyxRQUFNL1gsU0FBUyxHQUFHclAsUUFBUSxDQUFDL0wsSUFBM0I7O0FBQ0EsTUFBS25DLElBQUwsRUFBNkM7QUFDekMsUUFBSXVkLFNBQVMsQ0FBQ25OLElBQWQsRUFBb0I7QUFDaEJzckIsMkJBQXFCLENBQUNuZSxTQUFTLENBQUNuTixJQUFYLEVBQWlCbEMsUUFBUSxDQUFDRyxVQUFULENBQW9CQyxNQUFyQyxDQUFyQjtBQUNIOztBQUNELFFBQUlpUCxTQUFTLENBQUN5VixVQUFkLEVBQTBCO0FBQ3RCLFlBQU04YyxLQUFLLEdBQUdoc0MsTUFBTSxDQUFDK0wsSUFBUCxDQUFZME4sU0FBUyxDQUFDeVYsVUFBdEIsQ0FBZDs7QUFDQSxXQUFLLElBQUl0eEIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR291QyxLQUFLLENBQUN4dUMsTUFBMUIsRUFBa0NJLENBQUMsRUFBbkMsRUFBdUM7QUFDbkNnNkIsNkJBQXFCLENBQUNvVSxLQUFLLENBQUNwdUMsQ0FBRCxDQUFOLEVBQVd3TSxRQUFRLENBQUNHLFVBQVQsQ0FBb0JDLE1BQS9CLENBQXJCO0FBQ0g7QUFDSjs7QUFDRCxRQUFJaVAsU0FBUyxDQUFDMFYsVUFBZCxFQUEwQjtBQUN0QixZQUFNNmMsS0FBSyxHQUFHaHNDLE1BQU0sQ0FBQytMLElBQVAsQ0FBWTBOLFNBQVMsQ0FBQzBWLFVBQXRCLENBQWQ7O0FBQ0EsV0FBSyxJQUFJdnhCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdvdUMsS0FBSyxDQUFDeHVDLE1BQTFCLEVBQWtDSSxDQUFDLEVBQW5DLEVBQXVDO0FBQ25DaTRCLDZCQUFxQixDQUFDbVcsS0FBSyxDQUFDcHVDLENBQUQsQ0FBTixDQUFyQjtBQUNIO0FBQ0o7O0FBQ0QsUUFBSTZiLFNBQVMsQ0FBQ2tkLGVBQVYsSUFBNkJwaUIsYUFBYSxFQUE5QyxFQUFrRDtBQUM5Q3ZSLFVBQUksQ0FBRSxxRUFBRCxHQUNBLG9FQURBLEdBRUEseUVBRkQsQ0FBSjtBQUdIO0FBQ0osR0F2QjRDLENBd0I3Qzs7O0FBQ0FvSCxVQUFRLENBQUNzZ0MsV0FBVCxHQUF1QjFxQyxNQUFNLENBQUM4VSxNQUFQLENBQWMsSUFBZCxDQUF2QixDQXpCNkMsQ0EwQjdDO0FBQ0E7O0FBQ0ExSyxVQUFRLENBQUNyRCxLQUFULEdBQWlCSSx3REFBTyxDQUFDLElBQUlILEtBQUosQ0FBVW9ELFFBQVEsQ0FBQzBPLEdBQW5CLEVBQXdCMnhCLDJCQUF4QixDQUFELENBQXhCOztBQUNBLE1BQUt2dUMsSUFBTCxFQUE2QztBQUN6Q2t2Qyw4QkFBMEIsQ0FBQ2hoQyxRQUFELENBQTFCO0FBQ0gsR0EvQjRDLENBZ0M3Qzs7O0FBQ0EsUUFBTTtBQUFFeWI7QUFBRixNQUFZcE0sU0FBbEI7O0FBQ0EsTUFBSW9NLEtBQUosRUFBVztBQUNQLFVBQU00bEIsWUFBWSxHQUFJcmhDLFFBQVEsQ0FBQ3FoQyxZQUFULEdBQ2xCNWxCLEtBQUssQ0FBQ3JvQixNQUFOLEdBQWUsQ0FBZixHQUFtQnl1QyxrQkFBa0IsQ0FBQzdoQyxRQUFELENBQXJDLEdBQWtELElBRHREO0FBRUErWCxtQkFBZSxHQUFHL1gsUUFBbEI7QUFDQXBNLGtFQUFhO0FBQ2IsVUFBTTh0QyxXQUFXLEdBQUdsaEMscUJBQXFCLENBQUNpYixLQUFELEVBQVF6YixRQUFSLEVBQWtCO0FBQUU7QUFBcEIsTUFBMEMsQ0FBRWxPLEtBQUQsR0FBMEN1SyxnRUFBZSxDQUFDMkQsUUFBUSxDQUFDeUIsS0FBVixDQUF6RCxHQUE0RXpCLENBQTdFLEVBQTZGcWhDLFlBQTdGLENBQTFDLENBQXpDO0FBQ0FsdUMsa0VBQWE7QUFDYjRrQixtQkFBZSxHQUFHLElBQWxCOztBQUNBLFFBQUl4VixzREFBVyxDQUFDbS9CLFdBQUQsQ0FBZixFQUE4QjtBQUMxQixZQUFNSSxhQUFhLEdBQUcsTUFBTTtBQUN4Qi9wQix1QkFBZSxHQUFHLElBQWxCO0FBQ0gsT0FGRDs7QUFHQTJwQixpQkFBVyxDQUFDbDlCLElBQVosQ0FBaUJzOUIsYUFBakIsRUFBZ0NBLGFBQWhDOztBQUNBLFVBQUkxYSxLQUFKLEVBQVc7QUFDUDtBQUNBLGVBQU9zYSxXQUFXLENBQ2JsOUIsSUFERSxDQUNJdTlCLGNBQUQsSUFBb0I7QUFDMUJwckIsMkJBQWlCLENBQUMzVyxRQUFELEVBQVcraEMsY0FBWCxFQUEyQjNhLEtBQTNCLENBQWpCO0FBQ0gsU0FITSxFQUlGNWtCLEtBSkUsQ0FJSStGLENBQUMsSUFBSTtBQUNabEcscUJBQVcsQ0FBQ2tHLENBQUQsRUFBSXZJLFFBQUosRUFBYztBQUFFO0FBQWhCLFdBQVg7QUFDSCxTQU5NLENBQVA7QUFPSCxPQVRELE1BVUs7QUFDRDtBQUNBO0FBQ0FBLGdCQUFRLENBQUN1VyxRQUFULEdBQW9CbXJCLFdBQXBCO0FBQ0g7QUFDSixLQXBCRCxNQXFCSztBQUNEL3FCLHVCQUFpQixDQUFDM1csUUFBRCxFQUFXMGhDLFdBQVgsRUFBd0J0YSxLQUF4QixDQUFqQjtBQUNIO0FBQ0osR0FoQ0QsTUFpQ0s7QUFDRDRhLHdCQUFvQixDQUFDaGlDLFFBQUQsRUFBV29uQixLQUFYLENBQXBCO0FBQ0g7QUFDSjs7QUFDRCxTQUFTelEsaUJBQVQsQ0FBMkIzVyxRQUEzQixFQUFxQzBoQyxXQUFyQyxFQUFrRHRhLEtBQWxELEVBQXlEO0FBQ3JELE1BQUlubEIsdURBQVksQ0FBQ3kvQixXQUFELENBQWhCLEVBQStCO0FBQzNCO0FBQ0E7QUFDSTFoQyxjQUFRLENBQUNnSSxNQUFULEdBQWtCMDVCLFdBQWxCO0FBQ0g7QUFDSixHQUxELE1BTUssSUFBSTVuQixxREFBVSxDQUFDNG5CLFdBQUQsQ0FBZCxFQUE2QjtBQUM5QixRQUFLNXZDLEtBQUQsSUFBMkM0ZixPQUFPLENBQUNnd0IsV0FBRCxDQUF0RCxFQUFxRTtBQUNqRTlvQyxVQUFJLENBQUUsOENBQUQsR0FDQSxtQ0FERCxDQUFKO0FBRUgsS0FKNkIsQ0FLOUI7QUFDQTs7O0FBQ0EsUUFBSzlHLElBQUwsRUFBc0U7QUFDbEVrTyxjQUFRLENBQUNpaUMscUJBQVQsR0FBaUNQLFdBQWpDO0FBQ0g7O0FBQ0QxaEMsWUFBUSxDQUFDMFAsVUFBVCxHQUFzQnZSLDBEQUFTLENBQUN1akMsV0FBRCxDQUEvQjs7QUFDQSxRQUFLNXZDLElBQUwsRUFBNkM7QUFDekNtdkMscUNBQStCLENBQUNqaEMsUUFBRCxDQUEvQjtBQUNIO0FBQ0osR0FkSSxNQWVBLElBQUtsTyxLQUFELElBQTJDNHZDLFdBQVcsS0FBSzV0QyxTQUEvRCxFQUEwRTtBQUMzRThFLFFBQUksQ0FBRSw4Q0FBNkM4b0MsV0FBVyxLQUFLLElBQWhCLEdBQXVCLE1BQXZCLEdBQWdDLE9BQU9BLFdBQVksRUFBbEcsQ0FBSjtBQUNIOztBQUNETSxzQkFBb0IsQ0FBQ2hpQyxRQUFELEVBQVdvbkIsS0FBWCxDQUFwQjtBQUNIOztBQUNELElBQUk4YSxPQUFKLEMsQ0FDQTs7QUFDQSxNQUFNLzNCLGFBQWEsR0FBRyxNQUFNLENBQUMrM0IsT0FBN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU0MsdUJBQVQsQ0FBaUNDLFFBQWpDLEVBQTJDO0FBQ3ZDRixTQUFPLEdBQUdFLFFBQVY7QUFDSDs7QUFDRCxTQUFTSixvQkFBVCxDQUE4QmhpQyxRQUE5QixFQUF3Q29uQixLQUF4QyxFQUErQ2liLFdBQS9DLEVBQTREO0FBQ3hELFFBQU1oekIsU0FBUyxHQUFHclAsUUFBUSxDQUFDL0wsSUFBM0IsQ0FEd0QsQ0FFeEQ7O0FBQ0EsTUFBSSxDQUFDK0wsUUFBUSxDQUFDZ0ksTUFBZCxFQUFzQjtBQUNsQjtBQUNBLFFBQUlrNkIsT0FBTyxJQUFJLENBQUM3eUIsU0FBUyxDQUFDckgsTUFBMUIsRUFBa0M7QUFDOUIsWUFBTXM2QixRQUFRLEdBQUdqekIsU0FBUyxDQUFDaXpCLFFBQTNCOztBQUNBLFVBQUlBLFFBQUosRUFBYztBQUNWLFlBQUt4d0MsSUFBTCxFQUE2QztBQUN6QzIrQixzQkFBWSxDQUFDendCLFFBQUQsRUFBWSxTQUFaLENBQVo7QUFDSDs7QUFDRCxjQUFNO0FBQUV1aUMseUJBQUY7QUFBbUJoVztBQUFuQixZQUF1Q3ZzQixRQUFRLENBQUNHLFVBQVQsQ0FBb0JDLE1BQWpFO0FBQ0EsY0FBTTtBQUFFb2lDLG9CQUFGO0FBQWNqVyx5QkFBZSxFQUFFa1c7QUFBL0IsWUFBNERwekIsU0FBbEU7QUFDQSxjQUFNcXpCLG9CQUFvQixHQUFHM3BDLG1EQUFNLENBQUNBLG1EQUFNLENBQUM7QUFDdkN3cEMseUJBRHVDO0FBRXZDQztBQUZ1QyxTQUFELEVBR3ZDalcsZUFIdUMsQ0FBUCxFQUdka1csd0JBSGMsQ0FBbkM7QUFJQXB6QixpQkFBUyxDQUFDckgsTUFBVixHQUFtQms2QixPQUFPLENBQUNJLFFBQUQsRUFBV0ksb0JBQVgsQ0FBMUI7O0FBQ0EsWUFBSzV3QyxJQUFMLEVBQTZDO0FBQ3pDZy9CLG9CQUFVLENBQUM5d0IsUUFBRCxFQUFZLFNBQVosQ0FBVjtBQUNIO0FBQ0o7QUFDSjs7QUFDREEsWUFBUSxDQUFDZ0ksTUFBVCxHQUFtQnFILFNBQVMsQ0FBQ3JILE1BQVYsSUFBb0J0SSw2Q0FBdkMsQ0FwQmtCLENBcUJsQjtBQUNBO0FBQ0E7O0FBQ0EsUUFBSU0sUUFBUSxDQUFDZ0ksTUFBVCxDQUFnQjI2QixHQUFwQixFQUF5QjtBQUNyQjNpQyxjQUFRLENBQUNzUCxTQUFULEdBQXFCLElBQUkxUyxLQUFKLENBQVVvRCxRQUFRLENBQUMwTyxHQUFuQixFQUF3Qmt5QiwwQ0FBeEIsQ0FBckI7QUFDSDtBQUNKLEdBOUJ1RCxDQStCeEQ7OztBQUNBLE1BQUlwekIsSUFBSixFQUFzQztBQUNsQ3VLLG1CQUFlLEdBQUcvWCxRQUFsQjtBQUNBcE0sa0VBQWE7QUFDYnl2QixnQkFBWSxDQUFDcmpCLFFBQUQsQ0FBWjtBQUNBN00sa0VBQWE7QUFDYjRrQixtQkFBZSxHQUFHLElBQWxCO0FBQ0gsR0F0Q3VELENBdUN4RDtBQUNBOzs7QUFDQSxNQUFLam1CLEtBQUQsSUFBMkMsQ0FBQ3VkLFNBQVMsQ0FBQ3JILE1BQXRELElBQWdFaEksUUFBUSxDQUFDZ0ksTUFBVCxLQUFvQnRJLDZDQUFwRixJQUE0RixDQUFDMG5CLEtBQWpHLEVBQXdHO0FBQ3BHO0FBQ0EsUUFBSSxDQUFDOGEsT0FBRCxJQUFZN3lCLFNBQVMsQ0FBQ2l6QixRQUExQixFQUFvQztBQUNoQzFwQyxVQUFJLENBQUUseUNBQUQsR0FDQSw0REFEQSxHQUVDO0FBQ0k7QUFITixPQUFKO0FBSUgsS0FMRCxNQU1LO0FBQ0RBLFVBQUksQ0FBRSxtREFBRixDQUFKO0FBQ0g7QUFDSjtBQUNKOztBQUNELE1BQU1ncUMsb0JBQW9CLEdBQUc7QUFDekJ4dUMsS0FBRyxFQUFFLENBQUNKLE1BQUQsRUFBU0UsR0FBVCxLQUFpQjtBQUNsQmliLHFCQUFpQjtBQUNqQixXQUFPbmIsTUFBTSxDQUFDRSxHQUFELENBQWI7QUFDSCxHQUp3QjtBQUt6QkcsS0FBRyxFQUFFLE1BQU07QUFDUHVFLFFBQUksQ0FBRSxpQ0FBRixDQUFKO0FBQ0EsV0FBTyxLQUFQO0FBQ0gsR0FSd0I7QUFTekJMLGdCQUFjLEVBQUUsTUFBTTtBQUNsQkssUUFBSSxDQUFFLGlDQUFGLENBQUo7QUFDQSxXQUFPLEtBQVA7QUFDSDtBQVp3QixDQUE3Qjs7QUFjQSxTQUFTaXBDLGtCQUFULENBQTRCN2hDLFFBQTVCLEVBQXNDO0FBQ2xDLFFBQU02a0IsTUFBTSxHQUFHZ0IsT0FBTyxJQUFJO0FBQ3RCLFFBQUsvekIsS0FBRCxJQUEyQ2tPLFFBQVEsQ0FBQzZsQixPQUF4RCxFQUFpRTtBQUM3RGp0QixVQUFJLENBQUUsa0RBQUYsQ0FBSjtBQUNIOztBQUNEb0gsWUFBUSxDQUFDNmxCLE9BQVQsR0FBbUJBLE9BQU8sSUFBSSxFQUE5QjtBQUNILEdBTEQ7O0FBTUEsTUFBSy96QixJQUFMLEVBQTZDO0FBQ3pDLFFBQUkwZCxLQUFKLENBRHlDLENBRXpDO0FBQ0E7O0FBQ0EsV0FBTzVaLE1BQU0sQ0FBQ2l0QyxNQUFQLENBQWM7QUFDakIsVUFBSXJ6QixLQUFKLEdBQVk7QUFDUixlQUFRQSxLQUFLLEtBQUtBLEtBQUssR0FBRyxJQUFJNVMsS0FBSixDQUFVb0QsUUFBUSxDQUFDd1AsS0FBbkIsRUFBMEJvekIsb0JBQTFCLENBQWIsQ0FBYjtBQUNILE9BSGdCOztBQUlqQixVQUFJcnpCLEtBQUosR0FBWTtBQUNSLGVBQU9sVCxnRUFBZSxDQUFDMkQsUUFBUSxDQUFDdVAsS0FBVixDQUF0QjtBQUNILE9BTmdCOztBQU9qQixVQUFJekcsSUFBSixHQUFXO0FBQ1AsZUFBTyxDQUFDZ0IsS0FBRCxFQUFRLEdBQUduVCxJQUFYLEtBQW9CcUosUUFBUSxDQUFDOEksSUFBVCxDQUFjZ0IsS0FBZCxFQUFxQixHQUFHblQsSUFBeEIsQ0FBM0I7QUFDSCxPQVRnQjs7QUFVakJrdUI7QUFWaUIsS0FBZCxDQUFQO0FBWUgsR0FoQkQsTUFpQkssRUFPSjtBQUNKOztBQUNELFNBQVNnTixjQUFULENBQXdCN3hCLFFBQXhCLEVBQWtDO0FBQzlCLE1BQUlBLFFBQVEsQ0FBQzZsQixPQUFiLEVBQXNCO0FBQ2xCLFdBQVE3bEIsUUFBUSxDQUFDb2hDLFdBQVQsS0FDSHBoQyxRQUFRLENBQUNvaEMsV0FBVCxHQUF1QixJQUFJeGtDLEtBQUosQ0FBVXVCLDBEQUFTLENBQUNwQix3REFBTyxDQUFDaUQsUUFBUSxDQUFDNmxCLE9BQVYsQ0FBUixDQUFuQixFQUFnRDtBQUNwRXp4QixTQUFHLENBQUNKLE1BQUQsRUFBU0UsR0FBVCxFQUFjO0FBQ2IsWUFBSUEsR0FBRyxJQUFJRixNQUFYLEVBQW1CO0FBQ2YsaUJBQU9BLE1BQU0sQ0FBQ0UsR0FBRCxDQUFiO0FBQ0gsU0FGRCxNQUdLLElBQUlBLEdBQUcsSUFBSW9yQyxtQkFBWCxFQUFnQztBQUNqQyxpQkFBT0EsbUJBQW1CLENBQUNwckMsR0FBRCxDQUFuQixDQUF5QjhMLFFBQXpCLENBQVA7QUFDSDtBQUNKOztBQVJtRSxLQUFoRCxDQURwQixDQUFSO0FBV0g7QUFDSixDLENBQ0Q7QUFDQTs7O0FBQ0EsU0FBU3VaLHlCQUFULENBQW1DcG5CLE1BQW5DLEVBQTJDNk4sUUFBUSxHQUFHK1gsZUFBdEQsRUFBdUU7QUFDbkUsTUFBSS9YLFFBQUosRUFBYztBQUNWLEtBQUNBLFFBQVEsQ0FBQ2hMLE9BQVQsS0FBcUJnTCxRQUFRLENBQUNoTCxPQUFULEdBQW1CLEVBQXhDLENBQUQsRUFBOEMvQixJQUE5QyxDQUFtRGQsTUFBbkQ7QUFDSDtBQUNKOztBQUNELE1BQU0yd0MsVUFBVSxHQUFHLGlCQUFuQjs7QUFDQSxNQUFNQyxRQUFRLEdBQUlDLEdBQUQsSUFBU0EsR0FBRyxDQUFDajFCLE9BQUosQ0FBWSswQixVQUFaLEVBQXdCbnJCLENBQUMsSUFBSUEsQ0FBQyxDQUFDc3JCLFdBQUYsRUFBN0IsRUFBOENsMUIsT0FBOUMsQ0FBc0QsT0FBdEQsRUFBK0QsRUFBL0QsQ0FBMUI7O0FBQ0EsU0FBU2xILGdCQUFULENBQTBCd0ksU0FBMUIsRUFBcUM7QUFDakMsU0FBT3BOLHVEQUFZLENBQUNvTixTQUFELENBQVosR0FDREEsU0FBUyxDQUFDNnpCLFdBQVYsSUFBeUI3ekIsU0FBUyxDQUFDbk4sSUFEbEMsR0FFRG1OLFNBQVMsQ0FBQ25OLElBRmhCO0FBR0g7QUFDRDs7O0FBQ0EsU0FBU3hCLG1CQUFULENBQTZCVixRQUE3QixFQUF1Q3FQLFNBQXZDLEVBQWtEL04sTUFBTSxHQUFHLEtBQTNELEVBQWtFO0FBQzlELE1BQUlZLElBQUksR0FBRzJFLGdCQUFnQixDQUFDd0ksU0FBRCxDQUEzQjs7QUFDQSxNQUFJLENBQUNuTixJQUFELElBQVNtTixTQUFTLENBQUM4ekIsTUFBdkIsRUFBK0I7QUFDM0IsVUFBTS9aLEtBQUssR0FBRy9aLFNBQVMsQ0FBQzh6QixNQUFWLENBQWlCL1osS0FBakIsQ0FBdUIsaUJBQXZCLENBQWQ7O0FBQ0EsUUFBSUEsS0FBSixFQUFXO0FBQ1BsbkIsVUFBSSxHQUFHa25CLEtBQUssQ0FBQyxDQUFELENBQVo7QUFDSDtBQUNKOztBQUNELE1BQUksQ0FBQ2xuQixJQUFELElBQVNsQyxRQUFULElBQXFCQSxRQUFRLENBQUNpQixNQUFsQyxFQUEwQztBQUN0QztBQUNBLFVBQU1taUMsaUJBQWlCLEdBQUlqSCxRQUFELElBQWM7QUFDcEMsV0FBSyxNQUFNam9DLEdBQVgsSUFBa0Jpb0MsUUFBbEIsRUFBNEI7QUFDeEIsWUFBSUEsUUFBUSxDQUFDam9DLEdBQUQsQ0FBUixLQUFrQm1iLFNBQXRCLEVBQWlDO0FBQzdCLGlCQUFPbmIsR0FBUDtBQUNIO0FBQ0o7QUFDSixLQU5EOztBQU9BZ08sUUFBSSxHQUNBa2hDLGlCQUFpQixDQUFDcGpDLFFBQVEsQ0FBQzhrQixVQUFULElBQ2Q5a0IsUUFBUSxDQUFDaUIsTUFBVCxDQUFnQmhOLElBQWhCLENBQXFCNndCLFVBRFIsQ0FBakIsSUFDd0NzZSxpQkFBaUIsQ0FBQ3BqQyxRQUFRLENBQUNHLFVBQVQsQ0FBb0Iya0IsVUFBckIsQ0FGN0Q7QUFHSDs7QUFDRCxTQUFPNWlCLElBQUksR0FBRzZnQyxRQUFRLENBQUM3Z0MsSUFBRCxDQUFYLEdBQW9CWixNQUFNLEdBQUksS0FBSixHQUFZLFdBQWpEO0FBQ0g7O0FBQ0QsU0FBU3VHLGdCQUFULENBQTBCaFEsS0FBMUIsRUFBaUM7QUFDN0IsU0FBT29LLHVEQUFZLENBQUNwSyxLQUFELENBQVosSUFBdUIsZUFBZUEsS0FBN0M7QUFDSDs7QUFFRCxTQUFTeUgsUUFBVCxDQUFrQkMsZUFBbEIsRUFBbUM7QUFDL0IsUUFBTW9ZLENBQUMsR0FBRzByQix5REFBVSxDQUFDOWpDLGVBQUQsQ0FBcEI7QUFDQWdhLDJCQUF5QixDQUFDNUIsQ0FBQyxDQUFDeGxCLE1BQUgsQ0FBekI7QUFDQSxTQUFPd2xCLENBQVA7QUFDSDs7QUFFQTdsQixLQUFELEdBQ004RCxNQUFNLENBQUNpdEMsTUFBUCxDQUFjLEVBQWQsQ0FETixHQUVNLENBRk47QUFHQy93QyxLQUFELEdBQTBDOEQsTUFBTSxDQUFDaXRDLE1BQVAsQ0FBYyxFQUFkLENBQTFDLEdBQThELENBQTlEOztBQUNBLE1BQU1wakMsVUFBVSxHQUFJdkMsR0FBRCxJQUFTLE9BQU9BLEdBQVAsS0FBZSxVQUEzQzs7QUFDQSxNQUFNcEYsUUFBUSxHQUFJb0YsR0FBRCxJQUFTQSxHQUFHLEtBQUssSUFBUixJQUFnQixPQUFPQSxHQUFQLEtBQWUsUUFBekQ7O0FBQ0EsTUFBTW9tQyxTQUFTLEdBQUlwbUMsR0FBRCxJQUFTO0FBQ3ZCLFNBQU9wRixRQUFRLENBQUNvRixHQUFELENBQVIsSUFBaUJ1QyxVQUFVLENBQUN2QyxHQUFHLENBQUNzSCxJQUFMLENBQTNCLElBQXlDL0UsVUFBVSxDQUFDdkMsR0FBRyxDQUFDc0YsS0FBTCxDQUExRDtBQUNILENBRkQsQyxDQUlBOzs7QUFDQSxNQUFNK2dDLGdCQUFnQixHQUFJL3NDLE1BQUQsSUFBWW9DLElBQUksQ0FBRSxHQUFFcEMsTUFBTywwREFBVixHQUNyQyxxRUFEcUMsR0FFckMsd0RBRm9DLENBQXpDLEMsQ0FHQTs7O0FBQ0EsU0FBU2d0QyxXQUFULEdBQXVCO0FBQ25CLE1BQUsxeEMsSUFBTCxFQUE2QztBQUN6Q3l4QyxvQkFBZ0IsQ0FBRSxhQUFGLENBQWhCO0FBQ0g7O0FBQ0QsU0FBTyxJQUFQO0FBQ0gsQyxDQUNEOzs7QUFDQSxTQUFTRSxXQUFULEdBQXVCO0FBQ25CLE1BQUszeEMsSUFBTCxFQUE2QztBQUN6Q3l4QyxvQkFBZ0IsQ0FBRSxhQUFGLENBQWhCO0FBQ0g7O0FBQ0QsU0FBTyxJQUFQO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7OztBQUNBLE1BQU1HLFVBQVUsR0FBR0QsV0FBbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBU0UsWUFBVCxDQUFzQjlkLE9BQXRCLEVBQStCO0FBQzNCLE1BQUsvekIsSUFBTCxFQUE2QztBQUN6Q3l4QyxvQkFBZ0IsQ0FBRSxjQUFGLENBQWhCO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU0ssWUFBVCxDQUFzQm5pQyxLQUF0QixFQUE2Qm9pQyxRQUE3QixFQUF1QztBQUNuQyxNQUFLL3hDLElBQUwsRUFBNkM7QUFDekN5eEMsb0JBQWdCLENBQUUsY0FBRixDQUFoQjtBQUNIOztBQUNELFNBQU8sSUFBUDtBQUNIO0FBQ0Q7QUFDQTtBQUNBOzs7QUFDQSxTQUFTTyxVQUFULEdBQXNCO0FBQ2xCLE1BQUtoeUMsSUFBTCxFQUE2QztBQUN6QzhHLFFBQUksQ0FBRSxrRUFBRCxHQUNBLG9FQURELENBQUo7QUFFSDs7QUFDRCxTQUFPbXJDLFVBQVUsRUFBakI7QUFDSDs7QUFDRCxTQUFTQyxRQUFULEdBQW9CO0FBQ2hCLFNBQU9ELFVBQVUsR0FBR3gwQixLQUFwQjtBQUNIOztBQUNELFNBQVMwMEIsUUFBVCxHQUFvQjtBQUNoQixTQUFPRixVQUFVLEdBQUd2MEIsS0FBcEI7QUFDSDs7QUFDRCxTQUFTdTBCLFVBQVQsR0FBc0I7QUFDbEIsUUFBTXZ3QyxDQUFDLEdBQUdxWCxrQkFBa0IsRUFBNUI7O0FBQ0EsTUFBSy9ZLEtBQUQsSUFBMkMsQ0FBQzBCLENBQWhELEVBQW1EO0FBQy9Db0YsUUFBSSxDQUFFLDhDQUFGLENBQUo7QUFDSDs7QUFDRCxTQUFPcEYsQ0FBQyxDQUFDNnRDLFlBQUYsS0FBbUI3dEMsQ0FBQyxDQUFDNnRDLFlBQUYsR0FBaUJRLGtCQUFrQixDQUFDcnVDLENBQUQsQ0FBdEQsQ0FBUDtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUzB3QyxhQUFULEVBQ0E7QUFDQXppQyxLQUZBLEVBRU9vaUMsUUFGUCxFQUVpQjtBQUNiLE9BQUssTUFBTTN2QyxHQUFYLElBQWtCMnZDLFFBQWxCLEVBQTRCO0FBQ3hCLFVBQU0zbUMsR0FBRyxHQUFHdUUsS0FBSyxDQUFDdk4sR0FBRCxDQUFqQjs7QUFDQSxRQUFJZ0osR0FBSixFQUFTO0FBQ0xBLFNBQUcsQ0FBQ2lhLE9BQUosR0FBYzBzQixRQUFRLENBQUMzdkMsR0FBRCxDQUF0QjtBQUNILEtBRkQsTUFHSyxJQUFJZ0osR0FBRyxLQUFLLElBQVosRUFBa0I7QUFDbkJ1RSxXQUFLLENBQUN2TixHQUFELENBQUwsR0FBYTtBQUFFaWpCLGVBQU8sRUFBRTBzQixRQUFRLENBQUMzdkMsR0FBRDtBQUFuQixPQUFiO0FBQ0gsS0FGSSxNQUdBLElBQUtwQyxJQUFMLEVBQTZDO0FBQzlDOEcsVUFBSSxDQUFFLHNCQUFxQjFFLEdBQUkscUNBQTNCLENBQUo7QUFDSDtBQUNKOztBQUNELFNBQU91TixLQUFQO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUzBpQyxnQkFBVCxDQUEwQkMsU0FBMUIsRUFBcUM7QUFDakMsUUFBTTExQixHQUFHLEdBQUc3RCxrQkFBa0IsRUFBOUI7QUFDQTBYLG9CQUFrQixDQUFDLElBQUQsQ0FBbEIsQ0FGaUMsQ0FFUDs7QUFDMUIsTUFBS3p3QixLQUFELElBQTJDLENBQUM0YyxHQUFoRCxFQUFxRDtBQUNqRDlWLFFBQUksQ0FBRSxxRUFBRixDQUFKO0FBQ0g7O0FBQ0QsU0FBTzBxQyxTQUFTLENBQUNjLFNBQUQsQ0FBVCxHQUNEQSxTQUFTLENBQUM1L0IsSUFBVixDQUFlek4sR0FBRyxJQUFJO0FBQ3BCd3JCLHNCQUFrQixDQUFDN1QsR0FBRCxDQUFsQjtBQUNBLFdBQU8zWCxHQUFQO0FBQ0gsR0FIQyxFQUdDcUwsR0FBRyxJQUFJO0FBQ05tZ0Isc0JBQWtCLENBQUM3VCxHQUFELENBQWxCO0FBQ0EsVUFBTXRNLEdBQU47QUFDSCxHQU5DLENBREMsR0FRRGdpQyxTQVJOO0FBU0gsQyxDQUVEOzs7QUFDQSxTQUFTcmUsQ0FBVCxDQUFXOXhCLElBQVgsRUFBaUJvd0MsZUFBakIsRUFBa0NuekIsUUFBbEMsRUFBNEM7QUFDeEMsUUFBTXBhLENBQUMsR0FBR3VoQixTQUFTLENBQUNqbEIsTUFBcEI7O0FBQ0EsTUFBSTBELENBQUMsS0FBSyxDQUFWLEVBQWE7QUFDVCxRQUFJZ2pCLHFEQUFVLENBQUN1cUIsZUFBRCxDQUFWLElBQStCLENBQUNsdkMsb0RBQU8sQ0FBQ2t2QyxlQUFELENBQTNDLEVBQThEO0FBQzFEO0FBQ0EsVUFBSTN5QixPQUFPLENBQUMyeUIsZUFBRCxDQUFYLEVBQThCO0FBQzFCLGVBQU9yekIsV0FBVyxDQUFDL2MsSUFBRCxFQUFPLElBQVAsRUFBYSxDQUFDb3dDLGVBQUQsQ0FBYixDQUFsQjtBQUNILE9BSnlELENBSzFEOzs7QUFDQSxhQUFPcnpCLFdBQVcsQ0FBQy9jLElBQUQsRUFBT293QyxlQUFQLENBQWxCO0FBQ0gsS0FQRCxNQVFLO0FBQ0Q7QUFDQSxhQUFPcnpCLFdBQVcsQ0FBQy9jLElBQUQsRUFBTyxJQUFQLEVBQWFvd0MsZUFBYixDQUFsQjtBQUNIO0FBQ0osR0FiRCxNQWNLO0FBQ0QsUUFBSXZ0QyxDQUFDLEdBQUcsQ0FBUixFQUFXO0FBQ1BvYSxjQUFRLEdBQUd6YSxLQUFLLENBQUNDLFNBQU4sQ0FBZ0JrTCxLQUFoQixDQUFzQmhJLElBQXRCLENBQTJCeWUsU0FBM0IsRUFBc0MsQ0FBdEMsQ0FBWDtBQUNILEtBRkQsTUFHSyxJQUFJdmhCLENBQUMsS0FBSyxDQUFOLElBQVc0YSxPQUFPLENBQUNSLFFBQUQsQ0FBdEIsRUFBa0M7QUFDbkNBLGNBQVEsR0FBRyxDQUFDQSxRQUFELENBQVg7QUFDSDs7QUFDRCxXQUFPRixXQUFXLENBQUMvYyxJQUFELEVBQU9vd0MsZUFBUCxFQUF3Qm56QixRQUF4QixDQUFsQjtBQUNIO0FBQ0o7O0FBRUQsTUFBTW96QixhQUFhLEdBQUd6eUMsTUFBTSxDQUFFQyxLQUFELEdBQTJDLFlBQTNDLEdBQTBELENBQTNELENBQTVCOztBQUNBLE1BQU15eUMsYUFBYSxHQUFHLE1BQU07QUFDeEI7QUFDSSxVQUFNNzFCLEdBQUcsR0FBR3dKLE1BQU0sQ0FBQ29zQixhQUFELENBQWxCOztBQUNBLFFBQUksQ0FBQzUxQixHQUFMLEVBQVU7QUFDTjlWLFVBQUksQ0FBRSxnRUFBRCxHQUNBLG9EQURELENBQUo7QUFFSDs7QUFDRCxXQUFPOFYsR0FBUDtBQUNIO0FBQ0osQ0FURDs7QUFXQSxTQUFTODFCLG1CQUFULEdBQStCO0FBQzNCO0FBQ0EsTUFBSSxVQUE0QyxPQUFPdDlCLE1BQVAsS0FBa0IsV0FBbEUsRUFBK0U7QUFDM0U7QUFDSDs7QUFDRCxRQUFNdTlCLFFBQVEsR0FBRztBQUFFalAsU0FBSyxFQUFFO0FBQVQsR0FBakI7QUFDQSxRQUFNa1AsV0FBVyxHQUFHO0FBQUVsUCxTQUFLLEVBQUU7QUFBVCxHQUFwQjtBQUNBLFFBQU1tUCxXQUFXLEdBQUc7QUFBRW5QLFNBQUssRUFBRTtBQUFULEdBQXBCO0FBQ0EsUUFBTW9QLFlBQVksR0FBRztBQUFFcFAsU0FBSyxFQUFFO0FBQVQsR0FBckIsQ0FSMkIsQ0FTM0I7QUFDQTs7QUFDQSxRQUFNcVAsU0FBUyxHQUFHO0FBQ2RDLFVBQU0sQ0FBQzNGLEdBQUQsRUFBTTtBQUNSO0FBQ0EsVUFBSSxDQUFDcmxCLHFEQUFVLENBQUNxbEIsR0FBRCxDQUFmLEVBQXNCO0FBQ2xCLGVBQU8sSUFBUDtBQUNIOztBQUNELFVBQUlBLEdBQUcsQ0FBQzRGLE9BQVIsRUFBaUI7QUFDYixlQUFPLENBQUMsS0FBRCxFQUFRTixRQUFSLEVBQW1CLGFBQW5CLENBQVA7QUFDSCxPQUZELE1BR0ssSUFBSTlzQyxzREFBSyxDQUFDd25DLEdBQUQsQ0FBVCxFQUFnQjtBQUNqQixlQUFPLENBQ0gsS0FERyxFQUVILEVBRkcsRUFHSCxDQUFDLE1BQUQsRUFBU3NGLFFBQVQsRUFBbUJPLFVBQVUsQ0FBQzdGLEdBQUQsQ0FBN0IsQ0FIRyxFQUlILEdBSkcsRUFLSDhGLFdBQVcsQ0FBQzlGLEdBQUcsQ0FBQ3RuQyxLQUFMLENBTFIsRUFNRixHQU5FLENBQVA7QUFRSCxPQVRJLE1BVUEsSUFBSWdGLDJEQUFVLENBQUNzaUMsR0FBRCxDQUFkLEVBQXFCO0FBQ3RCLGVBQU8sQ0FDSCxLQURHLEVBRUgsRUFGRyxFQUdILENBQUMsTUFBRCxFQUFTc0YsUUFBVCxFQUFtQixVQUFuQixDQUhHLEVBSUgsR0FKRyxFQUtIUSxXQUFXLENBQUM5RixHQUFELENBTFIsRUFNRixJQUFHbG9DLDJEQUFVLENBQUNrb0MsR0FBRCxDQUFWLEdBQW1CLGFBQW5CLEdBQW1DLEVBQUUsRUFOdEMsQ0FBUDtBQVFILE9BVEksTUFVQSxJQUFJbG9DLDJEQUFVLENBQUNrb0MsR0FBRCxDQUFkLEVBQXFCO0FBQ3RCLGVBQU8sQ0FDSCxLQURHLEVBRUgsRUFGRyxFQUdILENBQUMsTUFBRCxFQUFTc0YsUUFBVCxFQUFtQixVQUFuQixDQUhHLEVBSUgsR0FKRyxFQUtIUSxXQUFXLENBQUM5RixHQUFELENBTFIsRUFNSCxHQU5HLENBQVA7QUFRSDs7QUFDRCxhQUFPLElBQVA7QUFDSCxLQXhDYTs7QUF5Q2QrRixXQUFPLENBQUMvRixHQUFELEVBQU07QUFDVCxhQUFPQSxHQUFHLElBQUlBLEdBQUcsQ0FBQzRGLE9BQWxCO0FBQ0gsS0EzQ2E7O0FBNENkSSxRQUFJLENBQUNoRyxHQUFELEVBQU07QUFDTixVQUFJQSxHQUFHLElBQUlBLEdBQUcsQ0FBQzRGLE9BQWYsRUFBd0I7QUFDcEIsZUFBTyxDQUNILEtBREcsRUFFSCxFQUZHLEVBR0gsR0FBR0ssY0FBYyxDQUFDakcsR0FBRyxDQUFDSSxDQUFMLENBSGQsQ0FBUDtBQUtIO0FBQ0o7O0FBcERhLEdBQWxCOztBQXNEQSxXQUFTNkYsY0FBVCxDQUF3QnBsQyxRQUF4QixFQUFrQztBQUM5QixVQUFNcWxDLE1BQU0sR0FBRyxFQUFmOztBQUNBLFFBQUlybEMsUUFBUSxDQUFDL0wsSUFBVCxDQUFjd04sS0FBZCxJQUF1QnpCLFFBQVEsQ0FBQ3lCLEtBQXBDLEVBQTJDO0FBQ3ZDNGpDLFlBQU0sQ0FBQ3B5QyxJQUFQLENBQVlxeUMsbUJBQW1CLENBQUMsT0FBRCxFQUFVenVDLHNEQUFLLENBQUNtSixRQUFRLENBQUN5QixLQUFWLENBQWYsQ0FBL0I7QUFDSDs7QUFDRCxRQUFJekIsUUFBUSxDQUFDMFAsVUFBVCxLQUF3QnJkLGtEQUE1QixFQUF1QztBQUNuQ2d6QyxZQUFNLENBQUNweUMsSUFBUCxDQUFZcXlDLG1CQUFtQixDQUFDLE9BQUQsRUFBVXRsQyxRQUFRLENBQUMwUCxVQUFuQixDQUEvQjtBQUNIOztBQUNELFFBQUkxUCxRQUFRLENBQUN5UCxJQUFULEtBQWtCcGQsa0RBQXRCLEVBQWlDO0FBQzdCZ3pDLFlBQU0sQ0FBQ3B5QyxJQUFQLENBQVlxeUMsbUJBQW1CLENBQUMsTUFBRCxFQUFTenVDLHNEQUFLLENBQUNtSixRQUFRLENBQUN5UCxJQUFWLENBQWQsQ0FBL0I7QUFDSDs7QUFDRCxVQUFNblEsUUFBUSxHQUFHaW1DLFdBQVcsQ0FBQ3ZsQyxRQUFELEVBQVcsVUFBWCxDQUE1Qjs7QUFDQSxRQUFJVixRQUFKLEVBQWM7QUFDVitsQyxZQUFNLENBQUNweUMsSUFBUCxDQUFZcXlDLG1CQUFtQixDQUFDLFVBQUQsRUFBYWhtQyxRQUFiLENBQS9CO0FBQ0g7O0FBQ0QsVUFBTTZpQixRQUFRLEdBQUdvakIsV0FBVyxDQUFDdmxDLFFBQUQsRUFBVyxRQUFYLENBQTVCOztBQUNBLFFBQUltaUIsUUFBSixFQUFjO0FBQ1ZrakIsWUFBTSxDQUFDcHlDLElBQVAsQ0FBWXF5QyxtQkFBbUIsQ0FBQyxVQUFELEVBQWFuakIsUUFBYixDQUEvQjtBQUNIOztBQUNEa2pCLFVBQU0sQ0FBQ3B5QyxJQUFQLENBQVksQ0FDUixLQURRLEVBRVIsRUFGUSxFQUdSLENBQ0ksTUFESixFQUVJO0FBQ0l1aUMsV0FBSyxFQUFFb1AsWUFBWSxDQUFDcFAsS0FBYixHQUFxQjtBQURoQyxLQUZKLEVBS0ksZ0JBTEosQ0FIUSxFQVVSLENBQUMsUUFBRCxFQUFXO0FBQUU3MkIsWUFBTSxFQUFFcUI7QUFBVixLQUFYLENBVlEsQ0FBWjtBQVlBLFdBQU9xbEMsTUFBUDtBQUNIOztBQUNELFdBQVNDLG1CQUFULENBQTZCcnhDLElBQTdCLEVBQW1DRCxNQUFuQyxFQUEyQztBQUN2Q0EsVUFBTSxHQUFHK0UsbURBQU0sQ0FBQyxFQUFELEVBQUsvRSxNQUFMLENBQWY7O0FBQ0EsUUFBSSxDQUFDNEIsTUFBTSxDQUFDK0wsSUFBUCxDQUFZM04sTUFBWixFQUFvQlosTUFBekIsRUFBaUM7QUFDN0IsYUFBTyxDQUFDLE1BQUQsRUFBUyxFQUFULENBQVA7QUFDSDs7QUFDRCxXQUFPLENBQ0gsS0FERyxFQUVIO0FBQUVvaUMsV0FBSyxFQUFFO0FBQVQsS0FGRyxFQUdILENBQ0ksS0FESixFQUVJO0FBQ0lBLFdBQUssRUFBRTtBQURYLEtBRkosRUFLSXZoQyxJQUxKLENBSEcsRUFVSCxDQUNJLEtBREosRUFFSTtBQUNJdWhDLFdBQUssRUFBRTtBQURYLEtBRkosRUFLSSxHQUFHNS9CLE1BQU0sQ0FBQytMLElBQVAsQ0FBWTNOLE1BQVosRUFBb0I4QixHQUFwQixDQUF3QjVCLEdBQUcsSUFBSTtBQUM5QixhQUFPLENBQ0gsS0FERyxFQUVILEVBRkcsRUFHSCxDQUFDLE1BQUQsRUFBUzB3QyxZQUFULEVBQXVCMXdDLEdBQUcsR0FBRyxJQUE3QixDQUhHLEVBSUgrd0MsV0FBVyxDQUFDanhDLE1BQU0sQ0FBQ0UsR0FBRCxDQUFQLEVBQWMsS0FBZCxDQUpSLENBQVA7QUFNSCxLQVBFLENBTFAsQ0FWRyxDQUFQO0FBeUJIOztBQUNELFdBQVMrd0MsV0FBVCxDQUFxQjVyQyxDQUFyQixFQUF3Qm1zQyxLQUFLLEdBQUcsSUFBaEMsRUFBc0M7QUFDbEMsUUFBSSxPQUFPbnNDLENBQVAsS0FBYSxRQUFqQixFQUEyQjtBQUN2QixhQUFPLENBQUMsTUFBRCxFQUFTcXJDLFdBQVQsRUFBc0JyckMsQ0FBdEIsQ0FBUDtBQUNILEtBRkQsTUFHSyxJQUFJLE9BQU9BLENBQVAsS0FBYSxRQUFqQixFQUEyQjtBQUM1QixhQUFPLENBQUMsTUFBRCxFQUFTc3JDLFdBQVQsRUFBc0I1aUMsSUFBSSxDQUFDQyxTQUFMLENBQWUzSSxDQUFmLENBQXRCLENBQVA7QUFDSCxLQUZJLE1BR0EsSUFBSSxPQUFPQSxDQUFQLEtBQWEsU0FBakIsRUFBNEI7QUFDN0IsYUFBTyxDQUFDLE1BQUQsRUFBU3VyQyxZQUFULEVBQXVCdnJDLENBQXZCLENBQVA7QUFDSCxLQUZJLE1BR0EsSUFBSXlnQixxREFBVSxDQUFDemdCLENBQUQsQ0FBZCxFQUFtQjtBQUNwQixhQUFPLENBQUMsUUFBRCxFQUFXO0FBQUVzRixjQUFNLEVBQUU2bUMsS0FBSyxHQUFHM3VDLHNEQUFLLENBQUN3QyxDQUFELENBQVIsR0FBY0E7QUFBN0IsT0FBWCxDQUFQO0FBQ0gsS0FGSSxNQUdBO0FBQ0QsYUFBTyxDQUFDLE1BQUQsRUFBU3NyQyxXQUFULEVBQXNCOXJDLE1BQU0sQ0FBQ1EsQ0FBRCxDQUE1QixDQUFQO0FBQ0g7QUFDSjs7QUFDRCxXQUFTa3NDLFdBQVQsQ0FBcUJ2bEMsUUFBckIsRUFBK0IvTCxJQUEvQixFQUFxQztBQUNqQyxVQUFNd3hDLElBQUksR0FBR3psQyxRQUFRLENBQUMvTCxJQUF0Qjs7QUFDQSxRQUFJZ08sdURBQVksQ0FBQ3dqQyxJQUFELENBQWhCLEVBQXdCO0FBQ3BCO0FBQ0g7O0FBQ0QsVUFBTUMsU0FBUyxHQUFHLEVBQWxCOztBQUNBLFNBQUssTUFBTXh4QyxHQUFYLElBQWtCOEwsUUFBUSxDQUFDME8sR0FBM0IsRUFBZ0M7QUFDNUIsVUFBSWkzQixXQUFXLENBQUNGLElBQUQsRUFBT3Z4QyxHQUFQLEVBQVlELElBQVosQ0FBZixFQUFrQztBQUM5Qnl4QyxpQkFBUyxDQUFDeHhDLEdBQUQsQ0FBVCxHQUFpQjhMLFFBQVEsQ0FBQzBPLEdBQVQsQ0FBYXhhLEdBQWIsQ0FBakI7QUFDSDtBQUNKOztBQUNELFdBQU93eEMsU0FBUDtBQUNIOztBQUNELFdBQVNDLFdBQVQsQ0FBcUJGLElBQXJCLEVBQTJCdnhDLEdBQTNCLEVBQWdDRCxJQUFoQyxFQUFzQztBQUNsQyxVQUFNMnhDLElBQUksR0FBR0gsSUFBSSxDQUFDeHhDLElBQUQsQ0FBakI7O0FBQ0EsUUFBS2tCLG9EQUFPLENBQUN5d0MsSUFBRCxDQUFQLElBQWlCQSxJQUFJLENBQUM3eUMsUUFBTCxDQUFjbUIsR0FBZCxDQUFsQixJQUNDNGxCLHFEQUFVLENBQUM4ckIsSUFBRCxDQUFWLElBQW9CMXhDLEdBQUcsSUFBSTB4QyxJQURoQyxFQUN1QztBQUNuQyxhQUFPLElBQVA7QUFDSDs7QUFDRCxRQUFJSCxJQUFJLENBQUM3M0IsT0FBTCxJQUFnQiszQixXQUFXLENBQUNGLElBQUksQ0FBQzczQixPQUFOLEVBQWUxWixHQUFmLEVBQW9CRCxJQUFwQixDQUEvQixFQUEwRDtBQUN0RCxhQUFPLElBQVA7QUFDSDs7QUFDRCxRQUFJd3hDLElBQUksQ0FBQzkzQixNQUFMLElBQWU4M0IsSUFBSSxDQUFDOTNCLE1BQUwsQ0FBWTBDLElBQVosQ0FBaUJpRixDQUFDLElBQUlxd0IsV0FBVyxDQUFDcndCLENBQUQsRUFBSXBoQixHQUFKLEVBQVNELElBQVQsQ0FBakMsQ0FBbkIsRUFBcUU7QUFDakUsYUFBTyxJQUFQO0FBQ0g7QUFDSjs7QUFDRCxXQUFTK3dDLFVBQVQsQ0FBb0IzckMsQ0FBcEIsRUFBdUI7QUFDbkIsUUFBSUEsQ0FBQyxDQUFDdUUsUUFBTixFQUFnQjtBQUNaLGFBQVEsWUFBUjtBQUNIOztBQUNELFFBQUl2RSxDQUFDLENBQUNsSCxNQUFOLEVBQWM7QUFDVixhQUFRLGFBQVI7QUFDSDs7QUFDRCxXQUFRLEtBQVI7QUFDSDs7QUFDRCxNQUFJK1UsTUFBTSxDQUFDMitCLGtCQUFYLEVBQStCO0FBQzNCMytCLFVBQU0sQ0FBQzIrQixrQkFBUCxDQUEwQjV5QyxJQUExQixDQUErQjR4QyxTQUEvQjtBQUNILEdBRkQsTUFHSztBQUNEMzlCLFVBQU0sQ0FBQzIrQixrQkFBUCxHQUE0QixDQUFDaEIsU0FBRCxDQUE1QjtBQUNIO0FBQ0osQyxDQUVEOzs7QUFDQSxNQUFNaDhCLE9BQU8sR0FBRyxPQUFoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE1BQU1pOUIsUUFBUSxHQUFJLElBQWxCO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE1BQU1DLGFBQWEsR0FBRyxJQUF0QjtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNQyxXQUFXLEdBQUksSUFBckI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9sUEE7QUFDQTtBQUNBO0FBRUEsTUFBTUMsS0FBSyxHQUFHLDRCQUFkO0FBQ0EsTUFBTUMsR0FBRyxHQUFJLE9BQU9sdkIsUUFBUCxLQUFvQixXQUFwQixHQUFrQ0EsUUFBbEMsR0FBNkMsSUFBMUQ7QUFDQSxNQUFNbXZCLE9BQU8sR0FBRztBQUNaMVgsUUFBTSxFQUFFLENBQUNoZCxLQUFELEVBQVF4USxNQUFSLEVBQWdCK1IsTUFBaEIsS0FBMkI7QUFDL0IvUixVQUFNLENBQUNtbEMsWUFBUCxDQUFvQjMwQixLQUFwQixFQUEyQnVCLE1BQU0sSUFBSSxJQUFyQztBQUNILEdBSFc7QUFJWjBDLFFBQU0sRUFBRWpFLEtBQUssSUFBSTtBQUNiLFVBQU14USxNQUFNLEdBQUd3USxLQUFLLENBQUNnRSxVQUFyQjs7QUFDQSxRQUFJeFUsTUFBSixFQUFZO0FBQ1JBLFlBQU0sQ0FBQ29sQyxXQUFQLENBQW1CNTBCLEtBQW5CO0FBQ0g7QUFDSixHQVRXO0FBVVp5QyxlQUFhLEVBQUUsQ0FBQ295QixHQUFELEVBQU1uekIsS0FBTixFQUFhMGhCLEVBQWIsRUFBaUJwekIsS0FBakIsS0FBMkI7QUFDdEMsVUFBTStRLEVBQUUsR0FBR1csS0FBSyxHQUNWK3lCLEdBQUcsQ0FBQ0ssZUFBSixDQUFvQk4sS0FBcEIsRUFBMkJLLEdBQTNCLENBRFUsR0FFVkosR0FBRyxDQUFDaHlCLGFBQUosQ0FBa0JveUIsR0FBbEIsRUFBdUJ6UixFQUFFLEdBQUc7QUFBRUE7QUFBRixLQUFILEdBQVkvZ0MsU0FBckMsQ0FGTjs7QUFHQSxRQUFJd3lDLEdBQUcsS0FBSyxRQUFSLElBQW9CN2tDLEtBQXBCLElBQTZCQSxLQUFLLENBQUMra0MsUUFBTixJQUFrQixJQUFuRCxFQUF5RDtBQUNyRGgwQixRQUFFLENBQUNpMEIsWUFBSCxDQUFnQixVQUFoQixFQUE0QmhsQyxLQUFLLENBQUMra0MsUUFBbEM7QUFDSDs7QUFDRCxXQUFPaDBCLEVBQVA7QUFDSCxHQWxCVztBQW1CWnVnQixZQUFVLEVBQUU0SyxJQUFJLElBQUl1SSxHQUFHLENBQUNRLGNBQUosQ0FBbUIvSSxJQUFuQixDQW5CUjtBQW9CWmpQLGVBQWEsRUFBRWlQLElBQUksSUFBSXVJLEdBQUcsQ0FBQ3hYLGFBQUosQ0FBa0JpUCxJQUFsQixDQXBCWDtBQXFCWnpLLFNBQU8sRUFBRSxDQUFDcGMsSUFBRCxFQUFPNm1CLElBQVAsS0FBZ0I7QUFDckI3bUIsUUFBSSxDQUFDNnZCLFNBQUwsR0FBaUJoSixJQUFqQjtBQUNILEdBdkJXO0FBd0JadkssZ0JBQWMsRUFBRSxDQUFDNWdCLEVBQUQsRUFBS21yQixJQUFMLEtBQWM7QUFDMUJuckIsTUFBRSxDQUFDMmQsV0FBSCxHQUFpQndOLElBQWpCO0FBQ0gsR0ExQlc7QUEyQlpsb0IsWUFBVSxFQUFFcUIsSUFBSSxJQUFJQSxJQUFJLENBQUNyQixVQTNCYjtBQTRCWitZLGFBQVcsRUFBRTFYLElBQUksSUFBSUEsSUFBSSxDQUFDMFgsV0E1QmQ7QUE2QlpvTSxlQUFhLEVBQUVnTSxRQUFRLElBQUlWLEdBQUcsQ0FBQ3RMLGFBQUosQ0FBa0JnTSxRQUFsQixDQTdCZjs7QUE4QlpwVCxZQUFVLENBQUNoaEIsRUFBRCxFQUFLbmYsRUFBTCxFQUFTO0FBQ2ZtZixNQUFFLENBQUNpMEIsWUFBSCxDQUFnQnB6QyxFQUFoQixFQUFvQixFQUFwQjtBQUNILEdBaENXOztBQWlDWnFnQyxXQUFTLENBQUNsaEIsRUFBRCxFQUFLO0FBQ1YsVUFBTXdxQixNQUFNLEdBQUd4cUIsRUFBRSxDQUFDa2hCLFNBQUgsQ0FBYSxJQUFiLENBQWYsQ0FEVSxDQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxRQUFLLFFBQUQsSUFBWWxoQixFQUFoQixFQUFvQjtBQUNoQndxQixZQUFNLENBQUNuL0IsTUFBUCxHQUFnQjJVLEVBQUUsQ0FBQzNVLE1BQW5CO0FBQ0g7O0FBQ0QsV0FBT20vQixNQUFQO0FBQ0gsR0FoRFc7O0FBaURaO0FBQ0E7QUFDQTtBQUNBO0FBQ0FwSixxQkFBbUIsQ0FBQ2tLLE9BQUQsRUFBVTc4QixNQUFWLEVBQWtCK1IsTUFBbEIsRUFBMEJHLEtBQTFCLEVBQWlDL0YsTUFBakMsRUFBeUM7QUFDeEQsUUFBSUEsTUFBSixFQUFZO0FBQ1IsVUFBSXk1QixLQUFKO0FBQ0EsVUFBSWh6QyxJQUFKO0FBQ0EsVUFBSUwsQ0FBQyxHQUFHLENBQVI7QUFDQSxVQUFJc0QsQ0FBQyxHQUFHc1csTUFBTSxDQUFDaGEsTUFBZjs7QUFDQSxhQUFPSSxDQUFDLEdBQUdzRCxDQUFYLEVBQWN0RCxDQUFDLEVBQWYsRUFBbUI7QUFDZixjQUFNc2pCLElBQUksR0FBRzFKLE1BQU0sQ0FBQzVaLENBQUQsQ0FBTixDQUFVa2dDLFNBQVYsQ0FBb0IsSUFBcEIsQ0FBYjtBQUNBLFlBQUlsZ0MsQ0FBQyxLQUFLLENBQVYsRUFDSXF6QyxLQUFLLEdBQUcvdkIsSUFBUjtBQUNKLFlBQUl0akIsQ0FBQyxLQUFLc0QsQ0FBQyxHQUFHLENBQWQsRUFDSWpELElBQUksR0FBR2lqQixJQUFQO0FBQ0o3VixjQUFNLENBQUNtbEMsWUFBUCxDQUFvQnR2QixJQUFwQixFQUEwQjlELE1BQTFCO0FBQ0g7O0FBQ0QsYUFBTyxDQUFDNnpCLEtBQUQsRUFBUWh6QyxJQUFSLENBQVA7QUFDSCxLQWZ1RCxDQWdCeEQ7OztBQUNBLFVBQU1pekMsTUFBTSxHQUFHOXpCLE1BQU0sR0FBR0EsTUFBTSxDQUFDd2MsZUFBVixHQUE0QnZ1QixNQUFNLENBQUN3dUIsU0FBeEQ7O0FBQ0EsUUFBSXpjLE1BQUosRUFBWTtBQUNSLFVBQUkrekIsY0FBSjtBQUNBLFVBQUlDLHVCQUF1QixHQUFHLEtBQTlCOztBQUNBLFVBQUloMEIsTUFBTSxZQUFZaTBCLE9BQXRCLEVBQStCO0FBQzNCRixzQkFBYyxHQUFHL3pCLE1BQWpCO0FBQ0gsT0FGRCxNQUdLO0FBQ0Q7QUFDQTtBQUNBZzBCLCtCQUF1QixHQUFHLElBQTFCO0FBQ0FELHNCQUFjLEdBQUc1ekIsS0FBSyxHQUNoQit5QixHQUFHLENBQUNLLGVBQUosQ0FBb0JOLEtBQXBCLEVBQTJCLEdBQTNCLENBRGdCLEdBRWhCQyxHQUFHLENBQUNoeUIsYUFBSixDQUFrQixLQUFsQixDQUZOO0FBR0FqVCxjQUFNLENBQUNtbEMsWUFBUCxDQUFvQlcsY0FBcEIsRUFBb0MvekIsTUFBcEM7QUFDSDs7QUFDRCt6QixvQkFBYyxDQUFDRyxrQkFBZixDQUFrQyxhQUFsQyxFQUFpRHBKLE9BQWpEOztBQUNBLFVBQUlrSix1QkFBSixFQUE2QjtBQUN6Qi9sQyxjQUFNLENBQUNvbEMsV0FBUCxDQUFtQlUsY0FBbkI7QUFDSDtBQUNKLEtBbkJELE1Bb0JLO0FBQ0Q5bEMsWUFBTSxDQUFDaW1DLGtCQUFQLENBQTBCLFdBQTFCLEVBQXVDcEosT0FBdkM7QUFDSDs7QUFDRCxRQUFJK0ksS0FBSyxHQUFHQyxNQUFNLEdBQUdBLE1BQU0sQ0FBQ3RZLFdBQVYsR0FBd0J2dEIsTUFBTSxDQUFDMnRCLFVBQWpEO0FBQ0EsVUFBTS82QixJQUFJLEdBQUdtZixNQUFNLEdBQUdBLE1BQU0sQ0FBQ3djLGVBQVYsR0FBNEJ2dUIsTUFBTSxDQUFDd3VCLFNBQXREO0FBQ0EsVUFBTTd3QixHQUFHLEdBQUcsRUFBWjs7QUFDQSxXQUFPaW9DLEtBQVAsRUFBYztBQUNWam9DLFNBQUcsQ0FBQzNMLElBQUosQ0FBUzR6QyxLQUFUO0FBQ0EsVUFBSUEsS0FBSyxLQUFLaHpDLElBQWQsRUFDSTtBQUNKZ3pDLFdBQUssR0FBR0EsS0FBSyxDQUFDclksV0FBZDtBQUNIOztBQUNELFdBQU81dkIsR0FBUDtBQUNIOztBQXhHVyxDQUFoQixDLENBMkdBO0FBQ0E7O0FBQ0EsU0FBU3VvQyxVQUFULENBQW9CMzBCLEVBQXBCLEVBQXdCM2EsS0FBeEIsRUFBK0JzYixLQUEvQixFQUFzQztBQUNsQyxNQUFJdGIsS0FBSyxJQUFJLElBQWIsRUFBbUI7QUFDZkEsU0FBSyxHQUFHLEVBQVI7QUFDSDs7QUFDRCxNQUFJc2IsS0FBSixFQUFXO0FBQ1BYLE1BQUUsQ0FBQ2kwQixZQUFILENBQWdCLE9BQWhCLEVBQXlCNXVDLEtBQXpCO0FBQ0gsR0FGRCxNQUdLO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsVUFBTXV2QyxpQkFBaUIsR0FBRzUwQixFQUFFLENBQUM2MEIsSUFBN0I7O0FBQ0EsUUFBSUQsaUJBQUosRUFBdUI7QUFDbkJ2dkMsV0FBSyxHQUFHLENBQUNBLEtBQUssR0FDUixDQUFDQSxLQUFELEVBQVEsR0FBR3V2QyxpQkFBWCxDQURRLEdBRVIsQ0FBQyxHQUFHQSxpQkFBSixDQUZFLEVBRXNCM21DLElBRnRCLENBRTJCLEdBRjNCLENBQVI7QUFHSDs7QUFDRCtSLE1BQUUsQ0FBQzgwQixTQUFILEdBQWV6dkMsS0FBZjtBQUNIO0FBQ0o7O0FBRUQsU0FBUzB2QyxVQUFULENBQW9CLzBCLEVBQXBCLEVBQXdCckUsSUFBeEIsRUFBOEJwVCxJQUE5QixFQUFvQztBQUNoQyxRQUFNeTZCLEtBQUssR0FBR2hqQixFQUFFLENBQUNnakIsS0FBakI7O0FBQ0EsTUFBSSxDQUFDejZCLElBQUwsRUFBVztBQUNQeVgsTUFBRSxDQUFDZzFCLGVBQUgsQ0FBbUIsT0FBbkI7QUFDSCxHQUZELE1BR0ssSUFBSTFsQyxxREFBUSxDQUFDL0csSUFBRCxDQUFaLEVBQW9CO0FBQ3JCLFFBQUlvVCxJQUFJLEtBQUtwVCxJQUFiLEVBQW1CO0FBQ2YsWUFBTWlsQixPQUFPLEdBQUd3VixLQUFLLENBQUNpUyxPQUF0QjtBQUNBalMsV0FBSyxDQUFDa1MsT0FBTixHQUFnQjNzQyxJQUFoQixDQUZlLENBR2Y7QUFDQTtBQUNBOztBQUNBLFVBQUksVUFBVXlYLEVBQWQsRUFBa0I7QUFDZGdqQixhQUFLLENBQUNpUyxPQUFOLEdBQWdCem5CLE9BQWhCO0FBQ0g7QUFDSjtBQUNKLEdBWEksTUFZQTtBQUNELFNBQUssTUFBTTlyQixHQUFYLElBQWtCNkcsSUFBbEIsRUFBd0I7QUFDcEI0c0MsY0FBUSxDQUFDblMsS0FBRCxFQUFRdGhDLEdBQVIsRUFBYTZHLElBQUksQ0FBQzdHLEdBQUQsQ0FBakIsQ0FBUjtBQUNIOztBQUNELFFBQUlpYSxJQUFJLElBQUksQ0FBQ3JNLHFEQUFRLENBQUNxTSxJQUFELENBQXJCLEVBQTZCO0FBQ3pCLFdBQUssTUFBTWphLEdBQVgsSUFBa0JpYSxJQUFsQixFQUF3QjtBQUNwQixZQUFJcFQsSUFBSSxDQUFDN0csR0FBRCxDQUFKLElBQWEsSUFBakIsRUFBdUI7QUFDbkJ5ekMsa0JBQVEsQ0FBQ25TLEtBQUQsRUFBUXRoQyxHQUFSLEVBQWEsRUFBYixDQUFSO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDSjs7QUFDRCxNQUFNMHpDLFdBQVcsR0FBRyxnQkFBcEI7O0FBQ0EsU0FBU0QsUUFBVCxDQUFrQm5TLEtBQWxCLEVBQXlCdHpCLElBQXpCLEVBQStCaEYsR0FBL0IsRUFBb0M7QUFDaEMsTUFBSS9ILG9EQUFPLENBQUMrSCxHQUFELENBQVgsRUFBa0I7QUFDZEEsT0FBRyxDQUFDaEksT0FBSixDQUFZbUUsQ0FBQyxJQUFJc3VDLFFBQVEsQ0FBQ25TLEtBQUQsRUFBUXR6QixJQUFSLEVBQWM3SSxDQUFkLENBQXpCO0FBQ0gsR0FGRCxNQUdLO0FBQ0QsUUFBSTZJLElBQUksQ0FBQ2dLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBSixFQUEyQjtBQUN2QjtBQUNBc3BCLFdBQUssQ0FBQ3FTLFdBQU4sQ0FBa0IzbEMsSUFBbEIsRUFBd0JoRixHQUF4QjtBQUNILEtBSEQsTUFJSztBQUNELFlBQU00cUMsUUFBUSxHQUFHQyxVQUFVLENBQUN2UyxLQUFELEVBQVF0ekIsSUFBUixDQUEzQjs7QUFDQSxVQUFJMGxDLFdBQVcsQ0FBQ2xtQixJQUFaLENBQWlCeGtCLEdBQWpCLENBQUosRUFBMkI7QUFDdkI7QUFDQXM0QixhQUFLLENBQUNxUyxXQUFOLENBQWtCbjdCLHNEQUFTLENBQUNvN0IsUUFBRCxDQUEzQixFQUF1QzVxQyxHQUFHLENBQUM2USxPQUFKLENBQVk2NUIsV0FBWixFQUF5QixFQUF6QixDQUF2QyxFQUFxRSxXQUFyRTtBQUNILE9BSEQsTUFJSztBQUNEcFMsYUFBSyxDQUFDc1MsUUFBRCxDQUFMLEdBQWtCNXFDLEdBQWxCO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBQ0QsTUFBTThxQyxRQUFRLEdBQUcsQ0FBQyxRQUFELEVBQVcsS0FBWCxFQUFrQixJQUFsQixDQUFqQjtBQUNBLE1BQU1DLFdBQVcsR0FBRyxFQUFwQjs7QUFDQSxTQUFTRixVQUFULENBQW9CdlMsS0FBcEIsRUFBMkIwUyxPQUEzQixFQUFvQztBQUNoQyxRQUFNOTZCLE1BQU0sR0FBRzY2QixXQUFXLENBQUNDLE9BQUQsQ0FBMUI7O0FBQ0EsTUFBSTk2QixNQUFKLEVBQVk7QUFDUixXQUFPQSxNQUFQO0FBQ0g7O0FBQ0QsTUFBSWxMLElBQUksR0FBRzJLLHFEQUFRLENBQUNxN0IsT0FBRCxDQUFuQjs7QUFDQSxNQUFJaG1DLElBQUksS0FBSyxRQUFULElBQXFCQSxJQUFJLElBQUlzekIsS0FBakMsRUFBd0M7QUFDcEMsV0FBUXlTLFdBQVcsQ0FBQ0MsT0FBRCxDQUFYLEdBQXVCaG1DLElBQS9CO0FBQ0g7O0FBQ0RBLE1BQUksR0FBR2hILHVEQUFVLENBQUNnSCxJQUFELENBQWpCOztBQUNBLE9BQUssSUFBSTFPLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd3MEMsUUFBUSxDQUFDNTBDLE1BQTdCLEVBQXFDSSxDQUFDLEVBQXRDLEVBQTBDO0FBQ3RDLFVBQU1zMEMsUUFBUSxHQUFHRSxRQUFRLENBQUN4MEMsQ0FBRCxDQUFSLEdBQWMwTyxJQUEvQjs7QUFDQSxRQUFJNGxDLFFBQVEsSUFBSXRTLEtBQWhCLEVBQXVCO0FBQ25CLGFBQVF5UyxXQUFXLENBQUNDLE9BQUQsQ0FBWCxHQUF1QkosUUFBL0I7QUFDSDtBQUNKOztBQUNELFNBQU9JLE9BQVA7QUFDSDs7QUFFRCxNQUFNQyxPQUFPLEdBQUcsOEJBQWhCOztBQUNBLFNBQVNDLFNBQVQsQ0FBbUI1MUIsRUFBbkIsRUFBdUJ0ZSxHQUF2QixFQUE0QjJELEtBQTVCLEVBQW1Dc2IsS0FBbkMsRUFBMENuVCxRQUExQyxFQUFvRDtBQUNoRCxNQUFJbVQsS0FBSyxJQUFJamYsR0FBRyxDQUFDZ1ksVUFBSixDQUFlLFFBQWYsQ0FBYixFQUF1QztBQUNuQyxRQUFJclUsS0FBSyxJQUFJLElBQWIsRUFBbUI7QUFDZjJhLFFBQUUsQ0FBQzYxQixpQkFBSCxDQUFxQkYsT0FBckIsRUFBOEJqMEMsR0FBRyxDQUFDME4sS0FBSixDQUFVLENBQVYsRUFBYTFOLEdBQUcsQ0FBQ2QsTUFBakIsQ0FBOUI7QUFDSCxLQUZELE1BR0s7QUFDRG9mLFFBQUUsQ0FBQzgxQixjQUFILENBQWtCSCxPQUFsQixFQUEyQmowQyxHQUEzQixFQUFnQzJELEtBQWhDO0FBQ0g7QUFDSixHQVBELE1BUUs7QUFDRDtBQUNBO0FBQ0EsVUFBTTJ5QixTQUFTLEdBQUcrZCxpRUFBb0IsQ0FBQ3IwQyxHQUFELENBQXRDOztBQUNBLFFBQUkyRCxLQUFLLElBQUksSUFBVCxJQUFrQjJ5QixTQUFTLElBQUkzeUIsS0FBSyxLQUFLLEtBQTdDLEVBQXFEO0FBQ2pEMmEsUUFBRSxDQUFDZzFCLGVBQUgsQ0FBbUJ0ekMsR0FBbkI7QUFDSCxLQUZELE1BR0s7QUFDRHNlLFFBQUUsQ0FBQ2kwQixZQUFILENBQWdCdnlDLEdBQWhCLEVBQXFCczJCLFNBQVMsR0FBRyxFQUFILEdBQVEzeUIsS0FBdEM7QUFDSDtBQUNKO0FBQ0osQyxDQUVEO0FBQ0E7OztBQUNBLFNBQVMyd0MsWUFBVCxDQUFzQmgyQixFQUF0QixFQUEwQnRlLEdBQTFCLEVBQStCMkQsS0FBL0IsRUFDQTtBQUNBO0FBQ0E7QUFDQW1hLFlBSkEsRUFJY2lCLGVBSmQsRUFJK0JDLGNBSi9CLEVBSStDNmhCLGVBSi9DLEVBSWdFO0FBQzVELE1BQUk3Z0MsR0FBRyxLQUFLLFdBQVIsSUFBdUJBLEdBQUcsS0FBSyxhQUFuQyxFQUFrRDtBQUM5QyxRQUFJOGQsWUFBSixFQUFrQjtBQUNkK2lCLHFCQUFlLENBQUMvaUIsWUFBRCxFQUFlaUIsZUFBZixFQUFnQ0MsY0FBaEMsQ0FBZjtBQUNIOztBQUNEVixNQUFFLENBQUN0ZSxHQUFELENBQUYsR0FBVTJELEtBQUssSUFBSSxJQUFULEdBQWdCLEVBQWhCLEdBQXFCQSxLQUEvQjtBQUNBO0FBQ0g7O0FBQ0QsTUFBSTNELEdBQUcsS0FBSyxPQUFSLElBQW1Cc2UsRUFBRSxDQUFDeWIsT0FBSCxLQUFlLFVBQXRDLEVBQWtEO0FBQzlDO0FBQ0E7QUFDQXpiLE1BQUUsQ0FBQzNVLE1BQUgsR0FBWWhHLEtBQVo7QUFDQSxVQUFNaEQsUUFBUSxHQUFHZ0QsS0FBSyxJQUFJLElBQVQsR0FBZ0IsRUFBaEIsR0FBcUJBLEtBQXRDOztBQUNBLFFBQUkyYSxFQUFFLENBQUMzYSxLQUFILEtBQWFoRCxRQUFqQixFQUEyQjtBQUN2QjJkLFFBQUUsQ0FBQzNhLEtBQUgsR0FBV2hELFFBQVg7QUFDSDs7QUFDRCxRQUFJZ0QsS0FBSyxJQUFJLElBQWIsRUFBbUI7QUFDZjJhLFFBQUUsQ0FBQ2cxQixlQUFILENBQW1CdHpDLEdBQW5CO0FBQ0g7O0FBQ0Q7QUFDSDs7QUFDRCxNQUFJMkQsS0FBSyxLQUFLLEVBQVYsSUFBZ0JBLEtBQUssSUFBSSxJQUE3QixFQUFtQztBQUMvQixVQUFNNUQsSUFBSSxHQUFHLE9BQU91ZSxFQUFFLENBQUN0ZSxHQUFELENBQXRCOztBQUNBLFFBQUkyRCxLQUFLLEtBQUssRUFBVixJQUFnQjVELElBQUksS0FBSyxTQUE3QixFQUF3QztBQUNwQztBQUNBdWUsUUFBRSxDQUFDdGUsR0FBRCxDQUFGLEdBQVUsSUFBVjtBQUNBO0FBQ0gsS0FKRCxNQUtLLElBQUkyRCxLQUFLLElBQUksSUFBVCxJQUFpQjVELElBQUksS0FBSyxRQUE5QixFQUF3QztBQUN6QztBQUNBdWUsUUFBRSxDQUFDdGUsR0FBRCxDQUFGLEdBQVUsRUFBVjtBQUNBc2UsUUFBRSxDQUFDZzFCLGVBQUgsQ0FBbUJ0ekMsR0FBbkI7QUFDQTtBQUNILEtBTEksTUFNQSxJQUFJRCxJQUFJLEtBQUssUUFBYixFQUF1QjtBQUN4QjtBQUNBdWUsUUFBRSxDQUFDdGUsR0FBRCxDQUFGLEdBQVUsQ0FBVjtBQUNBc2UsUUFBRSxDQUFDZzFCLGVBQUgsQ0FBbUJ0ekMsR0FBbkI7QUFDQTtBQUNIO0FBQ0osR0F4QzJELENBeUM1RDs7O0FBQ0EsTUFBSTtBQUNBc2UsTUFBRSxDQUFDdGUsR0FBRCxDQUFGLEdBQVUyRCxLQUFWO0FBQ0gsR0FGRCxDQUdBLE9BQU8wUSxDQUFQLEVBQVU7QUFDTixRQUFLelcsSUFBTCxFQUE2QztBQUN6QzhHLDZEQUFJLENBQUUsd0JBQXVCMUUsR0FBSSxTQUFRc2UsRUFBRSxDQUFDeWIsT0FBSCxDQUFXeGhCLFdBQVgsRUFBeUIsS0FBN0QsR0FDQSxTQUFRNVUsS0FBTSxjQURmLEVBQzhCMFEsQ0FEOUIsQ0FBSjtBQUVIO0FBQ0o7QUFDSixDLENBRUQ7OztBQUNBLElBQUlrZ0MsT0FBTyxHQUFHNVgsSUFBSSxDQUFDRCxHQUFuQjtBQUNBLElBQUk4WCxrQkFBa0IsR0FBRyxLQUF6Qjs7QUFDQSxJQUFJLE9BQU94aEMsTUFBUCxLQUFrQixXQUF0QixFQUFtQztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUl1aEMsT0FBTyxLQUFLenhCLFFBQVEsQ0FBQzJ4QixXQUFULENBQXFCLE9BQXJCLEVBQThCQyxTQUE5QyxFQUF5RDtBQUNyRDtBQUNBO0FBQ0E7QUFDQUgsV0FBTyxHQUFHLE1BQU1wYyxXQUFXLENBQUN1RSxHQUFaLEVBQWhCO0FBQ0gsR0FWOEIsQ0FXL0I7QUFDQTs7O0FBQ0EsUUFBTWlZLE9BQU8sR0FBR0MsU0FBUyxDQUFDQyxTQUFWLENBQW9CM2YsS0FBcEIsQ0FBMEIsaUJBQTFCLENBQWhCO0FBQ0FzZixvQkFBa0IsR0FBRyxDQUFDLEVBQUVHLE9BQU8sSUFBSXp3QyxNQUFNLENBQUN5d0MsT0FBTyxDQUFDLENBQUQsQ0FBUixDQUFOLElBQXNCLEVBQW5DLENBQXRCO0FBQ0gsQyxDQUNEO0FBQ0E7OztBQUNBLElBQUlHLFNBQVMsR0FBRyxDQUFoQjtBQUNBLE1BQU16a0MsQ0FBQyxHQUFHTixPQUFPLENBQUNDLE9BQVIsRUFBVjs7QUFDQSxNQUFNK2tDLEtBQUssR0FBRyxNQUFNO0FBQ2hCRCxXQUFTLEdBQUcsQ0FBWjtBQUNILENBRkQ7O0FBR0EsTUFBTUUsTUFBTSxHQUFHLE1BQU1GLFNBQVMsS0FBS3prQyxDQUFDLENBQUNDLElBQUYsQ0FBT3lrQyxLQUFQLEdBQWdCRCxTQUFTLEdBQUdQLE9BQU8sRUFBeEMsQ0FBOUI7O0FBQ0EsU0FBU1UsZ0JBQVQsQ0FBMEIzMkIsRUFBMUIsRUFBOEIxSSxLQUE5QixFQUFxQzhDLE9BQXJDLEVBQThDeGEsT0FBOUMsRUFBdUQ7QUFDbkRvZ0IsSUFBRSxDQUFDMjJCLGdCQUFILENBQW9Cci9CLEtBQXBCLEVBQTJCOEMsT0FBM0IsRUFBb0N4YSxPQUFwQztBQUNIOztBQUNELFNBQVNnM0MsbUJBQVQsQ0FBNkI1MkIsRUFBN0IsRUFBaUMxSSxLQUFqQyxFQUF3QzhDLE9BQXhDLEVBQWlEeGEsT0FBakQsRUFBMEQ7QUFDdERvZ0IsSUFBRSxDQUFDNDJCLG1CQUFILENBQXVCdC9CLEtBQXZCLEVBQThCOEMsT0FBOUIsRUFBdUN4YSxPQUF2QztBQUNIOztBQUNELFNBQVNpM0MsVUFBVCxDQUFvQjcyQixFQUFwQixFQUF3QjAxQixPQUF4QixFQUFpQ29CLFNBQWpDLEVBQTRDQyxTQUE1QyxFQUF1RHZwQyxRQUFRLEdBQUcsSUFBbEUsRUFBd0U7QUFDcEU7QUFDQSxRQUFNd3BDLFFBQVEsR0FBR2gzQixFQUFFLENBQUNpM0IsSUFBSCxLQUFZajNCLEVBQUUsQ0FBQ2kzQixJQUFILEdBQVUsRUFBdEIsQ0FBakI7QUFDQSxRQUFNQyxlQUFlLEdBQUdGLFFBQVEsQ0FBQ3RCLE9BQUQsQ0FBaEM7O0FBQ0EsTUFBSXFCLFNBQVMsSUFBSUcsZUFBakIsRUFBa0M7QUFDOUI7QUFDQUEsbUJBQWUsQ0FBQzd4QyxLQUFoQixHQUF3QjB4QyxTQUF4QjtBQUNILEdBSEQsTUFJSztBQUNELFVBQU0sQ0FBQ3JuQyxJQUFELEVBQU85UCxPQUFQLElBQWtCdTNDLFNBQVMsQ0FBQ3pCLE9BQUQsQ0FBakM7O0FBQ0EsUUFBSXFCLFNBQUosRUFBZTtBQUNYO0FBQ0EsWUFBTUssT0FBTyxHQUFJSixRQUFRLENBQUN0QixPQUFELENBQVIsR0FBb0IyQixhQUFhLENBQUNOLFNBQUQsRUFBWXZwQyxRQUFaLENBQWxEO0FBQ0FtcEMsc0JBQWdCLENBQUMzMkIsRUFBRCxFQUFLdFEsSUFBTCxFQUFXMG5DLE9BQVgsRUFBb0J4M0MsT0FBcEIsQ0FBaEI7QUFDSCxLQUpELE1BS0ssSUFBSXMzQyxlQUFKLEVBQXFCO0FBQ3RCO0FBQ0FOLHlCQUFtQixDQUFDNTJCLEVBQUQsRUFBS3RRLElBQUwsRUFBV3duQyxlQUFYLEVBQTRCdDNDLE9BQTVCLENBQW5CO0FBQ0FvM0MsY0FBUSxDQUFDdEIsT0FBRCxDQUFSLEdBQW9CcDBDLFNBQXBCO0FBQ0g7QUFDSjtBQUNKOztBQUNELE1BQU1nMkMsaUJBQWlCLEdBQUcsMkJBQTFCOztBQUNBLFNBQVNILFNBQVQsQ0FBbUJ6bkMsSUFBbkIsRUFBeUI7QUFDckIsTUFBSTlQLE9BQUo7O0FBQ0EsTUFBSTAzQyxpQkFBaUIsQ0FBQ3BvQixJQUFsQixDQUF1QnhmLElBQXZCLENBQUosRUFBa0M7QUFDOUI5UCxXQUFPLEdBQUcsRUFBVjtBQUNBLFFBQUlrakIsQ0FBSjs7QUFDQSxXQUFRQSxDQUFDLEdBQUdwVCxJQUFJLENBQUNrbkIsS0FBTCxDQUFXMGdCLGlCQUFYLENBQVosRUFBNEM7QUFDeEM1bkMsVUFBSSxHQUFHQSxJQUFJLENBQUNOLEtBQUwsQ0FBVyxDQUFYLEVBQWNNLElBQUksQ0FBQzlPLE1BQUwsR0FBY2tpQixDQUFDLENBQUMsQ0FBRCxDQUFELENBQUtsaUIsTUFBakMsQ0FBUDtBQUNBaEIsYUFBTyxDQUFDa2pCLENBQUMsQ0FBQyxDQUFELENBQUQsQ0FBSzdJLFdBQUwsRUFBRCxDQUFQLEdBQThCLElBQTlCO0FBQ0g7QUFDSjs7QUFDRCxTQUFPLENBQUNDLHNEQUFTLENBQUN4SyxJQUFJLENBQUNOLEtBQUwsQ0FBVyxDQUFYLENBQUQsQ0FBVixFQUEyQnhQLE9BQTNCLENBQVA7QUFDSDs7QUFDRCxTQUFTeTNDLGFBQVQsQ0FBdUJFLFlBQXZCLEVBQXFDL3BDLFFBQXJDLEVBQStDO0FBQzNDLFFBQU00cEMsT0FBTyxHQUFJcmhDLENBQUQsSUFBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFNcWdDLFNBQVMsR0FBR3JnQyxDQUFDLENBQUNxZ0MsU0FBRixJQUFlSCxPQUFPLEVBQXhDOztBQUNBLFFBQUlDLGtCQUFrQixJQUFJRSxTQUFTLElBQUlnQixPQUFPLENBQUNJLFFBQVIsR0FBbUIsQ0FBMUQsRUFBNkQ7QUFDekQxbkMsbUZBQTBCLENBQUMybkMsNkJBQTZCLENBQUMxaEMsQ0FBRCxFQUFJcWhDLE9BQU8sQ0FBQy94QyxLQUFaLENBQTlCLEVBQWtEbUksUUFBbEQsRUFBNEQ7QUFBRTtBQUE5RCxRQUEwRixDQUFDdUksQ0FBRCxDQUExRixDQUExQjtBQUNIO0FBQ0osR0FYRDs7QUFZQXFoQyxTQUFPLENBQUMveEMsS0FBUixHQUFnQmt5QyxZQUFoQjtBQUNBSCxTQUFPLENBQUNJLFFBQVIsR0FBbUJkLE1BQU0sRUFBekI7QUFDQSxTQUFPVSxPQUFQO0FBQ0g7O0FBQ0QsU0FBU0ssNkJBQVQsQ0FBdUMxaEMsQ0FBdkMsRUFBMEMxUSxLQUExQyxFQUFpRDtBQUM3QyxNQUFJMUMsb0RBQU8sQ0FBQzBDLEtBQUQsQ0FBWCxFQUFvQjtBQUNoQixVQUFNcXlDLFlBQVksR0FBRzNoQyxDQUFDLENBQUM0aEMsd0JBQXZCOztBQUNBNWhDLEtBQUMsQ0FBQzRoQyx3QkFBRixHQUE2QixNQUFNO0FBQy9CRCxrQkFBWSxDQUFDdHdDLElBQWIsQ0FBa0IyTyxDQUFsQjtBQUNBQSxPQUFDLENBQUM2aEMsUUFBRixHQUFhLElBQWI7QUFDSCxLQUhEOztBQUlBLFdBQU92eUMsS0FBSyxDQUFDL0IsR0FBTixDQUFVN0QsRUFBRSxJQUFLc1csQ0FBRCxJQUFPLENBQUNBLENBQUMsQ0FBQzZoQyxRQUFILElBQWVuNEMsRUFBRSxDQUFDc1csQ0FBRCxDQUF4QyxDQUFQO0FBQ0gsR0FQRCxNQVFLO0FBQ0QsV0FBTzFRLEtBQVA7QUFDSDtBQUNKOztBQUVELE1BQU13eUMsVUFBVSxHQUFHLFVBQW5COztBQUNBLE1BQU16WCxjQUFjLEdBQUcsQ0FBQ3hILENBQUQsRUFBSWwzQixHQUFKLEtBQVlBLEdBQUcsS0FBSyxPQUEzQzs7QUFDQSxNQUFNcTZCLFNBQVMsR0FBRyxDQUFDL2IsRUFBRCxFQUFLdGUsR0FBTCxFQUFVbzFDLFNBQVYsRUFBcUJDLFNBQXJCLEVBQWdDcDJCLEtBQUssR0FBRyxLQUF4QyxFQUErQ25CLFlBQS9DLEVBQTZEaUIsZUFBN0QsRUFBOEVDLGNBQTlFLEVBQThGNmhCLGVBQTlGLEtBQWtIO0FBQ2hJLFVBQVE3Z0MsR0FBUjtBQUNJO0FBQ0EsU0FBSyxPQUFMO0FBQ0lpekMsZ0JBQVUsQ0FBQzMwQixFQUFELEVBQUsrMkIsU0FBTCxFQUFnQnAyQixLQUFoQixDQUFWO0FBQ0E7O0FBQ0osU0FBSyxPQUFMO0FBQ0lvMEIsZ0JBQVUsQ0FBQy8wQixFQUFELEVBQUs4MkIsU0FBTCxFQUFnQkMsU0FBaEIsQ0FBVjtBQUNBOztBQUNKO0FBQ0ksVUFBSXo3QixpREFBSSxDQUFDNVosR0FBRCxDQUFSLEVBQWU7QUFDWDtBQUNBLFlBQUksQ0FBQytYLDREQUFlLENBQUMvWCxHQUFELENBQXBCLEVBQTJCO0FBQ3ZCbTFDLG9CQUFVLENBQUM3MkIsRUFBRCxFQUFLdGUsR0FBTCxFQUFVbzFDLFNBQVYsRUFBcUJDLFNBQXJCLEVBQWdDdDJCLGVBQWhDLENBQVY7QUFDSDtBQUNKLE9BTEQsTUFNSyxJQUFJcTNCLGVBQWUsQ0FBQzkzQixFQUFELEVBQUt0ZSxHQUFMLEVBQVVxMUMsU0FBVixFQUFxQnAyQixLQUFyQixDQUFuQixFQUFnRDtBQUNqRHExQixvQkFBWSxDQUFDaDJCLEVBQUQsRUFBS3RlLEdBQUwsRUFBVXExQyxTQUFWLEVBQXFCdjNCLFlBQXJCLEVBQW1DaUIsZUFBbkMsRUFBb0RDLGNBQXBELEVBQW9FNmhCLGVBQXBFLENBQVo7QUFDSCxPQUZJLE1BR0E7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk3Z0MsR0FBRyxLQUFLLFlBQVosRUFBMEI7QUFDdEJzZSxZQUFFLENBQUMrM0IsVUFBSCxHQUFnQmhCLFNBQWhCO0FBQ0gsU0FGRCxNQUdLLElBQUlyMUMsR0FBRyxLQUFLLGFBQVosRUFBMkI7QUFDNUJzZSxZQUFFLENBQUNnNEIsV0FBSCxHQUFpQmpCLFNBQWpCO0FBQ0g7O0FBQ0RuQixpQkFBUyxDQUFDNTFCLEVBQUQsRUFBS3RlLEdBQUwsRUFBVXExQyxTQUFWLEVBQXFCcDJCLEtBQXJCLENBQVQ7QUFDSDs7QUFDRDtBQS9CUjtBQWlDSCxDQWxDRDs7QUFtQ0EsU0FBU20zQixlQUFULENBQXlCOTNCLEVBQXpCLEVBQTZCdGUsR0FBN0IsRUFBa0MyRCxLQUFsQyxFQUF5Q3NiLEtBQXpDLEVBQWdEO0FBQzVDLE1BQUlBLEtBQUosRUFBVztBQUNQO0FBQ0E7QUFDQSxRQUFJamYsR0FBRyxLQUFLLFdBQVosRUFBeUI7QUFDckIsYUFBTyxJQUFQO0FBQ0gsS0FMTSxDQU1QOzs7QUFDQSxRQUFJQSxHQUFHLElBQUlzZSxFQUFQLElBQWE2M0IsVUFBVSxDQUFDM29CLElBQVgsQ0FBZ0J4dEIsR0FBaEIsQ0FBYixJQUFxQ3VMLHVEQUFVLENBQUM1SCxLQUFELENBQW5ELEVBQTREO0FBQ3hELGFBQU8sSUFBUDtBQUNIOztBQUNELFdBQU8sS0FBUDtBQUNILEdBWjJDLENBYTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBSTNELEdBQUcsS0FBSyxZQUFSLElBQXdCQSxHQUFHLEtBQUssV0FBcEMsRUFBaUQ7QUFDN0MsV0FBTyxLQUFQO0FBQ0gsR0FyQjJDLENBc0I1QztBQUNBOzs7QUFDQSxNQUFJQSxHQUFHLEtBQUssTUFBWixFQUFvQjtBQUNoQixXQUFPLEtBQVA7QUFDSCxHQTFCMkMsQ0EyQjVDOzs7QUFDQSxNQUFJQSxHQUFHLEtBQUssTUFBUixJQUFrQnNlLEVBQUUsQ0FBQ3liLE9BQUgsS0FBZSxPQUFyQyxFQUE4QztBQUMxQyxXQUFPLEtBQVA7QUFDSCxHQTlCMkMsQ0ErQjVDOzs7QUFDQSxNQUFJLzVCLEdBQUcsS0FBSyxNQUFSLElBQWtCc2UsRUFBRSxDQUFDeWIsT0FBSCxLQUFlLFVBQXJDLEVBQWlEO0FBQzdDLFdBQU8sS0FBUDtBQUNILEdBbEMyQyxDQW1DNUM7OztBQUNBLE1BQUlvYyxVQUFVLENBQUMzb0IsSUFBWCxDQUFnQnh0QixHQUFoQixLQUF3QjROLHFEQUFRLENBQUNqSyxLQUFELENBQXBDLEVBQTZDO0FBQ3pDLFdBQU8sS0FBUDtBQUNIOztBQUNELFNBQU8zRCxHQUFHLElBQUlzZSxFQUFkO0FBQ0g7O0FBRUQsU0FBU2k0QixZQUFULENBQXNCdm9DLElBQUksR0FBRyxRQUE3QixFQUF1QztBQUNuQztBQUNBO0FBQ0ksVUFBTWxDLFFBQVEsR0FBRzZLLHFFQUFrQixFQUFuQzs7QUFDQSxRQUFJLENBQUM3SyxRQUFMLEVBQWU7QUFDVmxPLFdBQUQsSUFBMkM4Ryx1REFBSSxDQUFFLDRDQUFGLENBQS9DO0FBQ0EsYUFBT3ZHLGtEQUFQO0FBQ0g7O0FBQ0QsVUFBTXE0QyxPQUFPLEdBQUcxcUMsUUFBUSxDQUFDL0wsSUFBVCxDQUFjMHNDLFlBQTlCOztBQUNBLFFBQUksQ0FBQytKLE9BQUwsRUFBYztBQUNUNTRDLFdBQUQsSUFBMkM4Ryx1REFBSSxDQUFFLHNEQUFGLENBQS9DO0FBQ0EsYUFBT3ZHLGtEQUFQO0FBQ0g7O0FBQ0QsVUFBTXM0QyxHQUFHLEdBQUdELE9BQU8sQ0FBQ3hvQyxJQUFELENBQW5COztBQUNBLFFBQUksQ0FBQ3lvQyxHQUFMLEVBQVU7QUFDTDc0QyxXQUFELElBQ0k4Ryx1REFBSSxDQUFFLG9EQUFtRHNKLElBQUssSUFBMUQsQ0FEUjtBQUVBLGFBQU83UCxrREFBUDtBQUNIOztBQUNELFdBQU9zNEMsR0FBUDtBQUNIO0FBQ0o7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU0MsVUFBVCxDQUFvQjFyQyxNQUFwQixFQUE0QjtBQUN4QixRQUFNYyxRQUFRLEdBQUc2SyxxRUFBa0IsRUFBbkM7QUFDQTs7QUFDQSxNQUFJLENBQUM3SyxRQUFMLEVBQWU7QUFDVmxPLFNBQUQsSUFDSThHLHVEQUFJLENBQUUsaUVBQUYsQ0FEUjtBQUVBO0FBQ0g7O0FBQ0QsUUFBTWl5QyxPQUFPLEdBQUcsTUFBTUMsY0FBYyxDQUFDOXFDLFFBQVEsQ0FBQ3lTLE9BQVYsRUFBbUJ2VCxNQUFNLENBQUNjLFFBQVEsQ0FBQ3JELEtBQVYsQ0FBekIsQ0FBcEM7O0FBQ0EyZCw4REFBUyxDQUFDLE1BQU1oQyw4REFBVyxDQUFDdXlCLE9BQUQsRUFBVTtBQUFFaHlCLFNBQUssRUFBRTtBQUFULEdBQVYsQ0FBbEIsQ0FBVDtBQUNBdUksOERBQVMsQ0FBQ3lwQixPQUFELENBQVQ7QUFDSDs7QUFDRCxTQUFTQyxjQUFULENBQXdCanJDLEtBQXhCLEVBQStCa3JDLElBQS9CLEVBQXFDO0FBQ2pDLE1BQUlsckMsS0FBSyxDQUFDZ1EsU0FBTixHQUFrQjtBQUFJO0FBQTFCLElBQTBDO0FBQ3RDLFlBQU11RSxRQUFRLEdBQUd2VSxLQUFLLENBQUN1VSxRQUF2QjtBQUNBdlUsV0FBSyxHQUFHdVUsUUFBUSxDQUFDUyxZQUFqQjs7QUFDQSxVQUFJVCxRQUFRLENBQUNDLGFBQVQsSUFBMEIsQ0FBQ0QsUUFBUSxDQUFDVyxXQUF4QyxFQUFxRDtBQUNqRFgsZ0JBQVEsQ0FBQ3BmLE9BQVQsQ0FBaUIvQixJQUFqQixDQUFzQixNQUFNO0FBQ3hCNjNDLHdCQUFjLENBQUMxMkIsUUFBUSxDQUFDUyxZQUFWLEVBQXdCazJCLElBQXhCLENBQWQ7QUFDSCxTQUZEO0FBR0g7QUFDSixLQVRnQyxDQVVqQzs7O0FBQ0EsU0FBT2xyQyxLQUFLLENBQUNJLFNBQWIsRUFBd0I7QUFDcEJKLFNBQUssR0FBR0EsS0FBSyxDQUFDSSxTQUFOLENBQWdCd1MsT0FBeEI7QUFDSDs7QUFDRCxNQUFJNVMsS0FBSyxDQUFDZ1EsU0FBTixHQUFrQjtBQUFFO0FBQXBCLEtBQXFDaFEsS0FBSyxDQUFDMlMsRUFBL0MsRUFBbUQ7QUFDL0MsVUFBTWdqQixLQUFLLEdBQUczMUIsS0FBSyxDQUFDMlMsRUFBTixDQUFTZ2pCLEtBQXZCOztBQUNBLFNBQUssTUFBTXRoQyxHQUFYLElBQWtCNjJDLElBQWxCLEVBQXdCO0FBQ3BCdlYsV0FBSyxDQUFDcVMsV0FBTixDQUFtQixLQUFJM3pDLEdBQUksRUFBM0IsRUFBOEI2MkMsSUFBSSxDQUFDNzJDLEdBQUQsQ0FBbEM7QUFDSDtBQUNKLEdBTEQsTUFNSyxJQUFJMkwsS0FBSyxDQUFDNUwsSUFBTixLQUFlOFUsdURBQW5CLEVBQTZCO0FBQzlCbEosU0FBSyxDQUFDcVIsUUFBTixDQUFlaGMsT0FBZixDQUF1QnlpQixDQUFDLElBQUltekIsY0FBYyxDQUFDbnpCLENBQUQsRUFBSW96QixJQUFKLENBQTFDO0FBQ0g7QUFDSjs7QUFFRCxNQUFNQyxVQUFVLEdBQUcsWUFBbkI7QUFDQSxNQUFNQyxTQUFTLEdBQUcsV0FBbEIsQyxDQUNBO0FBQ0E7O0FBQ0EsTUFBTUMsVUFBVSxHQUFHLENBQUN6cEMsS0FBRCxFQUFRO0FBQUU4TjtBQUFGLENBQVIsS0FBc0J3VyxvREFBQyxDQUFDakosNkRBQUQsRUFBaUJxdUIsc0JBQXNCLENBQUMxcEMsS0FBRCxDQUF2QyxFQUFnRDhOLEtBQWhELENBQTFDOztBQUNBMjdCLFVBQVUsQ0FBQ2hJLFdBQVgsR0FBeUIsWUFBekI7QUFDQSxNQUFNa0ksNEJBQTRCLEdBQUc7QUFDakNscEMsTUFBSSxFQUFFckosTUFEMkI7QUFFakM1RSxNQUFJLEVBQUU0RSxNQUYyQjtBQUdqQ3d5QyxLQUFHLEVBQUU7QUFDRHAzQyxRQUFJLEVBQUVtSixPQURMO0FBRUQrWixXQUFPLEVBQUU7QUFGUixHQUg0QjtBQU9qQ20wQixVQUFRLEVBQUUsQ0FBQ3p5QyxNQUFELEVBQVNULE1BQVQsRUFBaUJ4QyxNQUFqQixDQVB1QjtBQVFqQzIxQyxnQkFBYyxFQUFFMXlDLE1BUmlCO0FBU2pDMnlDLGtCQUFnQixFQUFFM3lDLE1BVGU7QUFVakM0eUMsY0FBWSxFQUFFNXlDLE1BVm1CO0FBV2pDNnlDLGlCQUFlLEVBQUU3eUMsTUFYZ0I7QUFZakM4eUMsbUJBQWlCLEVBQUU5eUMsTUFaYztBQWFqQyt5QyxlQUFhLEVBQUUveUMsTUFia0I7QUFjakNnekMsZ0JBQWMsRUFBRWh6QyxNQWRpQjtBQWVqQ2l6QyxrQkFBZ0IsRUFBRWp6QyxNQWZlO0FBZ0JqQ2t6QyxjQUFZLEVBQUVsekM7QUFoQm1CLENBQXJDO0FBa0JBLE1BQU1tekMseUJBQXlCLEdBQUlkLFVBQVUsQ0FBQ3pwQyxLQUFYLEdBQW1CLGFBQWMxSSxtREFBTSxDQUFDLEVBQUQsRUFBSytqQixtRUFBTCxFQUEyQnN1Qiw0QkFBM0IsQ0FBMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNcnVCLFFBQVEsR0FBRyxDQUFDclUsSUFBRCxFQUFPL1IsSUFBSSxHQUFHLEVBQWQsS0FBcUI7QUFDbEMsTUFBSXhCLG9EQUFPLENBQUN1VCxJQUFELENBQVgsRUFBbUI7QUFDZkEsUUFBSSxDQUFDeFQsT0FBTCxDQUFhNndCLENBQUMsSUFBSUEsQ0FBQyxDQUFDLEdBQUdwdkIsSUFBSixDQUFuQjtBQUNILEdBRkQsTUFHSyxJQUFJK1IsSUFBSixFQUFVO0FBQ1hBLFFBQUksQ0FBQyxHQUFHL1IsSUFBSixDQUFKO0FBQ0g7QUFDSixDQVBEO0FBUUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1zMUMsbUJBQW1CLEdBQUl2akMsSUFBRCxJQUFVO0FBQ2xDLFNBQU9BLElBQUksR0FDTHZULG9EQUFPLENBQUN1VCxJQUFELENBQVAsR0FDSUEsSUFBSSxDQUFDMkgsSUFBTCxDQUFVMFYsQ0FBQyxJQUFJQSxDQUFDLENBQUMzeUIsTUFBRixHQUFXLENBQTFCLENBREosR0FFSXNWLElBQUksQ0FBQ3RWLE1BQUwsR0FBYyxDQUhiLEdBSUwsS0FKTjtBQUtILENBTkQ7O0FBT0EsU0FBUyszQyxzQkFBVCxDQUFnQ3Z2QixRQUFoQyxFQUEwQztBQUN0QyxRQUFNc3dCLFNBQVMsR0FBRyxFQUFsQjs7QUFDQSxPQUFLLE1BQU1oNEMsR0FBWCxJQUFrQjBuQixRQUFsQixFQUE0QjtBQUN4QixRQUFJLEVBQUUxbkIsR0FBRyxJQUFJazNDLDRCQUFULENBQUosRUFBNEM7QUFDeENjLGVBQVMsQ0FBQ2g0QyxHQUFELENBQVQsR0FBaUIwbkIsUUFBUSxDQUFDMW5CLEdBQUQsQ0FBekI7QUFDSDtBQUNKOztBQUNELE1BQUkwbkIsUUFBUSxDQUFDeXZCLEdBQVQsS0FBaUIsS0FBckIsRUFBNEI7QUFDeEIsV0FBT2EsU0FBUDtBQUNIOztBQUNELFFBQU07QUFBRWhxQyxRQUFJLEdBQUcsR0FBVDtBQUFjak8sUUFBZDtBQUFvQnEzQyxZQUFwQjtBQUE4QkMsa0JBQWMsR0FBSSxHQUFFcnBDLElBQUssYUFBdkQ7QUFBcUVzcEMsb0JBQWdCLEdBQUksR0FBRXRwQyxJQUFLLGVBQWhHO0FBQWdIdXBDLGdCQUFZLEdBQUksR0FBRXZwQyxJQUFLLFdBQXZJO0FBQW1Kd3BDLG1CQUFlLEdBQUdILGNBQXJLO0FBQXFMSSxxQkFBaUIsR0FBR0gsZ0JBQXpNO0FBQTJOSSxpQkFBYSxHQUFHSCxZQUEzTztBQUF5UEksa0JBQWMsR0FBSSxHQUFFM3BDLElBQUssYUFBbFI7QUFBZ1M0cEMsb0JBQWdCLEdBQUksR0FBRTVwQyxJQUFLLGVBQTNUO0FBQTJVNnBDLGdCQUFZLEdBQUksR0FBRTdwQyxJQUFLO0FBQWxXLE1BQWlYMFosUUFBdlg7QUFDQSxRQUFNdXdCLFNBQVMsR0FBR0MsaUJBQWlCLENBQUNkLFFBQUQsQ0FBbkM7QUFDQSxRQUFNZSxhQUFhLEdBQUdGLFNBQVMsSUFBSUEsU0FBUyxDQUFDLENBQUQsQ0FBNUM7QUFDQSxRQUFNRyxhQUFhLEdBQUdILFNBQVMsSUFBSUEsU0FBUyxDQUFDLENBQUQsQ0FBNUM7QUFDQSxRQUFNO0FBQUV0eEIsaUJBQUY7QUFBaUJDLFdBQWpCO0FBQTBCRSxvQkFBMUI7QUFBNENFLFdBQTVDO0FBQXFERSxvQkFBckQ7QUFBdUVDLGtCQUFjLEdBQUdSLGFBQXhGO0FBQXVHUyxZQUFRLEdBQUdSLE9BQWxIO0FBQTJIVSxxQkFBaUIsR0FBR1I7QUFBL0ksTUFBb0treEIsU0FBMUs7O0FBQ0EsUUFBTUssV0FBVyxHQUFHLENBQUMvNUIsRUFBRCxFQUFLZzZCLFFBQUwsRUFBZXh4QyxJQUFmLEtBQXdCO0FBQ3hDeXhDLHlCQUFxQixDQUFDajZCLEVBQUQsRUFBS2c2QixRQUFRLEdBQUdaLGFBQUgsR0FBbUJILFlBQWhDLENBQXJCO0FBQ0FnQix5QkFBcUIsQ0FBQ2o2QixFQUFELEVBQUtnNkIsUUFBUSxHQUFHYixpQkFBSCxHQUF1QkgsZ0JBQXBDLENBQXJCO0FBQ0F4d0MsUUFBSSxJQUFJQSxJQUFJLEVBQVo7QUFDSCxHQUpEOztBQUtBLFFBQU0weEMsV0FBVyxHQUFHLENBQUNsNkIsRUFBRCxFQUFLeFgsSUFBTCxLQUFjO0FBQzlCeXhDLHlCQUFxQixDQUFDajZCLEVBQUQsRUFBS3U1QixZQUFMLENBQXJCO0FBQ0FVLHlCQUFxQixDQUFDajZCLEVBQUQsRUFBS3M1QixnQkFBTCxDQUFyQjtBQUNBOXdDLFFBQUksSUFBSUEsSUFBSSxFQUFaO0FBQ0gsR0FKRDs7QUFLQSxRQUFNMnhDLGFBQWEsR0FBSUgsUUFBRCxJQUFjO0FBQ2hDLFdBQU8sQ0FBQ2g2QixFQUFELEVBQUt4WCxJQUFMLEtBQWM7QUFDakIsWUFBTTBOLElBQUksR0FBRzhqQyxRQUFRLEdBQUdseEIsUUFBSCxHQUFjUixPQUFuQzs7QUFDQSxZQUFNNVcsT0FBTyxHQUFHLE1BQU1xb0MsV0FBVyxDQUFDLzVCLEVBQUQsRUFBS2c2QixRQUFMLEVBQWV4eEMsSUFBZixDQUFqQzs7QUFDQStoQixjQUFRLENBQUNyVSxJQUFELEVBQU8sQ0FBQzhKLEVBQUQsRUFBS3RPLE9BQUwsQ0FBUCxDQUFSO0FBQ0Ewb0MsZUFBUyxDQUFDLE1BQU07QUFDWkgsNkJBQXFCLENBQUNqNkIsRUFBRCxFQUFLZzZCLFFBQVEsR0FBR2QsZUFBSCxHQUFxQkgsY0FBbEMsQ0FBckI7QUFDQXNCLDBCQUFrQixDQUFDcjZCLEVBQUQsRUFBS2c2QixRQUFRLEdBQUdaLGFBQUgsR0FBbUJILFlBQWhDLENBQWxCOztBQUNBLFlBQUksQ0FBQ1EsbUJBQW1CLENBQUN2akMsSUFBRCxDQUF4QixFQUFnQztBQUM1Qm9rQyw0QkFBa0IsQ0FBQ3Q2QixFQUFELEVBQUt2ZSxJQUFMLEVBQVdvNEMsYUFBWCxFQUEwQm5vQyxPQUExQixDQUFsQjtBQUNIO0FBQ0osT0FOUSxDQUFUO0FBT0gsS0FYRDtBQVlILEdBYkQ7O0FBY0EsU0FBT25MLG1EQUFNLENBQUNtekMsU0FBRCxFQUFZO0FBQ3JCcnhCLGlCQUFhLENBQUNySSxFQUFELEVBQUs7QUFDZHVLLGNBQVEsQ0FBQ2xDLGFBQUQsRUFBZ0IsQ0FBQ3JJLEVBQUQsQ0FBaEIsQ0FBUjtBQUNBcTZCLHdCQUFrQixDQUFDcjZCLEVBQUQsRUFBSys0QixjQUFMLENBQWxCO0FBQ0FzQix3QkFBa0IsQ0FBQ3I2QixFQUFELEVBQUtnNUIsZ0JBQUwsQ0FBbEI7QUFDSCxLQUxvQjs7QUFNckJud0Isa0JBQWMsQ0FBQzdJLEVBQUQsRUFBSztBQUNmdUssY0FBUSxDQUFDMUIsY0FBRCxFQUFpQixDQUFDN0ksRUFBRCxDQUFqQixDQUFSO0FBQ0FxNkIsd0JBQWtCLENBQUNyNkIsRUFBRCxFQUFLazVCLGVBQUwsQ0FBbEI7QUFDQW1CLHdCQUFrQixDQUFDcjZCLEVBQUQsRUFBS201QixpQkFBTCxDQUFsQjtBQUNILEtBVm9COztBQVdyQjd3QixXQUFPLEVBQUU2eEIsYUFBYSxDQUFDLEtBQUQsQ0FYRDtBQVlyQnJ4QixZQUFRLEVBQUVxeEIsYUFBYSxDQUFDLElBQUQsQ0FaRjs7QUFhckJ6eEIsV0FBTyxDQUFDMUksRUFBRCxFQUFLeFgsSUFBTCxFQUFXO0FBQ2QsWUFBTWtKLE9BQU8sR0FBRyxNQUFNd29DLFdBQVcsQ0FBQ2w2QixFQUFELEVBQUt4WCxJQUFMLENBQWpDOztBQUNBNnhDLHdCQUFrQixDQUFDcjZCLEVBQUQsRUFBS3E1QixjQUFMLENBQWxCLENBRmMsQ0FHZDs7QUFDQWtCLGlCQUFXO0FBQ1hGLHdCQUFrQixDQUFDcjZCLEVBQUQsRUFBS3M1QixnQkFBTCxDQUFsQjtBQUNBYyxlQUFTLENBQUMsTUFBTTtBQUNaSCw2QkFBcUIsQ0FBQ2o2QixFQUFELEVBQUtxNUIsY0FBTCxDQUFyQjtBQUNBZ0IsMEJBQWtCLENBQUNyNkIsRUFBRCxFQUFLdTVCLFlBQUwsQ0FBbEI7O0FBQ0EsWUFBSSxDQUFDRSxtQkFBbUIsQ0FBQy93QixPQUFELENBQXhCLEVBQW1DO0FBQy9CNHhCLDRCQUFrQixDQUFDdDZCLEVBQUQsRUFBS3ZlLElBQUwsRUFBV3E0QyxhQUFYLEVBQTBCcG9DLE9BQTFCLENBQWxCO0FBQ0g7QUFDSixPQU5RLENBQVQ7QUFPQTZZLGNBQVEsQ0FBQzdCLE9BQUQsRUFBVSxDQUFDMUksRUFBRCxFQUFLdE8sT0FBTCxDQUFWLENBQVI7QUFDSCxLQTNCb0I7O0FBNEJyQjhXLG9CQUFnQixDQUFDeEksRUFBRCxFQUFLO0FBQ2pCKzVCLGlCQUFXLENBQUMvNUIsRUFBRCxFQUFLLEtBQUwsQ0FBWDtBQUNBdUssY0FBUSxDQUFDL0IsZ0JBQUQsRUFBbUIsQ0FBQ3hJLEVBQUQsQ0FBbkIsQ0FBUjtBQUNILEtBL0JvQjs7QUFnQ3JCZ0oscUJBQWlCLENBQUNoSixFQUFELEVBQUs7QUFDbEIrNUIsaUJBQVcsQ0FBQy81QixFQUFELEVBQUssSUFBTCxDQUFYO0FBQ0F1SyxjQUFRLENBQUN2QixpQkFBRCxFQUFvQixDQUFDaEosRUFBRCxDQUFwQixDQUFSO0FBQ0gsS0FuQ29COztBQW9DckI0SSxvQkFBZ0IsQ0FBQzVJLEVBQUQsRUFBSztBQUNqQms2QixpQkFBVyxDQUFDbDZCLEVBQUQsQ0FBWDtBQUNBdUssY0FBUSxDQUFDM0IsZ0JBQUQsRUFBbUIsQ0FBQzVJLEVBQUQsQ0FBbkIsQ0FBUjtBQUNIOztBQXZDb0IsR0FBWixDQUFiO0FBeUNIOztBQUNELFNBQVM0NUIsaUJBQVQsQ0FBMkJkLFFBQTNCLEVBQXFDO0FBQ2pDLE1BQUlBLFFBQVEsSUFBSSxJQUFoQixFQUFzQjtBQUNsQixXQUFPLElBQVA7QUFDSCxHQUZELE1BR0ssSUFBSXh6QyxxREFBUSxDQUFDd3pDLFFBQUQsQ0FBWixFQUF3QjtBQUN6QixXQUFPLENBQUMwQixRQUFRLENBQUMxQixRQUFRLENBQUNudUIsS0FBVixDQUFULEVBQTJCNnZCLFFBQVEsQ0FBQzFCLFFBQVEsQ0FBQzd0QixLQUFWLENBQW5DLENBQVA7QUFDSCxHQUZJLE1BR0E7QUFDRCxVQUFNakksQ0FBQyxHQUFHdzNCLFFBQVEsQ0FBQzFCLFFBQUQsQ0FBbEI7QUFDQSxXQUFPLENBQUM5MUIsQ0FBRCxFQUFJQSxDQUFKLENBQVA7QUFDSDtBQUNKOztBQUNELFNBQVN3M0IsUUFBVCxDQUFrQjl2QyxHQUFsQixFQUF1QjtBQUNuQixRQUFNbkcsR0FBRyxHQUFHd1YscURBQVEsQ0FBQ3JQLEdBQUQsQ0FBcEI7QUFDQSxNQUFLcEwsSUFBTCxFQUNJbTdDLGdCQUFnQixDQUFDbDJDLEdBQUQsQ0FBaEI7QUFDSixTQUFPQSxHQUFQO0FBQ0g7O0FBQ0QsU0FBU2syQyxnQkFBVCxDQUEwQi92QyxHQUExQixFQUErQjtBQUMzQixNQUFJLE9BQU9BLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUN6QnRFLDJEQUFJLENBQUUseURBQUQsR0FDQSxPQUFNbUosSUFBSSxDQUFDQyxTQUFMLENBQWU5RSxHQUFmLENBQW9CLEdBRDNCLENBQUo7QUFFSCxHQUhELE1BSUssSUFBSWd3QyxLQUFLLENBQUNod0MsR0FBRCxDQUFULEVBQWdCO0FBQ2pCdEUsMkRBQUksQ0FBRSwwQ0FBRCxHQUNELDZDQURBLENBQUo7QUFFSDtBQUNKOztBQUNELFNBQVNpMEMsa0JBQVQsQ0FBNEJyNkIsRUFBNUIsRUFBZ0MyNkIsR0FBaEMsRUFBcUM7QUFDakNBLEtBQUcsQ0FBQ3R6QixLQUFKLENBQVUsS0FBVixFQUFpQjNrQixPQUFqQixDQUF5QnlpQixDQUFDLElBQUlBLENBQUMsSUFBSW5GLEVBQUUsQ0FBQzQ2QixTQUFILENBQWExNEMsR0FBYixDQUFpQmlqQixDQUFqQixDQUFuQztBQUNBLEdBQUNuRixFQUFFLENBQUM2MEIsSUFBSCxLQUNJNzBCLEVBQUUsQ0FBQzYwQixJQUFILEdBQVUsSUFBSTd5QyxHQUFKLEVBRGQsQ0FBRCxFQUMyQkUsR0FEM0IsQ0FDK0J5NEMsR0FEL0I7QUFFSDs7QUFDRCxTQUFTVixxQkFBVCxDQUErQmo2QixFQUEvQixFQUFtQzI2QixHQUFuQyxFQUF3QztBQUNwQ0EsS0FBRyxDQUFDdHpCLEtBQUosQ0FBVSxLQUFWLEVBQWlCM2tCLE9BQWpCLENBQXlCeWlCLENBQUMsSUFBSUEsQ0FBQyxJQUFJbkYsRUFBRSxDQUFDNDZCLFNBQUgsQ0FBYTEzQixNQUFiLENBQW9CaUMsQ0FBcEIsQ0FBbkM7QUFDQSxRQUFNO0FBQUUwdkI7QUFBRixNQUFXNzBCLEVBQWpCOztBQUNBLE1BQUk2MEIsSUFBSixFQUFVO0FBQ05BLFFBQUksQ0FBQzV6QyxNQUFMLENBQVkwNUMsR0FBWjs7QUFDQSxRQUFJLENBQUM5RixJQUFJLENBQUN2dEMsSUFBVixFQUFnQjtBQUNaMFksUUFBRSxDQUFDNjBCLElBQUgsR0FBVXZ6QyxTQUFWO0FBQ0g7QUFDSjtBQUNKOztBQUNELFNBQVM4NEMsU0FBVCxDQUFtQmxuQyxFQUFuQixFQUF1QjtBQUNuQjJuQyx1QkFBcUIsQ0FBQyxNQUFNO0FBQ3hCQSx5QkFBcUIsQ0FBQzNuQyxFQUFELENBQXJCO0FBQ0gsR0FGb0IsQ0FBckI7QUFHSDs7QUFDRCxJQUFJNG5DLEtBQUssR0FBRyxDQUFaOztBQUNBLFNBQVNSLGtCQUFULENBQTRCdDZCLEVBQTVCLEVBQWdDdVgsWUFBaEMsRUFBOEN3akIsZUFBOUMsRUFBK0RycEMsT0FBL0QsRUFBd0U7QUFDcEUsUUFBTTdRLEVBQUUsR0FBSW1mLEVBQUUsQ0FBQ2c3QixNQUFILEdBQVksRUFBRUYsS0FBMUI7O0FBQ0EsUUFBTUcsaUJBQWlCLEdBQUcsTUFBTTtBQUM1QixRQUFJcDZDLEVBQUUsS0FBS21mLEVBQUUsQ0FBQ2c3QixNQUFkLEVBQXNCO0FBQ2xCdHBDLGFBQU87QUFDVjtBQUNKLEdBSkQ7O0FBS0EsTUFBSXFwQyxlQUFKLEVBQXFCO0FBQ2pCLFdBQU9wNEIsVUFBVSxDQUFDczRCLGlCQUFELEVBQW9CRixlQUFwQixDQUFqQjtBQUNIOztBQUNELFFBQU07QUFBRXQ1QyxRQUFGO0FBQVFpaEIsV0FBUjtBQUFpQnc0QjtBQUFqQixNQUErQkMsaUJBQWlCLENBQUNuN0IsRUFBRCxFQUFLdVgsWUFBTCxDQUF0RDs7QUFDQSxNQUFJLENBQUM5MUIsSUFBTCxFQUFXO0FBQ1AsV0FBT2lRLE9BQU8sRUFBZDtBQUNIOztBQUNELFFBQU0wcEMsUUFBUSxHQUFHMzVDLElBQUksR0FBRyxLQUF4QjtBQUNBLE1BQUk0NUMsS0FBSyxHQUFHLENBQVo7O0FBQ0EsUUFBTWhwQyxHQUFHLEdBQUcsTUFBTTtBQUNkMk4sTUFBRSxDQUFDNDJCLG1CQUFILENBQXVCd0UsUUFBdkIsRUFBaUNFLEtBQWpDO0FBQ0FMLHFCQUFpQjtBQUNwQixHQUhEOztBQUlBLFFBQU1LLEtBQUssR0FBSXZsQyxDQUFELElBQU87QUFDakIsUUFBSUEsQ0FBQyxDQUFDdlUsTUFBRixLQUFhd2UsRUFBYixJQUFtQixFQUFFcTdCLEtBQUYsSUFBV0gsU0FBbEMsRUFBNkM7QUFDekM3b0MsU0FBRztBQUNOO0FBQ0osR0FKRDs7QUFLQXNRLFlBQVUsQ0FBQyxNQUFNO0FBQ2IsUUFBSTA0QixLQUFLLEdBQUdILFNBQVosRUFBdUI7QUFDbkI3b0MsU0FBRztBQUNOO0FBQ0osR0FKUyxFQUlQcVEsT0FBTyxHQUFHLENBSkgsQ0FBVjtBQUtBMUMsSUFBRSxDQUFDMjJCLGdCQUFILENBQW9CeUUsUUFBcEIsRUFBOEJFLEtBQTlCO0FBQ0g7O0FBQ0QsU0FBU0gsaUJBQVQsQ0FBMkJuN0IsRUFBM0IsRUFBK0J1WCxZQUEvQixFQUE2QztBQUN6QyxRQUFNZ2tCLE1BQU0sR0FBRzdtQyxNQUFNLENBQUM4bUMsZ0JBQVAsQ0FBd0J4N0IsRUFBeEIsQ0FBZixDQUR5QyxDQUV6Qzs7QUFDQSxRQUFNeTdCLGtCQUFrQixHQUFJLzVDLEdBQUQsSUFBUyxDQUFDNjVDLE1BQU0sQ0FBQzc1QyxHQUFELENBQU4sSUFBZSxFQUFoQixFQUFvQjJsQixLQUFwQixDQUEwQixJQUExQixDQUFwQzs7QUFDQSxRQUFNcTBCLGdCQUFnQixHQUFHRCxrQkFBa0IsQ0FBQ2pELFVBQVUsR0FBRyxPQUFkLENBQTNDO0FBQ0EsUUFBTW1ELG1CQUFtQixHQUFHRixrQkFBa0IsQ0FBQ2pELFVBQVUsR0FBRyxVQUFkLENBQTlDO0FBQ0EsUUFBTW9ELGlCQUFpQixHQUFHQyxVQUFVLENBQUNILGdCQUFELEVBQW1CQyxtQkFBbkIsQ0FBcEM7QUFDQSxRQUFNRyxlQUFlLEdBQUdMLGtCQUFrQixDQUFDaEQsU0FBUyxHQUFHLE9BQWIsQ0FBMUM7QUFDQSxRQUFNc0Qsa0JBQWtCLEdBQUdOLGtCQUFrQixDQUFDaEQsU0FBUyxHQUFHLFVBQWIsQ0FBN0M7QUFDQSxRQUFNdUQsZ0JBQWdCLEdBQUdILFVBQVUsQ0FBQ0MsZUFBRCxFQUFrQkMsa0JBQWxCLENBQW5DO0FBQ0EsTUFBSXQ2QyxJQUFJLEdBQUcsSUFBWDtBQUNBLE1BQUlpaEIsT0FBTyxHQUFHLENBQWQ7QUFDQSxNQUFJdzRCLFNBQVMsR0FBRyxDQUFoQjtBQUNBOztBQUNBLE1BQUkzakIsWUFBWSxLQUFLaWhCLFVBQXJCLEVBQWlDO0FBQzdCLFFBQUlvRCxpQkFBaUIsR0FBRyxDQUF4QixFQUEyQjtBQUN2Qm42QyxVQUFJLEdBQUcrMkMsVUFBUDtBQUNBOTFCLGFBQU8sR0FBR2s1QixpQkFBVjtBQUNBVixlQUFTLEdBQUdTLG1CQUFtQixDQUFDLzZDLE1BQWhDO0FBQ0g7QUFDSixHQU5ELE1BT0ssSUFBSTIyQixZQUFZLEtBQUtraEIsU0FBckIsRUFBZ0M7QUFDakMsUUFBSXVELGdCQUFnQixHQUFHLENBQXZCLEVBQTBCO0FBQ3RCdjZDLFVBQUksR0FBR2czQyxTQUFQO0FBQ0EvMUIsYUFBTyxHQUFHczVCLGdCQUFWO0FBQ0FkLGVBQVMsR0FBR2Esa0JBQWtCLENBQUNuN0MsTUFBL0I7QUFDSDtBQUNKLEdBTkksTUFPQTtBQUNEOGhCLFdBQU8sR0FBR3lpQixJQUFJLENBQUM5WCxHQUFMLENBQVN1dUIsaUJBQVQsRUFBNEJJLGdCQUE1QixDQUFWO0FBQ0F2NkMsUUFBSSxHQUNBaWhCLE9BQU8sR0FBRyxDQUFWLEdBQ01rNUIsaUJBQWlCLEdBQUdJLGdCQUFwQixHQUNJeEQsVUFESixHQUVJQyxTQUhWLEdBSU0sSUFMVjtBQU1BeUMsYUFBUyxHQUFHejVDLElBQUksR0FDVkEsSUFBSSxLQUFLKzJDLFVBQVQsR0FDSW1ELG1CQUFtQixDQUFDLzZDLE1BRHhCLEdBRUltN0Msa0JBQWtCLENBQUNuN0MsTUFIYixHQUlWLENBSk47QUFLSDs7QUFDRCxRQUFNcTdDLFlBQVksR0FBR3g2QyxJQUFJLEtBQUsrMkMsVUFBVCxJQUNqQix5QkFBeUJ0cEIsSUFBekIsQ0FBOEJxc0IsTUFBTSxDQUFDL0MsVUFBVSxHQUFHLFVBQWQsQ0FBcEMsQ0FESjtBQUVBLFNBQU87QUFDSC8yQyxRQURHO0FBRUhpaEIsV0FGRztBQUdIdzRCLGFBSEc7QUFJSGU7QUFKRyxHQUFQO0FBTUg7O0FBQ0QsU0FBU0osVUFBVCxDQUFvQkssTUFBcEIsRUFBNEJ2QyxTQUE1QixFQUF1QztBQUNuQyxTQUFPdUMsTUFBTSxDQUFDdDdDLE1BQVAsR0FBZ0IrNEMsU0FBUyxDQUFDLzRDLE1BQWpDLEVBQXlDO0FBQ3JDczdDLFVBQU0sR0FBR0EsTUFBTSxDQUFDNzlCLE1BQVAsQ0FBYzY5QixNQUFkLENBQVQ7QUFDSDs7QUFDRCxTQUFPL1csSUFBSSxDQUFDOVgsR0FBTCxDQUFTLEdBQUdzc0IsU0FBUyxDQUFDcjJDLEdBQVYsQ0FBYyxDQUFDNjRDLENBQUQsRUFBSW43QyxDQUFKLEtBQVVvN0MsSUFBSSxDQUFDRCxDQUFELENBQUosR0FBVUMsSUFBSSxDQUFDRixNQUFNLENBQUNsN0MsQ0FBRCxDQUFQLENBQXRDLENBQVosQ0FBUDtBQUNILEMsQ0FDRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU283QyxJQUFULENBQWN4M0IsQ0FBZCxFQUFpQjtBQUNiLFNBQU9oZixNQUFNLENBQUNnZixDQUFDLENBQUN4VixLQUFGLENBQVEsQ0FBUixFQUFXLENBQUMsQ0FBWixFQUFlbU0sT0FBZixDQUF1QixHQUF2QixFQUE0QixHQUE1QixDQUFELENBQU4sR0FBMkMsSUFBbEQ7QUFDSCxDLENBQ0Q7OztBQUNBLFNBQVNnL0IsV0FBVCxHQUF1QjtBQUNuQixTQUFPLzFCLFFBQVEsQ0FBQ211QixJQUFULENBQWMwSixZQUFyQjtBQUNIOztBQUVELE1BQU1DLFdBQVcsR0FBRyxJQUFJcjlDLE9BQUosRUFBcEI7QUFDQSxNQUFNczlDLGNBQWMsR0FBRyxJQUFJdDlDLE9BQUosRUFBdkI7QUFDQSxNQUFNdTlDLG1CQUFtQixHQUFHO0FBQ3hCOXNDLE1BQUksRUFBRSxpQkFEa0I7QUFFeEJULE9BQUssRUFBRSxhQUFjMUksbURBQU0sQ0FBQyxFQUFELEVBQUtpekMseUJBQUwsRUFBZ0M7QUFDdkQxRixPQUFHLEVBQUV6dEMsTUFEa0Q7QUFFdkRvMkMsYUFBUyxFQUFFcDJDO0FBRjRDLEdBQWhDLENBRkg7O0FBTXhCNGlCLE9BQUssQ0FBQ2hhLEtBQUQsRUFBUTtBQUFFOE47QUFBRixHQUFSLEVBQW1CO0FBQ3BCLFVBQU12UCxRQUFRLEdBQUc2SyxxRUFBa0IsRUFBbkM7QUFDQSxVQUFNcVAsS0FBSyxHQUFHRCxxRUFBa0IsRUFBaEM7QUFDQSxRQUFJakksWUFBSjtBQUNBLFFBQUlkLFFBQUo7QUFDQWtRLGdFQUFTLENBQUMsTUFBTTtBQUNaO0FBQ0EsVUFBSSxDQUFDcFAsWUFBWSxDQUFDNWUsTUFBbEIsRUFBMEI7QUFDdEI7QUFDSDs7QUFDRCxZQUFNNjdDLFNBQVMsR0FBR3h0QyxLQUFLLENBQUN3dEMsU0FBTixJQUFvQixHQUFFeHRDLEtBQUssQ0FBQ1MsSUFBTixJQUFjLEdBQUksT0FBMUQ7O0FBQ0EsVUFBSSxDQUFDZ3RDLGVBQWUsQ0FBQ2w5QixZQUFZLENBQUMsQ0FBRCxDQUFaLENBQWdCUSxFQUFqQixFQUFxQnhTLFFBQVEsQ0FBQ0gsS0FBVCxDQUFlMlMsRUFBcEMsRUFBd0N5OEIsU0FBeEMsQ0FBcEIsRUFBd0U7QUFDcEU7QUFDSCxPQVJXLENBU1o7QUFDQTs7O0FBQ0FqOUIsa0JBQVksQ0FBQzljLE9BQWIsQ0FBcUJpNkMsY0FBckI7QUFDQW45QixrQkFBWSxDQUFDOWMsT0FBYixDQUFxQms2QyxjQUFyQjtBQUNBLFlBQU1DLGFBQWEsR0FBR3I5QixZQUFZLENBQUNqYyxNQUFiLENBQW9CdTVDLGdCQUFwQixDQUF0QixDQWJZLENBY1o7O0FBQ0F2QyxpQkFBVztBQUNYc0MsbUJBQWEsQ0FBQ242QyxPQUFkLENBQXNCeWlCLENBQUMsSUFBSTtBQUN2QixjQUFNbkYsRUFBRSxHQUFHbUYsQ0FBQyxDQUFDbkYsRUFBYjtBQUNBLGNBQU1nakIsS0FBSyxHQUFHaGpCLEVBQUUsQ0FBQ2dqQixLQUFqQjtBQUNBcVgsMEJBQWtCLENBQUNyNkIsRUFBRCxFQUFLeThCLFNBQUwsQ0FBbEI7QUFDQXpaLGFBQUssQ0FBQytaLFNBQU4sR0FBa0IvWixLQUFLLENBQUNnYSxlQUFOLEdBQXdCaGEsS0FBSyxDQUFDaWEsa0JBQU4sR0FBMkIsRUFBckU7O0FBQ0EsY0FBTS9wQyxFQUFFLEdBQUk4TSxFQUFFLENBQUNrOUIsT0FBSCxHQUFjbm5DLENBQUQsSUFBTztBQUM1QixjQUFJQSxDQUFDLElBQUlBLENBQUMsQ0FBQ3ZVLE1BQUYsS0FBYXdlLEVBQXRCLEVBQTBCO0FBQ3RCO0FBQ0g7O0FBQ0QsY0FBSSxDQUFDakssQ0FBRCxJQUFNLGFBQWFtWixJQUFiLENBQWtCblosQ0FBQyxDQUFDb25DLFlBQXBCLENBQVYsRUFBNkM7QUFDekNuOUIsY0FBRSxDQUFDNDJCLG1CQUFILENBQXVCLGVBQXZCLEVBQXdDMWpDLEVBQXhDO0FBQ0E4TSxjQUFFLENBQUNrOUIsT0FBSCxHQUFhLElBQWI7QUFDQWpELGlDQUFxQixDQUFDajZCLEVBQUQsRUFBS3k4QixTQUFMLENBQXJCO0FBQ0g7QUFDSixTQVREOztBQVVBejhCLFVBQUUsQ0FBQzIyQixnQkFBSCxDQUFvQixlQUFwQixFQUFxQ3pqQyxFQUFyQztBQUNILE9BaEJEO0FBaUJILEtBakNRLENBQVQ7QUFrQ0EsV0FBTyxNQUFNO0FBQ1QsWUFBTWtXLFFBQVEsR0FBRy9rQix3REFBSyxDQUFDNEssS0FBRCxDQUF0QjtBQUNBLFlBQU1tdUMsa0JBQWtCLEdBQUd6RSxzQkFBc0IsQ0FBQ3Z2QixRQUFELENBQWpEO0FBQ0EsVUFBSTBxQixHQUFHLEdBQUcxcUIsUUFBUSxDQUFDMHFCLEdBQVQsSUFBZ0J2OUIsdURBQTFCO0FBQ0FpSixrQkFBWSxHQUFHZCxRQUFmO0FBQ0FBLGNBQVEsR0FBRzNCLEtBQUssQ0FBQzRILE9BQU4sR0FBZ0J3RSwyRUFBd0IsQ0FBQ3BNLEtBQUssQ0FBQzRILE9BQU4sRUFBRCxDQUF4QyxHQUE0RCxFQUF2RTs7QUFDQSxXQUFLLElBQUkzakIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzBkLFFBQVEsQ0FBQzlkLE1BQTdCLEVBQXFDSSxDQUFDLEVBQXRDLEVBQTBDO0FBQ3RDLGNBQU1pZSxLQUFLLEdBQUdQLFFBQVEsQ0FBQzFkLENBQUQsQ0FBdEI7O0FBQ0EsWUFBSWllLEtBQUssQ0FBQ3ZkLEdBQU4sSUFBYSxJQUFqQixFQUF1QjtBQUNuQmdvQiwrRUFBa0IsQ0FBQ3pLLEtBQUQsRUFBUXdLLHlFQUFzQixDQUFDeEssS0FBRCxFQUFRbStCLGtCQUFSLEVBQTRCMTFCLEtBQTVCLEVBQW1DbGEsUUFBbkMsQ0FBOUIsQ0FBbEI7QUFDSCxTQUZELE1BR0ssSUFBS2xPLElBQUwsRUFBNkM7QUFDOUM4RyxpRUFBSSxDQUFFLDJDQUFGLENBQUo7QUFDSDtBQUNKOztBQUNELFVBQUlvWixZQUFKLEVBQWtCO0FBQ2QsYUFBSyxJQUFJeGUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3dlLFlBQVksQ0FBQzVlLE1BQWpDLEVBQXlDSSxDQUFDLEVBQTFDLEVBQThDO0FBQzFDLGdCQUFNaWUsS0FBSyxHQUFHTyxZQUFZLENBQUN4ZSxDQUFELENBQTFCO0FBQ0Ewb0IsK0VBQWtCLENBQUN6SyxLQUFELEVBQVF3Syx5RUFBc0IsQ0FBQ3hLLEtBQUQsRUFBUW0rQixrQkFBUixFQUE0QjExQixLQUE1QixFQUFtQ2xhLFFBQW5DLENBQTlCLENBQWxCO0FBQ0E4dUMscUJBQVcsQ0FBQ3o2QyxHQUFaLENBQWdCb2QsS0FBaEIsRUFBdUJBLEtBQUssQ0FBQ2UsRUFBTixDQUFTcTlCLHFCQUFULEVBQXZCO0FBQ0g7QUFDSjs7QUFDRCxhQUFPNytCLDhEQUFXLENBQUNzMUIsR0FBRCxFQUFNLElBQU4sRUFBWXAxQixRQUFaLENBQWxCO0FBQ0gsS0F2QkQ7QUF3Qkg7O0FBckV1QixDQUE1QjtBQXVFQSxNQUFNNCtCLGVBQWUsR0FBR2QsbUJBQXhCOztBQUNBLFNBQVNHLGNBQVQsQ0FBd0J4M0IsQ0FBeEIsRUFBMkI7QUFDdkIsUUFBTW5GLEVBQUUsR0FBR21GLENBQUMsQ0FBQ25GLEVBQWI7O0FBQ0EsTUFBSUEsRUFBRSxDQUFDazlCLE9BQVAsRUFBZ0I7QUFDWmw5QixNQUFFLENBQUNrOUIsT0FBSDtBQUNIOztBQUNELE1BQUlsOUIsRUFBRSxDQUFDK0ssUUFBUCxFQUFpQjtBQUNiL0ssTUFBRSxDQUFDK0ssUUFBSDtBQUNIO0FBQ0o7O0FBQ0QsU0FBUzZ4QixjQUFULENBQXdCejNCLENBQXhCLEVBQTJCO0FBQ3ZCbzNCLGdCQUFjLENBQUMxNkMsR0FBZixDQUFtQnNqQixDQUFuQixFQUFzQkEsQ0FBQyxDQUFDbkYsRUFBRixDQUFLcTlCLHFCQUFMLEVBQXRCO0FBQ0g7O0FBQ0QsU0FBU1AsZ0JBQVQsQ0FBMEIzM0IsQ0FBMUIsRUFBNkI7QUFDekIsUUFBTW80QixNQUFNLEdBQUdqQixXQUFXLENBQUMxNkMsR0FBWixDQUFnQnVqQixDQUFoQixDQUFmO0FBQ0EsUUFBTXE0QixNQUFNLEdBQUdqQixjQUFjLENBQUMzNkMsR0FBZixDQUFtQnVqQixDQUFuQixDQUFmO0FBQ0EsUUFBTXM0QixFQUFFLEdBQUdGLE1BQU0sQ0FBQ0csSUFBUCxHQUFjRixNQUFNLENBQUNFLElBQWhDO0FBQ0EsUUFBTUMsRUFBRSxHQUFHSixNQUFNLENBQUNLLEdBQVAsR0FBYUosTUFBTSxDQUFDSSxHQUEvQjs7QUFDQSxNQUFJSCxFQUFFLElBQUlFLEVBQVYsRUFBYztBQUNWLFVBQU0vNEIsQ0FBQyxHQUFHTyxDQUFDLENBQUNuRixFQUFGLENBQUtnakIsS0FBZjtBQUNBcGUsS0FBQyxDQUFDbTRCLFNBQUYsR0FBY240QixDQUFDLENBQUNvNEIsZUFBRixHQUFxQixhQUFZUyxFQUFHLE1BQUtFLEVBQUcsS0FBMUQ7QUFDQS80QixLQUFDLENBQUNxNEIsa0JBQUYsR0FBdUIsSUFBdkI7QUFDQSxXQUFPOTNCLENBQVA7QUFDSDtBQUNKOztBQUNELFNBQVN1M0IsZUFBVCxDQUF5QjE4QixFQUF6QixFQUE2QnZDLElBQTdCLEVBQW1DZy9CLFNBQW5DLEVBQThDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFNdnhCLEtBQUssR0FBR2xMLEVBQUUsQ0FBQ2toQixTQUFILEVBQWQ7O0FBQ0EsTUFBSWxoQixFQUFFLENBQUM2MEIsSUFBUCxFQUFhO0FBQ1Q3MEIsTUFBRSxDQUFDNjBCLElBQUgsQ0FBUW55QyxPQUFSLENBQWdCaTRDLEdBQUcsSUFBSTtBQUNuQkEsU0FBRyxDQUFDdHpCLEtBQUosQ0FBVSxLQUFWLEVBQWlCM2tCLE9BQWpCLENBQXlCeWlCLENBQUMsSUFBSUEsQ0FBQyxJQUFJK0YsS0FBSyxDQUFDMHZCLFNBQU4sQ0FBZ0IxM0IsTUFBaEIsQ0FBdUJpQyxDQUF2QixDQUFuQztBQUNILEtBRkQ7QUFHSDs7QUFDRHMzQixXQUFTLENBQUNwMUIsS0FBVixDQUFnQixLQUFoQixFQUF1QjNrQixPQUF2QixDQUErQnlpQixDQUFDLElBQUlBLENBQUMsSUFBSStGLEtBQUssQ0FBQzB2QixTQUFOLENBQWdCMTRDLEdBQWhCLENBQW9CaWpCLENBQXBCLENBQXpDO0FBQ0ErRixPQUFLLENBQUM4WCxLQUFOLENBQVlpUyxPQUFaLEdBQXNCLE1BQXRCO0FBQ0EsUUFBTTEwQixTQUFTLEdBQUk5QyxJQUFJLENBQUNrZSxRQUFMLEtBQWtCLENBQWxCLEdBQ2JsZSxJQURhLEdBRWJBLElBQUksQ0FBQ3dGLFVBRlg7QUFHQTFDLFdBQVMsQ0FBQ3M5QixXQUFWLENBQXNCM3lCLEtBQXRCO0FBQ0EsUUFBTTtBQUFFK3dCO0FBQUYsTUFBbUJkLGlCQUFpQixDQUFDandCLEtBQUQsQ0FBMUM7QUFDQTNLLFdBQVMsQ0FBQ3N6QixXQUFWLENBQXNCM29CLEtBQXRCO0FBQ0EsU0FBTyt3QixZQUFQO0FBQ0g7O0FBRUQsTUFBTTZCLGdCQUFnQixHQUFJendDLEtBQUQsSUFBVztBQUNoQyxRQUFNNU4sRUFBRSxHQUFHNE4sS0FBSyxDQUFDNEIsS0FBTixDQUFZLHFCQUFaLENBQVg7QUFDQSxTQUFPdE0sb0RBQU8sQ0FBQ2xELEVBQUQsQ0FBUCxHQUFjNEYsS0FBSyxJQUFJeW9CLDJEQUFjLENBQUNydUIsRUFBRCxFQUFLNEYsS0FBTCxDQUFyQyxHQUFtRDVGLEVBQTFEO0FBQ0gsQ0FIRDs7QUFJQSxTQUFTcytDLGtCQUFULENBQTRCaG9DLENBQTVCLEVBQStCO0FBQzNCQSxHQUFDLENBQUN2VSxNQUFGLENBQVN3OEMsU0FBVCxHQUFxQixJQUFyQjtBQUNIOztBQUNELFNBQVNDLGdCQUFULENBQTBCbG9DLENBQTFCLEVBQTZCO0FBQ3pCLFFBQU12VSxNQUFNLEdBQUd1VSxDQUFDLENBQUN2VSxNQUFqQjs7QUFDQSxNQUFJQSxNQUFNLENBQUN3OEMsU0FBWCxFQUFzQjtBQUNsQng4QyxVQUFNLENBQUN3OEMsU0FBUCxHQUFtQixLQUFuQjtBQUNBNTdDLFdBQU8sQ0FBQ1osTUFBRCxFQUFTLE9BQVQsQ0FBUDtBQUNIO0FBQ0o7O0FBQ0QsU0FBU1ksT0FBVCxDQUFpQjRkLEVBQWpCLEVBQXFCdmUsSUFBckIsRUFBMkI7QUFDdkIsUUFBTXNVLENBQUMsR0FBR3lPLFFBQVEsQ0FBQzJ4QixXQUFULENBQXFCLFlBQXJCLENBQVY7QUFDQXBnQyxHQUFDLENBQUNtb0MsU0FBRixDQUFZejhDLElBQVosRUFBa0IsSUFBbEIsRUFBd0IsSUFBeEI7QUFDQXVlLElBQUUsQ0FBQ20rQixhQUFILENBQWlCcG9DLENBQWpCO0FBQ0gsQyxDQUNEO0FBQ0E7OztBQUNBLE1BQU1xb0MsVUFBVSxHQUFHO0FBQ2Y5c0IsU0FBTyxDQUFDdFIsRUFBRCxFQUFLO0FBQUVzWixhQUFTLEVBQUU7QUFBRXQ1QixVQUFGO0FBQVE4WixVQUFSO0FBQWNEO0FBQWQ7QUFBYixHQUFMLEVBQTRDeE0sS0FBNUMsRUFBbUQ7QUFDdEQyUyxNQUFFLENBQUNxK0IsT0FBSCxHQUFhUCxnQkFBZ0IsQ0FBQ3p3QyxLQUFELENBQTdCO0FBQ0EsVUFBTWl4QyxZQUFZLEdBQUd6a0MsTUFBTSxJQUFJbUcsRUFBRSxDQUFDdmUsSUFBSCxLQUFZLFFBQTNDO0FBQ0FrMUMsb0JBQWdCLENBQUMzMkIsRUFBRCxFQUFLaGdCLElBQUksR0FBRyxRQUFILEdBQWMsT0FBdkIsRUFBZ0MrVixDQUFDLElBQUk7QUFDakQsVUFBSUEsQ0FBQyxDQUFDdlUsTUFBRixDQUFTdzhDLFNBQWIsRUFDSTtBQUNKLFVBQUlPLFFBQVEsR0FBR3YrQixFQUFFLENBQUMzYSxLQUFsQjs7QUFDQSxVQUFJeVUsSUFBSixFQUFVO0FBQ055a0MsZ0JBQVEsR0FBR0EsUUFBUSxDQUFDemtDLElBQVQsRUFBWDtBQUNILE9BRkQsTUFHSyxJQUFJd2tDLFlBQUosRUFBa0I7QUFDbkJDLGdCQUFRLEdBQUd4a0MscURBQVEsQ0FBQ3drQyxRQUFELENBQW5CO0FBQ0g7O0FBQ0R2K0IsUUFBRSxDQUFDcStCLE9BQUgsQ0FBV0UsUUFBWDtBQUNILEtBWGUsQ0FBaEI7O0FBWUEsUUFBSXprQyxJQUFKLEVBQVU7QUFDTjY4QixzQkFBZ0IsQ0FBQzMyQixFQUFELEVBQUssUUFBTCxFQUFlLE1BQU07QUFDakNBLFVBQUUsQ0FBQzNhLEtBQUgsR0FBVzJhLEVBQUUsQ0FBQzNhLEtBQUgsQ0FBU3lVLElBQVQsRUFBWDtBQUNILE9BRmUsQ0FBaEI7QUFHSDs7QUFDRCxRQUFJLENBQUM5WixJQUFMLEVBQVc7QUFDUDIyQyxzQkFBZ0IsQ0FBQzMyQixFQUFELEVBQUssa0JBQUwsRUFBeUIrOUIsa0JBQXpCLENBQWhCO0FBQ0FwSCxzQkFBZ0IsQ0FBQzMyQixFQUFELEVBQUssZ0JBQUwsRUFBdUJpK0IsZ0JBQXZCLENBQWhCLENBRk8sQ0FHUDtBQUNBO0FBQ0E7QUFDQTs7QUFDQXRILHNCQUFnQixDQUFDMzJCLEVBQUQsRUFBSyxRQUFMLEVBQWVpK0IsZ0JBQWYsQ0FBaEI7QUFDSDtBQUNKLEdBOUJjOztBQStCZjtBQUNBenNCLFNBQU8sQ0FBQ3hSLEVBQUQsRUFBSztBQUFFM2E7QUFBRixHQUFMLEVBQWdCO0FBQ25CMmEsTUFBRSxDQUFDM2EsS0FBSCxHQUFXQSxLQUFLLElBQUksSUFBVCxHQUFnQixFQUFoQixHQUFxQkEsS0FBaEM7QUFDSCxHQWxDYzs7QUFtQ2Zvc0IsY0FBWSxDQUFDelIsRUFBRCxFQUFLO0FBQUUzYSxTQUFGO0FBQVNpMEIsYUFBUyxFQUFFO0FBQUV4ZixVQUFGO0FBQVFEO0FBQVI7QUFBcEIsR0FBTCxFQUE2Q3hNLEtBQTdDLEVBQW9EO0FBQzVEMlMsTUFBRSxDQUFDcStCLE9BQUgsR0FBYVAsZ0JBQWdCLENBQUN6d0MsS0FBRCxDQUE3QixDQUQ0RCxDQUU1RDs7QUFDQSxRQUFJMlMsRUFBRSxDQUFDZytCLFNBQVAsRUFDSTs7QUFDSixRQUFJeDVCLFFBQVEsQ0FBQ2c2QixhQUFULEtBQTJCeCtCLEVBQS9CLEVBQW1DO0FBQy9CLFVBQUlsRyxJQUFJLElBQUlrRyxFQUFFLENBQUMzYSxLQUFILENBQVN5VSxJQUFULE9BQW9CelUsS0FBaEMsRUFBdUM7QUFDbkM7QUFDSDs7QUFDRCxVQUFJLENBQUN3VSxNQUFNLElBQUltRyxFQUFFLENBQUN2ZSxJQUFILEtBQVksUUFBdkIsS0FBb0NzWSxxREFBUSxDQUFDaUcsRUFBRSxDQUFDM2EsS0FBSixDQUFSLEtBQXVCQSxLQUEvRCxFQUFzRTtBQUNsRTtBQUNIO0FBQ0o7O0FBQ0QsVUFBTWhELFFBQVEsR0FBR2dELEtBQUssSUFBSSxJQUFULEdBQWdCLEVBQWhCLEdBQXFCQSxLQUF0Qzs7QUFDQSxRQUFJMmEsRUFBRSxDQUFDM2EsS0FBSCxLQUFhaEQsUUFBakIsRUFBMkI7QUFDdkIyZCxRQUFFLENBQUMzYSxLQUFILEdBQVdoRCxRQUFYO0FBQ0g7QUFDSjs7QUFwRGMsQ0FBbkI7QUFzREEsTUFBTW84QyxjQUFjLEdBQUc7QUFDbkJudEIsU0FBTyxDQUFDdFIsRUFBRCxFQUFLNFksQ0FBTCxFQUFRdnJCLEtBQVIsRUFBZTtBQUNsQjJTLE1BQUUsQ0FBQ3ErQixPQUFILEdBQWFQLGdCQUFnQixDQUFDendDLEtBQUQsQ0FBN0I7QUFDQXNwQyxvQkFBZ0IsQ0FBQzMyQixFQUFELEVBQUssUUFBTCxFQUFlLE1BQU07QUFDakMsWUFBTTArQixVQUFVLEdBQUcxK0IsRUFBRSxDQUFDMitCLFdBQXRCO0FBQ0EsWUFBTUMsWUFBWSxHQUFHQyxRQUFRLENBQUM3K0IsRUFBRCxDQUE3QjtBQUNBLFlBQU04K0IsT0FBTyxHQUFHOStCLEVBQUUsQ0FBQzgrQixPQUFuQjtBQUNBLFlBQU1DLE1BQU0sR0FBRy8rQixFQUFFLENBQUNxK0IsT0FBbEI7O0FBQ0EsVUFBSTE3QyxvREFBTyxDQUFDKzdDLFVBQUQsQ0FBWCxFQUF5QjtBQUNyQixjQUFNcnJDLEtBQUssR0FBRzJyQyx5REFBWSxDQUFDTixVQUFELEVBQWFFLFlBQWIsQ0FBMUI7QUFDQSxjQUFNSyxLQUFLLEdBQUc1ckMsS0FBSyxLQUFLLENBQUMsQ0FBekI7O0FBQ0EsWUFBSXlyQyxPQUFPLElBQUksQ0FBQ0csS0FBaEIsRUFBdUI7QUFDbkJGLGdCQUFNLENBQUNMLFVBQVUsQ0FBQ3JnQyxNQUFYLENBQWtCdWdDLFlBQWxCLENBQUQsQ0FBTjtBQUNILFNBRkQsTUFHSyxJQUFJLENBQUNFLE9BQUQsSUFBWUcsS0FBaEIsRUFBdUI7QUFDeEIsZ0JBQU1DLFFBQVEsR0FBRyxDQUFDLEdBQUdSLFVBQUosQ0FBakI7QUFDQVEsa0JBQVEsQ0FBQ3RzQyxNQUFULENBQWdCUyxLQUFoQixFQUF1QixDQUF2QjtBQUNBMHJDLGdCQUFNLENBQUNHLFFBQUQsQ0FBTjtBQUNIO0FBQ0osT0FYRCxNQVlLLElBQUkzM0Isa0RBQUssQ0FBQ20zQixVQUFELENBQVQsRUFBdUI7QUFDeEIsY0FBTWxVLE1BQU0sR0FBRyxJQUFJeG9DLEdBQUosQ0FBUTA4QyxVQUFSLENBQWY7O0FBQ0EsWUFBSUksT0FBSixFQUFhO0FBQ1R0VSxnQkFBTSxDQUFDdG9DLEdBQVAsQ0FBVzA4QyxZQUFYO0FBQ0gsU0FGRCxNQUdLO0FBQ0RwVSxnQkFBTSxDQUFDdnBDLE1BQVAsQ0FBYzI5QyxZQUFkO0FBQ0g7O0FBQ0RHLGNBQU0sQ0FBQ3ZVLE1BQUQsQ0FBTjtBQUNILE9BVEksTUFVQTtBQUNEdVUsY0FBTSxDQUFDSSxnQkFBZ0IsQ0FBQ24vQixFQUFELEVBQUs4K0IsT0FBTCxDQUFqQixDQUFOO0FBQ0g7QUFDSixLQTlCZSxDQUFoQjtBQStCSCxHQWxDa0I7O0FBbUNuQjtBQUNBdHRCLFNBQU8sRUFBRTR0QixVQXBDVTs7QUFxQ25CM3RCLGNBQVksQ0FBQ3pSLEVBQUQsRUFBS3laLE9BQUwsRUFBY3BzQixLQUFkLEVBQXFCO0FBQzdCMlMsTUFBRSxDQUFDcStCLE9BQUgsR0FBYVAsZ0JBQWdCLENBQUN6d0MsS0FBRCxDQUE3QjtBQUNBK3hDLGNBQVUsQ0FBQ3AvQixFQUFELEVBQUt5WixPQUFMLEVBQWNwc0IsS0FBZCxDQUFWO0FBQ0g7O0FBeENrQixDQUF2Qjs7QUEwQ0EsU0FBUyt4QyxVQUFULENBQW9CcC9CLEVBQXBCLEVBQXdCO0FBQUUzYSxPQUFGO0FBQVMvQztBQUFULENBQXhCLEVBQTZDK0ssS0FBN0MsRUFBb0Q7QUFDaEQyUyxJQUFFLENBQUMyK0IsV0FBSCxHQUFpQnQ1QyxLQUFqQjs7QUFDQSxNQUFJMUMsb0RBQU8sQ0FBQzBDLEtBQUQsQ0FBWCxFQUFvQjtBQUNoQjJhLE1BQUUsQ0FBQzgrQixPQUFILEdBQWFFLHlEQUFZLENBQUMzNUMsS0FBRCxFQUFRZ0ksS0FBSyxDQUFDNEIsS0FBTixDQUFZNUosS0FBcEIsQ0FBWixHQUF5QyxDQUFDLENBQXZEO0FBQ0gsR0FGRCxNQUdLLElBQUlraUIsa0RBQUssQ0FBQ2xpQixLQUFELENBQVQsRUFBa0I7QUFDbkIyYSxNQUFFLENBQUM4K0IsT0FBSCxHQUFhejVDLEtBQUssQ0FBQ3BELEdBQU4sQ0FBVW9MLEtBQUssQ0FBQzRCLEtBQU4sQ0FBWTVKLEtBQXRCLENBQWI7QUFDSCxHQUZJLE1BR0EsSUFBSUEsS0FBSyxLQUFLL0MsUUFBZCxFQUF3QjtBQUN6QjBkLE1BQUUsQ0FBQzgrQixPQUFILEdBQWFPLHVEQUFVLENBQUNoNkMsS0FBRCxFQUFRODVDLGdCQUFnQixDQUFDbi9CLEVBQUQsRUFBSyxJQUFMLENBQXhCLENBQXZCO0FBQ0g7QUFDSjs7QUFDRCxNQUFNcy9CLFdBQVcsR0FBRztBQUNoQmh1QixTQUFPLENBQUN0UixFQUFELEVBQUs7QUFBRTNhO0FBQUYsR0FBTCxFQUFnQmdJLEtBQWhCLEVBQXVCO0FBQzFCMlMsTUFBRSxDQUFDOCtCLE9BQUgsR0FBYU8sdURBQVUsQ0FBQ2g2QyxLQUFELEVBQVFnSSxLQUFLLENBQUM0QixLQUFOLENBQVk1SixLQUFwQixDQUF2QjtBQUNBMmEsTUFBRSxDQUFDcStCLE9BQUgsR0FBYVAsZ0JBQWdCLENBQUN6d0MsS0FBRCxDQUE3QjtBQUNBc3BDLG9CQUFnQixDQUFDMzJCLEVBQUQsRUFBSyxRQUFMLEVBQWUsTUFBTTtBQUNqQ0EsUUFBRSxDQUFDcStCLE9BQUgsQ0FBV1EsUUFBUSxDQUFDNytCLEVBQUQsQ0FBbkI7QUFDSCxLQUZlLENBQWhCO0FBR0gsR0FQZTs7QUFRaEJ5UixjQUFZLENBQUN6UixFQUFELEVBQUs7QUFBRTNhLFNBQUY7QUFBUy9DO0FBQVQsR0FBTCxFQUEwQitLLEtBQTFCLEVBQWlDO0FBQ3pDMlMsTUFBRSxDQUFDcStCLE9BQUgsR0FBYVAsZ0JBQWdCLENBQUN6d0MsS0FBRCxDQUE3Qjs7QUFDQSxRQUFJaEksS0FBSyxLQUFLL0MsUUFBZCxFQUF3QjtBQUNwQjBkLFFBQUUsQ0FBQzgrQixPQUFILEdBQWFPLHVEQUFVLENBQUNoNkMsS0FBRCxFQUFRZ0ksS0FBSyxDQUFDNEIsS0FBTixDQUFZNUosS0FBcEIsQ0FBdkI7QUFDSDtBQUNKOztBQWJlLENBQXBCO0FBZUEsTUFBTWs2QyxZQUFZLEdBQUc7QUFDakJqdUIsU0FBTyxDQUFDdFIsRUFBRCxFQUFLO0FBQUUzYSxTQUFGO0FBQVNpMEIsYUFBUyxFQUFFO0FBQUV6ZjtBQUFGO0FBQXBCLEdBQUwsRUFBdUN4TSxLQUF2QyxFQUE4QztBQUNqRCxVQUFNbXlDLFVBQVUsR0FBR2o0QixrREFBSyxDQUFDbGlCLEtBQUQsQ0FBeEI7QUFDQXN4QyxvQkFBZ0IsQ0FBQzMyQixFQUFELEVBQUssUUFBTCxFQUFlLE1BQU07QUFDakMsWUFBTXkvQixXQUFXLEdBQUd4N0MsS0FBSyxDQUFDQyxTQUFOLENBQWdCWCxNQUFoQixDQUNmNkQsSUFEZSxDQUNWNFksRUFBRSxDQUFDcGdCLE9BRE8sRUFDRzZoQixDQUFELElBQU9BLENBQUMsQ0FBQ2krQixRQURYLEVBRWZwOEMsR0FGZSxDQUVWbWUsQ0FBRCxJQUFPNUgsTUFBTSxHQUFHRSxxREFBUSxDQUFDOGtDLFFBQVEsQ0FBQ3A5QixDQUFELENBQVQsQ0FBWCxHQUEyQm85QixRQUFRLENBQUNwOUIsQ0FBRCxDQUZyQyxDQUFwQjs7QUFHQXpCLFFBQUUsQ0FBQ3ErQixPQUFILENBQVdyK0IsRUFBRSxDQUFDZzBCLFFBQUgsR0FDTHdMLFVBQVUsR0FDTixJQUFJeDlDLEdBQUosQ0FBUXk5QyxXQUFSLENBRE0sR0FFTkEsV0FIQyxHQUlMQSxXQUFXLENBQUMsQ0FBRCxDQUpqQjtBQUtILEtBVGUsQ0FBaEI7QUFVQXovQixNQUFFLENBQUNxK0IsT0FBSCxHQUFhUCxnQkFBZ0IsQ0FBQ3p3QyxLQUFELENBQTdCO0FBQ0gsR0FkZ0I7O0FBZWpCO0FBQ0E7QUFDQW1rQixTQUFPLENBQUN4UixFQUFELEVBQUs7QUFBRTNhO0FBQUYsR0FBTCxFQUFnQjtBQUNuQnM2QyxlQUFXLENBQUMzL0IsRUFBRCxFQUFLM2EsS0FBTCxDQUFYO0FBQ0gsR0FuQmdCOztBQW9CakJvc0IsY0FBWSxDQUFDelIsRUFBRCxFQUFLNC9CLFFBQUwsRUFBZXZ5QyxLQUFmLEVBQXNCO0FBQzlCMlMsTUFBRSxDQUFDcStCLE9BQUgsR0FBYVAsZ0JBQWdCLENBQUN6d0MsS0FBRCxDQUE3QjtBQUNILEdBdEJnQjs7QUF1QmpCcWtCLFNBQU8sQ0FBQzFSLEVBQUQsRUFBSztBQUFFM2E7QUFBRixHQUFMLEVBQWdCO0FBQ25CczZDLGVBQVcsQ0FBQzMvQixFQUFELEVBQUszYSxLQUFMLENBQVg7QUFDSDs7QUF6QmdCLENBQXJCOztBQTJCQSxTQUFTczZDLFdBQVQsQ0FBcUIzL0IsRUFBckIsRUFBeUIzYSxLQUF6QixFQUFnQztBQUM1QixRQUFNdzZDLFVBQVUsR0FBRzcvQixFQUFFLENBQUNnMEIsUUFBdEI7O0FBQ0EsTUFBSTZMLFVBQVUsSUFBSSxDQUFDbDlDLG9EQUFPLENBQUMwQyxLQUFELENBQXRCLElBQWlDLENBQUNraUIsa0RBQUssQ0FBQ2xpQixLQUFELENBQTNDLEVBQW9EO0FBQy9DL0YsU0FBRCxJQUNJOEcsdURBQUksQ0FBRSwyRUFBRCxHQUNBLFdBQVVoRCxNQUFNLENBQUNjLFNBQVAsQ0FBaUIyeUIsUUFBakIsQ0FBMEJ6dkIsSUFBMUIsQ0FBK0IvQixLQUEvQixFQUFzQytKLEtBQXRDLENBQTRDLENBQTVDLEVBQStDLENBQUMsQ0FBaEQsQ0FBbUQsR0FEOUQsQ0FEUjtBQUdBO0FBQ0g7O0FBQ0QsT0FBSyxJQUFJcE8sQ0FBQyxHQUFHLENBQVIsRUFBV3NELENBQUMsR0FBRzBiLEVBQUUsQ0FBQ3BnQixPQUFILENBQVdnQixNQUEvQixFQUF1Q0ksQ0FBQyxHQUFHc0QsQ0FBM0MsRUFBOEN0RCxDQUFDLEVBQS9DLEVBQW1EO0FBQy9DLFVBQU04K0MsTUFBTSxHQUFHOS9CLEVBQUUsQ0FBQ3BnQixPQUFILENBQVdvQixDQUFYLENBQWY7QUFDQSxVQUFNKytDLFdBQVcsR0FBR2xCLFFBQVEsQ0FBQ2lCLE1BQUQsQ0FBNUI7O0FBQ0EsUUFBSUQsVUFBSixFQUFnQjtBQUNaLFVBQUlsOUMsb0RBQU8sQ0FBQzBDLEtBQUQsQ0FBWCxFQUFvQjtBQUNoQnk2QyxjQUFNLENBQUNKLFFBQVAsR0FBa0JWLHlEQUFZLENBQUMzNUMsS0FBRCxFQUFRMDZDLFdBQVIsQ0FBWixHQUFtQyxDQUFDLENBQXREO0FBQ0gsT0FGRCxNQUdLO0FBQ0RELGNBQU0sQ0FBQ0osUUFBUCxHQUFrQnI2QyxLQUFLLENBQUNwRCxHQUFOLENBQVU4OUMsV0FBVixDQUFsQjtBQUNIO0FBQ0osS0FQRCxNQVFLO0FBQ0QsVUFBSVYsdURBQVUsQ0FBQ1IsUUFBUSxDQUFDaUIsTUFBRCxDQUFULEVBQW1CejZDLEtBQW5CLENBQWQsRUFBeUM7QUFDckMsWUFBSTJhLEVBQUUsQ0FBQ2dnQyxhQUFILEtBQXFCaC9DLENBQXpCLEVBQ0lnZixFQUFFLENBQUNnZ0MsYUFBSCxHQUFtQmgvQyxDQUFuQjtBQUNKO0FBQ0g7QUFDSjtBQUNKOztBQUNELE1BQUksQ0FBQzYrQyxVQUFELElBQWU3L0IsRUFBRSxDQUFDZ2dDLGFBQUgsS0FBcUIsQ0FBQyxDQUF6QyxFQUE0QztBQUN4Q2hnQyxNQUFFLENBQUNnZ0MsYUFBSCxHQUFtQixDQUFDLENBQXBCO0FBQ0g7QUFDSixDLENBQ0Q7OztBQUNBLFNBQVNuQixRQUFULENBQWtCNytCLEVBQWxCLEVBQXNCO0FBQ2xCLFNBQU8sWUFBWUEsRUFBWixHQUFpQkEsRUFBRSxDQUFDM1UsTUFBcEIsR0FBNkIyVSxFQUFFLENBQUMzYSxLQUF2QztBQUNILEMsQ0FDRDs7O0FBQ0EsU0FBUzg1QyxnQkFBVCxDQUEwQm4vQixFQUExQixFQUE4QjgrQixPQUE5QixFQUF1QztBQUNuQyxRQUFNcDlDLEdBQUcsR0FBR285QyxPQUFPLEdBQUcsWUFBSCxHQUFrQixhQUFyQztBQUNBLFNBQU9wOUMsR0FBRyxJQUFJc2UsRUFBUCxHQUFZQSxFQUFFLENBQUN0ZSxHQUFELENBQWQsR0FBc0JvOUMsT0FBN0I7QUFDSDs7QUFDRCxNQUFNbUIsYUFBYSxHQUFHO0FBQ2xCM3VCLFNBQU8sQ0FBQ3RSLEVBQUQsRUFBS3laLE9BQUwsRUFBY3BzQixLQUFkLEVBQXFCO0FBQ3hCNnlDLGlCQUFhLENBQUNsZ0MsRUFBRCxFQUFLeVosT0FBTCxFQUFjcHNCLEtBQWQsRUFBcUIsSUFBckIsRUFBMkIsU0FBM0IsQ0FBYjtBQUNILEdBSGlCOztBQUlsQm1rQixTQUFPLENBQUN4UixFQUFELEVBQUt5WixPQUFMLEVBQWNwc0IsS0FBZCxFQUFxQjtBQUN4QjZ5QyxpQkFBYSxDQUFDbGdDLEVBQUQsRUFBS3laLE9BQUwsRUFBY3BzQixLQUFkLEVBQXFCLElBQXJCLEVBQTJCLFNBQTNCLENBQWI7QUFDSCxHQU5pQjs7QUFPbEJva0IsY0FBWSxDQUFDelIsRUFBRCxFQUFLeVosT0FBTCxFQUFjcHNCLEtBQWQsRUFBcUIrUixTQUFyQixFQUFnQztBQUN4QzhnQyxpQkFBYSxDQUFDbGdDLEVBQUQsRUFBS3laLE9BQUwsRUFBY3BzQixLQUFkLEVBQXFCK1IsU0FBckIsRUFBZ0MsY0FBaEMsQ0FBYjtBQUNILEdBVGlCOztBQVVsQnNTLFNBQU8sQ0FBQzFSLEVBQUQsRUFBS3laLE9BQUwsRUFBY3BzQixLQUFkLEVBQXFCK1IsU0FBckIsRUFBZ0M7QUFDbkM4Z0MsaUJBQWEsQ0FBQ2xnQyxFQUFELEVBQUt5WixPQUFMLEVBQWNwc0IsS0FBZCxFQUFxQitSLFNBQXJCLEVBQWdDLFNBQWhDLENBQWI7QUFDSDs7QUFaaUIsQ0FBdEI7O0FBY0EsU0FBUzhnQyxhQUFULENBQXVCbGdDLEVBQXZCLEVBQTJCeVosT0FBM0IsRUFBb0Nwc0IsS0FBcEMsRUFBMkMrUixTQUEzQyxFQUFzRGxKLElBQXRELEVBQTREO0FBQ3hELE1BQUlpcUMsVUFBSjs7QUFDQSxVQUFRbmdDLEVBQUUsQ0FBQ3liLE9BQVg7QUFDSSxTQUFLLFFBQUw7QUFDSTBrQixnQkFBVSxHQUFHWixZQUFiO0FBQ0E7O0FBQ0osU0FBSyxVQUFMO0FBQ0lZLGdCQUFVLEdBQUcvQixVQUFiO0FBQ0E7O0FBQ0o7QUFDSSxjQUFRL3dDLEtBQUssQ0FBQzRCLEtBQU4sSUFBZTVCLEtBQUssQ0FBQzRCLEtBQU4sQ0FBWXhOLElBQW5DO0FBQ0ksYUFBSyxVQUFMO0FBQ0kwK0Msb0JBQVUsR0FBRzFCLGNBQWI7QUFDQTs7QUFDSixhQUFLLE9BQUw7QUFDSTBCLG9CQUFVLEdBQUdiLFdBQWI7QUFDQTs7QUFDSjtBQUNJYSxvQkFBVSxHQUFHL0IsVUFBYjtBQVJSOztBQVJSOztBQW1CQSxRQUFNMytDLEVBQUUsR0FBRzBnRCxVQUFVLENBQUNqcUMsSUFBRCxDQUFyQjtBQUNBelcsSUFBRSxJQUFJQSxFQUFFLENBQUN1Z0IsRUFBRCxFQUFLeVosT0FBTCxFQUFjcHNCLEtBQWQsRUFBcUIrUixTQUFyQixDQUFSO0FBQ0g7O0FBRUQsTUFBTWdoQyxlQUFlLEdBQUcsQ0FBQyxNQUFELEVBQVMsT0FBVCxFQUFrQixLQUFsQixFQUF5QixNQUF6QixDQUF4QjtBQUNBLE1BQU1DLGNBQWMsR0FBRztBQUNuQnBnRCxNQUFJLEVBQUU4VixDQUFDLElBQUlBLENBQUMsQ0FBQ3VxQyxlQUFGLEVBRFE7QUFFbkJDLFNBQU8sRUFBRXhxQyxDQUFDLElBQUlBLENBQUMsQ0FBQ3lxQyxjQUFGLEVBRks7QUFHbkIzekMsTUFBSSxFQUFFa0osQ0FBQyxJQUFJQSxDQUFDLENBQUN2VSxNQUFGLEtBQWF1VSxDQUFDLENBQUMwcUMsYUFIUDtBQUluQkMsTUFBSSxFQUFFM3FDLENBQUMsSUFBSSxDQUFDQSxDQUFDLENBQUM0cUMsT0FKSztBQUtuQkMsT0FBSyxFQUFFN3FDLENBQUMsSUFBSSxDQUFDQSxDQUFDLENBQUM4cUMsUUFMSTtBQU1uQkMsS0FBRyxFQUFFL3FDLENBQUMsSUFBSSxDQUFDQSxDQUFDLENBQUNnckMsTUFOTTtBQU9uQkMsTUFBSSxFQUFFanJDLENBQUMsSUFBSSxDQUFDQSxDQUFDLENBQUNrckMsT0FQSztBQVFuQnZELE1BQUksRUFBRTNuQyxDQUFDLElBQUksWUFBWUEsQ0FBWixJQUFpQkEsQ0FBQyxDQUFDbXJDLE1BQUYsS0FBYSxDQVJ0QjtBQVNuQjF1QyxRQUFNLEVBQUV1RCxDQUFDLElBQUksWUFBWUEsQ0FBWixJQUFpQkEsQ0FBQyxDQUFDbXJDLE1BQUYsS0FBYSxDQVR4QjtBQVVuQkMsT0FBSyxFQUFFcHJDLENBQUMsSUFBSSxZQUFZQSxDQUFaLElBQWlCQSxDQUFDLENBQUNtckMsTUFBRixLQUFhLENBVnZCO0FBV25CRSxPQUFLLEVBQUUsQ0FBQ3JyQyxDQUFELEVBQUl1akIsU0FBSixLQUFrQjhtQixlQUFlLENBQUN2aUMsSUFBaEIsQ0FBcUJpRixDQUFDLElBQUkvTSxDQUFDLENBQUUsR0FBRStNLENBQUUsS0FBTixDQUFELElBQWdCLENBQUN3VyxTQUFTLENBQUMvNEIsUUFBVixDQUFtQnVpQixDQUFuQixDQUEzQztBQVhOLENBQXZCO0FBYUE7QUFDQTtBQUNBOztBQUNBLE1BQU11K0IsYUFBYSxHQUFHLENBQUM1aEQsRUFBRCxFQUFLNjVCLFNBQUwsS0FBbUI7QUFDckMsU0FBTyxDQUFDaGlCLEtBQUQsRUFBUSxHQUFHblQsSUFBWCxLQUFvQjtBQUN2QixTQUFLLElBQUluRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHczRCLFNBQVMsQ0FBQzE0QixNQUE5QixFQUFzQ0ksQ0FBQyxFQUF2QyxFQUEyQztBQUN2QyxZQUFNc2dELEtBQUssR0FBR2pCLGNBQWMsQ0FBQy9tQixTQUFTLENBQUN0NEIsQ0FBRCxDQUFWLENBQTVCO0FBQ0EsVUFBSXNnRCxLQUFLLElBQUlBLEtBQUssQ0FBQ2hxQyxLQUFELEVBQVFnaUIsU0FBUixDQUFsQixFQUNJO0FBQ1A7O0FBQ0QsV0FBTzc1QixFQUFFLENBQUM2WCxLQUFELEVBQVEsR0FBR25ULElBQVgsQ0FBVDtBQUNILEdBUEQ7QUFRSCxDQVRELEMsQ0FVQTtBQUNBOzs7QUFDQSxNQUFNbzlDLFFBQVEsR0FBRztBQUNiQyxLQUFHLEVBQUUsUUFEUTtBQUViQyxPQUFLLEVBQUUsR0FGTTtBQUdiQyxJQUFFLEVBQUUsVUFIUztBQUliaEUsTUFBSSxFQUFFLFlBSk87QUFLYnlELE9BQUssRUFBRSxhQUxNO0FBTWJRLE1BQUksRUFBRSxZQU5PO0FBT2IxZ0QsUUFBTSxFQUFFO0FBUEssQ0FBakI7QUFTQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBTTJnRCxRQUFRLEdBQUcsQ0FBQ25pRCxFQUFELEVBQUs2NUIsU0FBTCxLQUFtQjtBQUNoQyxTQUFRaGlCLEtBQUQsSUFBVztBQUNkLFFBQUksRUFBRSxTQUFTQSxLQUFYLENBQUosRUFBdUI7QUFDbkI7QUFDSDs7QUFDRCxVQUFNdXFDLFFBQVEsR0FBRzNuQyxzREFBUyxDQUFDNUMsS0FBSyxDQUFDNVYsR0FBUCxDQUExQjs7QUFDQSxRQUFJNDNCLFNBQVMsQ0FBQ3piLElBQVYsQ0FBZWlrQyxDQUFDLElBQUlBLENBQUMsS0FBS0QsUUFBTixJQUFrQk4sUUFBUSxDQUFDTyxDQUFELENBQVIsS0FBZ0JELFFBQXRELENBQUosRUFBcUU7QUFDakUsYUFBT3BpRCxFQUFFLENBQUM2WCxLQUFELENBQVQ7QUFDSDtBQUNKLEdBUkQ7QUFTSCxDQVZEOztBQVlBLE1BQU15cUMsS0FBSyxHQUFHO0FBQ1Z4d0IsYUFBVyxDQUFDdlIsRUFBRCxFQUFLO0FBQUUzYTtBQUFGLEdBQUwsRUFBZ0I7QUFBRWlaO0FBQUYsR0FBaEIsRUFBZ0M7QUFDdkMwQixNQUFFLENBQUNnaUMsSUFBSCxHQUFVaGlDLEVBQUUsQ0FBQ2dqQixLQUFILENBQVNpUyxPQUFULEtBQXFCLE1BQXJCLEdBQThCLEVBQTlCLEdBQW1DajFCLEVBQUUsQ0FBQ2dqQixLQUFILENBQVNpUyxPQUF0RDs7QUFDQSxRQUFJMzJCLFVBQVUsSUFBSWpaLEtBQWxCLEVBQXlCO0FBQ3JCaVosZ0JBQVUsQ0FBQ21NLFdBQVgsQ0FBdUJ6SyxFQUF2QjtBQUNILEtBRkQsTUFHSztBQUNEaWlDLGdCQUFVLENBQUNqaUMsRUFBRCxFQUFLM2EsS0FBTCxDQUFWO0FBQ0g7QUFDSixHQVRTOztBQVVWbXNCLFNBQU8sQ0FBQ3hSLEVBQUQsRUFBSztBQUFFM2E7QUFBRixHQUFMLEVBQWdCO0FBQUVpWjtBQUFGLEdBQWhCLEVBQWdDO0FBQ25DLFFBQUlBLFVBQVUsSUFBSWpaLEtBQWxCLEVBQXlCO0FBQ3JCaVosZ0JBQVUsQ0FBQ3FNLEtBQVgsQ0FBaUIzSyxFQUFqQjtBQUNIO0FBQ0osR0FkUzs7QUFlVjBSLFNBQU8sQ0FBQzFSLEVBQUQsRUFBSztBQUFFM2EsU0FBRjtBQUFTL0M7QUFBVCxHQUFMLEVBQTBCO0FBQUVnYztBQUFGLEdBQTFCLEVBQTBDO0FBQzdDLFFBQUksQ0FBQ2paLEtBQUQsS0FBVyxDQUFDL0MsUUFBaEIsRUFDSTs7QUFDSixRQUFJZ2MsVUFBSixFQUFnQjtBQUNaLFVBQUlqWixLQUFKLEVBQVc7QUFDUGlaLGtCQUFVLENBQUNtTSxXQUFYLENBQXVCekssRUFBdkI7QUFDQWlpQyxrQkFBVSxDQUFDamlDLEVBQUQsRUFBSyxJQUFMLENBQVY7QUFDQTFCLGtCQUFVLENBQUNxTSxLQUFYLENBQWlCM0ssRUFBakI7QUFDSCxPQUpELE1BS0s7QUFDRDFCLGtCQUFVLENBQUMyTSxLQUFYLENBQWlCakwsRUFBakIsRUFBcUIsTUFBTTtBQUN2QmlpQyxvQkFBVSxDQUFDamlDLEVBQUQsRUFBSyxLQUFMLENBQVY7QUFDSCxTQUZEO0FBR0g7QUFDSixLQVhELE1BWUs7QUFDRGlpQyxnQkFBVSxDQUFDamlDLEVBQUQsRUFBSzNhLEtBQUwsQ0FBVjtBQUNIO0FBQ0osR0FqQ1M7O0FBa0NWeXNCLGVBQWEsQ0FBQzlSLEVBQUQsRUFBSztBQUFFM2E7QUFBRixHQUFMLEVBQWdCO0FBQ3pCNDhDLGNBQVUsQ0FBQ2ppQyxFQUFELEVBQUszYSxLQUFMLENBQVY7QUFDSDs7QUFwQ1MsQ0FBZDs7QUFzQ0EsU0FBUzQ4QyxVQUFULENBQW9CamlDLEVBQXBCLEVBQXdCM2EsS0FBeEIsRUFBK0I7QUFDM0IyYSxJQUFFLENBQUNnakIsS0FBSCxDQUFTaVMsT0FBVCxHQUFtQjV2QyxLQUFLLEdBQUcyYSxFQUFFLENBQUNnaUMsSUFBTixHQUFhLE1BQXJDO0FBQ0g7O0FBRUQsTUFBTUUsZUFBZSxHQUFHMzdDLG1EQUFNLENBQUM7QUFBRXcxQixXQUFGO0FBQWFxRTtBQUFiLENBQUQsRUFBZ0N1VCxPQUFoQyxDQUE5QixDLENBQ0E7QUFDQTs7QUFDQSxJQUFJcG1CLFFBQUo7QUFDQSxJQUFJNDBCLGdCQUFnQixHQUFHLEtBQXZCOztBQUNBLFNBQVNDLGNBQVQsR0FBMEI7QUFDdEIsU0FBTzcwQixRQUFRLEtBQUtBLFFBQVEsR0FBR21TLGlFQUFjLENBQUN3aUIsZUFBRCxDQUE5QixDQUFmO0FBQ0g7O0FBQ0QsU0FBU0csdUJBQVQsR0FBbUM7QUFDL0I5MEIsVUFBUSxHQUFHNDBCLGdCQUFnQixHQUNyQjUwQixRQURxQixHQUVyQnFTLDBFQUF1QixDQUFDc2lCLGVBQUQsQ0FGN0I7QUFHQUMsa0JBQWdCLEdBQUcsSUFBbkI7QUFDQSxTQUFPNTBCLFFBQVA7QUFDSCxDLENBQ0Q7OztBQUNBLE1BQU0vWCxNQUFNLEdBQUksQ0FBQyxHQUFHclIsSUFBSixLQUFhO0FBQ3pCaStDLGdCQUFjLEdBQUc1c0MsTUFBakIsQ0FBd0IsR0FBR3JSLElBQTNCO0FBQ0gsQ0FGRDs7QUFHQSxNQUFNNmMsT0FBTyxHQUFJLENBQUMsR0FBRzdjLElBQUosS0FBYTtBQUMxQmsrQyx5QkFBdUIsR0FBR3JoQyxPQUExQixDQUFrQyxHQUFHN2MsSUFBckM7QUFDSCxDQUZEOztBQUdBLE1BQU04MUIsU0FBUyxHQUFJLENBQUMsR0FBRzkxQixJQUFKLEtBQWE7QUFDNUIsUUFBTWlTLEdBQUcsR0FBR2dzQyxjQUFjLEdBQUdub0IsU0FBakIsQ0FBMkIsR0FBRzkxQixJQUE5QixDQUFaOztBQUNBLE1BQUs3RSxJQUFMLEVBQTZDO0FBQ3pDZ2pELHdCQUFvQixDQUFDbHNDLEdBQUQsQ0FBcEI7QUFDQW1zQyw4QkFBMEIsQ0FBQ25zQyxHQUFELENBQTFCO0FBQ0g7O0FBQ0QsUUFBTTtBQUFFOGtCO0FBQUYsTUFBWTlrQixHQUFsQjs7QUFDQUEsS0FBRyxDQUFDOGtCLEtBQUosR0FBYXNuQixtQkFBRCxJQUF5QjtBQUNqQyxVQUFNamlDLFNBQVMsR0FBR2tpQyxrQkFBa0IsQ0FBQ0QsbUJBQUQsQ0FBcEM7QUFDQSxRQUFJLENBQUNqaUMsU0FBTCxFQUNJO0FBQ0osVUFBTTlTLFNBQVMsR0FBRzJJLEdBQUcsQ0FBQ21rQixVQUF0Qjs7QUFDQSxRQUFJLENBQUN0dEIsdURBQVUsQ0FBQ1EsU0FBRCxDQUFYLElBQTBCLENBQUNBLFNBQVMsQ0FBQytILE1BQXJDLElBQStDLENBQUMvSCxTQUFTLENBQUNxaUMsUUFBOUQsRUFBd0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQXJpQyxlQUFTLENBQUNxaUMsUUFBVixHQUFxQnZ2QixTQUFTLENBQUNtZCxTQUEvQjtBQUNILEtBWGdDLENBWWpDOzs7QUFDQW5kLGFBQVMsQ0FBQ21kLFNBQVYsR0FBc0IsRUFBdEI7QUFDQSxVQUFNdnpCLEtBQUssR0FBRyt3QixLQUFLLENBQUMzYSxTQUFELEVBQVksS0FBWixFQUFtQkEsU0FBUyxZQUFZd25CLFVBQXhDLENBQW5COztBQUNBLFFBQUl4bkIsU0FBUyxZQUFZazBCLE9BQXpCLEVBQWtDO0FBQzlCbDBCLGVBQVMsQ0FBQ3kwQixlQUFWLENBQTBCLFNBQTFCO0FBQ0F6MEIsZUFBUyxDQUFDMHpCLFlBQVYsQ0FBdUIsWUFBdkIsRUFBcUMsRUFBckM7QUFDSDs7QUFDRCxXQUFPOXBDLEtBQVA7QUFDSCxHQXBCRDs7QUFxQkEsU0FBT2lNLEdBQVA7QUFDSCxDQTdCRDs7QUE4QkEsTUFBTXNzQyxZQUFZLEdBQUksQ0FBQyxHQUFHditDLElBQUosS0FBYTtBQUMvQixRQUFNaVMsR0FBRyxHQUFHaXNDLHVCQUF1QixHQUFHcG9CLFNBQTFCLENBQW9DLEdBQUc5MUIsSUFBdkMsQ0FBWjs7QUFDQSxNQUFLN0UsSUFBTCxFQUE2QztBQUN6Q2dqRCx3QkFBb0IsQ0FBQ2xzQyxHQUFELENBQXBCO0FBQ0Ftc0MsOEJBQTBCLENBQUNuc0MsR0FBRCxDQUExQjtBQUNIOztBQUNELFFBQU07QUFBRThrQjtBQUFGLE1BQVk5a0IsR0FBbEI7O0FBQ0FBLEtBQUcsQ0FBQzhrQixLQUFKLEdBQWFzbkIsbUJBQUQsSUFBeUI7QUFDakMsVUFBTWppQyxTQUFTLEdBQUdraUMsa0JBQWtCLENBQUNELG1CQUFELENBQXBDOztBQUNBLFFBQUlqaUMsU0FBSixFQUFlO0FBQ1gsYUFBTzJhLEtBQUssQ0FBQzNhLFNBQUQsRUFBWSxJQUFaLEVBQWtCQSxTQUFTLFlBQVl3bkIsVUFBdkMsQ0FBWjtBQUNIO0FBQ0osR0FMRDs7QUFNQSxTQUFPM3hCLEdBQVA7QUFDSCxDQWREOztBQWVBLFNBQVNrc0Msb0JBQVQsQ0FBOEJsc0MsR0FBOUIsRUFBbUM7QUFDL0I7QUFDQTtBQUNBaFQsUUFBTSxDQUFDd3ZCLGNBQVAsQ0FBc0J4YyxHQUFHLENBQUN4SSxNQUExQixFQUFrQyxhQUFsQyxFQUFpRDtBQUM3Q3ZJLFNBQUssRUFBR3l1QyxHQUFELElBQVM2TyxzREFBUyxDQUFDN08sR0FBRCxDQUFULElBQWtCOE8scURBQVEsQ0FBQzlPLEdBQUQsQ0FERztBQUU3Qy9nQixZQUFRLEVBQUU7QUFGbUMsR0FBakQ7QUFJSCxDLENBQ0Q7OztBQUNBLFNBQVN3dkIsMEJBQVQsQ0FBb0Nuc0MsR0FBcEMsRUFBeUM7QUFDckMsTUFBSXVCLGdFQUFhLEVBQWpCLEVBQXFCO0FBQ2pCLFVBQU1vNEIsZUFBZSxHQUFHMzVCLEdBQUcsQ0FBQ3hJLE1BQUosQ0FBV21pQyxlQUFuQztBQUNBM3NDLFVBQU0sQ0FBQ3d2QixjQUFQLENBQXNCeGMsR0FBRyxDQUFDeEksTUFBMUIsRUFBa0MsaUJBQWxDLEVBQXFEO0FBQ2pEaE0sU0FBRyxHQUFHO0FBQ0YsZUFBT211QyxlQUFQO0FBQ0gsT0FIZ0Q7O0FBSWpEbHVDLFNBQUcsR0FBRztBQUNGdUUsK0RBQUksQ0FBRSwyREFBRCxHQUNBLDhDQURELENBQUo7QUFFSDs7QUFQZ0QsS0FBckQ7QUFTQSxVQUFNMnpCLGVBQWUsR0FBRzNqQixHQUFHLENBQUN4SSxNQUFKLENBQVdtc0IsZUFBbkM7QUFDQSxVQUFNeHNCLEdBQUcsR0FBSSxxRUFBRCxHQUNQLDJFQURPLEdBRVAsa0VBRk8sR0FHUCx1RUFITyxHQUlQLGlGQUpPLEdBS1AsNkZBTE8sR0FNUCxxS0FOTDtBQU9BbkssVUFBTSxDQUFDd3ZCLGNBQVAsQ0FBc0J4YyxHQUFHLENBQUN4SSxNQUExQixFQUFrQyxpQkFBbEMsRUFBcUQ7QUFDakRoTSxTQUFHLEdBQUc7QUFDRndFLCtEQUFJLENBQUNtSCxHQUFELENBQUo7QUFDQSxlQUFPd3NCLGVBQVA7QUFDSCxPQUpnRDs7QUFLakRsNEIsU0FBRyxHQUFHO0FBQ0Z1RSwrREFBSSxDQUFDbUgsR0FBRCxDQUFKO0FBQ0g7O0FBUGdELEtBQXJEO0FBU0g7QUFDSjs7QUFDRCxTQUFTazFDLGtCQUFULENBQTRCbGlDLFNBQTVCLEVBQXVDO0FBQ25DLE1BQUlqUixxREFBUSxDQUFDaVIsU0FBRCxDQUFaLEVBQXlCO0FBQ3JCLFVBQU1oYyxHQUFHLEdBQUdpZ0IsUUFBUSxDQUFDNGpCLGFBQVQsQ0FBdUI3bkIsU0FBdkIsQ0FBWjs7QUFDQSxRQUFLamhCLEtBQUQsSUFBMkMsQ0FBQ2lGLEdBQWhELEVBQXFEO0FBQ2pENkIsNkRBQUksQ0FBRSwrQ0FBOENtYSxTQUFVLGtCQUExRCxDQUFKO0FBQ0g7O0FBQ0QsV0FBT2hjLEdBQVA7QUFDSDs7QUFDRCxNQUFLakYsS0FBRCxJQUNBaWhCLFNBQVMsWUFBWTdMLE1BQU0sQ0FBQ211QyxVQUQ1QixJQUVBdGlDLFNBQVMsQ0FBQ3JILElBQVYsS0FBbUIsUUFGdkIsRUFFaUM7QUFDN0I5UywyREFBSSxDQUFFLG1GQUFGLENBQUo7QUFDSDs7QUFDRCxTQUFPbWEsU0FBUDtBQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdjNDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNyZCxPQUFULENBQWlCc3RDLEdBQWpCLEVBQXNCc1MsZ0JBQXRCLEVBQXdDO0FBQ3BDLFFBQU14L0MsR0FBRyxHQUFHRixNQUFNLENBQUM4VSxNQUFQLENBQWMsSUFBZCxDQUFaO0FBQ0EsUUFBTTZxQyxJQUFJLEdBQUd2UyxHQUFHLENBQUNucEIsS0FBSixDQUFVLEdBQVYsQ0FBYjs7QUFDQSxPQUFLLElBQUlybUIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRytoRCxJQUFJLENBQUNuaUQsTUFBekIsRUFBaUNJLENBQUMsRUFBbEMsRUFBc0M7QUFDbENzQyxPQUFHLENBQUN5L0MsSUFBSSxDQUFDL2hELENBQUQsQ0FBTCxDQUFILEdBQWUsSUFBZjtBQUNIOztBQUNELFNBQU84aEQsZ0JBQWdCLEdBQUdwNEMsR0FBRyxJQUFJLENBQUMsQ0FBQ3BILEdBQUcsQ0FBQ29ILEdBQUcsQ0FBQ3VQLFdBQUosRUFBRCxDQUFmLEdBQXFDdlAsR0FBRyxJQUFJLENBQUMsQ0FBQ3BILEdBQUcsQ0FBQ29ILEdBQUQsQ0FBeEU7QUFDSDtBQUVEO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTXM0QyxjQUFjLEdBQUc7QUFDbkIsR0FBQztBQUFFO0FBQUgsS0FBaUIsTUFERTtBQUVuQixHQUFDO0FBQUU7QUFBSCxLQUFrQixPQUZDO0FBR25CLEdBQUM7QUFBRTtBQUFILEtBQWtCLE9BSEM7QUFJbkIsR0FBQztBQUFFO0FBQUgsS0FBa0IsT0FKQztBQUtuQixHQUFDO0FBQUc7QUFBSixLQUF3QixZQUxMO0FBTW5CLEdBQUM7QUFBRztBQUFKLEtBQTRCLGdCQU5UO0FBT25CLEdBQUM7QUFBRztBQUFKLEtBQTZCLGlCQVBWO0FBUW5CLEdBQUM7QUFBSTtBQUFMLEtBQTZCLGdCQVJWO0FBU25CLEdBQUM7QUFBSTtBQUFMLEtBQStCLGtCQVRaO0FBVW5CLEdBQUM7QUFBSTtBQUFMLEtBQXlCLFlBVk47QUFXbkIsR0FBQztBQUFLO0FBQU4sS0FBNkIsZUFYVjtBQVluQixHQUFDO0FBQUs7QUFBTixLQUFpQyxtQkFaZDtBQWFuQixHQUFDLENBQUM7QUFBRTtBQUFKLEtBQXFCLFNBYkY7QUFjbkIsR0FBQyxDQUFDO0FBQUU7QUFBSixLQUFrQjtBQWRDLENBQXZCO0FBaUJBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNQyxhQUFhLEdBQUc7QUFDbEIsR0FBQztBQUFFO0FBQUgsS0FBa0IsUUFEQTtBQUVsQixHQUFDO0FBQUU7QUFBSCxLQUFtQixTQUZEO0FBR2xCLEdBQUM7QUFBRTtBQUFILEtBQXFCO0FBSEgsQ0FBdEI7QUFNQSxNQUFNQyxvQkFBb0IsR0FBRyx5RUFDekIseUVBRHlCLEdBRXpCLHVEQUZKO0FBR0EsTUFBTTVVLHFCQUFxQixHQUFHLGFBQWNwckMsT0FBTyxDQUFDZ2dELG9CQUFELENBQW5EO0FBRUEsTUFBTUMsS0FBSyxHQUFHLENBQWQ7O0FBQ0EsU0FBU0MsaUJBQVQsQ0FBMkJsOUIsTUFBM0IsRUFBbUM5VCxLQUFLLEdBQUcsQ0FBM0MsRUFBOENDLEdBQUcsR0FBRzZULE1BQU0sQ0FBQ3RsQixNQUEzRCxFQUFtRTtBQUMvRCxRQUFNeWlELEtBQUssR0FBR245QixNQUFNLENBQUNtQixLQUFQLENBQWEsT0FBYixDQUFkO0FBQ0EsTUFBSW5ULEtBQUssR0FBRyxDQUFaO0FBQ0EsUUFBTTNQLEdBQUcsR0FBRyxFQUFaOztBQUNBLE9BQUssSUFBSXZELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdxaUQsS0FBSyxDQUFDemlELE1BQTFCLEVBQWtDSSxDQUFDLEVBQW5DLEVBQXVDO0FBQ25Da1QsU0FBSyxJQUFJbXZDLEtBQUssQ0FBQ3JpRCxDQUFELENBQUwsQ0FBU0osTUFBVCxHQUFrQixDQUEzQjs7QUFDQSxRQUFJc1QsS0FBSyxJQUFJOUIsS0FBYixFQUFvQjtBQUNoQixXQUFLLElBQUkwekIsQ0FBQyxHQUFHOWtDLENBQUMsR0FBR21pRCxLQUFqQixFQUF3QnJkLENBQUMsSUFBSTlrQyxDQUFDLEdBQUdtaUQsS0FBVCxJQUFrQjl3QyxHQUFHLEdBQUc2QixLQUFoRCxFQUF1RDR4QixDQUFDLEVBQXhELEVBQTREO0FBQ3hELFlBQUlBLENBQUMsR0FBRyxDQUFKLElBQVNBLENBQUMsSUFBSXVkLEtBQUssQ0FBQ3ppRCxNQUF4QixFQUNJO0FBQ0osY0FBTTBpRCxJQUFJLEdBQUd4ZCxDQUFDLEdBQUcsQ0FBakI7QUFDQXZoQyxXQUFHLENBQUM5RCxJQUFKLENBQVUsR0FBRTZpRCxJQUFLLEdBQUUsSUFBSUMsTUFBSixDQUFXcGUsSUFBSSxDQUFDOVgsR0FBTCxDQUFTLElBQUlobkIsTUFBTSxDQUFDaTlDLElBQUQsQ0FBTixDQUFhMWlELE1BQTFCLEVBQWtDLENBQWxDLENBQVgsQ0FBaUQsTUFBS3lpRCxLQUFLLENBQUN2ZCxDQUFELENBQUksRUFBbEY7QUFDQSxjQUFNMGQsVUFBVSxHQUFHSCxLQUFLLENBQUN2ZCxDQUFELENBQUwsQ0FBU2xsQyxNQUE1Qjs7QUFDQSxZQUFJa2xDLENBQUMsS0FBSzlrQyxDQUFWLEVBQWE7QUFDVDtBQUNBLGdCQUFNeWlELEdBQUcsR0FBR3J4QyxLQUFLLElBQUk4QixLQUFLLEdBQUdzdkMsVUFBWixDQUFMLEdBQStCLENBQTNDO0FBQ0EsZ0JBQU01aUQsTUFBTSxHQUFHdWtDLElBQUksQ0FBQzlYLEdBQUwsQ0FBUyxDQUFULEVBQVloYixHQUFHLEdBQUc2QixLQUFOLEdBQWNzdkMsVUFBVSxHQUFHQyxHQUEzQixHQUFpQ3B4QyxHQUFHLEdBQUdELEtBQW5ELENBQWY7QUFDQTdOLGFBQUcsQ0FBQzlELElBQUosQ0FBVSxRQUFELEdBQVcsSUFBSThpRCxNQUFKLENBQVdFLEdBQVgsQ0FBWCxHQUE2QixJQUFJRixNQUFKLENBQVczaUQsTUFBWCxDQUF0QztBQUNILFNBTEQsTUFNSyxJQUFJa2xDLENBQUMsR0FBRzlrQyxDQUFSLEVBQVc7QUFDWixjQUFJcVIsR0FBRyxHQUFHNkIsS0FBVixFQUFpQjtBQUNiLGtCQUFNdFQsTUFBTSxHQUFHdWtDLElBQUksQ0FBQzlYLEdBQUwsQ0FBUzhYLElBQUksQ0FBQ0MsR0FBTCxDQUFTL3lCLEdBQUcsR0FBRzZCLEtBQWYsRUFBc0JzdkMsVUFBdEIsQ0FBVCxFQUE0QyxDQUE1QyxDQUFmO0FBQ0FqL0MsZUFBRyxDQUFDOUQsSUFBSixDQUFVLFFBQUQsR0FBVyxJQUFJOGlELE1BQUosQ0FBVzNpRCxNQUFYLENBQXBCO0FBQ0g7O0FBQ0RzVCxlQUFLLElBQUlzdkMsVUFBVSxHQUFHLENBQXRCO0FBQ0g7QUFDSjs7QUFDRDtBQUNIO0FBQ0o7O0FBQ0QsU0FBT2ovQyxHQUFHLENBQUMwSixJQUFKLENBQVMsSUFBVCxDQUFQO0FBQ0g7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNeTFDLG1CQUFtQixHQUFJLDZFQUE3QjtBQUNBLE1BQU0zTixvQkFBb0IsR0FBRyxhQUFjN3lDLE9BQU8sQ0FBQ3dnRCxtQkFBRCxDQUFsRDtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNQyxhQUFhLEdBQUcsYUFBY3pnRCxPQUFPLENBQUN3Z0QsbUJBQW1CLEdBQzFELG1FQUR1QyxHQUV2Qyw4Q0FGdUMsR0FHdkMsaUNBSHNDLENBQTNDO0FBSUEsTUFBTUUsZ0JBQWdCLEdBQUcsaUNBQXpCO0FBQ0EsTUFBTUMsbUJBQW1CLEdBQUcsRUFBNUI7O0FBQ0EsU0FBU0MsaUJBQVQsQ0FBMkJwMEMsSUFBM0IsRUFBaUM7QUFDN0IsTUFBSW0wQyxtQkFBbUIsQ0FBQ0UsY0FBcEIsQ0FBbUNyMEMsSUFBbkMsQ0FBSixFQUE4QztBQUMxQyxXQUFPbTBDLG1CQUFtQixDQUFDbjBDLElBQUQsQ0FBMUI7QUFDSDs7QUFDRCxRQUFNczBDLFFBQVEsR0FBR0osZ0JBQWdCLENBQUMxMEIsSUFBakIsQ0FBc0J4ZixJQUF0QixDQUFqQjs7QUFDQSxNQUFJczBDLFFBQUosRUFBYztBQUNWNzlDLFdBQU8sQ0FBQzBLLEtBQVIsQ0FBZSwwQkFBeUJuQixJQUFLLEVBQTdDO0FBQ0g7O0FBQ0QsU0FBUW0wQyxtQkFBbUIsQ0FBQ24wQyxJQUFELENBQW5CLEdBQTRCLENBQUNzMEMsUUFBckM7QUFDSDs7QUFDRCxNQUFNQyxjQUFjLEdBQUc7QUFDbkJDLGVBQWEsRUFBRSxnQkFESTtBQUVuQnBQLFdBQVMsRUFBRSxPQUZRO0FBR25CcVAsU0FBTyxFQUFFLEtBSFU7QUFJbkJDLFdBQVMsRUFBRTtBQUpRLENBQXZCO0FBTUE7QUFDQTtBQUNBOztBQUNBLE1BQU1DLHdCQUF3QixHQUFHLGFBQWNuaEQsT0FBTyxDQUFFLG1FQUFELEdBQ2xELDRFQURrRCxHQUVsRCw0RUFGa0QsR0FHbEQsaUVBSGtELEdBSWxELDRFQUprRCxHQUtsRCxpRUFMa0QsR0FNbkQ7QUFDQyw2RUFQa0QsR0FRbEQsK0NBUmlELENBQXREO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE1BQU1vaEQsV0FBVyxHQUFHLGFBQWNwaEQsT0FBTyxDQUFFLCtEQUFELEdBQ3JDLG9FQURxQyxHQUVyQyxvRUFGcUMsR0FHckMsMkVBSHFDLEdBSXJDLDBFQUpxQyxHQUtyQyxxRUFMcUMsR0FNckMsc0VBTnFDLEdBT3JDLDJFQVBxQyxHQVFyQyx3RUFScUMsR0FTckMsNEVBVHFDLEdBVXJDLDJFQVZxQyxHQVdyQyx5RUFYcUMsR0FZckMsMkVBWnFDLEdBYXJDLHVFQWJxQyxHQWNyQyxrQkFkb0MsQ0FBekM7O0FBZ0JBLFNBQVMwbkMsY0FBVCxDQUF3QnZsQyxLQUF4QixFQUErQjtBQUMzQixNQUFJMUMsT0FBTyxDQUFDMEMsS0FBRCxDQUFYLEVBQW9CO0FBQ2hCLFVBQU1kLEdBQUcsR0FBRyxFQUFaOztBQUNBLFNBQUssSUFBSXZELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdxRSxLQUFLLENBQUN6RSxNQUExQixFQUFrQ0ksQ0FBQyxFQUFuQyxFQUF1QztBQUNuQyxZQUFNdWpELElBQUksR0FBR2wvQyxLQUFLLENBQUNyRSxDQUFELENBQWxCO0FBQ0EsWUFBTThaLFVBQVUsR0FBRzh2QixjQUFjLENBQUN0N0IsUUFBUSxDQUFDaTFDLElBQUQsQ0FBUixHQUFpQkMsZ0JBQWdCLENBQUNELElBQUQsQ0FBakMsR0FBMENBLElBQTNDLENBQWpDOztBQUNBLFVBQUl6cEMsVUFBSixFQUFnQjtBQUNaLGFBQUssTUFBTXBaLEdBQVgsSUFBa0JvWixVQUFsQixFQUE4QjtBQUMxQnZXLGFBQUcsQ0FBQzdDLEdBQUQsQ0FBSCxHQUFXb1osVUFBVSxDQUFDcFosR0FBRCxDQUFyQjtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxXQUFPNkMsR0FBUDtBQUNILEdBWkQsTUFhSyxJQUFJZSxRQUFRLENBQUNELEtBQUQsQ0FBWixFQUFxQjtBQUN0QixXQUFPQSxLQUFQO0FBQ0g7QUFDSjs7QUFDRCxNQUFNby9DLGVBQWUsR0FBRyxlQUF4QjtBQUNBLE1BQU1DLG1CQUFtQixHQUFHLE9BQTVCOztBQUNBLFNBQVNGLGdCQUFULENBQTBCdFAsT0FBMUIsRUFBbUM7QUFDL0IsUUFBTTlvQyxHQUFHLEdBQUcsRUFBWjtBQUNBOG9DLFNBQU8sQ0FBQzd0QixLQUFSLENBQWNvOUIsZUFBZCxFQUErQi9oRCxPQUEvQixDQUF1QzZoRCxJQUFJLElBQUk7QUFDM0MsUUFBSUEsSUFBSixFQUFVO0FBQ04sWUFBTUksR0FBRyxHQUFHSixJQUFJLENBQUNsOUIsS0FBTCxDQUFXcTlCLG1CQUFYLENBQVo7QUFDQUMsU0FBRyxDQUFDL2pELE1BQUosR0FBYSxDQUFiLEtBQW1Cd0wsR0FBRyxDQUFDdTRDLEdBQUcsQ0FBQyxDQUFELENBQUgsQ0FBTzdxQyxJQUFQLEVBQUQsQ0FBSCxHQUFxQjZxQyxHQUFHLENBQUMsQ0FBRCxDQUFILENBQU83cUMsSUFBUCxFQUF4QztBQUNIO0FBQ0osR0FMRDtBQU1BLFNBQU8xTixHQUFQO0FBQ0g7O0FBQ0QsU0FBU3c0QyxjQUFULENBQXdCckosTUFBeEIsRUFBZ0M7QUFDNUIsTUFBSW52QyxHQUFHLEdBQUcsRUFBVjs7QUFDQSxNQUFJLENBQUNtdkMsTUFBTCxFQUFhO0FBQ1QsV0FBT252QyxHQUFQO0FBQ0g7O0FBQ0QsT0FBSyxNQUFNMUssR0FBWCxJQUFrQjY1QyxNQUFsQixFQUEwQjtBQUN0QixVQUFNbDJDLEtBQUssR0FBR2syQyxNQUFNLENBQUM3NUMsR0FBRCxDQUFwQjtBQUNBLFVBQU0wMEIsYUFBYSxHQUFHMTBCLEdBQUcsQ0FBQ2dZLFVBQUosQ0FBZ0IsSUFBaEIsSUFBdUJoWSxHQUF2QixHQUE2QndZLFNBQVMsQ0FBQ3hZLEdBQUQsQ0FBNUQ7O0FBQ0EsUUFBSTROLFFBQVEsQ0FBQ2pLLEtBQUQsQ0FBUixJQUNDLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJnL0Msd0JBQXdCLENBQUNqdUIsYUFBRCxDQUQxRCxFQUM0RTtBQUN4RTtBQUNBaHFCLFNBQUcsSUFBSyxHQUFFZ3FCLGFBQWMsSUFBRy93QixLQUFNLEdBQWpDO0FBQ0g7QUFDSjs7QUFDRCxTQUFPK0csR0FBUDtBQUNIOztBQUNELFNBQVN1K0IsY0FBVCxDQUF3QnRsQyxLQUF4QixFQUErQjtBQUMzQixNQUFJZCxHQUFHLEdBQUcsRUFBVjs7QUFDQSxNQUFJK0ssUUFBUSxDQUFDakssS0FBRCxDQUFaLEVBQXFCO0FBQ2pCZCxPQUFHLEdBQUdjLEtBQU47QUFDSCxHQUZELE1BR0ssSUFBSTFDLE9BQU8sQ0FBQzBDLEtBQUQsQ0FBWCxFQUFvQjtBQUNyQixTQUFLLElBQUlyRSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcUUsS0FBSyxDQUFDekUsTUFBMUIsRUFBa0NJLENBQUMsRUFBbkMsRUFBdUM7QUFDbkMsWUFBTThaLFVBQVUsR0FBRzZ2QixjQUFjLENBQUN0bEMsS0FBSyxDQUFDckUsQ0FBRCxDQUFOLENBQWpDOztBQUNBLFVBQUk4WixVQUFKLEVBQWdCO0FBQ1p2VyxXQUFHLElBQUl1VyxVQUFVLEdBQUcsR0FBcEI7QUFDSDtBQUNKO0FBQ0osR0FQSSxNQVFBLElBQUl4VixRQUFRLENBQUNELEtBQUQsQ0FBWixFQUFxQjtBQUN0QixTQUFLLE1BQU1xSyxJQUFYLElBQW1CckssS0FBbkIsRUFBMEI7QUFDdEIsVUFBSUEsS0FBSyxDQUFDcUssSUFBRCxDQUFULEVBQWlCO0FBQ2JuTCxXQUFHLElBQUltTCxJQUFJLEdBQUcsR0FBZDtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxTQUFPbkwsR0FBRyxDQUFDdVYsSUFBSixFQUFQO0FBQ0gsQyxDQUVEO0FBQ0E7OztBQUNBLE1BQU0rcUMsU0FBUyxHQUFHLDRFQUNkLHNFQURjLEdBRWQsMEVBRmMsR0FHZCwyRUFIYyxHQUlkLHNFQUpjLEdBS2QsMkVBTGMsR0FNZCx3RUFOYyxHQU9kLDZEQVBjLEdBUWQsMENBUkosQyxDQVNBOztBQUNBLE1BQU1DLFFBQVEsR0FBRyw4RUFDYixzRUFEYSxHQUViLG1FQUZhLEdBR2IsdUVBSGEsR0FJYixtRUFKYSxHQUtiLHlFQUxhLEdBTWIsd0VBTmEsR0FPYixrRUFQYSxHQVFiLHlFQVJhLEdBU2IsNENBVEo7QUFVQSxNQUFNQyxTQUFTLEdBQUcsc0VBQWxCO0FBQ0EsTUFBTXBDLFNBQVMsR0FBRyxhQUFjei9DLE9BQU8sQ0FBQzJoRCxTQUFELENBQXZDO0FBQ0EsTUFBTWpDLFFBQVEsR0FBRyxhQUFjMS9DLE9BQU8sQ0FBQzRoRCxRQUFELENBQXRDO0FBQ0EsTUFBTUUsU0FBUyxHQUFHLGFBQWM5aEQsT0FBTyxDQUFDNmhELFNBQUQsQ0FBdkM7QUFFQSxNQUFNRSxRQUFRLEdBQUcsU0FBakI7O0FBQ0EsU0FBU0MsVUFBVCxDQUFvQkMsTUFBcEIsRUFBNEI7QUFDeEIsUUFBTTNVLEdBQUcsR0FBRyxLQUFLMlUsTUFBakI7QUFDQSxRQUFNdnVCLEtBQUssR0FBR3F1QixRQUFRLENBQUNHLElBQVQsQ0FBYzVVLEdBQWQsQ0FBZDs7QUFDQSxNQUFJLENBQUM1WixLQUFMLEVBQVk7QUFDUixXQUFPNFosR0FBUDtBQUNIOztBQUNELE1BQUk2VSxJQUFJLEdBQUcsRUFBWDtBQUNBLE1BQUlDLE9BQUo7QUFDQSxNQUFJanlDLEtBQUo7QUFDQSxNQUFJa3lDLFNBQVMsR0FBRyxDQUFoQjs7QUFDQSxPQUFLbHlDLEtBQUssR0FBR3VqQixLQUFLLENBQUN2akIsS0FBbkIsRUFBMEJBLEtBQUssR0FBR205QixHQUFHLENBQUM1dkMsTUFBdEMsRUFBOEN5UyxLQUFLLEVBQW5ELEVBQXVEO0FBQ25ELFlBQVFtOUIsR0FBRyxDQUFDZ1YsVUFBSixDQUFlbnlDLEtBQWYsQ0FBUjtBQUNJLFdBQUssRUFBTDtBQUFTO0FBQ0xpeUMsZUFBTyxHQUFHLFFBQVY7QUFDQTs7QUFDSixXQUFLLEVBQUw7QUFBUztBQUNMQSxlQUFPLEdBQUcsT0FBVjtBQUNBOztBQUNKLFdBQUssRUFBTDtBQUFTO0FBQ0xBLGVBQU8sR0FBRyxPQUFWO0FBQ0E7O0FBQ0osV0FBSyxFQUFMO0FBQVM7QUFDTEEsZUFBTyxHQUFHLE1BQVY7QUFDQTs7QUFDSixXQUFLLEVBQUw7QUFBUztBQUNMQSxlQUFPLEdBQUcsTUFBVjtBQUNBOztBQUNKO0FBQ0k7QUFqQlI7O0FBbUJBLFFBQUlDLFNBQVMsS0FBS2x5QyxLQUFsQixFQUF5QjtBQUNyQmd5QyxVQUFJLElBQUk3VSxHQUFHLENBQUNpVixTQUFKLENBQWNGLFNBQWQsRUFBeUJseUMsS0FBekIsQ0FBUjtBQUNIOztBQUNEa3lDLGFBQVMsR0FBR2x5QyxLQUFLLEdBQUcsQ0FBcEI7QUFDQWd5QyxRQUFJLElBQUlDLE9BQVI7QUFDSDs7QUFDRCxTQUFPQyxTQUFTLEtBQUtseUMsS0FBZCxHQUFzQmd5QyxJQUFJLEdBQUc3VSxHQUFHLENBQUNpVixTQUFKLENBQWNGLFNBQWQsRUFBeUJseUMsS0FBekIsQ0FBN0IsR0FBK0RneUMsSUFBdEU7QUFDSCxDLENBQ0Q7OztBQUNBLE1BQU1LLGNBQWMsR0FBRywwQkFBdkI7O0FBQ0EsU0FBU0MsaUJBQVQsQ0FBMkJDLEdBQTNCLEVBQWdDO0FBQzVCLFNBQU9BLEdBQUcsQ0FBQ3JxQyxPQUFKLENBQVltcUMsY0FBWixFQUE0QixFQUE1QixDQUFQO0FBQ0g7O0FBRUQsU0FBU0csa0JBQVQsQ0FBNEI5eEMsQ0FBNUIsRUFBK0JDLENBQS9CLEVBQWtDO0FBQzlCLE1BQUlELENBQUMsQ0FBQ25ULE1BQUYsS0FBYW9ULENBQUMsQ0FBQ3BULE1BQW5CLEVBQ0ksT0FBTyxLQUFQO0FBQ0osTUFBSWtsRCxLQUFLLEdBQUcsSUFBWjs7QUFDQSxPQUFLLElBQUk5a0QsQ0FBQyxHQUFHLENBQWIsRUFBZ0I4a0QsS0FBSyxJQUFJOWtELENBQUMsR0FBRytTLENBQUMsQ0FBQ25ULE1BQS9CLEVBQXVDSSxDQUFDLEVBQXhDLEVBQTRDO0FBQ3hDOGtELFNBQUssR0FBR3pHLFVBQVUsQ0FBQ3RyQyxDQUFDLENBQUMvUyxDQUFELENBQUYsRUFBT2dULENBQUMsQ0FBQ2hULENBQUQsQ0FBUixDQUFsQjtBQUNIOztBQUNELFNBQU84a0QsS0FBUDtBQUNIOztBQUNELFNBQVN6RyxVQUFULENBQW9CdHJDLENBQXBCLEVBQXVCQyxDQUF2QixFQUEwQjtBQUN0QixNQUFJRCxDQUFDLEtBQUtDLENBQVYsRUFDSSxPQUFPLElBQVA7QUFDSixNQUFJK3hDLFVBQVUsR0FBR0MsTUFBTSxDQUFDanlDLENBQUQsQ0FBdkI7QUFDQSxNQUFJa3lDLFVBQVUsR0FBR0QsTUFBTSxDQUFDaHlDLENBQUQsQ0FBdkI7O0FBQ0EsTUFBSSt4QyxVQUFVLElBQUlFLFVBQWxCLEVBQThCO0FBQzFCLFdBQU9GLFVBQVUsSUFBSUUsVUFBZCxHQUEyQmx5QyxDQUFDLENBQUNteUMsT0FBRixPQUFnQmx5QyxDQUFDLENBQUNreUMsT0FBRixFQUEzQyxHQUF5RCxLQUFoRTtBQUNIOztBQUNESCxZQUFVLEdBQUdwakQsT0FBTyxDQUFDb1IsQ0FBRCxDQUFwQjtBQUNBa3lDLFlBQVUsR0FBR3RqRCxPQUFPLENBQUNxUixDQUFELENBQXBCOztBQUNBLE1BQUkreEMsVUFBVSxJQUFJRSxVQUFsQixFQUE4QjtBQUMxQixXQUFPRixVQUFVLElBQUlFLFVBQWQsR0FBMkJKLGtCQUFrQixDQUFDOXhDLENBQUQsRUFBSUMsQ0FBSixDQUE3QyxHQUFzRCxLQUE3RDtBQUNIOztBQUNEK3hDLFlBQVUsR0FBR3pnRCxRQUFRLENBQUN5TyxDQUFELENBQXJCO0FBQ0FreUMsWUFBVSxHQUFHM2dELFFBQVEsQ0FBQzBPLENBQUQsQ0FBckI7O0FBQ0EsTUFBSSt4QyxVQUFVLElBQUlFLFVBQWxCLEVBQThCO0FBQzFCO0FBQ0EsUUFBSSxDQUFDRixVQUFELElBQWUsQ0FBQ0UsVUFBcEIsRUFBZ0M7QUFDNUIsYUFBTyxLQUFQO0FBQ0g7O0FBQ0QsVUFBTUUsVUFBVSxHQUFHL2lELE1BQU0sQ0FBQytMLElBQVAsQ0FBWTRFLENBQVosRUFBZW5ULE1BQWxDO0FBQ0EsVUFBTXdsRCxVQUFVLEdBQUdoakQsTUFBTSxDQUFDK0wsSUFBUCxDQUFZNkUsQ0FBWixFQUFlcFQsTUFBbEM7O0FBQ0EsUUFBSXVsRCxVQUFVLEtBQUtDLFVBQW5CLEVBQStCO0FBQzNCLGFBQU8sS0FBUDtBQUNIOztBQUNELFNBQUssTUFBTTFrRCxHQUFYLElBQWtCcVMsQ0FBbEIsRUFBcUI7QUFDakIsWUFBTXN5QyxPQUFPLEdBQUd0eUMsQ0FBQyxDQUFDZ3dDLGNBQUYsQ0FBaUJyaUQsR0FBakIsQ0FBaEI7QUFDQSxZQUFNNGtELE9BQU8sR0FBR3R5QyxDQUFDLENBQUMrdkMsY0FBRixDQUFpQnJpRCxHQUFqQixDQUFoQjs7QUFDQSxVQUFLMmtELE9BQU8sSUFBSSxDQUFDQyxPQUFiLElBQ0MsQ0FBQ0QsT0FBRCxJQUFZQyxPQURiLElBRUEsQ0FBQ2pILFVBQVUsQ0FBQ3RyQyxDQUFDLENBQUNyUyxHQUFELENBQUYsRUFBU3NTLENBQUMsQ0FBQ3RTLEdBQUQsQ0FBVixDQUZmLEVBRWlDO0FBQzdCLGVBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxTQUFPMkUsTUFBTSxDQUFDME4sQ0FBRCxDQUFOLEtBQWMxTixNQUFNLENBQUMyTixDQUFELENBQTNCO0FBQ0g7O0FBQ0QsU0FBU2dyQyxZQUFULENBQXNCNTZDLEdBQXRCLEVBQTJCc0csR0FBM0IsRUFBZ0M7QUFDNUIsU0FBT3RHLEdBQUcsQ0FBQzR5QixTQUFKLENBQWN1dEIsSUFBSSxJQUFJbEYsVUFBVSxDQUFDa0YsSUFBRCxFQUFPNzVDLEdBQVAsQ0FBaEMsQ0FBUDtBQUNIO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU02N0MsZUFBZSxHQUFJNzdDLEdBQUQsSUFBUztBQUM3QixTQUFPQSxHQUFHLElBQUksSUFBUCxHQUNELEVBREMsR0FFRHBGLFFBQVEsQ0FBQ29GLEdBQUQsQ0FBUixHQUNJNkUsSUFBSSxDQUFDQyxTQUFMLENBQWU5RSxHQUFmLEVBQW9CODdDLFFBQXBCLEVBQThCLENBQTlCLENBREosR0FFSW5nRCxNQUFNLENBQUNxRSxHQUFELENBSmhCO0FBS0gsQ0FORDs7QUFPQSxNQUFNODdDLFFBQVEsR0FBRyxDQUFDaDZDLElBQUQsRUFBTzlCLEdBQVAsS0FBZTtBQUM1QixNQUFJOUgsS0FBSyxDQUFDOEgsR0FBRCxDQUFULEVBQWdCO0FBQ1osV0FBTztBQUNILE9BQUUsT0FBTUEsR0FBRyxDQUFDcEQsSUFBSyxHQUFqQixHQUFzQixDQUFDLEdBQUdvRCxHQUFHLENBQUMrN0MsT0FBSixFQUFKLEVBQW1CQyxNQUFuQixDQUEwQixDQUFDRCxPQUFELEVBQVUsQ0FBQy9rRCxHQUFELEVBQU1nSixHQUFOLENBQVYsS0FBeUI7QUFDckUrN0MsZUFBTyxDQUFFLEdBQUUva0QsR0FBSSxLQUFSLENBQVAsR0FBdUJnSixHQUF2QjtBQUNBLGVBQU8rN0MsT0FBUDtBQUNILE9BSHFCLEVBR25CLEVBSG1CO0FBRG5CLEtBQVA7QUFNSCxHQVBELE1BUUssSUFBSWwvQixLQUFLLENBQUM3YyxHQUFELENBQVQsRUFBZ0I7QUFDakIsV0FBTztBQUNILE9BQUUsT0FBTUEsR0FBRyxDQUFDcEQsSUFBSyxHQUFqQixHQUFzQixDQUFDLEdBQUdvRCxHQUFHLENBQUN1RixNQUFKLEVBQUo7QUFEbkIsS0FBUDtBQUdILEdBSkksTUFLQSxJQUFJM0ssUUFBUSxDQUFDb0YsR0FBRCxDQUFSLElBQWlCLENBQUMvSCxPQUFPLENBQUMrSCxHQUFELENBQXpCLElBQWtDLENBQUM4YyxhQUFhLENBQUM5YyxHQUFELENBQXBELEVBQTJEO0FBQzVELFdBQU9yRSxNQUFNLENBQUNxRSxHQUFELENBQWI7QUFDSDs7QUFDRCxTQUFPQSxHQUFQO0FBQ0gsQ0FsQkQ7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNaThDLHlCQUF5QixHQUFHLENBQzlCLFFBRDhCLEVBRTlCLGtCQUY4QixFQUc5QiwyQkFIOEIsQ0FBbEM7QUFLQSxNQUFNOW1ELFNBQVMsR0FBSVAsS0FBRCxHQUNaOEQsTUFBTSxDQUFDaXRDLE1BQVAsQ0FBYyxFQUFkLENBRFksR0FFWixDQUZOO0FBR0EsTUFBTWxhLFNBQVMsR0FBSTcyQixLQUFELEdBQTBDOEQsTUFBTSxDQUFDaXRDLE1BQVAsQ0FBYyxFQUFkLENBQTFDLEdBQThELENBQWhGOztBQUNBLE1BQU1uakMsSUFBSSxHQUFHLE1BQU0sQ0FBRyxDQUF0QjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTTBzQixFQUFFLEdBQUcsTUFBTSxLQUFqQjs7QUFDQSxNQUFNZ3RCLElBQUksR0FBRyxXQUFiOztBQUNBLE1BQU10ckMsSUFBSSxHQUFJNVosR0FBRCxJQUFTa2xELElBQUksQ0FBQzEzQixJQUFMLENBQVV4dEIsR0FBVixDQUF0Qjs7QUFDQSxNQUFNK1gsZUFBZSxHQUFJL1gsR0FBRCxJQUFTQSxHQUFHLENBQUNnWSxVQUFKLENBQWUsV0FBZixDQUFqQzs7QUFDQSxNQUFNblQsTUFBTSxHQUFHbkQsTUFBTSxDQUFDMjdDLE1BQXRCOztBQUNBLE1BQU03N0IsTUFBTSxHQUFHLENBQUM5ZSxHQUFELEVBQU00YixFQUFOLEtBQWE7QUFDeEIsUUFBTWhmLENBQUMsR0FBR29ELEdBQUcsQ0FBQzRPLE9BQUosQ0FBWWdOLEVBQVosQ0FBVjs7QUFDQSxNQUFJaGYsQ0FBQyxHQUFHLENBQUMsQ0FBVCxFQUFZO0FBQ1JvRCxPQUFHLENBQUN3TyxNQUFKLENBQVc1UixDQUFYLEVBQWMsQ0FBZDtBQUNIO0FBQ0osQ0FMRDs7QUFNQSxNQUFNK2lELGNBQWMsR0FBRzNnRCxNQUFNLENBQUNjLFNBQVAsQ0FBaUI2L0MsY0FBeEM7O0FBQ0EsTUFBTTkrQyxNQUFNLEdBQUcsQ0FBQ3lGLEdBQUQsRUFBTWhKLEdBQU4sS0FBY3FpRCxjQUFjLENBQUMzOEMsSUFBZixDQUFvQnNELEdBQXBCLEVBQXlCaEosR0FBekIsQ0FBN0I7O0FBQ0EsTUFBTWlCLE9BQU8sR0FBR3NCLEtBQUssQ0FBQ3RCLE9BQXRCOztBQUNBLE1BQU1DLEtBQUssR0FBSThILEdBQUQsSUFBU204QyxZQUFZLENBQUNuOEMsR0FBRCxDQUFaLEtBQXNCLGNBQTdDOztBQUNBLE1BQU02YyxLQUFLLEdBQUk3YyxHQUFELElBQVNtOEMsWUFBWSxDQUFDbjhDLEdBQUQsQ0FBWixLQUFzQixjQUE3Qzs7QUFDQSxNQUFNczdDLE1BQU0sR0FBSXQ3QyxHQUFELElBQVNBLEdBQUcsWUFBWTJ6QixJQUF2Qzs7QUFDQSxNQUFNcHhCLFVBQVUsR0FBSXZDLEdBQUQsSUFBUyxPQUFPQSxHQUFQLEtBQWUsVUFBM0M7O0FBQ0EsTUFBTTRFLFFBQVEsR0FBSTVFLEdBQUQsSUFBUyxPQUFPQSxHQUFQLEtBQWUsUUFBekM7O0FBQ0EsTUFBTWxILFFBQVEsR0FBSWtILEdBQUQsSUFBUyxPQUFPQSxHQUFQLEtBQWUsUUFBekM7O0FBQ0EsTUFBTXBGLFFBQVEsR0FBSW9GLEdBQUQsSUFBU0EsR0FBRyxLQUFLLElBQVIsSUFBZ0IsT0FBT0EsR0FBUCxLQUFlLFFBQXpEOztBQUNBLE1BQU1vbUMsU0FBUyxHQUFJcG1DLEdBQUQsSUFBUztBQUN2QixTQUFPcEYsUUFBUSxDQUFDb0YsR0FBRCxDQUFSLElBQWlCdUMsVUFBVSxDQUFDdkMsR0FBRyxDQUFDc0gsSUFBTCxDQUEzQixJQUF5Qy9FLFVBQVUsQ0FBQ3ZDLEdBQUcsQ0FBQ3NGLEtBQUwsQ0FBMUQ7QUFDSCxDQUZEOztBQUdBLE1BQU04MkMsY0FBYyxHQUFHMWpELE1BQU0sQ0FBQ2MsU0FBUCxDQUFpQjJ5QixRQUF4Qzs7QUFDQSxNQUFNZ3dCLFlBQVksR0FBSXhoRCxLQUFELElBQVd5aEQsY0FBYyxDQUFDMS9DLElBQWYsQ0FBb0IvQixLQUFwQixDQUFoQzs7QUFDQSxNQUFNaUUsU0FBUyxHQUFJakUsS0FBRCxJQUFXO0FBQ3pCO0FBQ0EsU0FBT3doRCxZQUFZLENBQUN4aEQsS0FBRCxDQUFaLENBQW9CK0osS0FBcEIsQ0FBMEIsQ0FBMUIsRUFBNkIsQ0FBQyxDQUE5QixDQUFQO0FBQ0gsQ0FIRDs7QUFJQSxNQUFNb1ksYUFBYSxHQUFJOWMsR0FBRCxJQUFTbThDLFlBQVksQ0FBQ244QyxHQUFELENBQVosS0FBc0IsaUJBQXJEOztBQUNBLE1BQU03SCxZQUFZLEdBQUluQixHQUFELElBQVM0TixRQUFRLENBQUM1TixHQUFELENBQVIsSUFDMUJBLEdBQUcsS0FBSyxLQURrQixJQUUxQkEsR0FBRyxDQUFDLENBQUQsQ0FBSCxLQUFXLEdBRmUsSUFHMUIsS0FBS3F0QixRQUFRLENBQUNydEIsR0FBRCxFQUFNLEVBQU4sQ0FBYixLQUEyQkEsR0FIL0I7O0FBSUEsTUFBTWkwQixjQUFjLEdBQUcsYUFBY3p5QixPQUFPLEVBQzVDO0FBQ0EsY0FDSSxvQ0FESixHQUVJLHFDQUZKLEdBR0ksdUNBTHdDLENBQTVDOztBQU1BLE1BQU02akQsbUJBQW1CLEdBQUl0bkQsRUFBRCxJQUFRO0FBQ2hDLFFBQU1pYixLQUFLLEdBQUd0WCxNQUFNLENBQUM4VSxNQUFQLENBQWMsSUFBZCxDQUFkO0FBQ0EsU0FBU3M0QixHQUFELElBQVM7QUFDYixVQUFNd1csR0FBRyxHQUFHdHNDLEtBQUssQ0FBQzgxQixHQUFELENBQWpCO0FBQ0EsV0FBT3dXLEdBQUcsS0FBS3RzQyxLQUFLLENBQUM4MUIsR0FBRCxDQUFMLEdBQWEvd0MsRUFBRSxDQUFDK3dDLEdBQUQsQ0FBcEIsQ0FBVjtBQUNILEdBSEQ7QUFJSCxDQU5EOztBQU9BLE1BQU15VyxVQUFVLEdBQUcsUUFBbkI7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBTTVzQyxRQUFRLEdBQUcwc0MsbUJBQW1CLENBQUV2VyxHQUFELElBQVM7QUFDMUMsU0FBT0EsR0FBRyxDQUFDajFCLE9BQUosQ0FBWTByQyxVQUFaLEVBQXdCLENBQUNydUIsQ0FBRCxFQUFJelQsQ0FBSixLQUFXQSxDQUFDLEdBQUdBLENBQUMsQ0FBQ3NyQixXQUFGLEVBQUgsR0FBcUIsRUFBekQsQ0FBUDtBQUNILENBRm1DLENBQXBDO0FBR0EsTUFBTXlXLFdBQVcsR0FBRyxZQUFwQjtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNaHRDLFNBQVMsR0FBRzZzQyxtQkFBbUIsQ0FBRXZXLEdBQUQsSUFBU0EsR0FBRyxDQUFDajFCLE9BQUosQ0FBWTJyQyxXQUFaLEVBQXlCLEtBQXpCLEVBQWdDanRDLFdBQWhDLEVBQVYsQ0FBckM7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBTXZSLFVBQVUsR0FBR3ErQyxtQkFBbUIsQ0FBRXZXLEdBQUQsSUFBU0EsR0FBRyxDQUFDMlcsTUFBSixDQUFXLENBQVgsRUFBYzFXLFdBQWQsS0FBOEJELEdBQUcsQ0FBQ3BoQyxLQUFKLENBQVUsQ0FBVixDQUF4QyxDQUF0QztBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNa0ssWUFBWSxHQUFHeXRDLG1CQUFtQixDQUFFdlcsR0FBRCxJQUFVQSxHQUFHLEdBQUksS0FBSTluQyxVQUFVLENBQUM4bkMsR0FBRCxDQUFNLEVBQXhCLEdBQTZCLEVBQTNDLENBQXhDLEMsQ0FDQTs7QUFDQSxNQUFNMXFDLFVBQVUsR0FBRyxDQUFDVCxLQUFELEVBQVEvQyxRQUFSLEtBQXFCK0MsS0FBSyxLQUFLL0MsUUFBVixLQUF1QitDLEtBQUssS0FBS0EsS0FBVixJQUFtQi9DLFFBQVEsS0FBS0EsUUFBdkQsQ0FBeEM7O0FBQ0EsTUFBTXdyQixjQUFjLEdBQUcsQ0FBQ3M1QixHQUFELEVBQU10eEMsR0FBTixLQUFjO0FBQ2pDLE9BQUssSUFBSTlVLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdvbUQsR0FBRyxDQUFDeG1ELE1BQXhCLEVBQWdDSSxDQUFDLEVBQWpDLEVBQXFDO0FBQ2pDb21ELE9BQUcsQ0FBQ3BtRCxDQUFELENBQUgsQ0FBTzhVLEdBQVA7QUFDSDtBQUNKLENBSkQ7O0FBS0EsTUFBTXRMLEdBQUcsR0FBRyxDQUFDbWlDLEdBQUQsRUFBTWpyQyxHQUFOLEVBQVcyRCxLQUFYLEtBQXFCO0FBQzdCakMsUUFBTSxDQUFDd3ZCLGNBQVAsQ0FBc0IrWixHQUF0QixFQUEyQmpyQyxHQUEzQixFQUFnQztBQUM1Qm14QixnQkFBWSxFQUFFLElBRGM7QUFFNUJDLGNBQVUsRUFBRSxLQUZnQjtBQUc1Qnp0QjtBQUg0QixHQUFoQztBQUtILENBTkQ7O0FBT0EsTUFBTTBVLFFBQVEsR0FBSXJQLEdBQUQsSUFBUztBQUN0QixRQUFNc1ksQ0FBQyxHQUFHcWtDLFVBQVUsQ0FBQzM4QyxHQUFELENBQXBCO0FBQ0EsU0FBT2d3QyxLQUFLLENBQUMxM0IsQ0FBRCxDQUFMLEdBQVd0WSxHQUFYLEdBQWlCc1ksQ0FBeEI7QUFDSCxDQUhEOztBQUlBLElBQUlza0MsV0FBSjs7QUFDQSxNQUFNeG5CLGFBQWEsR0FBRyxNQUFNO0FBQ3hCLFNBQVF3bkIsV0FBVyxLQUNkQSxXQUFXLEdBQ1IsT0FBT0MsVUFBUCxLQUFzQixXQUF0QixHQUNNQSxVQUROLEdBRU0sT0FBTzE2QyxJQUFQLEtBQWdCLFdBQWhCLEdBQ0lBLElBREosR0FFSSxPQUFPNkgsTUFBUCxLQUFrQixXQUFsQixHQUNJQSxNQURKLEdBRUksT0FBT0QscUJBQVAsS0FBa0IsV0FBbEIsR0FDSUEscUJBREosR0FFSSxFQVZQLENBQW5CO0FBV0gsQ0FaRDs7Ozs7Ozs7Ozs7O0FDcGVBK3lDLDRGQUFBLEM7Ozs7Ozs7Ozs7O0FDQWE7O0FBRWIsSUFBSUMsS0FBSyxHQUFHQyxtQkFBTyxDQUFDLHFEQUFELENBQW5COztBQUNBLElBQUlDLE1BQU0sR0FBR0QsbUJBQU8sQ0FBQyxpRUFBRCxDQUFwQjs7QUFDQSxJQUFJRSxPQUFPLEdBQUdGLG1CQUFPLENBQUMseUVBQUQsQ0FBckI7O0FBQ0EsSUFBSUcsUUFBUSxHQUFHSCxtQkFBTyxDQUFDLDJFQUFELENBQXRCOztBQUNBLElBQUlJLGFBQWEsR0FBR0osbUJBQU8sQ0FBQyw2RUFBRCxDQUEzQjs7QUFDQSxJQUFJSyxZQUFZLEdBQUdMLG1CQUFPLENBQUMsbUZBQUQsQ0FBMUI7O0FBQ0EsSUFBSU0sZUFBZSxHQUFHTixtQkFBTyxDQUFDLHlGQUFELENBQTdCOztBQUNBLElBQUlPLFdBQVcsR0FBR1AsbUJBQU8sQ0FBQyx5RUFBRCxDQUF6Qjs7QUFFQUYsTUFBTSxDQUFDVSxPQUFQLEdBQWlCLFNBQVNDLFVBQVQsQ0FBb0J2NkMsTUFBcEIsRUFBNEI7QUFDM0MsU0FBTyxJQUFJNkQsT0FBSixDQUFZLFNBQVMyMkMsa0JBQVQsQ0FBNEIxMkMsT0FBNUIsRUFBcUM2YSxNQUFyQyxFQUE2QztBQUM5RCxRQUFJODdCLFdBQVcsR0FBR3o2QyxNQUFNLENBQUNxUCxJQUF6QjtBQUNBLFFBQUlxckMsY0FBYyxHQUFHMTZDLE1BQU0sQ0FBQzI2QyxPQUE1Qjs7QUFFQSxRQUFJZCxLQUFLLENBQUNlLFVBQU4sQ0FBaUJILFdBQWpCLENBQUosRUFBbUM7QUFDakMsYUFBT0MsY0FBYyxDQUFDLGNBQUQsQ0FBckIsQ0FEaUMsQ0FDTTtBQUN4Qzs7QUFFRCxRQUFJRyxPQUFPLEdBQUcsSUFBSUMsY0FBSixFQUFkLENBUjhELENBVTlEOztBQUNBLFFBQUk5NkMsTUFBTSxDQUFDKzZDLElBQVgsRUFBaUI7QUFDZixVQUFJQyxRQUFRLEdBQUdoN0MsTUFBTSxDQUFDKzZDLElBQVAsQ0FBWUMsUUFBWixJQUF3QixFQUF2QztBQUNBLFVBQUlDLFFBQVEsR0FBR2o3QyxNQUFNLENBQUMrNkMsSUFBUCxDQUFZRSxRQUFaLEdBQXVCQyxRQUFRLENBQUNDLGtCQUFrQixDQUFDbjdDLE1BQU0sQ0FBQys2QyxJQUFQLENBQVlFLFFBQWIsQ0FBbkIsQ0FBL0IsR0FBNEUsRUFBM0Y7QUFDQVAsb0JBQWMsQ0FBQ1UsYUFBZixHQUErQixXQUFXQyxJQUFJLENBQUNMLFFBQVEsR0FBRyxHQUFYLEdBQWlCQyxRQUFsQixDQUE5QztBQUNEOztBQUVELFFBQUlLLFFBQVEsR0FBR3BCLGFBQWEsQ0FBQ2w2QyxNQUFNLENBQUN1N0MsT0FBUixFQUFpQnY3QyxNQUFNLENBQUN3N0MsR0FBeEIsQ0FBNUI7QUFDQVgsV0FBTyxDQUFDMTVDLElBQVIsQ0FBYW5CLE1BQU0sQ0FBQzVKLE1BQVAsQ0FBY3lzQyxXQUFkLEVBQWIsRUFBMENvWCxRQUFRLENBQUNxQixRQUFELEVBQVd0N0MsTUFBTSxDQUFDMkosTUFBbEIsRUFBMEIzSixNQUFNLENBQUN5N0MsZ0JBQWpDLENBQWxELEVBQXNHLElBQXRHLEVBbEI4RCxDQW9COUQ7O0FBQ0FaLFdBQU8sQ0FBQy9sQyxPQUFSLEdBQWtCOVUsTUFBTSxDQUFDOFUsT0FBekIsQ0FyQjhELENBdUI5RDs7QUFDQStsQyxXQUFPLENBQUNhLGtCQUFSLEdBQTZCLFNBQVNDLFVBQVQsR0FBc0I7QUFDakQsVUFBSSxDQUFDZCxPQUFELElBQVlBLE9BQU8sQ0FBQ2UsVUFBUixLQUF1QixDQUF2QyxFQUEwQztBQUN4QztBQUNELE9BSGdELENBS2pEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxVQUFJZixPQUFPLENBQUNnQixNQUFSLEtBQW1CLENBQW5CLElBQXdCLEVBQUVoQixPQUFPLENBQUNpQixXQUFSLElBQXVCakIsT0FBTyxDQUFDaUIsV0FBUixDQUFvQjEyQyxPQUFwQixDQUE0QixPQUE1QixNQUF5QyxDQUFsRSxDQUE1QixFQUFrRztBQUNoRztBQUNELE9BWGdELENBYWpEOzs7QUFDQSxVQUFJMjJDLGVBQWUsR0FBRywyQkFBMkJsQixPQUEzQixHQUFxQ1YsWUFBWSxDQUFDVSxPQUFPLENBQUNtQixxQkFBUixFQUFELENBQWpELEdBQXFGLElBQTNHO0FBQ0EsVUFBSUMsWUFBWSxHQUFHLENBQUNqOEMsTUFBTSxDQUFDazhDLFlBQVIsSUFBd0JsOEMsTUFBTSxDQUFDazhDLFlBQVAsS0FBd0IsTUFBaEQsR0FBeURyQixPQUFPLENBQUNzQixZQUFqRSxHQUFnRnRCLE9BQU8sQ0FBQ3VCLFFBQTNHO0FBQ0EsVUFBSUEsUUFBUSxHQUFHO0FBQ2Ivc0MsWUFBSSxFQUFFNHNDLFlBRE87QUFFYkosY0FBTSxFQUFFaEIsT0FBTyxDQUFDZ0IsTUFGSDtBQUdiUSxrQkFBVSxFQUFFeEIsT0FBTyxDQUFDd0IsVUFIUDtBQUliMUIsZUFBTyxFQUFFb0IsZUFKSTtBQUtiLzdDLGNBQU0sRUFBRUEsTUFMSztBQU1iNjZDLGVBQU8sRUFBRUE7QUFOSSxPQUFmO0FBU0FkLFlBQU0sQ0FBQ2oyQyxPQUFELEVBQVU2YSxNQUFWLEVBQWtCeTlCLFFBQWxCLENBQU4sQ0F6QmlELENBMkJqRDs7QUFDQXZCLGFBQU8sR0FBRyxJQUFWO0FBQ0QsS0E3QkQsQ0F4QjhELENBdUQ5RDs7O0FBQ0FBLFdBQU8sQ0FBQ3lCLE9BQVIsR0FBa0IsU0FBU0MsV0FBVCxHQUF1QjtBQUN2QyxVQUFJLENBQUMxQixPQUFMLEVBQWM7QUFDWjtBQUNEOztBQUVEbDhCLFlBQU0sQ0FBQzA3QixXQUFXLENBQUMsaUJBQUQsRUFBb0JyNkMsTUFBcEIsRUFBNEIsY0FBNUIsRUFBNEM2NkMsT0FBNUMsQ0FBWixDQUFOLENBTHVDLENBT3ZDOztBQUNBQSxhQUFPLEdBQUcsSUFBVjtBQUNELEtBVEQsQ0F4RDhELENBbUU5RDs7O0FBQ0FBLFdBQU8sQ0FBQzJCLE9BQVIsR0FBa0IsU0FBU3Y2QyxXQUFULEdBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTBjLFlBQU0sQ0FBQzA3QixXQUFXLENBQUMsZUFBRCxFQUFrQnI2QyxNQUFsQixFQUEwQixJQUExQixFQUFnQzY2QyxPQUFoQyxDQUFaLENBQU4sQ0FIdUMsQ0FLdkM7O0FBQ0FBLGFBQU8sR0FBRyxJQUFWO0FBQ0QsS0FQRCxDQXBFOEQsQ0E2RTlEOzs7QUFDQUEsV0FBTyxDQUFDNEIsU0FBUixHQUFvQixTQUFTQyxhQUFULEdBQXlCO0FBQzNDLFVBQUlDLG1CQUFtQixHQUFHLGdCQUFnQjM4QyxNQUFNLENBQUM4VSxPQUF2QixHQUFpQyxhQUEzRDs7QUFDQSxVQUFJOVUsTUFBTSxDQUFDMjhDLG1CQUFYLEVBQWdDO0FBQzlCQSwyQkFBbUIsR0FBRzM4QyxNQUFNLENBQUMyOEMsbUJBQTdCO0FBQ0Q7O0FBQ0RoK0IsWUFBTSxDQUFDMDdCLFdBQVcsQ0FBQ3NDLG1CQUFELEVBQXNCMzhDLE1BQXRCLEVBQThCLGNBQTlCLEVBQ2hCNjZDLE9BRGdCLENBQVosQ0FBTixDQUwyQyxDQVEzQzs7QUFDQUEsYUFBTyxHQUFHLElBQVY7QUFDRCxLQVZELENBOUU4RCxDQTBGOUQ7QUFDQTtBQUNBOzs7QUFDQSxRQUFJaEIsS0FBSyxDQUFDK0Msb0JBQU4sRUFBSixFQUFrQztBQUNoQztBQUNBLFVBQUlDLFNBQVMsR0FBRyxDQUFDNzhDLE1BQU0sQ0FBQzg4QyxlQUFQLElBQTBCMUMsZUFBZSxDQUFDa0IsUUFBRCxDQUExQyxLQUF5RHQ3QyxNQUFNLENBQUMrOEMsY0FBaEUsR0FDZC9DLE9BQU8sQ0FBQ2dELElBQVIsQ0FBYWg5QyxNQUFNLENBQUMrOEMsY0FBcEIsQ0FEYyxHQUVkcnBELFNBRkY7O0FBSUEsVUFBSW1wRCxTQUFKLEVBQWU7QUFDYm5DLHNCQUFjLENBQUMxNkMsTUFBTSxDQUFDaTlDLGNBQVIsQ0FBZCxHQUF3Q0osU0FBeEM7QUFDRDtBQUNGLEtBdEc2RCxDQXdHOUQ7OztBQUNBLFFBQUksc0JBQXNCaEMsT0FBMUIsRUFBbUM7QUFDakNoQixXQUFLLENBQUMva0QsT0FBTixDQUFjNGxELGNBQWQsRUFBOEIsU0FBU3dDLGdCQUFULENBQTBCcGdELEdBQTFCLEVBQStCaEosR0FBL0IsRUFBb0M7QUFDaEUsWUFBSSxPQUFPMm1ELFdBQVAsS0FBdUIsV0FBdkIsSUFBc0MzbUQsR0FBRyxDQUFDdVksV0FBSixPQUFzQixjQUFoRSxFQUFnRjtBQUM5RTtBQUNBLGlCQUFPcXVDLGNBQWMsQ0FBQzVtRCxHQUFELENBQXJCO0FBQ0QsU0FIRCxNQUdPO0FBQ0w7QUFDQSttRCxpQkFBTyxDQUFDcUMsZ0JBQVIsQ0FBeUJwcEQsR0FBekIsRUFBOEJnSixHQUE5QjtBQUNEO0FBQ0YsT0FSRDtBQVNELEtBbkg2RCxDQXFIOUQ7OztBQUNBLFFBQUksQ0FBQys4QyxLQUFLLENBQUNzRCxXQUFOLENBQWtCbjlDLE1BQU0sQ0FBQzg4QyxlQUF6QixDQUFMLEVBQWdEO0FBQzlDakMsYUFBTyxDQUFDaUMsZUFBUixHQUEwQixDQUFDLENBQUM5OEMsTUFBTSxDQUFDODhDLGVBQW5DO0FBQ0QsS0F4SDZELENBMEg5RDs7O0FBQ0EsUUFBSTk4QyxNQUFNLENBQUNrOEMsWUFBWCxFQUF5QjtBQUN2QixVQUFJO0FBQ0ZyQixlQUFPLENBQUNxQixZQUFSLEdBQXVCbDhDLE1BQU0sQ0FBQ2s4QyxZQUE5QjtBQUNELE9BRkQsQ0FFRSxPQUFPL3pDLENBQVAsRUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFJbkksTUFBTSxDQUFDazhDLFlBQVAsS0FBd0IsTUFBNUIsRUFBb0M7QUFDbEMsZ0JBQU0vekMsQ0FBTjtBQUNEO0FBQ0Y7QUFDRixLQXJJNkQsQ0F1STlEOzs7QUFDQSxRQUFJLE9BQU9uSSxNQUFNLENBQUNvOUMsa0JBQWQsS0FBcUMsVUFBekMsRUFBcUQ7QUFDbkR2QyxhQUFPLENBQUM5UixnQkFBUixDQUF5QixVQUF6QixFQUFxQy9vQyxNQUFNLENBQUNvOUMsa0JBQTVDO0FBQ0QsS0ExSTZELENBNEk5RDs7O0FBQ0EsUUFBSSxPQUFPcDlDLE1BQU0sQ0FBQ3E5QyxnQkFBZCxLQUFtQyxVQUFuQyxJQUFpRHhDLE9BQU8sQ0FBQ3lDLE1BQTdELEVBQXFFO0FBQ25FekMsYUFBTyxDQUFDeUMsTUFBUixDQUFldlUsZ0JBQWYsQ0FBZ0MsVUFBaEMsRUFBNEMvb0MsTUFBTSxDQUFDcTlDLGdCQUFuRDtBQUNEOztBQUVELFFBQUlyOUMsTUFBTSxDQUFDdTlDLFdBQVgsRUFBd0I7QUFDdEI7QUFDQXY5QyxZQUFNLENBQUN1OUMsV0FBUCxDQUFtQkMsT0FBbkIsQ0FBMkJwNUMsSUFBM0IsQ0FBZ0MsU0FBU3E1QyxVQUFULENBQW9CQyxNQUFwQixFQUE0QjtBQUMxRCxZQUFJLENBQUM3QyxPQUFMLEVBQWM7QUFDWjtBQUNEOztBQUVEQSxlQUFPLENBQUM4QyxLQUFSO0FBQ0FoL0IsY0FBTSxDQUFDKytCLE1BQUQsQ0FBTixDQU4wRCxDQU8xRDs7QUFDQTdDLGVBQU8sR0FBRyxJQUFWO0FBQ0QsT0FURDtBQVVEOztBQUVELFFBQUksQ0FBQ0osV0FBTCxFQUFrQjtBQUNoQkEsaUJBQVcsR0FBRyxJQUFkO0FBQ0QsS0FqSzZELENBbUs5RDs7O0FBQ0FJLFdBQU8sQ0FBQytDLElBQVIsQ0FBYW5ELFdBQWI7QUFDRCxHQXJLTSxDQUFQO0FBc0tELENBdktELEM7Ozs7Ozs7Ozs7O0FDWGE7O0FBRWIsSUFBSVosS0FBSyxHQUFHQyxtQkFBTyxDQUFDLGtEQUFELENBQW5COztBQUNBLElBQUl6MUMsSUFBSSxHQUFHeTFDLG1CQUFPLENBQUMsZ0VBQUQsQ0FBbEI7O0FBQ0EsSUFBSStELEtBQUssR0FBRy9ELG1CQUFPLENBQUMsNERBQUQsQ0FBbkI7O0FBQ0EsSUFBSWdFLFdBQVcsR0FBR2hFLG1CQUFPLENBQUMsd0VBQUQsQ0FBekI7O0FBQ0EsSUFBSXJXLFFBQVEsR0FBR3FXLG1CQUFPLENBQUMsd0RBQUQsQ0FBdEI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNpRSxjQUFULENBQXdCQyxhQUF4QixFQUF1QztBQUNyQyxNQUFJeHhCLE9BQU8sR0FBRyxJQUFJcXhCLEtBQUosQ0FBVUcsYUFBVixDQUFkO0FBQ0EsTUFBSXArQyxRQUFRLEdBQUd5RSxJQUFJLENBQUN3NUMsS0FBSyxDQUFDdm5ELFNBQU4sQ0FBZ0J1a0QsT0FBakIsRUFBMEJydUIsT0FBMUIsQ0FBbkIsQ0FGcUMsQ0FJckM7O0FBQ0FxdEIsT0FBSyxDQUFDbGhELE1BQU4sQ0FBYWlILFFBQWIsRUFBdUJpK0MsS0FBSyxDQUFDdm5ELFNBQTdCLEVBQXdDazJCLE9BQXhDLEVBTHFDLENBT3JDOztBQUNBcXRCLE9BQUssQ0FBQ2xoRCxNQUFOLENBQWFpSCxRQUFiLEVBQXVCNHNCLE9BQXZCO0FBRUEsU0FBTzVzQixRQUFQO0FBQ0QsQyxDQUVEOzs7QUFDQSxJQUFJcStDLEtBQUssR0FBR0YsY0FBYyxDQUFDdGEsUUFBRCxDQUExQixDLENBRUE7O0FBQ0F3YSxLQUFLLENBQUNKLEtBQU4sR0FBY0EsS0FBZCxDLENBRUE7O0FBQ0FJLEtBQUssQ0FBQzN6QyxNQUFOLEdBQWUsU0FBU0EsTUFBVCxDQUFnQlcsY0FBaEIsRUFBZ0M7QUFDN0MsU0FBTzh5QyxjQUFjLENBQUNELFdBQVcsQ0FBQ0csS0FBSyxDQUFDeGEsUUFBUCxFQUFpQng0QixjQUFqQixDQUFaLENBQXJCO0FBQ0QsQ0FGRCxDLENBSUE7OztBQUNBZ3pDLEtBQUssQ0FBQ0MsTUFBTixHQUFlcEUsbUJBQU8sQ0FBQyxrRUFBRCxDQUF0QjtBQUNBbUUsS0FBSyxDQUFDRSxXQUFOLEdBQW9CckUsbUJBQU8sQ0FBQyw0RUFBRCxDQUEzQjtBQUNBbUUsS0FBSyxDQUFDRyxRQUFOLEdBQWlCdEUsbUJBQU8sQ0FBQyxzRUFBRCxDQUF4QixDLENBRUE7O0FBQ0FtRSxLQUFLLENBQUNJLEdBQU4sR0FBWSxTQUFTQSxHQUFULENBQWFDLFFBQWIsRUFBdUI7QUFDakMsU0FBT3o2QyxPQUFPLENBQUN3NkMsR0FBUixDQUFZQyxRQUFaLENBQVA7QUFDRCxDQUZEOztBQUdBTCxLQUFLLENBQUNNLE1BQU4sR0FBZXpFLG1CQUFPLENBQUMsb0VBQUQsQ0FBdEIsQyxDQUVBOztBQUNBbUUsS0FBSyxDQUFDTyxZQUFOLEdBQXFCMUUsbUJBQU8sQ0FBQyxnRkFBRCxDQUE1QjtBQUVBRixNQUFNLENBQUNVLE9BQVAsR0FBaUIyRCxLQUFqQixDLENBRUE7O0FBQ0FyRSxzQkFBQSxHQUF5QnFFLEtBQXpCLEM7Ozs7Ozs7Ozs7O0FDdkRhO0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFNBQVNDLE1BQVQsQ0FBZ0JyMEMsT0FBaEIsRUFBeUI7QUFDdkIsT0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0Q7O0FBRURxMEMsTUFBTSxDQUFDNW5ELFNBQVAsQ0FBaUIyeUIsUUFBakIsR0FBNEIsU0FBU0EsUUFBVCxHQUFvQjtBQUM5QyxTQUFPLFlBQVksS0FBS3BmLE9BQUwsR0FBZSxPQUFPLEtBQUtBLE9BQTNCLEdBQXFDLEVBQWpELENBQVA7QUFDRCxDQUZEOztBQUlBcTBDLE1BQU0sQ0FBQzVuRCxTQUFQLENBQWlCbW9ELFVBQWpCLEdBQThCLElBQTlCO0FBRUE3RSxNQUFNLENBQUNVLE9BQVAsR0FBaUI0RCxNQUFqQixDOzs7Ozs7Ozs7OztBQ2xCYTs7QUFFYixJQUFJQSxNQUFNLEdBQUdwRSxtQkFBTyxDQUFDLDJEQUFELENBQXBCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTcUUsV0FBVCxDQUFxQk8sUUFBckIsRUFBK0I7QUFDN0IsTUFBSSxPQUFPQSxRQUFQLEtBQW9CLFVBQXhCLEVBQW9DO0FBQ2xDLFVBQU0sSUFBSUMsU0FBSixDQUFjLDhCQUFkLENBQU47QUFDRDs7QUFFRCxNQUFJQyxjQUFKO0FBQ0EsT0FBS3BCLE9BQUwsR0FBZSxJQUFJMzVDLE9BQUosQ0FBWSxTQUFTZzdDLGVBQVQsQ0FBeUIvNkMsT0FBekIsRUFBa0M7QUFDM0Q4NkMsa0JBQWMsR0FBRzk2QyxPQUFqQjtBQUNELEdBRmMsQ0FBZjtBQUlBLE1BQUlnN0MsS0FBSyxHQUFHLElBQVo7QUFDQUosVUFBUSxDQUFDLFNBQVNoQixNQUFULENBQWdCN3pDLE9BQWhCLEVBQXlCO0FBQ2hDLFFBQUlpMUMsS0FBSyxDQUFDQyxNQUFWLEVBQWtCO0FBQ2hCO0FBQ0E7QUFDRDs7QUFFREQsU0FBSyxDQUFDQyxNQUFOLEdBQWUsSUFBSWIsTUFBSixDQUFXcjBDLE9BQVgsQ0FBZjtBQUNBKzBDLGtCQUFjLENBQUNFLEtBQUssQ0FBQ0MsTUFBUCxDQUFkO0FBQ0QsR0FSTyxDQUFSO0FBU0Q7QUFFRDtBQUNBO0FBQ0E7OztBQUNBWixXQUFXLENBQUM3bkQsU0FBWixDQUFzQjBvRCxnQkFBdEIsR0FBeUMsU0FBU0EsZ0JBQVQsR0FBNEI7QUFDbkUsTUFBSSxLQUFLRCxNQUFULEVBQWlCO0FBQ2YsVUFBTSxLQUFLQSxNQUFYO0FBQ0Q7QUFDRixDQUpEO0FBTUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBWixXQUFXLENBQUM3bEMsTUFBWixHQUFxQixTQUFTQSxNQUFULEdBQWtCO0FBQ3JDLE1BQUlvbEMsTUFBSjtBQUNBLE1BQUlvQixLQUFLLEdBQUcsSUFBSVgsV0FBSixDQUFnQixTQUFTTyxRQUFULENBQWtCbm5DLENBQWxCLEVBQXFCO0FBQy9DbW1DLFVBQU0sR0FBR25tQyxDQUFUO0FBQ0QsR0FGVyxDQUFaO0FBR0EsU0FBTztBQUNMdW5DLFNBQUssRUFBRUEsS0FERjtBQUVMcEIsVUFBTSxFQUFFQTtBQUZILEdBQVA7QUFJRCxDQVREOztBQVdBOUQsTUFBTSxDQUFDVSxPQUFQLEdBQWlCNkQsV0FBakIsQzs7Ozs7Ozs7Ozs7QUN4RGE7O0FBRWJ2RSxNQUFNLENBQUNVLE9BQVAsR0FBaUIsU0FBUzhELFFBQVQsQ0FBa0IzbUQsS0FBbEIsRUFBeUI7QUFDeEMsU0FBTyxDQUFDLEVBQUVBLEtBQUssSUFBSUEsS0FBSyxDQUFDZ25ELFVBQWpCLENBQVI7QUFDRCxDQUZELEM7Ozs7Ozs7Ozs7O0FDRmE7O0FBRWIsSUFBSTVFLEtBQUssR0FBR0MsbUJBQU8sQ0FBQyxxREFBRCxDQUFuQjs7QUFDQSxJQUFJRyxRQUFRLEdBQUdILG1CQUFPLENBQUMseUVBQUQsQ0FBdEI7O0FBQ0EsSUFBSW1GLGtCQUFrQixHQUFHbkYsbUJBQU8sQ0FBQyxpRkFBRCxDQUFoQzs7QUFDQSxJQUFJb0YsZUFBZSxHQUFHcEYsbUJBQU8sQ0FBQywyRUFBRCxDQUE3Qjs7QUFDQSxJQUFJZ0UsV0FBVyxHQUFHaEUsbUJBQU8sQ0FBQyxtRUFBRCxDQUF6QjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMrRCxLQUFULENBQWU1eUMsY0FBZixFQUErQjtBQUM3QixPQUFLdzRCLFFBQUwsR0FBZ0J4NEIsY0FBaEI7QUFDQSxPQUFLazBDLFlBQUwsR0FBb0I7QUFDbEJ0RSxXQUFPLEVBQUUsSUFBSW9FLGtCQUFKLEVBRFM7QUFFbEI3QyxZQUFRLEVBQUUsSUFBSTZDLGtCQUFKO0FBRlEsR0FBcEI7QUFJRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBcEIsS0FBSyxDQUFDdm5ELFNBQU4sQ0FBZ0J1a0QsT0FBaEIsR0FBMEIsU0FBU0EsT0FBVCxDQUFpQjc2QyxNQUFqQixFQUF5QjtBQUNqRDtBQUNBO0FBQ0EsTUFBSSxPQUFPQSxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQzlCQSxVQUFNLEdBQUdpWSxTQUFTLENBQUMsQ0FBRCxDQUFULElBQWdCLEVBQXpCO0FBQ0FqWSxVQUFNLENBQUN3N0MsR0FBUCxHQUFhdmpDLFNBQVMsQ0FBQyxDQUFELENBQXRCO0FBQ0QsR0FIRCxNQUdPO0FBQ0xqWSxVQUFNLEdBQUdBLE1BQU0sSUFBSSxFQUFuQjtBQUNEOztBQUVEQSxRQUFNLEdBQUc4OUMsV0FBVyxDQUFDLEtBQUtyYSxRQUFOLEVBQWdCempDLE1BQWhCLENBQXBCLENBVmlELENBWWpEOztBQUNBLE1BQUlBLE1BQU0sQ0FBQzVKLE1BQVgsRUFBbUI7QUFDakI0SixVQUFNLENBQUM1SixNQUFQLEdBQWdCNEosTUFBTSxDQUFDNUosTUFBUCxDQUFjaVcsV0FBZCxFQUFoQjtBQUNELEdBRkQsTUFFTyxJQUFJLEtBQUtvM0IsUUFBTCxDQUFjcnRDLE1BQWxCLEVBQTBCO0FBQy9CNEosVUFBTSxDQUFDNUosTUFBUCxHQUFnQixLQUFLcXRDLFFBQUwsQ0FBY3J0QyxNQUFkLENBQXFCaVcsV0FBckIsRUFBaEI7QUFDRCxHQUZNLE1BRUE7QUFDTHJNLFVBQU0sQ0FBQzVKLE1BQVAsR0FBZ0IsS0FBaEI7QUFDRCxHQW5CZ0QsQ0FxQmpEOzs7QUFDQSxNQUFJZ3BELEtBQUssR0FBRyxDQUFDRixlQUFELEVBQWtCeHJELFNBQWxCLENBQVo7QUFDQSxNQUFJOHBELE9BQU8sR0FBRzM1QyxPQUFPLENBQUNDLE9BQVIsQ0FBZ0I5RCxNQUFoQixDQUFkO0FBRUEsT0FBS20vQyxZQUFMLENBQWtCdEUsT0FBbEIsQ0FBMEIvbEQsT0FBMUIsQ0FBa0MsU0FBU3VxRCwwQkFBVCxDQUFvQ0MsV0FBcEMsRUFBaUQ7QUFDakZGLFNBQUssQ0FBQ2g5QixPQUFOLENBQWNrOUIsV0FBVyxDQUFDQyxTQUExQixFQUFxQ0QsV0FBVyxDQUFDRSxRQUFqRDtBQUNELEdBRkQ7QUFJQSxPQUFLTCxZQUFMLENBQWtCL0MsUUFBbEIsQ0FBMkJ0bkQsT0FBM0IsQ0FBbUMsU0FBUzJxRCx3QkFBVCxDQUFrQ0gsV0FBbEMsRUFBK0M7QUFDaEZGLFNBQUssQ0FBQ3ZzRCxJQUFOLENBQVd5c0QsV0FBVyxDQUFDQyxTQUF2QixFQUFrQ0QsV0FBVyxDQUFDRSxRQUE5QztBQUNELEdBRkQ7O0FBSUEsU0FBT0osS0FBSyxDQUFDcHNELE1BQWIsRUFBcUI7QUFDbkJ3cUQsV0FBTyxHQUFHQSxPQUFPLENBQUNwNUMsSUFBUixDQUFhZzdDLEtBQUssQ0FBQ3BNLEtBQU4sRUFBYixFQUE0Qm9NLEtBQUssQ0FBQ3BNLEtBQU4sRUFBNUIsQ0FBVjtBQUNEOztBQUVELFNBQU93SyxPQUFQO0FBQ0QsQ0F0Q0Q7O0FBd0NBSyxLQUFLLENBQUN2bkQsU0FBTixDQUFnQm9wRCxNQUFoQixHQUF5QixTQUFTQSxNQUFULENBQWdCMS9DLE1BQWhCLEVBQXdCO0FBQy9DQSxRQUFNLEdBQUc4OUMsV0FBVyxDQUFDLEtBQUtyYSxRQUFOLEVBQWdCempDLE1BQWhCLENBQXBCO0FBQ0EsU0FBT2k2QyxRQUFRLENBQUNqNkMsTUFBTSxDQUFDdzdDLEdBQVIsRUFBYXg3QyxNQUFNLENBQUMySixNQUFwQixFQUE0QjNKLE1BQU0sQ0FBQ3k3QyxnQkFBbkMsQ0FBUixDQUE2RDl0QyxPQUE3RCxDQUFxRSxLQUFyRSxFQUE0RSxFQUE1RSxDQUFQO0FBQ0QsQ0FIRCxDLENBS0E7OztBQUNBa3NDLEtBQUssQ0FBQy9rRCxPQUFOLENBQWMsQ0FBQyxRQUFELEVBQVcsS0FBWCxFQUFrQixNQUFsQixFQUEwQixTQUExQixDQUFkLEVBQW9ELFNBQVM2cUQsbUJBQVQsQ0FBNkJ2cEQsTUFBN0IsRUFBcUM7QUFDdkY7QUFDQXluRCxPQUFLLENBQUN2bkQsU0FBTixDQUFnQkYsTUFBaEIsSUFBMEIsVUFBU29sRCxHQUFULEVBQWN4N0MsTUFBZCxFQUFzQjtBQUM5QyxXQUFPLEtBQUs2NkMsT0FBTCxDQUFhaUQsV0FBVyxDQUFDOTlDLE1BQU0sSUFBSSxFQUFYLEVBQWU7QUFDNUM1SixZQUFNLEVBQUVBLE1BRG9DO0FBRTVDb2xELFNBQUcsRUFBRUEsR0FGdUM7QUFHNUNuc0MsVUFBSSxFQUFFLENBQUNyUCxNQUFNLElBQUksRUFBWCxFQUFlcVA7QUFIdUIsS0FBZixDQUF4QixDQUFQO0FBS0QsR0FORDtBQU9ELENBVEQ7QUFXQXdxQyxLQUFLLENBQUMva0QsT0FBTixDQUFjLENBQUMsTUFBRCxFQUFTLEtBQVQsRUFBZ0IsT0FBaEIsQ0FBZCxFQUF3QyxTQUFTOHFELHFCQUFULENBQStCeHBELE1BQS9CLEVBQXVDO0FBQzdFO0FBQ0F5bkQsT0FBSyxDQUFDdm5ELFNBQU4sQ0FBZ0JGLE1BQWhCLElBQTBCLFVBQVNvbEQsR0FBVCxFQUFjbnNDLElBQWQsRUFBb0JyUCxNQUFwQixFQUE0QjtBQUNwRCxXQUFPLEtBQUs2NkMsT0FBTCxDQUFhaUQsV0FBVyxDQUFDOTlDLE1BQU0sSUFBSSxFQUFYLEVBQWU7QUFDNUM1SixZQUFNLEVBQUVBLE1BRG9DO0FBRTVDb2xELFNBQUcsRUFBRUEsR0FGdUM7QUFHNUNuc0MsVUFBSSxFQUFFQTtBQUhzQyxLQUFmLENBQXhCLENBQVA7QUFLRCxHQU5EO0FBT0QsQ0FURDtBQVdBdXFDLE1BQU0sQ0FBQ1UsT0FBUCxHQUFpQnVELEtBQWpCLEM7Ozs7Ozs7Ozs7O0FDOUZhOztBQUViLElBQUloRSxLQUFLLEdBQUdDLG1CQUFPLENBQUMscURBQUQsQ0FBbkI7O0FBRUEsU0FBU21GLGtCQUFULEdBQThCO0FBQzVCLE9BQUtZLFFBQUwsR0FBZ0IsRUFBaEI7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBWixrQkFBa0IsQ0FBQzNvRCxTQUFuQixDQUE2QjAyQixHQUE3QixHQUFtQyxTQUFTQSxHQUFULENBQWF1eUIsU0FBYixFQUF3QkMsUUFBeEIsRUFBa0M7QUFDbkUsT0FBS0ssUUFBTCxDQUFjaHRELElBQWQsQ0FBbUI7QUFDakIwc0QsYUFBUyxFQUFFQSxTQURNO0FBRWpCQyxZQUFRLEVBQUVBO0FBRk8sR0FBbkI7QUFJQSxTQUFPLEtBQUtLLFFBQUwsQ0FBYzdzRCxNQUFkLEdBQXVCLENBQTlCO0FBQ0QsQ0FORDtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBaXNELGtCQUFrQixDQUFDM29ELFNBQW5CLENBQTZCd3BELEtBQTdCLEdBQXFDLFNBQVNBLEtBQVQsQ0FBZTdzRCxFQUFmLEVBQW1CO0FBQ3RELE1BQUksS0FBSzRzRCxRQUFMLENBQWM1c0QsRUFBZCxDQUFKLEVBQXVCO0FBQ3JCLFNBQUs0c0QsUUFBTCxDQUFjNXNELEVBQWQsSUFBb0IsSUFBcEI7QUFDRDtBQUNGLENBSkQ7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQWdzRCxrQkFBa0IsQ0FBQzNvRCxTQUFuQixDQUE2QnhCLE9BQTdCLEdBQXVDLFNBQVNBLE9BQVQsQ0FBaUJqRCxFQUFqQixFQUFxQjtBQUMxRGdvRCxPQUFLLENBQUMva0QsT0FBTixDQUFjLEtBQUsrcUQsUUFBbkIsRUFBNkIsU0FBU0UsY0FBVCxDQUF3QnA2QixDQUF4QixFQUEyQjtBQUN0RCxRQUFJQSxDQUFDLEtBQUssSUFBVixFQUFnQjtBQUNkOXpCLFFBQUUsQ0FBQzh6QixDQUFELENBQUY7QUFDRDtBQUNGLEdBSkQ7QUFLRCxDQU5EOztBQVFBaTBCLE1BQU0sQ0FBQ1UsT0FBUCxHQUFpQjJFLGtCQUFqQixDOzs7Ozs7Ozs7OztBQ25EYTs7QUFFYixJQUFJZSxhQUFhLEdBQUdsRyxtQkFBTyxDQUFDLG1GQUFELENBQTNCOztBQUNBLElBQUltRyxXQUFXLEdBQUduRyxtQkFBTyxDQUFDLCtFQUFELENBQXpCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQUYsTUFBTSxDQUFDVSxPQUFQLEdBQWlCLFNBQVNKLGFBQVQsQ0FBdUJxQixPQUF2QixFQUFnQzJFLFlBQWhDLEVBQThDO0FBQzdELE1BQUkzRSxPQUFPLElBQUksQ0FBQ3lFLGFBQWEsQ0FBQ0UsWUFBRCxDQUE3QixFQUE2QztBQUMzQyxXQUFPRCxXQUFXLENBQUMxRSxPQUFELEVBQVUyRSxZQUFWLENBQWxCO0FBQ0Q7O0FBQ0QsU0FBT0EsWUFBUDtBQUNELENBTEQsQzs7Ozs7Ozs7Ozs7QUNkYTs7QUFFYixJQUFJQyxZQUFZLEdBQUdyRyxtQkFBTyxDQUFDLHFFQUFELENBQTFCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBRixNQUFNLENBQUNVLE9BQVAsR0FBaUIsU0FBU0QsV0FBVCxDQUFxQnh3QyxPQUFyQixFQUE4QjdKLE1BQTlCLEVBQXNDb2dELElBQXRDLEVBQTRDdkYsT0FBNUMsRUFBcUR1QixRQUFyRCxFQUErRDtBQUM5RSxNQUFJbjVDLEtBQUssR0FBRyxJQUFJd1MsS0FBSixDQUFVNUwsT0FBVixDQUFaO0FBQ0EsU0FBT3MyQyxZQUFZLENBQUNsOUMsS0FBRCxFQUFRakQsTUFBUixFQUFnQm9nRCxJQUFoQixFQUFzQnZGLE9BQXRCLEVBQStCdUIsUUFBL0IsQ0FBbkI7QUFDRCxDQUhELEM7Ozs7Ozs7Ozs7O0FDZGE7O0FBRWIsSUFBSXZDLEtBQUssR0FBR0MsbUJBQU8sQ0FBQyxxREFBRCxDQUFuQjs7QUFDQSxJQUFJdUcsYUFBYSxHQUFHdkcsbUJBQU8sQ0FBQyx1RUFBRCxDQUEzQjs7QUFDQSxJQUFJc0UsUUFBUSxHQUFHdEUsbUJBQU8sQ0FBQyx1RUFBRCxDQUF0Qjs7QUFDQSxJQUFJclcsUUFBUSxHQUFHcVcsbUJBQU8sQ0FBQyx5REFBRCxDQUF0QjtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU3dHLDRCQUFULENBQXNDdGdELE1BQXRDLEVBQThDO0FBQzVDLE1BQUlBLE1BQU0sQ0FBQ3U5QyxXQUFYLEVBQXdCO0FBQ3RCdjlDLFVBQU0sQ0FBQ3U5QyxXQUFQLENBQW1CeUIsZ0JBQW5CO0FBQ0Q7QUFDRjtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0FwRixNQUFNLENBQUNVLE9BQVAsR0FBaUIsU0FBUzRFLGVBQVQsQ0FBeUJsL0MsTUFBekIsRUFBaUM7QUFDaERzZ0QsOEJBQTRCLENBQUN0Z0QsTUFBRCxDQUE1QixDQURnRCxDQUdoRDs7QUFDQUEsUUFBTSxDQUFDMjZDLE9BQVAsR0FBaUIzNkMsTUFBTSxDQUFDMjZDLE9BQVAsSUFBa0IsRUFBbkMsQ0FKZ0QsQ0FNaEQ7O0FBQ0EzNkMsUUFBTSxDQUFDcVAsSUFBUCxHQUFjZ3hDLGFBQWEsQ0FDekJyZ0QsTUFBTSxDQUFDcVAsSUFEa0IsRUFFekJyUCxNQUFNLENBQUMyNkMsT0FGa0IsRUFHekIzNkMsTUFBTSxDQUFDdWdELGdCQUhrQixDQUEzQixDQVBnRCxDQWFoRDs7QUFDQXZnRCxRQUFNLENBQUMyNkMsT0FBUCxHQUFpQmQsS0FBSyxDQUFDMkcsS0FBTixDQUNmeGdELE1BQU0sQ0FBQzI2QyxPQUFQLENBQWU4RixNQUFmLElBQXlCLEVBRFYsRUFFZnpnRCxNQUFNLENBQUMyNkMsT0FBUCxDQUFlMzZDLE1BQU0sQ0FBQzVKLE1BQXRCLEtBQWlDLEVBRmxCLEVBR2Y0SixNQUFNLENBQUMyNkMsT0FIUSxDQUFqQjtBQU1BZCxPQUFLLENBQUMva0QsT0FBTixDQUNFLENBQUMsUUFBRCxFQUFXLEtBQVgsRUFBa0IsTUFBbEIsRUFBMEIsTUFBMUIsRUFBa0MsS0FBbEMsRUFBeUMsT0FBekMsRUFBa0QsUUFBbEQsQ0FERixFQUVFLFNBQVM0ckQsaUJBQVQsQ0FBMkJ0cUQsTUFBM0IsRUFBbUM7QUFDakMsV0FBTzRKLE1BQU0sQ0FBQzI2QyxPQUFQLENBQWV2a0QsTUFBZixDQUFQO0FBQ0QsR0FKSDtBQU9BLE1BQUl1cUQsT0FBTyxHQUFHM2dELE1BQU0sQ0FBQzJnRCxPQUFQLElBQWtCbGQsUUFBUSxDQUFDa2QsT0FBekM7QUFFQSxTQUFPQSxPQUFPLENBQUMzZ0QsTUFBRCxDQUFQLENBQWdCb0UsSUFBaEIsQ0FBcUIsU0FBU3c4QyxtQkFBVCxDQUE2QnhFLFFBQTdCLEVBQXVDO0FBQ2pFa0UsZ0NBQTRCLENBQUN0Z0QsTUFBRCxDQUE1QixDQURpRSxDQUdqRTs7QUFDQW84QyxZQUFRLENBQUMvc0MsSUFBVCxHQUFnQmd4QyxhQUFhLENBQzNCakUsUUFBUSxDQUFDL3NDLElBRGtCLEVBRTNCK3NDLFFBQVEsQ0FBQ3pCLE9BRmtCLEVBRzNCMzZDLE1BQU0sQ0FBQzZnRCxpQkFIb0IsQ0FBN0I7QUFNQSxXQUFPekUsUUFBUDtBQUNELEdBWE0sRUFXSixTQUFTMEUsa0JBQVQsQ0FBNEIvQixNQUE1QixFQUFvQztBQUNyQyxRQUFJLENBQUNYLFFBQVEsQ0FBQ1csTUFBRCxDQUFiLEVBQXVCO0FBQ3JCdUIsa0NBQTRCLENBQUN0Z0QsTUFBRCxDQUE1QixDQURxQixDQUdyQjs7QUFDQSxVQUFJKytDLE1BQU0sSUFBSUEsTUFBTSxDQUFDM0MsUUFBckIsRUFBK0I7QUFDN0IyQyxjQUFNLENBQUMzQyxRQUFQLENBQWdCL3NDLElBQWhCLEdBQXVCZ3hDLGFBQWEsQ0FDbEN0QixNQUFNLENBQUMzQyxRQUFQLENBQWdCL3NDLElBRGtCLEVBRWxDMHZDLE1BQU0sQ0FBQzNDLFFBQVAsQ0FBZ0J6QixPQUZrQixFQUdsQzM2QyxNQUFNLENBQUM2Z0QsaUJBSDJCLENBQXBDO0FBS0Q7QUFDRjs7QUFFRCxXQUFPaDlDLE9BQU8sQ0FBQzhhLE1BQVIsQ0FBZW9nQyxNQUFmLENBQVA7QUFDRCxHQTFCTSxDQUFQO0FBMkJELENBeERELEM7Ozs7Ozs7Ozs7O0FDdEJhO0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0FuRixNQUFNLENBQUNVLE9BQVAsR0FBaUIsU0FBUzZGLFlBQVQsQ0FBc0JsOUMsS0FBdEIsRUFBNkJqRCxNQUE3QixFQUFxQ29nRCxJQUFyQyxFQUEyQ3ZGLE9BQTNDLEVBQW9EdUIsUUFBcEQsRUFBOEQ7QUFDN0VuNUMsT0FBSyxDQUFDakQsTUFBTixHQUFlQSxNQUFmOztBQUNBLE1BQUlvZ0QsSUFBSixFQUFVO0FBQ1JuOUMsU0FBSyxDQUFDbTlDLElBQU4sR0FBYUEsSUFBYjtBQUNEOztBQUVEbjlDLE9BQUssQ0FBQzQzQyxPQUFOLEdBQWdCQSxPQUFoQjtBQUNBNTNDLE9BQUssQ0FBQ201QyxRQUFOLEdBQWlCQSxRQUFqQjtBQUNBbjVDLE9BQUssQ0FBQ3U3QyxZQUFOLEdBQXFCLElBQXJCOztBQUVBdjdDLE9BQUssQ0FBQzg5QyxNQUFOLEdBQWUsU0FBU0EsTUFBVCxHQUFrQjtBQUMvQixXQUFPO0FBQ0w7QUFDQWwzQyxhQUFPLEVBQUUsS0FBS0EsT0FGVDtBQUdML0gsVUFBSSxFQUFFLEtBQUtBLElBSE47QUFJTDtBQUNBay9DLGlCQUFXLEVBQUUsS0FBS0EsV0FMYjtBQU1MLzBDLFlBQU0sRUFBRSxLQUFLQSxNQU5SO0FBT0w7QUFDQWcxQyxjQUFRLEVBQUUsS0FBS0EsUUFSVjtBQVNMQyxnQkFBVSxFQUFFLEtBQUtBLFVBVFo7QUFVTEMsa0JBQVksRUFBRSxLQUFLQSxZQVZkO0FBV0w1aEQsV0FBSyxFQUFFLEtBQUtBLEtBWFA7QUFZTDtBQUNBUyxZQUFNLEVBQUUsS0FBS0EsTUFiUjtBQWNMb2dELFVBQUksRUFBRSxLQUFLQTtBQWROLEtBQVA7QUFnQkQsR0FqQkQ7O0FBa0JBLFNBQU9uOUMsS0FBUDtBQUNELENBN0JELEM7Ozs7Ozs7Ozs7O0FDWmE7O0FBRWIsSUFBSTQyQyxLQUFLLEdBQUdDLG1CQUFPLENBQUMsbURBQUQsQ0FBbkI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQUYsTUFBTSxDQUFDVSxPQUFQLEdBQWlCLFNBQVN3RCxXQUFULENBQXFCc0QsT0FBckIsRUFBOEJDLE9BQTlCLEVBQXVDO0FBQ3REO0FBQ0FBLFNBQU8sR0FBR0EsT0FBTyxJQUFJLEVBQXJCO0FBQ0EsTUFBSXJoRCxNQUFNLEdBQUcsRUFBYjtBQUVBLE1BQUlzaEQsb0JBQW9CLEdBQUcsQ0FBQyxLQUFELEVBQVEsUUFBUixFQUFrQixNQUFsQixDQUEzQjtBQUNBLE1BQUlDLHVCQUF1QixHQUFHLENBQUMsU0FBRCxFQUFZLE1BQVosRUFBb0IsT0FBcEIsRUFBNkIsUUFBN0IsQ0FBOUI7QUFDQSxNQUFJQyxvQkFBb0IsR0FBRyxDQUN6QixTQUR5QixFQUNkLGtCQURjLEVBQ00sbUJBRE4sRUFDMkIsa0JBRDNCLEVBRXpCLFNBRnlCLEVBRWQsZ0JBRmMsRUFFSSxpQkFGSixFQUV1QixTQUZ2QixFQUVrQyxjQUZsQyxFQUVrRCxnQkFGbEQsRUFHekIsZ0JBSHlCLEVBR1Asa0JBSE8sRUFHYSxvQkFIYixFQUdtQyxZQUhuQyxFQUl6QixrQkFKeUIsRUFJTCxlQUpLLEVBSVksY0FKWixFQUk0QixXQUo1QixFQUl5QyxXQUp6QyxFQUt6QixZQUx5QixFQUtYLGFBTFcsRUFLSSxZQUxKLEVBS2tCLGtCQUxsQixDQUEzQjtBQU9BLE1BQUlDLGVBQWUsR0FBRyxDQUFDLGdCQUFELENBQXRCOztBQUVBLFdBQVNDLGNBQVQsQ0FBd0I5dEQsTUFBeEIsRUFBZ0Mwa0IsTUFBaEMsRUFBd0M7QUFDdEMsUUFBSXVoQyxLQUFLLENBQUNqZ0MsYUFBTixDQUFvQmhtQixNQUFwQixLQUErQmltRCxLQUFLLENBQUNqZ0MsYUFBTixDQUFvQnRCLE1BQXBCLENBQW5DLEVBQWdFO0FBQzlELGFBQU91aEMsS0FBSyxDQUFDMkcsS0FBTixDQUFZNXNELE1BQVosRUFBb0Iwa0IsTUFBcEIsQ0FBUDtBQUNELEtBRkQsTUFFTyxJQUFJdWhDLEtBQUssQ0FBQ2pnQyxhQUFOLENBQW9CdEIsTUFBcEIsQ0FBSixFQUFpQztBQUN0QyxhQUFPdWhDLEtBQUssQ0FBQzJHLEtBQU4sQ0FBWSxFQUFaLEVBQWdCbG9DLE1BQWhCLENBQVA7QUFDRCxLQUZNLE1BRUEsSUFBSXVoQyxLQUFLLENBQUM5a0QsT0FBTixDQUFjdWpCLE1BQWQsQ0FBSixFQUEyQjtBQUNoQyxhQUFPQSxNQUFNLENBQUM5VyxLQUFQLEVBQVA7QUFDRDs7QUFDRCxXQUFPOFcsTUFBUDtBQUNEOztBQUVELFdBQVNxcEMsbUJBQVQsQ0FBNkJqNUIsSUFBN0IsRUFBbUM7QUFDakMsUUFBSSxDQUFDbXhCLEtBQUssQ0FBQ3NELFdBQU4sQ0FBa0JrRSxPQUFPLENBQUMzNEIsSUFBRCxDQUF6QixDQUFMLEVBQXVDO0FBQ3JDMW9CLFlBQU0sQ0FBQzBvQixJQUFELENBQU4sR0FBZWc1QixjQUFjLENBQUNOLE9BQU8sQ0FBQzE0QixJQUFELENBQVIsRUFBZ0IyNEIsT0FBTyxDQUFDMzRCLElBQUQsQ0FBdkIsQ0FBN0I7QUFDRCxLQUZELE1BRU8sSUFBSSxDQUFDbXhCLEtBQUssQ0FBQ3NELFdBQU4sQ0FBa0JpRSxPQUFPLENBQUMxNEIsSUFBRCxDQUF6QixDQUFMLEVBQXVDO0FBQzVDMW9CLFlBQU0sQ0FBQzBvQixJQUFELENBQU4sR0FBZWc1QixjQUFjLENBQUNodUQsU0FBRCxFQUFZMHRELE9BQU8sQ0FBQzE0QixJQUFELENBQW5CLENBQTdCO0FBQ0Q7QUFDRjs7QUFFRG14QixPQUFLLENBQUMva0QsT0FBTixDQUFjd3NELG9CQUFkLEVBQW9DLFNBQVNNLGdCQUFULENBQTBCbDVCLElBQTFCLEVBQWdDO0FBQ2xFLFFBQUksQ0FBQ214QixLQUFLLENBQUNzRCxXQUFOLENBQWtCa0UsT0FBTyxDQUFDMzRCLElBQUQsQ0FBekIsQ0FBTCxFQUF1QztBQUNyQzFvQixZQUFNLENBQUMwb0IsSUFBRCxDQUFOLEdBQWVnNUIsY0FBYyxDQUFDaHVELFNBQUQsRUFBWTJ0RCxPQUFPLENBQUMzNEIsSUFBRCxDQUFuQixDQUE3QjtBQUNEO0FBQ0YsR0FKRDtBQU1BbXhCLE9BQUssQ0FBQy9rRCxPQUFOLENBQWN5c0QsdUJBQWQsRUFBdUNJLG1CQUF2QztBQUVBOUgsT0FBSyxDQUFDL2tELE9BQU4sQ0FBYzBzRCxvQkFBZCxFQUFvQyxTQUFTSyxnQkFBVCxDQUEwQm41QixJQUExQixFQUFnQztBQUNsRSxRQUFJLENBQUNteEIsS0FBSyxDQUFDc0QsV0FBTixDQUFrQmtFLE9BQU8sQ0FBQzM0QixJQUFELENBQXpCLENBQUwsRUFBdUM7QUFDckMxb0IsWUFBTSxDQUFDMG9CLElBQUQsQ0FBTixHQUFlZzVCLGNBQWMsQ0FBQ2h1RCxTQUFELEVBQVkydEQsT0FBTyxDQUFDMzRCLElBQUQsQ0FBbkIsQ0FBN0I7QUFDRCxLQUZELE1BRU8sSUFBSSxDQUFDbXhCLEtBQUssQ0FBQ3NELFdBQU4sQ0FBa0JpRSxPQUFPLENBQUMxNEIsSUFBRCxDQUF6QixDQUFMLEVBQXVDO0FBQzVDMW9CLFlBQU0sQ0FBQzBvQixJQUFELENBQU4sR0FBZWc1QixjQUFjLENBQUNodUQsU0FBRCxFQUFZMHRELE9BQU8sQ0FBQzE0QixJQUFELENBQW5CLENBQTdCO0FBQ0Q7QUFDRixHQU5EO0FBUUFteEIsT0FBSyxDQUFDL2tELE9BQU4sQ0FBYzJzRCxlQUFkLEVBQStCLFNBQVNqQixLQUFULENBQWU5M0IsSUFBZixFQUFxQjtBQUNsRCxRQUFJQSxJQUFJLElBQUkyNEIsT0FBWixFQUFxQjtBQUNuQnJoRCxZQUFNLENBQUMwb0IsSUFBRCxDQUFOLEdBQWVnNUIsY0FBYyxDQUFDTixPQUFPLENBQUMxNEIsSUFBRCxDQUFSLEVBQWdCMjRCLE9BQU8sQ0FBQzM0QixJQUFELENBQXZCLENBQTdCO0FBQ0QsS0FGRCxNQUVPLElBQUlBLElBQUksSUFBSTA0QixPQUFaLEVBQXFCO0FBQzFCcGhELFlBQU0sQ0FBQzBvQixJQUFELENBQU4sR0FBZWc1QixjQUFjLENBQUNodUQsU0FBRCxFQUFZMHRELE9BQU8sQ0FBQzE0QixJQUFELENBQW5CLENBQTdCO0FBQ0Q7QUFDRixHQU5EO0FBUUEsTUFBSW81QixTQUFTLEdBQUdSLG9CQUFvQixDQUNqQzd3QyxNQURhLENBQ044d0MsdUJBRE0sRUFFYjl3QyxNQUZhLENBRU4rd0Msb0JBRk0sRUFHYi93QyxNQUhhLENBR05neEMsZUFITSxDQUFoQjtBQUtBLE1BQUlNLFNBQVMsR0FBR3ZzRCxNQUFNLENBQ25CK0wsSUFEYSxDQUNSNi9DLE9BRFEsRUFFYjN3QyxNQUZhLENBRU5qYixNQUFNLENBQUMrTCxJQUFQLENBQVk4L0MsT0FBWixDQUZNLEVBR2IxckQsTUFIYSxDQUdOLFNBQVNxc0QsZUFBVCxDQUF5Qmx1RCxHQUF6QixFQUE4QjtBQUNwQyxXQUFPZ3VELFNBQVMsQ0FBQzE4QyxPQUFWLENBQWtCdFIsR0FBbEIsTUFBMkIsQ0FBQyxDQUFuQztBQUNELEdBTGEsQ0FBaEI7QUFPQStsRCxPQUFLLENBQUMva0QsT0FBTixDQUFjaXRELFNBQWQsRUFBeUJKLG1CQUF6QjtBQUVBLFNBQU8zaEQsTUFBUDtBQUNELENBMUVELEM7Ozs7Ozs7Ozs7O0FDWmE7O0FBRWIsSUFBSXE2QyxXQUFXLEdBQUdQLG1CQUFPLENBQUMsbUVBQUQsQ0FBekI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0FGLE1BQU0sQ0FBQ1UsT0FBUCxHQUFpQixTQUFTUCxNQUFULENBQWdCajJDLE9BQWhCLEVBQXlCNmEsTUFBekIsRUFBaUN5OUIsUUFBakMsRUFBMkM7QUFDMUQsTUFBSTZGLGNBQWMsR0FBRzdGLFFBQVEsQ0FBQ3A4QyxNQUFULENBQWdCaWlELGNBQXJDOztBQUNBLE1BQUksQ0FBQzdGLFFBQVEsQ0FBQ1AsTUFBVixJQUFvQixDQUFDb0csY0FBckIsSUFBdUNBLGNBQWMsQ0FBQzdGLFFBQVEsQ0FBQ1AsTUFBVixDQUF6RCxFQUE0RTtBQUMxRS8zQyxXQUFPLENBQUNzNEMsUUFBRCxDQUFQO0FBQ0QsR0FGRCxNQUVPO0FBQ0x6OUIsVUFBTSxDQUFDMDdCLFdBQVcsQ0FDaEIscUNBQXFDK0IsUUFBUSxDQUFDUCxNQUQ5QixFQUVoQk8sUUFBUSxDQUFDcDhDLE1BRk8sRUFHaEIsSUFIZ0IsRUFJaEJvOEMsUUFBUSxDQUFDdkIsT0FKTyxFQUtoQnVCLFFBTGdCLENBQVosQ0FBTjtBQU9EO0FBQ0YsQ0FiRCxDOzs7Ozs7Ozs7OztBQ1hhOztBQUViLElBQUl2QyxLQUFLLEdBQUdDLG1CQUFPLENBQUMscURBQUQsQ0FBbkI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQUYsTUFBTSxDQUFDVSxPQUFQLEdBQWlCLFNBQVMrRixhQUFULENBQXVCaHhDLElBQXZCLEVBQTZCc3JDLE9BQTdCLEVBQXNDbkIsR0FBdEMsRUFBMkM7QUFDMUQ7QUFDQUssT0FBSyxDQUFDL2tELE9BQU4sQ0FBYzBrRCxHQUFkLEVBQW1CLFNBQVNySyxTQUFULENBQW1CdDlDLEVBQW5CLEVBQXVCO0FBQ3hDd2QsUUFBSSxHQUFHeGQsRUFBRSxDQUFDd2QsSUFBRCxFQUFPc3JDLE9BQVAsQ0FBVDtBQUNELEdBRkQ7QUFJQSxTQUFPdHJDLElBQVA7QUFDRCxDQVBELEM7Ozs7Ozs7Ozs7O0FDWmE7O0FBRWIsSUFBSXdxQyxLQUFLLEdBQUdDLG1CQUFPLENBQUMsa0RBQUQsQ0FBbkI7O0FBQ0EsSUFBSW9JLG1CQUFtQixHQUFHcEksbUJBQU8sQ0FBQyw4RkFBRCxDQUFqQzs7QUFFQSxJQUFJcUksb0JBQW9CLEdBQUc7QUFDekIsa0JBQWdCO0FBRFMsQ0FBM0I7O0FBSUEsU0FBU0MscUJBQVQsQ0FBK0J6SCxPQUEvQixFQUF3Q2xqRCxLQUF4QyxFQUErQztBQUM3QyxNQUFJLENBQUNvaUQsS0FBSyxDQUFDc0QsV0FBTixDQUFrQnhDLE9BQWxCLENBQUQsSUFBK0JkLEtBQUssQ0FBQ3NELFdBQU4sQ0FBa0J4QyxPQUFPLENBQUMsY0FBRCxDQUF6QixDQUFuQyxFQUErRTtBQUM3RUEsV0FBTyxDQUFDLGNBQUQsQ0FBUCxHQUEwQmxqRCxLQUExQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBUzRxRCxpQkFBVCxHQUE2QjtBQUMzQixNQUFJMUIsT0FBSjs7QUFDQSxNQUFJLE9BQU83RixjQUFQLEtBQTBCLFdBQTlCLEVBQTJDO0FBQ3pDO0FBQ0E2RixXQUFPLEdBQUc3RyxtQkFBTyxDQUFDLGdFQUFELENBQWpCO0FBQ0QsR0FIRCxNQUdPLElBQUksT0FBT3BvRCxPQUFQLEtBQW1CLFdBQW5CLElBQWtDOEQsTUFBTSxDQUFDYyxTQUFQLENBQWlCMnlCLFFBQWpCLENBQTBCenZCLElBQTFCLENBQStCOUgsT0FBL0IsTUFBNEMsa0JBQWxGLEVBQXNHO0FBQzNHO0FBQ0FpdkQsV0FBTyxHQUFHN0csbUJBQU8sQ0FBQyxpRUFBRCxDQUFqQjtBQUNEOztBQUNELFNBQU82RyxPQUFQO0FBQ0Q7O0FBRUQsSUFBSWxkLFFBQVEsR0FBRztBQUNia2QsU0FBTyxFQUFFMEIsaUJBQWlCLEVBRGI7QUFHYjlCLGtCQUFnQixFQUFFLENBQUMsU0FBU0EsZ0JBQVQsQ0FBMEJseEMsSUFBMUIsRUFBZ0NzckMsT0FBaEMsRUFBeUM7QUFDMUR1SCx1QkFBbUIsQ0FBQ3ZILE9BQUQsRUFBVSxRQUFWLENBQW5CO0FBQ0F1SCx1QkFBbUIsQ0FBQ3ZILE9BQUQsRUFBVSxjQUFWLENBQW5COztBQUNBLFFBQUlkLEtBQUssQ0FBQ2UsVUFBTixDQUFpQnZyQyxJQUFqQixLQUNGd3FDLEtBQUssQ0FBQ3lJLGFBQU4sQ0FBb0JqekMsSUFBcEIsQ0FERSxJQUVGd3FDLEtBQUssQ0FBQzBJLFFBQU4sQ0FBZWx6QyxJQUFmLENBRkUsSUFHRndxQyxLQUFLLENBQUMySSxRQUFOLENBQWVuekMsSUFBZixDQUhFLElBSUZ3cUMsS0FBSyxDQUFDNEksTUFBTixDQUFhcHpDLElBQWIsQ0FKRSxJQUtGd3FDLEtBQUssQ0FBQzZJLE1BQU4sQ0FBYXJ6QyxJQUFiLENBTEYsRUFNRTtBQUNBLGFBQU9BLElBQVA7QUFDRDs7QUFDRCxRQUFJd3FDLEtBQUssQ0FBQzhJLGlCQUFOLENBQXdCdHpDLElBQXhCLENBQUosRUFBbUM7QUFDakMsYUFBT0EsSUFBSSxDQUFDdXpDLE1BQVo7QUFDRDs7QUFDRCxRQUFJL0ksS0FBSyxDQUFDZ0osaUJBQU4sQ0FBd0J4ekMsSUFBeEIsQ0FBSixFQUFtQztBQUNqQyt5QywyQkFBcUIsQ0FBQ3pILE9BQUQsRUFBVSxpREFBVixDQUFyQjtBQUNBLGFBQU90ckMsSUFBSSxDQUFDNFosUUFBTCxFQUFQO0FBQ0Q7O0FBQ0QsUUFBSTR3QixLQUFLLENBQUNuaUQsUUFBTixDQUFlMlgsSUFBZixDQUFKLEVBQTBCO0FBQ3hCK3lDLDJCQUFxQixDQUFDekgsT0FBRCxFQUFVLGdDQUFWLENBQXJCO0FBQ0EsYUFBT2g1QyxJQUFJLENBQUNDLFNBQUwsQ0FBZXlOLElBQWYsQ0FBUDtBQUNEOztBQUNELFdBQU9BLElBQVA7QUFDRCxHQXhCaUIsQ0FITDtBQTZCYnd4QyxtQkFBaUIsRUFBRSxDQUFDLFNBQVNBLGlCQUFULENBQTJCeHhDLElBQTNCLEVBQWlDO0FBQ25EO0FBQ0EsUUFBSSxPQUFPQSxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzVCLFVBQUk7QUFDRkEsWUFBSSxHQUFHMU4sSUFBSSxDQUFDbWhELEtBQUwsQ0FBV3p6QyxJQUFYLENBQVA7QUFDRCxPQUZELENBRUUsT0FBT2xILENBQVAsRUFBVTtBQUFFO0FBQWM7QUFDN0I7O0FBQ0QsV0FBT2tILElBQVA7QUFDRCxHQVJrQixDQTdCTjs7QUF1Q2I7QUFDRjtBQUNBO0FBQ0E7QUFDRXlGLFNBQU8sRUFBRSxDQTNDSTtBQTZDYmlvQyxnQkFBYyxFQUFFLFlBN0NIO0FBOENiRSxnQkFBYyxFQUFFLGNBOUNIO0FBZ0RiOEYsa0JBQWdCLEVBQUUsQ0FBQyxDQWhETjtBQWlEYkMsZUFBYSxFQUFFLENBQUMsQ0FqREg7QUFtRGJmLGdCQUFjLEVBQUUsU0FBU0EsY0FBVCxDQUF3QnBHLE1BQXhCLEVBQWdDO0FBQzlDLFdBQU9BLE1BQU0sSUFBSSxHQUFWLElBQWlCQSxNQUFNLEdBQUcsR0FBakM7QUFDRDtBQXJEWSxDQUFmO0FBd0RBcFksUUFBUSxDQUFDa1gsT0FBVCxHQUFtQjtBQUNqQjhGLFFBQU0sRUFBRTtBQUNOLGNBQVU7QUFESjtBQURTLENBQW5CO0FBTUE1RyxLQUFLLENBQUMva0QsT0FBTixDQUFjLENBQUMsUUFBRCxFQUFXLEtBQVgsRUFBa0IsTUFBbEIsQ0FBZCxFQUF5QyxTQUFTNnFELG1CQUFULENBQTZCdnBELE1BQTdCLEVBQXFDO0FBQzVFcXRDLFVBQVEsQ0FBQ2tYLE9BQVQsQ0FBaUJ2a0QsTUFBakIsSUFBMkIsRUFBM0I7QUFDRCxDQUZEO0FBSUF5akQsS0FBSyxDQUFDL2tELE9BQU4sQ0FBYyxDQUFDLE1BQUQsRUFBUyxLQUFULEVBQWdCLE9BQWhCLENBQWQsRUFBd0MsU0FBUzhxRCxxQkFBVCxDQUErQnhwRCxNQUEvQixFQUF1QztBQUM3RXF0QyxVQUFRLENBQUNrWCxPQUFULENBQWlCdmtELE1BQWpCLElBQTJCeWpELEtBQUssQ0FBQzJHLEtBQU4sQ0FBWTJCLG9CQUFaLENBQTNCO0FBQ0QsQ0FGRDtBQUlBdkksTUFBTSxDQUFDVSxPQUFQLEdBQWlCN1csUUFBakIsQzs7Ozs7Ozs7Ozs7QUNqR2E7O0FBRWJtVyxNQUFNLENBQUNVLE9BQVAsR0FBaUIsU0FBU2oyQyxJQUFULENBQWN4UyxFQUFkLEVBQWtCc0ksT0FBbEIsRUFBMkI7QUFDMUMsU0FBTyxTQUFTWixJQUFULEdBQWdCO0FBQ3JCLFFBQUloRCxJQUFJLEdBQUcsSUFBSUYsS0FBSixDQUFVNGhCLFNBQVMsQ0FBQ2psQixNQUFwQixDQUFYOztBQUNBLFNBQUssSUFBSUksQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR21ELElBQUksQ0FBQ3ZELE1BQXpCLEVBQWlDSSxDQUFDLEVBQWxDLEVBQXNDO0FBQ3BDbUQsVUFBSSxDQUFDbkQsQ0FBRCxDQUFKLEdBQVU2a0IsU0FBUyxDQUFDN2tCLENBQUQsQ0FBbkI7QUFDRDs7QUFDRCxXQUFPdkIsRUFBRSxDQUFDK0UsS0FBSCxDQUFTdUQsT0FBVCxFQUFrQjVELElBQWxCLENBQVA7QUFDRCxHQU5EO0FBT0QsQ0FSRCxDOzs7Ozs7Ozs7OztBQ0ZhOztBQUViLElBQUlzakQsS0FBSyxHQUFHQyxtQkFBTyxDQUFDLHFEQUFELENBQW5COztBQUVBLFNBQVNtSixNQUFULENBQWdCbm1ELEdBQWhCLEVBQXFCO0FBQ25CLFNBQU9xK0Msa0JBQWtCLENBQUNyK0MsR0FBRCxDQUFsQixDQUNMNlEsT0FESyxDQUNHLE9BREgsRUFDWSxHQURaLEVBRUxBLE9BRkssQ0FFRyxNQUZILEVBRVcsR0FGWCxFQUdMQSxPQUhLLENBR0csT0FISCxFQUdZLEdBSFosRUFJTEEsT0FKSyxDQUlHLE1BSkgsRUFJVyxHQUpYLEVBS0xBLE9BTEssQ0FLRyxPQUxILEVBS1ksR0FMWixFQU1MQSxPQU5LLENBTUcsT0FOSCxFQU1ZLEdBTlosQ0FBUDtBQU9EO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBaXNDLE1BQU0sQ0FBQ1UsT0FBUCxHQUFpQixTQUFTTCxRQUFULENBQWtCdUIsR0FBbEIsRUFBdUI3eEMsTUFBdkIsRUFBK0I4eEMsZ0JBQS9CLEVBQWlEO0FBQ2hFO0FBQ0EsTUFBSSxDQUFDOXhDLE1BQUwsRUFBYTtBQUNYLFdBQU82eEMsR0FBUDtBQUNEOztBQUVELE1BQUkwSCxnQkFBSjs7QUFDQSxNQUFJekgsZ0JBQUosRUFBc0I7QUFDcEJ5SCxvQkFBZ0IsR0FBR3pILGdCQUFnQixDQUFDOXhDLE1BQUQsQ0FBbkM7QUFDRCxHQUZELE1BRU8sSUFBSWt3QyxLQUFLLENBQUNnSixpQkFBTixDQUF3Qmw1QyxNQUF4QixDQUFKLEVBQXFDO0FBQzFDdTVDLG9CQUFnQixHQUFHdjVDLE1BQU0sQ0FBQ3NmLFFBQVAsRUFBbkI7QUFDRCxHQUZNLE1BRUE7QUFDTCxRQUFJazZCLEtBQUssR0FBRyxFQUFaO0FBRUF0SixTQUFLLENBQUMva0QsT0FBTixDQUFjNlUsTUFBZCxFQUFzQixTQUFTeTVDLFNBQVQsQ0FBbUJ0bUQsR0FBbkIsRUFBd0JoSixHQUF4QixFQUE2QjtBQUNqRCxVQUFJZ0osR0FBRyxLQUFLLElBQVIsSUFBZ0IsT0FBT0EsR0FBUCxLQUFlLFdBQW5DLEVBQWdEO0FBQzlDO0FBQ0Q7O0FBRUQsVUFBSSs4QyxLQUFLLENBQUM5a0QsT0FBTixDQUFjK0gsR0FBZCxDQUFKLEVBQXdCO0FBQ3RCaEosV0FBRyxHQUFHQSxHQUFHLEdBQUcsSUFBWjtBQUNELE9BRkQsTUFFTztBQUNMZ0osV0FBRyxHQUFHLENBQUNBLEdBQUQsQ0FBTjtBQUNEOztBQUVEKzhDLFdBQUssQ0FBQy9rRCxPQUFOLENBQWNnSSxHQUFkLEVBQW1CLFNBQVN1bUQsVUFBVCxDQUFvQnBxRCxDQUFwQixFQUF1QjtBQUN4QyxZQUFJNGdELEtBQUssQ0FBQ3pCLE1BQU4sQ0FBYW4vQyxDQUFiLENBQUosRUFBcUI7QUFDbkJBLFdBQUMsR0FBR0EsQ0FBQyxDQUFDcXFELFdBQUYsRUFBSjtBQUNELFNBRkQsTUFFTyxJQUFJekosS0FBSyxDQUFDbmlELFFBQU4sQ0FBZXVCLENBQWYsQ0FBSixFQUF1QjtBQUM1QkEsV0FBQyxHQUFHMEksSUFBSSxDQUFDQyxTQUFMLENBQWUzSSxDQUFmLENBQUo7QUFDRDs7QUFDRGtxRCxhQUFLLENBQUN0d0QsSUFBTixDQUFXb3dELE1BQU0sQ0FBQ252RCxHQUFELENBQU4sR0FBYyxHQUFkLEdBQW9CbXZELE1BQU0sQ0FBQ2hxRCxDQUFELENBQXJDO0FBQ0QsT0FQRDtBQVFELEtBbkJEO0FBcUJBaXFELG9CQUFnQixHQUFHQyxLQUFLLENBQUM5aUQsSUFBTixDQUFXLEdBQVgsQ0FBbkI7QUFDRDs7QUFFRCxNQUFJNmlELGdCQUFKLEVBQXNCO0FBQ3BCLFFBQUlLLGFBQWEsR0FBRy9ILEdBQUcsQ0FBQ3AyQyxPQUFKLENBQVksR0FBWixDQUFwQjs7QUFDQSxRQUFJbStDLGFBQWEsS0FBSyxDQUFDLENBQXZCLEVBQTBCO0FBQ3hCL0gsU0FBRyxHQUFHQSxHQUFHLENBQUNoNkMsS0FBSixDQUFVLENBQVYsRUFBYStoRCxhQUFiLENBQU47QUFDRDs7QUFFRC9ILE9BQUcsSUFBSSxDQUFDQSxHQUFHLENBQUNwMkMsT0FBSixDQUFZLEdBQVosTUFBcUIsQ0FBQyxDQUF0QixHQUEwQixHQUExQixHQUFnQyxHQUFqQyxJQUF3Qzg5QyxnQkFBL0M7QUFDRDs7QUFFRCxTQUFPMUgsR0FBUDtBQUNELENBaERELEM7Ozs7Ozs7Ozs7O0FDckJhO0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E1QixNQUFNLENBQUNVLE9BQVAsR0FBaUIsU0FBUzJGLFdBQVQsQ0FBcUIxRSxPQUFyQixFQUE4QmlJLFdBQTlCLEVBQTJDO0FBQzFELFNBQU9BLFdBQVcsR0FDZGpJLE9BQU8sQ0FBQzV0QyxPQUFSLENBQWdCLE1BQWhCLEVBQXdCLEVBQXhCLElBQThCLEdBQTlCLEdBQW9DNjFDLFdBQVcsQ0FBQzcxQyxPQUFaLENBQW9CLE1BQXBCLEVBQTRCLEVBQTVCLENBRHRCLEdBRWQ0dEMsT0FGSjtBQUdELENBSkQsQzs7Ozs7Ozs7Ozs7QUNUYTs7QUFFYixJQUFJMUIsS0FBSyxHQUFHQyxtQkFBTyxDQUFDLHFEQUFELENBQW5COztBQUVBRixNQUFNLENBQUNVLE9BQVAsR0FDRVQsS0FBSyxDQUFDK0Msb0JBQU4sS0FFQTtBQUNHLFNBQVM2RyxrQkFBVCxHQUE4QjtBQUM3QixTQUFPO0FBQ0xDLFNBQUssRUFBRSxTQUFTQSxLQUFULENBQWU1aEQsSUFBZixFQUFxQnJLLEtBQXJCLEVBQTRCa3NELE9BQTVCLEVBQXFDcHFDLElBQXJDLEVBQTJDcXFDLE1BQTNDLEVBQW1EQyxNQUFuRCxFQUEyRDtBQUNoRSxVQUFJQyxNQUFNLEdBQUcsRUFBYjtBQUNBQSxZQUFNLENBQUNqeEQsSUFBUCxDQUFZaVAsSUFBSSxHQUFHLEdBQVAsR0FBYXE1QyxrQkFBa0IsQ0FBQzFqRCxLQUFELENBQTNDOztBQUVBLFVBQUlvaUQsS0FBSyxDQUFDa0ssUUFBTixDQUFlSixPQUFmLENBQUosRUFBNkI7QUFDM0JHLGNBQU0sQ0FBQ2p4RCxJQUFQLENBQVksYUFBYSxJQUFJNDlCLElBQUosQ0FBU2t6QixPQUFULEVBQWtCSyxXQUFsQixFQUF6QjtBQUNEOztBQUVELFVBQUluSyxLQUFLLENBQUNuNEMsUUFBTixDQUFlNlgsSUFBZixDQUFKLEVBQTBCO0FBQ3hCdXFDLGNBQU0sQ0FBQ2p4RCxJQUFQLENBQVksVUFBVTBtQixJQUF0QjtBQUNEOztBQUVELFVBQUlzZ0MsS0FBSyxDQUFDbjRDLFFBQU4sQ0FBZWtpRCxNQUFmLENBQUosRUFBNEI7QUFDMUJFLGNBQU0sQ0FBQ2p4RCxJQUFQLENBQVksWUFBWSt3RCxNQUF4QjtBQUNEOztBQUVELFVBQUlDLE1BQU0sS0FBSyxJQUFmLEVBQXFCO0FBQ25CQyxjQUFNLENBQUNqeEQsSUFBUCxDQUFZLFFBQVo7QUFDRDs7QUFFRCtqQixjQUFRLENBQUNrdEMsTUFBVCxHQUFrQkEsTUFBTSxDQUFDempELElBQVAsQ0FBWSxJQUFaLENBQWxCO0FBQ0QsS0F0Qkk7QUF3QkwyOEMsUUFBSSxFQUFFLFNBQVNBLElBQVQsQ0FBY2w3QyxJQUFkLEVBQW9CO0FBQ3hCLFVBQUlrbkIsS0FBSyxHQUFHcFMsUUFBUSxDQUFDa3RDLE1BQVQsQ0FBZ0I5NkIsS0FBaEIsQ0FBc0IsSUFBSXpKLE1BQUosQ0FBVyxlQUFlemQsSUFBZixHQUFzQixXQUFqQyxDQUF0QixDQUFaO0FBQ0EsYUFBUWtuQixLQUFLLEdBQUdpN0Isa0JBQWtCLENBQUNqN0IsS0FBSyxDQUFDLENBQUQsQ0FBTixDQUFyQixHQUFrQyxJQUEvQztBQUNELEtBM0JJO0FBNkJMMVQsVUFBTSxFQUFFLFNBQVNBLE1BQVQsQ0FBZ0J4VCxJQUFoQixFQUFzQjtBQUM1QixXQUFLNGhELEtBQUwsQ0FBVzVoRCxJQUFYLEVBQWlCLEVBQWpCLEVBQXFCMnVCLElBQUksQ0FBQ0QsR0FBTCxLQUFhLFFBQWxDO0FBQ0Q7QUEvQkksR0FBUDtBQWlDRCxDQWxDRCxFQUhGLEdBdUNBO0FBQ0csU0FBUzB6QixxQkFBVCxHQUFpQztBQUNoQyxTQUFPO0FBQ0xSLFNBQUssRUFBRSxTQUFTQSxLQUFULEdBQWlCLENBQUUsQ0FEckI7QUFFTDFHLFFBQUksRUFBRSxTQUFTQSxJQUFULEdBQWdCO0FBQUUsYUFBTyxJQUFQO0FBQWMsS0FGakM7QUFHTDFuQyxVQUFNLEVBQUUsU0FBU0EsTUFBVCxHQUFrQixDQUFFO0FBSHZCLEdBQVA7QUFLRCxDQU5ELEVBekNKLEM7Ozs7Ozs7Ozs7O0FDSmE7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0Fza0MsTUFBTSxDQUFDVSxPQUFQLEdBQWlCLFNBQVMwRixhQUFULENBQXVCeEUsR0FBdkIsRUFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBTyxnQ0FBZ0NsNkIsSUFBaEMsQ0FBcUNrNkIsR0FBckMsQ0FBUDtBQUNELENBTEQsQzs7Ozs7Ozs7Ozs7QUNSYTtBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTVCLE1BQU0sQ0FBQ1UsT0FBUCxHQUFpQixTQUFTa0UsWUFBVCxDQUFzQjJGLE9BQXRCLEVBQStCO0FBQzlDLFNBQVEsT0FBT0EsT0FBUCxLQUFtQixRQUFwQixJQUFrQ0EsT0FBTyxDQUFDM0YsWUFBUixLQUF5QixJQUFsRTtBQUNELENBRkQsQzs7Ozs7Ozs7Ozs7QUNSYTs7QUFFYixJQUFJM0UsS0FBSyxHQUFHQyxtQkFBTyxDQUFDLHFEQUFELENBQW5COztBQUVBRixNQUFNLENBQUNVLE9BQVAsR0FDRVQsS0FBSyxDQUFDK0Msb0JBQU4sS0FFQTtBQUNBO0FBQ0csU0FBUzZHLGtCQUFULEdBQThCO0FBQzdCLE1BQUlXLElBQUksR0FBRyxrQkFBa0I5aUMsSUFBbEIsQ0FBdUJvbkIsU0FBUyxDQUFDQyxTQUFqQyxDQUFYO0FBQ0EsTUFBSTBiLGNBQWMsR0FBR3p0QyxRQUFRLENBQUM5QyxhQUFULENBQXVCLEdBQXZCLENBQXJCO0FBQ0EsTUFBSXd3QyxTQUFKO0FBRUE7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNNLFdBQVNDLFVBQVQsQ0FBb0IvSSxHQUFwQixFQUF5QjtBQUN2QixRQUFJZ0osSUFBSSxHQUFHaEosR0FBWDs7QUFFQSxRQUFJNEksSUFBSixFQUFVO0FBQ1Y7QUFDRUMsb0JBQWMsQ0FBQ2hlLFlBQWYsQ0FBNEIsTUFBNUIsRUFBb0NtZSxJQUFwQztBQUNBQSxVQUFJLEdBQUdILGNBQWMsQ0FBQ0csSUFBdEI7QUFDRDs7QUFFREgsa0JBQWMsQ0FBQ2hlLFlBQWYsQ0FBNEIsTUFBNUIsRUFBb0NtZSxJQUFwQyxFQVR1QixDQVd2Qjs7QUFDQSxXQUFPO0FBQ0xBLFVBQUksRUFBRUgsY0FBYyxDQUFDRyxJQURoQjtBQUVMQyxjQUFRLEVBQUVKLGNBQWMsQ0FBQ0ksUUFBZixHQUEwQkosY0FBYyxDQUFDSSxRQUFmLENBQXdCOTJDLE9BQXhCLENBQWdDLElBQWhDLEVBQXNDLEVBQXRDLENBQTFCLEdBQXNFLEVBRjNFO0FBR0wrMkMsVUFBSSxFQUFFTCxjQUFjLENBQUNLLElBSGhCO0FBSUxDLFlBQU0sRUFBRU4sY0FBYyxDQUFDTSxNQUFmLEdBQXdCTixjQUFjLENBQUNNLE1BQWYsQ0FBc0JoM0MsT0FBdEIsQ0FBOEIsS0FBOUIsRUFBcUMsRUFBckMsQ0FBeEIsR0FBbUUsRUFKdEU7QUFLTGkzQyxVQUFJLEVBQUVQLGNBQWMsQ0FBQ08sSUFBZixHQUFzQlAsY0FBYyxDQUFDTyxJQUFmLENBQW9CajNDLE9BQXBCLENBQTRCLElBQTVCLEVBQWtDLEVBQWxDLENBQXRCLEdBQThELEVBTC9EO0FBTUxrM0MsY0FBUSxFQUFFUixjQUFjLENBQUNRLFFBTnBCO0FBT0xDLFVBQUksRUFBRVQsY0FBYyxDQUFDUyxJQVBoQjtBQVFMQyxjQUFRLEVBQUdWLGNBQWMsQ0FBQ1UsUUFBZixDQUF3QnhMLE1BQXhCLENBQStCLENBQS9CLE1BQXNDLEdBQXZDLEdBQ1I4SyxjQUFjLENBQUNVLFFBRFAsR0FFUixNQUFNVixjQUFjLENBQUNVO0FBVmxCLEtBQVA7QUFZRDs7QUFFRFQsV0FBUyxHQUFHQyxVQUFVLENBQUN6OUMsTUFBTSxDQUFDbUIsUUFBUCxDQUFnQnU4QyxJQUFqQixDQUF0QjtBQUVBO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDTSxTQUFPLFNBQVNwSyxlQUFULENBQXlCNEssVUFBekIsRUFBcUM7QUFDMUMsUUFBSUMsTUFBTSxHQUFJcEwsS0FBSyxDQUFDbjRDLFFBQU4sQ0FBZXNqRCxVQUFmLENBQUQsR0FBK0JULFVBQVUsQ0FBQ1MsVUFBRCxDQUF6QyxHQUF3REEsVUFBckU7QUFDQSxXQUFRQyxNQUFNLENBQUNSLFFBQVAsS0FBb0JILFNBQVMsQ0FBQ0csUUFBOUIsSUFDSlEsTUFBTSxDQUFDUCxJQUFQLEtBQWdCSixTQUFTLENBQUNJLElBRDlCO0FBRUQsR0FKRDtBQUtELENBbERELEVBSkYsR0F3REE7QUFDRyxTQUFTUixxQkFBVCxHQUFpQztBQUNoQyxTQUFPLFNBQVM5SixlQUFULEdBQTJCO0FBQ2hDLFdBQU8sSUFBUDtBQUNELEdBRkQ7QUFHRCxDQUpELEVBMURKLEM7Ozs7Ozs7Ozs7O0FDSmE7O0FBRWIsSUFBSVAsS0FBSyxHQUFHQyxtQkFBTyxDQUFDLG1EQUFELENBQW5COztBQUVBRixNQUFNLENBQUNVLE9BQVAsR0FBaUIsU0FBUzRILG1CQUFULENBQTZCdkgsT0FBN0IsRUFBc0N1SyxjQUF0QyxFQUFzRDtBQUNyRXJMLE9BQUssQ0FBQy9rRCxPQUFOLENBQWM2bEQsT0FBZCxFQUF1QixTQUFTd0ssYUFBVCxDQUF1QjF0RCxLQUF2QixFQUE4QnFLLElBQTlCLEVBQW9DO0FBQ3pELFFBQUlBLElBQUksS0FBS29qRCxjQUFULElBQTJCcGpELElBQUksQ0FBQytnQyxXQUFMLE9BQXVCcWlCLGNBQWMsQ0FBQ3JpQixXQUFmLEVBQXRELEVBQW9GO0FBQ2xGOFgsYUFBTyxDQUFDdUssY0FBRCxDQUFQLEdBQTBCenRELEtBQTFCO0FBQ0EsYUFBT2tqRCxPQUFPLENBQUM3NEMsSUFBRCxDQUFkO0FBQ0Q7QUFDRixHQUxEO0FBTUQsQ0FQRCxDOzs7Ozs7Ozs7OztBQ0phOztBQUViLElBQUkrM0MsS0FBSyxHQUFHQyxtQkFBTyxDQUFDLHFEQUFELENBQW5CLEMsQ0FFQTtBQUNBOzs7QUFDQSxJQUFJc0wsaUJBQWlCLEdBQUcsQ0FDdEIsS0FEc0IsRUFDZixlQURlLEVBQ0UsZ0JBREYsRUFDb0IsY0FEcEIsRUFDb0MsTUFEcEMsRUFFdEIsU0FGc0IsRUFFWCxNQUZXLEVBRUgsTUFGRyxFQUVLLG1CQUZMLEVBRTBCLHFCQUYxQixFQUd0QixlQUhzQixFQUdMLFVBSEssRUFHTyxjQUhQLEVBR3VCLHFCQUh2QixFQUl0QixTQUpzQixFQUlYLGFBSlcsRUFJSSxZQUpKLENBQXhCO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0F4TCxNQUFNLENBQUNVLE9BQVAsR0FBaUIsU0FBU0gsWUFBVCxDQUFzQlEsT0FBdEIsRUFBK0I7QUFDOUMsTUFBSXNLLE1BQU0sR0FBRyxFQUFiO0FBQ0EsTUFBSW54RCxHQUFKO0FBQ0EsTUFBSWdKLEdBQUo7QUFDQSxNQUFJMUosQ0FBSjs7QUFFQSxNQUFJLENBQUN1bkQsT0FBTCxFQUFjO0FBQUUsV0FBT3NLLE1BQVA7QUFBZ0I7O0FBRWhDcEwsT0FBSyxDQUFDL2tELE9BQU4sQ0FBYzZsRCxPQUFPLENBQUNsaEMsS0FBUixDQUFjLElBQWQsQ0FBZCxFQUFtQyxTQUFTNHJDLE1BQVQsQ0FBZ0IzUCxJQUFoQixFQUFzQjtBQUN2RHRpRCxLQUFDLEdBQUdzaUQsSUFBSSxDQUFDdHdDLE9BQUwsQ0FBYSxHQUFiLENBQUo7QUFDQXRSLE9BQUcsR0FBRytsRCxLQUFLLENBQUMzdEMsSUFBTixDQUFXd3BDLElBQUksQ0FBQzRQLE1BQUwsQ0FBWSxDQUFaLEVBQWVseUQsQ0FBZixDQUFYLEVBQThCaVosV0FBOUIsRUFBTjtBQUNBdlAsT0FBRyxHQUFHKzhDLEtBQUssQ0FBQzN0QyxJQUFOLENBQVd3cEMsSUFBSSxDQUFDNFAsTUFBTCxDQUFZbHlELENBQUMsR0FBRyxDQUFoQixDQUFYLENBQU47O0FBRUEsUUFBSVUsR0FBSixFQUFTO0FBQ1AsVUFBSW14RCxNQUFNLENBQUNueEQsR0FBRCxDQUFOLElBQWVzeEQsaUJBQWlCLENBQUNoZ0QsT0FBbEIsQ0FBMEJ0UixHQUExQixLQUFrQyxDQUFyRCxFQUF3RDtBQUN0RDtBQUNEOztBQUNELFVBQUlBLEdBQUcsS0FBSyxZQUFaLEVBQTBCO0FBQ3hCbXhELGNBQU0sQ0FBQ254RCxHQUFELENBQU4sR0FBYyxDQUFDbXhELE1BQU0sQ0FBQ254RCxHQUFELENBQU4sR0FBY214RCxNQUFNLENBQUNueEQsR0FBRCxDQUFwQixHQUE0QixFQUE3QixFQUFpQzJjLE1BQWpDLENBQXdDLENBQUMzVCxHQUFELENBQXhDLENBQWQ7QUFDRCxPQUZELE1BRU87QUFDTG1vRCxjQUFNLENBQUNueEQsR0FBRCxDQUFOLEdBQWNteEQsTUFBTSxDQUFDbnhELEdBQUQsQ0FBTixHQUFjbXhELE1BQU0sQ0FBQ254RCxHQUFELENBQU4sR0FBYyxJQUFkLEdBQXFCZ0osR0FBbkMsR0FBeUNBLEdBQXZEO0FBQ0Q7QUFDRjtBQUNGLEdBZkQ7QUFpQkEsU0FBT21vRCxNQUFQO0FBQ0QsQ0ExQkQsQzs7Ozs7Ozs7Ozs7QUMxQmE7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBckwsTUFBTSxDQUFDVSxPQUFQLEdBQWlCLFNBQVNpRSxNQUFULENBQWdCcmtELFFBQWhCLEVBQTBCO0FBQ3pDLFNBQU8sU0FBU1gsSUFBVCxDQUFjL0MsR0FBZCxFQUFtQjtBQUN4QixXQUFPMEQsUUFBUSxDQUFDdEQsS0FBVCxDQUFlLElBQWYsRUFBcUJKLEdBQXJCLENBQVA7QUFDRCxHQUZEO0FBR0QsQ0FKRCxDOzs7Ozs7Ozs7OztBQ3RCYTs7QUFFYixJQUFJNk4sSUFBSSxHQUFHeTFDLG1CQUFPLENBQUMsZ0VBQUQsQ0FBbEI7QUFFQTtBQUVBOzs7QUFFQSxJQUFJN3dCLFFBQVEsR0FBR3p6QixNQUFNLENBQUNjLFNBQVAsQ0FBaUIyeUIsUUFBaEM7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBU2wwQixPQUFULENBQWlCK0gsR0FBakIsRUFBc0I7QUFDcEIsU0FBT21zQixRQUFRLENBQUN6dkIsSUFBVCxDQUFjc0QsR0FBZCxNQUF1QixnQkFBOUI7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU3FnRCxXQUFULENBQXFCcmdELEdBQXJCLEVBQTBCO0FBQ3hCLFNBQU8sT0FBT0EsR0FBUCxLQUFlLFdBQXRCO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVN5bEQsUUFBVCxDQUFrQnpsRCxHQUFsQixFQUF1QjtBQUNyQixTQUFPQSxHQUFHLEtBQUssSUFBUixJQUFnQixDQUFDcWdELFdBQVcsQ0FBQ3JnRCxHQUFELENBQTVCLElBQXFDQSxHQUFHLENBQUNRLFdBQUosS0FBb0IsSUFBekQsSUFBaUUsQ0FBQzYvQyxXQUFXLENBQUNyZ0QsR0FBRyxDQUFDUSxXQUFMLENBQTdFLElBQ0YsT0FBT1IsR0FBRyxDQUFDUSxXQUFKLENBQWdCaWxELFFBQXZCLEtBQW9DLFVBRGxDLElBQ2dEemxELEdBQUcsQ0FBQ1EsV0FBSixDQUFnQmlsRCxRQUFoQixDQUF5QnpsRCxHQUF6QixDQUR2RDtBQUVEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTd2xELGFBQVQsQ0FBdUJ4bEQsR0FBdkIsRUFBNEI7QUFDMUIsU0FBT21zQixRQUFRLENBQUN6dkIsSUFBVCxDQUFjc0QsR0FBZCxNQUF1QixzQkFBOUI7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUzg5QyxVQUFULENBQW9COTlDLEdBQXBCLEVBQXlCO0FBQ3ZCLFNBQVEsT0FBT3lvRCxRQUFQLEtBQW9CLFdBQXJCLElBQXNDem9ELEdBQUcsWUFBWXlvRCxRQUE1RDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTNUMsaUJBQVQsQ0FBMkI3bEQsR0FBM0IsRUFBZ0M7QUFDOUIsTUFBSTdFLE1BQUo7O0FBQ0EsTUFBSyxPQUFPdXRELFdBQVAsS0FBdUIsV0FBeEIsSUFBeUNBLFdBQVcsQ0FBQ0MsTUFBekQsRUFBa0U7QUFDaEV4dEQsVUFBTSxHQUFHdXRELFdBQVcsQ0FBQ0MsTUFBWixDQUFtQjNvRCxHQUFuQixDQUFUO0FBQ0QsR0FGRCxNQUVPO0FBQ0w3RSxVQUFNLEdBQUk2RSxHQUFELElBQVVBLEdBQUcsQ0FBQzhsRCxNQUFkLElBQTBCOWxELEdBQUcsQ0FBQzhsRCxNQUFKLFlBQXNCNEMsV0FBekQ7QUFDRDs7QUFDRCxTQUFPdnRELE1BQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU3lKLFFBQVQsQ0FBa0I1RSxHQUFsQixFQUF1QjtBQUNyQixTQUFPLE9BQU9BLEdBQVAsS0FBZSxRQUF0QjtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTaW5ELFFBQVQsQ0FBa0JqbkQsR0FBbEIsRUFBdUI7QUFDckIsU0FBTyxPQUFPQSxHQUFQLEtBQWUsUUFBdEI7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU3BGLFFBQVQsQ0FBa0JvRixHQUFsQixFQUF1QjtBQUNyQixTQUFPQSxHQUFHLEtBQUssSUFBUixJQUFnQixPQUFPQSxHQUFQLEtBQWUsUUFBdEM7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUzhjLGFBQVQsQ0FBdUI5YyxHQUF2QixFQUE0QjtBQUMxQixNQUFJbXNCLFFBQVEsQ0FBQ3p2QixJQUFULENBQWNzRCxHQUFkLE1BQXVCLGlCQUEzQixFQUE4QztBQUM1QyxXQUFPLEtBQVA7QUFDRDs7QUFFRCxNQUFJeEcsU0FBUyxHQUFHZCxNQUFNLENBQUMwRCxjQUFQLENBQXNCNEQsR0FBdEIsQ0FBaEI7QUFDQSxTQUFPeEcsU0FBUyxLQUFLLElBQWQsSUFBc0JBLFNBQVMsS0FBS2QsTUFBTSxDQUFDYyxTQUFsRDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTOGhELE1BQVQsQ0FBZ0J0N0MsR0FBaEIsRUFBcUI7QUFDbkIsU0FBT21zQixRQUFRLENBQUN6dkIsSUFBVCxDQUFjc0QsR0FBZCxNQUF1QixlQUE5QjtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTMmxELE1BQVQsQ0FBZ0IzbEQsR0FBaEIsRUFBcUI7QUFDbkIsU0FBT21zQixRQUFRLENBQUN6dkIsSUFBVCxDQUFjc0QsR0FBZCxNQUF1QixlQUE5QjtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTNGxELE1BQVQsQ0FBZ0I1bEQsR0FBaEIsRUFBcUI7QUFDbkIsU0FBT21zQixRQUFRLENBQUN6dkIsSUFBVCxDQUFjc0QsR0FBZCxNQUF1QixlQUE5QjtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTdUMsVUFBVCxDQUFvQnZDLEdBQXBCLEVBQXlCO0FBQ3ZCLFNBQU9tc0IsUUFBUSxDQUFDenZCLElBQVQsQ0FBY3NELEdBQWQsTUFBdUIsbUJBQTlCO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMwbEQsUUFBVCxDQUFrQjFsRCxHQUFsQixFQUF1QjtBQUNyQixTQUFPcEYsUUFBUSxDQUFDb0YsR0FBRCxDQUFSLElBQWlCdUMsVUFBVSxDQUFDdkMsR0FBRyxDQUFDNG9ELElBQUwsQ0FBbEM7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUzdDLGlCQUFULENBQTJCL2xELEdBQTNCLEVBQWdDO0FBQzlCLFNBQU8sT0FBTzZvRCxlQUFQLEtBQTJCLFdBQTNCLElBQTBDN29ELEdBQUcsWUFBWTZvRCxlQUFoRTtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTejVDLElBQVQsQ0FBYzAyQixHQUFkLEVBQW1CO0FBQ2pCLFNBQU9BLEdBQUcsQ0FBQ2oxQixPQUFKLENBQVksTUFBWixFQUFvQixFQUFwQixFQUF3QkEsT0FBeEIsQ0FBZ0MsTUFBaEMsRUFBd0MsRUFBeEMsQ0FBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTaXZDLG9CQUFULEdBQWdDO0FBQzlCLE1BQUksT0FBT2xVLFNBQVAsS0FBcUIsV0FBckIsS0FBcUNBLFNBQVMsQ0FBQ2tkLE9BQVYsS0FBc0IsYUFBdEIsSUFDQWxkLFNBQVMsQ0FBQ2tkLE9BQVYsS0FBc0IsY0FEdEIsSUFFQWxkLFNBQVMsQ0FBQ2tkLE9BQVYsS0FBc0IsSUFGM0QsQ0FBSixFQUVzRTtBQUNwRSxXQUFPLEtBQVA7QUFDRDs7QUFDRCxTQUNFLE9BQU85K0MsTUFBUCxLQUFrQixXQUFsQixJQUNBLE9BQU84UCxRQUFQLEtBQW9CLFdBRnRCO0FBSUQ7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVM5aEIsT0FBVCxDQUFpQmlxQyxHQUFqQixFQUFzQmx0QyxFQUF0QixFQUEwQjtBQUN4QjtBQUNBLE1BQUlrdEMsR0FBRyxLQUFLLElBQVIsSUFBZ0IsT0FBT0EsR0FBUCxLQUFlLFdBQW5DLEVBQWdEO0FBQzlDO0FBQ0QsR0FKdUIsQ0FNeEI7OztBQUNBLE1BQUksT0FBT0EsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCO0FBQ0FBLE9BQUcsR0FBRyxDQUFDQSxHQUFELENBQU47QUFDRDs7QUFFRCxNQUFJaHFDLE9BQU8sQ0FBQ2dxQyxHQUFELENBQVgsRUFBa0I7QUFDaEI7QUFDQSxTQUFLLElBQUkzckMsQ0FBQyxHQUFHLENBQVIsRUFBV3NELENBQUMsR0FBR3FvQyxHQUFHLENBQUMvckMsTUFBeEIsRUFBZ0NJLENBQUMsR0FBR3NELENBQXBDLEVBQXVDdEQsQ0FBQyxFQUF4QyxFQUE0QztBQUMxQ3ZCLFFBQUUsQ0FBQzJILElBQUgsQ0FBUSxJQUFSLEVBQWN1bEMsR0FBRyxDQUFDM3JDLENBQUQsQ0FBakIsRUFBc0JBLENBQXRCLEVBQXlCMnJDLEdBQXpCO0FBQ0Q7QUFDRixHQUxELE1BS087QUFDTDtBQUNBLFNBQUssSUFBSWpyQyxHQUFULElBQWdCaXJDLEdBQWhCLEVBQXFCO0FBQ25CLFVBQUl2cEMsTUFBTSxDQUFDYyxTQUFQLENBQWlCNi9DLGNBQWpCLENBQWdDMzhDLElBQWhDLENBQXFDdWxDLEdBQXJDLEVBQTBDanJDLEdBQTFDLENBQUosRUFBb0Q7QUFDbERqQyxVQUFFLENBQUMySCxJQUFILENBQVEsSUFBUixFQUFjdWxDLEdBQUcsQ0FBQ2pyQyxHQUFELENBQWpCLEVBQXdCQSxHQUF4QixFQUE2QmlyQyxHQUE3QjtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU3loQixLQUFUO0FBQWU7QUFBNkI7QUFDMUMsTUFBSXZvRCxNQUFNLEdBQUcsRUFBYjs7QUFDQSxXQUFTNHRELFdBQVQsQ0FBcUIvb0QsR0FBckIsRUFBMEJoSixHQUExQixFQUErQjtBQUM3QixRQUFJOGxCLGFBQWEsQ0FBQzNoQixNQUFNLENBQUNuRSxHQUFELENBQVAsQ0FBYixJQUE4QjhsQixhQUFhLENBQUM5YyxHQUFELENBQS9DLEVBQXNEO0FBQ3BEN0UsWUFBTSxDQUFDbkUsR0FBRCxDQUFOLEdBQWMwc0QsS0FBSyxDQUFDdm9ELE1BQU0sQ0FBQ25FLEdBQUQsQ0FBUCxFQUFjZ0osR0FBZCxDQUFuQjtBQUNELEtBRkQsTUFFTyxJQUFJOGMsYUFBYSxDQUFDOWMsR0FBRCxDQUFqQixFQUF3QjtBQUM3QjdFLFlBQU0sQ0FBQ25FLEdBQUQsQ0FBTixHQUFjMHNELEtBQUssQ0FBQyxFQUFELEVBQUsxakQsR0FBTCxDQUFuQjtBQUNELEtBRk0sTUFFQSxJQUFJL0gsT0FBTyxDQUFDK0gsR0FBRCxDQUFYLEVBQWtCO0FBQ3ZCN0UsWUFBTSxDQUFDbkUsR0FBRCxDQUFOLEdBQWNnSixHQUFHLENBQUMwRSxLQUFKLEVBQWQ7QUFDRCxLQUZNLE1BRUE7QUFDTHZKLFlBQU0sQ0FBQ25FLEdBQUQsQ0FBTixHQUFjZ0osR0FBZDtBQUNEO0FBQ0Y7O0FBRUQsT0FBSyxJQUFJMUosQ0FBQyxHQUFHLENBQVIsRUFBV3NELENBQUMsR0FBR3VoQixTQUFTLENBQUNqbEIsTUFBOUIsRUFBc0NJLENBQUMsR0FBR3NELENBQTFDLEVBQTZDdEQsQ0FBQyxFQUE5QyxFQUFrRDtBQUNoRDBCLFdBQU8sQ0FBQ21qQixTQUFTLENBQUM3a0IsQ0FBRCxDQUFWLEVBQWV5eUQsV0FBZixDQUFQO0FBQ0Q7O0FBQ0QsU0FBTzV0RCxNQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTVSxNQUFULENBQWdCd04sQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCak0sT0FBdEIsRUFBK0I7QUFDN0JyRixTQUFPLENBQUNzUixDQUFELEVBQUksU0FBU3kvQyxXQUFULENBQXFCL29ELEdBQXJCLEVBQTBCaEosR0FBMUIsRUFBK0I7QUFDeEMsUUFBSXFHLE9BQU8sSUFBSSxPQUFPMkMsR0FBUCxLQUFlLFVBQTlCLEVBQTBDO0FBQ3hDcUosT0FBQyxDQUFDclMsR0FBRCxDQUFELEdBQVN1USxJQUFJLENBQUN2SCxHQUFELEVBQU0zQyxPQUFOLENBQWI7QUFDRCxLQUZELE1BRU87QUFDTGdNLE9BQUMsQ0FBQ3JTLEdBQUQsQ0FBRCxHQUFTZ0osR0FBVDtBQUNEO0FBQ0YsR0FOTSxDQUFQO0FBT0EsU0FBT3FKLENBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUzIvQyxRQUFULENBQWtCcG9CLE9BQWxCLEVBQTJCO0FBQ3pCLE1BQUlBLE9BQU8sQ0FBQ2thLFVBQVIsQ0FBbUIsQ0FBbkIsTUFBMEIsTUFBOUIsRUFBc0M7QUFDcENsYSxXQUFPLEdBQUdBLE9BQU8sQ0FBQ2w4QixLQUFSLENBQWMsQ0FBZCxDQUFWO0FBQ0Q7O0FBQ0QsU0FBT2s4QixPQUFQO0FBQ0Q7O0FBRURrYyxNQUFNLENBQUNVLE9BQVAsR0FBaUI7QUFDZnZsRCxTQUFPLEVBQUVBLE9BRE07QUFFZnV0RCxlQUFhLEVBQUVBLGFBRkE7QUFHZkMsVUFBUSxFQUFFQSxRQUhLO0FBSWYzSCxZQUFVLEVBQUVBLFVBSkc7QUFLZitILG1CQUFpQixFQUFFQSxpQkFMSjtBQU1mamhELFVBQVEsRUFBRUEsUUFOSztBQU9mcWlELFVBQVEsRUFBRUEsUUFQSztBQVFmcnNELFVBQVEsRUFBRUEsUUFSSztBQVNma2lCLGVBQWEsRUFBRUEsYUFUQTtBQVVmdWpDLGFBQVcsRUFBRUEsV0FWRTtBQVdmL0UsUUFBTSxFQUFFQSxNQVhPO0FBWWZxSyxRQUFNLEVBQUVBLE1BWk87QUFhZkMsUUFBTSxFQUFFQSxNQWJPO0FBY2ZyakQsWUFBVSxFQUFFQSxVQWRHO0FBZWZtakQsVUFBUSxFQUFFQSxRQWZLO0FBZ0JmSyxtQkFBaUIsRUFBRUEsaUJBaEJKO0FBaUJmakcsc0JBQW9CLEVBQUVBLG9CQWpCUDtBQWtCZjluRCxTQUFPLEVBQUVBLE9BbEJNO0FBbUJmMHJELE9BQUssRUFBRUEsS0FuQlE7QUFvQmY3bkQsUUFBTSxFQUFFQSxNQXBCTztBQXFCZnVULE1BQUksRUFBRUEsSUFyQlM7QUFzQmY0NUMsVUFBUSxFQUFFQTtBQXRCSyxDQUFqQixDOzs7Ozs7Ozs7OztBQ3ZVYTtBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQWxNLE1BQU0sQ0FBQ1UsT0FBUCxHQUFpQixVQUFVeUwsc0JBQVYsRUFBa0M7QUFDakQsTUFBSTVRLElBQUksR0FBRyxFQUFYLENBRGlELENBQ2xDOztBQUVmQSxNQUFJLENBQUNsc0IsUUFBTCxHQUFnQixTQUFTQSxRQUFULEdBQW9CO0FBQ2xDLFdBQU8sS0FBS3Z6QixHQUFMLENBQVMsVUFBVWloRCxJQUFWLEVBQWdCO0FBQzlCLFVBQUlqWixPQUFPLEdBQUdxb0Isc0JBQXNCLENBQUNwUCxJQUFELENBQXBDOztBQUVBLFVBQUlBLElBQUksQ0FBQyxDQUFELENBQVIsRUFBYTtBQUNYLGVBQU8sVUFBVWxtQyxNQUFWLENBQWlCa21DLElBQUksQ0FBQyxDQUFELENBQXJCLEVBQTBCLElBQTFCLEVBQWdDbG1DLE1BQWhDLENBQXVDaXRCLE9BQXZDLEVBQWdELEdBQWhELENBQVA7QUFDRDs7QUFFRCxhQUFPQSxPQUFQO0FBQ0QsS0FSTSxFQVFKcjlCLElBUkksQ0FRQyxFQVJELENBQVA7QUFTRCxHQVZELENBSGlELENBYTlDO0FBQ0g7OztBQUdBODBDLE1BQUksQ0FBQy9oRCxDQUFMLEdBQVMsVUFBVWszQyxPQUFWLEVBQW1CMGIsVUFBbkIsRUFBK0JDLE1BQS9CLEVBQXVDO0FBQzlDLFFBQUksT0FBTzNiLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0I7QUFDQUEsYUFBTyxHQUFHLENBQUMsQ0FBQyxJQUFELEVBQU9BLE9BQVAsRUFBZ0IsRUFBaEIsQ0FBRCxDQUFWO0FBQ0Q7O0FBRUQsUUFBSTRiLHNCQUFzQixHQUFHLEVBQTdCOztBQUVBLFFBQUlELE1BQUosRUFBWTtBQUNWLFdBQUssSUFBSTd5RCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtKLE1BQXpCLEVBQWlDSSxDQUFDLEVBQWxDLEVBQXNDO0FBQ3BDO0FBQ0EsWUFBSUgsRUFBRSxHQUFHLEtBQUtHLENBQUwsRUFBUSxDQUFSLENBQVQ7O0FBRUEsWUFBSUgsRUFBRSxJQUFJLElBQVYsRUFBZ0I7QUFDZGl6RCxnQ0FBc0IsQ0FBQ2p6RCxFQUFELENBQXRCLEdBQTZCLElBQTdCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQUssSUFBSWt6RCxFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHN2IsT0FBTyxDQUFDdDNDLE1BQTlCLEVBQXNDbXpELEVBQUUsRUFBeEMsRUFBNEM7QUFDMUMsVUFBSXhQLElBQUksR0FBRyxHQUFHbG1DLE1BQUgsQ0FBVTY1QixPQUFPLENBQUM2YixFQUFELENBQWpCLENBQVg7O0FBRUEsVUFBSUYsTUFBTSxJQUFJQyxzQkFBc0IsQ0FBQ3ZQLElBQUksQ0FBQyxDQUFELENBQUwsQ0FBcEMsRUFBK0M7QUFDN0M7QUFDQTtBQUNEOztBQUVELFVBQUlxUCxVQUFKLEVBQWdCO0FBQ2QsWUFBSSxDQUFDclAsSUFBSSxDQUFDLENBQUQsQ0FBVCxFQUFjO0FBQ1pBLGNBQUksQ0FBQyxDQUFELENBQUosR0FBVXFQLFVBQVY7QUFDRCxTQUZELE1BRU87QUFDTHJQLGNBQUksQ0FBQyxDQUFELENBQUosR0FBVSxHQUFHbG1DLE1BQUgsQ0FBVXUxQyxVQUFWLEVBQXNCLE9BQXRCLEVBQStCdjFDLE1BQS9CLENBQXNDa21DLElBQUksQ0FBQyxDQUFELENBQTFDLENBQVY7QUFDRDtBQUNGOztBQUVEeEIsVUFBSSxDQUFDdGlELElBQUwsQ0FBVThqRCxJQUFWO0FBQ0Q7QUFDRixHQXJDRDs7QUF1Q0EsU0FBT3hCLElBQVA7QUFDRCxDQXpERCxDOzs7Ozs7Ozs7OztBQ1JhOztBQUViLFNBQVNpUixjQUFULENBQXdCNXZELEdBQXhCLEVBQTZCcEQsQ0FBN0IsRUFBZ0M7QUFBRSxTQUFPaXpELGVBQWUsQ0FBQzd2RCxHQUFELENBQWYsSUFBd0I4dkQscUJBQXFCLENBQUM5dkQsR0FBRCxFQUFNcEQsQ0FBTixDQUE3QyxJQUF5RG16RCwyQkFBMkIsQ0FBQy92RCxHQUFELEVBQU1wRCxDQUFOLENBQXBGLElBQWdHb3pELGdCQUFnQixFQUF2SDtBQUE0SDs7QUFFOUosU0FBU0EsZ0JBQVQsR0FBNEI7QUFBRSxRQUFNLElBQUk3SCxTQUFKLENBQWMsMklBQWQsQ0FBTjtBQUFtSzs7QUFFak0sU0FBUzRILDJCQUFULENBQXFDMXlDLENBQXJDLEVBQXdDNHlDLE1BQXhDLEVBQWdEO0FBQUUsTUFBSSxDQUFDNXlDLENBQUwsRUFBUTtBQUFRLE1BQUksT0FBT0EsQ0FBUCxLQUFhLFFBQWpCLEVBQTJCLE9BQU82eUMsaUJBQWlCLENBQUM3eUMsQ0FBRCxFQUFJNHlDLE1BQUosQ0FBeEI7QUFBcUMsTUFBSXJ4QyxDQUFDLEdBQUc1ZixNQUFNLENBQUNjLFNBQVAsQ0FBaUIyeUIsUUFBakIsQ0FBMEJ6dkIsSUFBMUIsQ0FBK0JxYSxDQUEvQixFQUFrQ3JTLEtBQWxDLENBQXdDLENBQXhDLEVBQTJDLENBQUMsQ0FBNUMsQ0FBUjtBQUF3RCxNQUFJNFQsQ0FBQyxLQUFLLFFBQU4sSUFBa0J2QixDQUFDLENBQUN2VyxXQUF4QixFQUFxQzhYLENBQUMsR0FBR3ZCLENBQUMsQ0FBQ3ZXLFdBQUYsQ0FBY3dFLElBQWxCO0FBQXdCLE1BQUlzVCxDQUFDLEtBQUssS0FBTixJQUFlQSxDQUFDLEtBQUssS0FBekIsRUFBZ0MsT0FBTy9lLEtBQUssQ0FBQ3dSLElBQU4sQ0FBV2dNLENBQVgsQ0FBUDtBQUFzQixNQUFJdUIsQ0FBQyxLQUFLLFdBQU4sSUFBcUIsMkNBQTJDa00sSUFBM0MsQ0FBZ0RsTSxDQUFoRCxDQUF6QixFQUE2RSxPQUFPc3hDLGlCQUFpQixDQUFDN3lDLENBQUQsRUFBSTR5QyxNQUFKLENBQXhCO0FBQXNDOztBQUVoYSxTQUFTQyxpQkFBVCxDQUEyQmx3RCxHQUEzQixFQUFnQ29qQyxHQUFoQyxFQUFxQztBQUFFLE1BQUlBLEdBQUcsSUFBSSxJQUFQLElBQWVBLEdBQUcsR0FBR3BqQyxHQUFHLENBQUN4RCxNQUE3QixFQUFxQzRtQyxHQUFHLEdBQUdwakMsR0FBRyxDQUFDeEQsTUFBVjs7QUFBa0IsT0FBSyxJQUFJSSxDQUFDLEdBQUcsQ0FBUixFQUFXdXpELElBQUksR0FBRyxJQUFJdHdELEtBQUosQ0FBVXVqQyxHQUFWLENBQXZCLEVBQXVDeG1DLENBQUMsR0FBR3dtQyxHQUEzQyxFQUFnRHhtQyxDQUFDLEVBQWpELEVBQXFEO0FBQUV1ekQsUUFBSSxDQUFDdnpELENBQUQsQ0FBSixHQUFVb0QsR0FBRyxDQUFDcEQsQ0FBRCxDQUFiO0FBQW1COztBQUFDLFNBQU91ekQsSUFBUDtBQUFjOztBQUV2TCxTQUFTTCxxQkFBVCxDQUErQjl2RCxHQUEvQixFQUFvQ3BELENBQXBDLEVBQXVDO0FBQUUsTUFBSSt5RCxFQUFFLEdBQUczdkQsR0FBRyxLQUFLLE9BQU8vRSxNQUFQLEtBQWtCLFdBQWxCLElBQWlDK0UsR0FBRyxDQUFDL0UsTUFBTSxDQUFDK0ksUUFBUixDQUFwQyxJQUF5RGhFLEdBQUcsQ0FBQyxZQUFELENBQWpFLENBQVo7O0FBQThGLE1BQUkydkQsRUFBRSxJQUFJLElBQVYsRUFBZ0I7QUFBUSxNQUFJUyxJQUFJLEdBQUcsRUFBWDtBQUFlLE1BQUlwNEMsRUFBRSxHQUFHLElBQVQ7QUFBZSxNQUFJRSxFQUFFLEdBQUcsS0FBVDs7QUFBZ0IsTUFBSW00QyxFQUFKLEVBQVFDLEVBQVI7O0FBQVksTUFBSTtBQUFFLFNBQUtYLEVBQUUsR0FBR0EsRUFBRSxDQUFDM3NELElBQUgsQ0FBUWhELEdBQVIsQ0FBVixFQUF3QixFQUFFZ1ksRUFBRSxHQUFHLENBQUNxNEMsRUFBRSxHQUFHVixFQUFFLENBQUN4ckQsSUFBSCxFQUFOLEVBQWlCQyxJQUF4QixDQUF4QixFQUF1RDRULEVBQUUsR0FBRyxJQUE1RCxFQUFrRTtBQUFFbzRDLFVBQUksQ0FBQy96RCxJQUFMLENBQVVnMEQsRUFBRSxDQUFDcHZELEtBQWI7O0FBQXFCLFVBQUlyRSxDQUFDLElBQUl3ekQsSUFBSSxDQUFDNXpELE1BQUwsS0FBZ0JJLENBQXpCLEVBQTRCO0FBQVE7QUFBRSxHQUFySSxDQUFzSSxPQUFPNE8sR0FBUCxFQUFZO0FBQUUwTSxNQUFFLEdBQUcsSUFBTDtBQUFXbzRDLE1BQUUsR0FBRzlrRCxHQUFMO0FBQVcsR0FBMUssU0FBbUw7QUFBRSxRQUFJO0FBQUUsVUFBSSxDQUFDd00sRUFBRCxJQUFPMjNDLEVBQUUsQ0FBQyxRQUFELENBQUYsSUFBZ0IsSUFBM0IsRUFBaUNBLEVBQUUsQ0FBQyxRQUFELENBQUY7QUFBaUIsS0FBeEQsU0FBaUU7QUFBRSxVQUFJejNDLEVBQUosRUFBUSxNQUFNbzRDLEVBQU47QUFBVztBQUFFOztBQUFDLFNBQU9GLElBQVA7QUFBYzs7QUFFcmYsU0FBU1AsZUFBVCxDQUF5Qjd2RCxHQUF6QixFQUE4QjtBQUFFLE1BQUlILEtBQUssQ0FBQ3RCLE9BQU4sQ0FBY3lCLEdBQWQsQ0FBSixFQUF3QixPQUFPQSxHQUFQO0FBQWE7O0FBRXJFb2pELE1BQU0sQ0FBQ1UsT0FBUCxHQUFpQixTQUFTeUwsc0JBQVQsQ0FBZ0NwUCxJQUFoQyxFQUFzQztBQUNyRCxNQUFJb1EsS0FBSyxHQUFHWCxjQUFjLENBQUN6UCxJQUFELEVBQU8sQ0FBUCxDQUExQjtBQUFBLE1BQ0lqWixPQUFPLEdBQUdxcEIsS0FBSyxDQUFDLENBQUQsQ0FEbkI7QUFBQSxNQUVJQyxVQUFVLEdBQUdELEtBQUssQ0FBQyxDQUFELENBRnRCOztBQUlBLE1BQUksT0FBTzFMLElBQVAsS0FBZ0IsVUFBcEIsRUFBZ0M7QUFDOUI7QUFDQSxRQUFJNEwsTUFBTSxHQUFHNUwsSUFBSSxDQUFDSCxRQUFRLENBQUNDLGtCQUFrQixDQUFDeDVDLElBQUksQ0FBQ0MsU0FBTCxDQUFlb2xELFVBQWYsQ0FBRCxDQUFuQixDQUFULENBQWpCO0FBQ0EsUUFBSTMzQyxJQUFJLEdBQUcsK0RBQStEb0IsTUFBL0QsQ0FBc0V3MkMsTUFBdEUsQ0FBWDtBQUNBLFFBQUlDLGFBQWEsR0FBRyxPQUFPejJDLE1BQVAsQ0FBY3BCLElBQWQsRUFBb0IsS0FBcEIsQ0FBcEI7QUFDQSxRQUFJODNDLFVBQVUsR0FBR0gsVUFBVSxDQUFDSSxPQUFYLENBQW1CMXhELEdBQW5CLENBQXVCLFVBQVU0aUIsTUFBVixFQUFrQjtBQUN4RCxhQUFPLGlCQUFpQjdILE1BQWpCLENBQXdCdTJDLFVBQVUsQ0FBQ0ssVUFBWCxJQUF5QixFQUFqRCxFQUFxRDUyQyxNQUFyRCxDQUE0RDZILE1BQTVELEVBQW9FLEtBQXBFLENBQVA7QUFDRCxLQUZnQixDQUFqQjtBQUdBLFdBQU8sQ0FBQ29sQixPQUFELEVBQVVqdEIsTUFBVixDQUFpQjAyQyxVQUFqQixFQUE2QjEyQyxNQUE3QixDQUFvQyxDQUFDeTJDLGFBQUQsQ0FBcEMsRUFBcUQ3bUQsSUFBckQsQ0FBMEQsSUFBMUQsQ0FBUDtBQUNEOztBQUVELFNBQU8sQ0FBQ3E5QixPQUFELEVBQVVyOUIsSUFBVixDQUFlLElBQWYsQ0FBUDtBQUNELENBakJELEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbUJBLE1BQU0sVUFBUyxHQUFJLHlEQUFuQjtBQUVBO0FBRUEsaUVBQWU7QUFDYixRQUFNLFlBQU4sR0FBcUI7QUFDbkIsUUFBSSxPQUFKOztBQUNBLFFBQUk7QUFDRixPQUFDO0FBQUMsWUFBSSxFQUFFO0FBQUMsY0FBSSxFQUFFO0FBQVA7QUFBUCxVQUEwQixNQUFNLDRDQUFLLENBQUMsVUFBRCxDQUF0QztBQUNGLEtBRkEsQ0FFRSxNQUFNLENBQUM7O0FBRVQsU0FBSyxPQUFMLEdBQWUsWUFBWSxDQUFDLE9BQUQsQ0FBM0I7QUFDRCxHQVJZOztBQVViLFNBQU8sRUFBRTtBQUNQLG1CQURPO0FBRVA7QUFGTyxHQVZJO0FBZWIsTUFBSSxFQUFFLE9BQU87QUFBQyxXQUFPLEVBQUUsRUFBVjtBQUFjLGNBQVUsRUFBRTtBQUExQixHQUFQO0FBZk8sQ0FBZjs7QUFrQkEsU0FBUyxZQUFULENBQXNCLE9BQXRCLEVBQStCO0FBQzdCLE9BQUksTUFBTSxNQUFWLElBQW9CLE9BQXBCLEVBQTZCO0FBQzNCLFVBQU0sQ0FBQyxNQUFQLENBQWMsTUFBZCxFQUFzQjtBQUNwQixZQUFNLEVBQUUsQ0FDTixNQUFNLENBQUMsZUFERCxFQUVOLE1BQU0sQ0FBQyxlQUZELEVBR04sTUFBTSxDQUFDLGVBSEQsRUFJTixNQUFNLENBQUMsaUJBSkQsRUFLTixNQUFNLENBQUMsaUJBTEQsRUFNTixNQUFNLENBQUMsaUJBTkQsRUFPTixNQUFNLENBQUMsWUFQRCxFQVFOLE1BQU0sQ0FBQyxZQVJELEVBU04sTUFBTSxDQUFDLFlBVEQsQ0FEWTtBQWFwQixjQUFRLEVBQUUsQ0FDUixNQUFNLENBQUMsdUJBREMsRUFFUixNQUFNLENBQUMsdUJBRkMsRUFHUixNQUFNLENBQUMsdUJBSEMsRUFJUixNQUFNLENBQUMseUJBSkMsRUFLUixNQUFNLENBQUMseUJBTEMsRUFNUixNQUFNLENBQUMseUJBTkMsRUFPUixNQUFNLENBQUMsb0JBUEMsRUFRUixNQUFNLENBQUMsb0JBUkMsRUFTUixNQUFNLENBQUMsb0JBVEM7QUFiVSxLQUF0QjtBQXlCRjs7QUFFQSxTQUFPLE9BQVA7QUFDRjs7QUFFQSxTQUFTLGVBQVQsQ0FBeUIsR0FBekIsRUFBOEI7QUFDNUIsUUFBTSxlQUFjLEdBQUksR0FBRyxFQUFFLFVBQUwsR0FBa0IsUUFBbEIsRUFBNEIsS0FBNUIsQ0FBeEI7QUFFQSxTQUFPLFVBQVUsQ0FBQyxlQUFELENBQWpCO0FBQ0Y7O0FBRUEsU0FBUyxvQkFBVCxDQUE4QixLQUE5QixFQUFxQztBQUNuQyxRQUFNLFdBQVUsR0FBSSxLQUFLLEVBQUUsTUFBUCxHQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUFwQjtBQUVBLFNBQU8sVUFBVSxDQUFDLFdBQUQsQ0FBakI7QUFDRjs7QUFFQSxTQUFTLFVBQVQsQ0FBb0IsR0FBcEIsRUFBeUI7QUFDdkIsU0FBUSxHQUFFLEdBQUcsRUFBRSxNQUFMLEdBQWMsQ0FBZCxFQUFpQixpQkFBakIsRUFBcUMsR0FBRSxHQUFHLEVBQUUsS0FBTCxHQUFhLENBQWIsQ0FBZ0IsRUFBakU7QUFDRixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXJHSyxPQUFLLEVBQUM7OztnQ0FBVSxpREFBOEMsS0FBOUMsRUFBOEM7QUFBekMsT0FBSyxFQUFDO0FBQW1DLENBQTlDLEVBQTJCLGVBQTNCLEVBQXdDO0FBQUE7QUFBeEMsQzs7O0FBQW1ELE9BQUssRUFBQzs7O0FBQTRULE9BQUssRUFBQzs7O0FBQWtCLE9BQUssRUFBQzs7O2dDQUFTLGlEQUFxQyxLQUFyQyxFQUFxQztBQUFoQyxPQUFLLEVBQUM7QUFBMEIsQ0FBckMsRUFBMEIsT0FBMUIsRUFBK0I7QUFBQTtBQUEvQixDOzs7QUFBMEMsT0FBSyxFQUFDOzs7QUFBb0IsT0FBSyxFQUFDOzs7QUFBZ0UsT0FBSyxFQUFDOzs7QUFBcUIsT0FBSyxFQUFDOzs7QUFBK0QsT0FBSyxFQUFDOzs7QUFBZ0UsT0FBSyxFQUFDOzs7QUFBeUUsT0FBSyxFQUFDOzs7QUFBb0IsT0FBSyxFQUFDOzs7QUFBa0UsT0FBSyxFQUFDOzs7QUFBcUIsT0FBSyxFQUFDOzs7QUFBK0QsT0FBSyxFQUFDOzs7QUFBZ0UsT0FBSyxFQUFDOzs7QUFBeUUsT0FBSyxFQUFDOzs7QUFBb0IsT0FBSyxFQUFDOzs7QUFBOEQsT0FBSyxFQUFDOzs7QUFBcUIsT0FBSyxFQUFDOzs7QUFBK0QsT0FBSyxFQUFDOzs7QUFBZ0UsT0FBSyxFQUFDOzs7aUNBQW9FLGlEQUErRCxLQUEvRCxFQUErRDtBQUExRCxPQUFLLEVBQUM7QUFBb0QsQ0FBL0QsRUFBOEMsYUFBOUMsRUFBeUQ7QUFBQTtBQUF6RCxDOzs7QUFBNkUsT0FBSyxFQUFDOzs7QUFBd0MsT0FBSyxFQUFDOzs7QUFBNEMsT0FBSyxFQUFDOzs7QUFBNEgsT0FBSyxFQUFDOzs7Ozs7MkRBQTF3RCxvSkFBcVksS0FBclksY0FBcVksQ0FBaFgsVUFBZ1gsRUFBbFUsaURBQTRULEtBQTVULGNBQTRULENBQWxTLGlEQUEySSxLQUEzSSxrREFBMkk7QUFBdEksU0FBSyxFQUFDO0FBQWdJLEdBQTNJLEVBQTRCO0FBQUEsV0FBa0JpbkQsb0JBQVUsT0FBVkEsSUFBVSxRQUFWQSxJQUFVO0FBQTVCLEdBQTVCLEVBQXdEO0FBQTJDLFdBQUssc0NBQUVBLGtCQUFVLE9BQVo7QUFBaEQsR0FBeEQsR0FBZ0ksT0FBaEksRUFBcUk7QUFBQTtBQUFySSxHQUFrUyxFQUF2SixpREFBaUosS0FBakosa0RBQWlKO0FBQTVJLFNBQUssRUFBQztBQUFzSSxHQUFqSixFQUE0QjtBQUFBLFdBQWtCQSxvQkFBVSxTQUFWQSxJQUFVLFFBQVZBLElBQVU7QUFBNUIsR0FBNUIsRUFBd0Q7QUFBNkMsV0FBSyxzQ0FBRUEsa0JBQVUsU0FBWjtBQUFsRCxHQUF4RCxHQUFvSSxTQUFwSSxFQUEySTtBQUFBO0FBQTNJLEdBQXVKLENBQTVULENBQWtVLENBQXJZLEdBQXFZLGlEQUFnL0MsS0FBaC9DLGNBQWcvQyxDQUEzOUMsaURBQW1vQyxRQUFub0MsY0FBbW9DLENBQTVtQyxVQUE0bUMsRUFBdmtDLGlEQUFxVixLQUFyVixjQUFxVixDQUEzVCxpREFBc0UsS0FBdEUsY0FBc0UscURBQW5DLHlCQUFlLFNBQWYsQ0FBbUMsQ0FBdEUsRUFBa0Q7QUFBQTtBQUFsRCxHQUEyVCxFQUFyUCxpREFBK08sS0FBL08sY0FBK08sQ0FBcE4saURBQXFFLEtBQXJFLGVBQXFFLHFEQUF4Qyw4QkFBb0IsU0FBcEIsQ0FBd0MsQ0FBckUsRUFBaUQ7QUFBQTtBQUFqRCxHQUFvTixFQUEvSSxpREFBc0UsS0FBdEUsZUFBc0UscURBQXpDLDhCQUFvQixVQUFwQixDQUF5QyxDQUF0RSxFQUFpRDtBQUFBO0FBQWpELEdBQStJLEVBQXpFLGlEQUFtRSxLQUFuRSxlQUFtRSxxREFBdEMsOEJBQW9CLE9BQXBCLENBQXNDLENBQW5FLEVBQWlEO0FBQUE7QUFBakQsR0FBeUUsQ0FBL08sQ0FBcVAsQ0FBclYsQ0FBdWtDLEVBQWx2QixpREFBdVYsS0FBdlYsZUFBdVYsQ0FBN1QsaURBQXdFLEtBQXhFLGVBQXdFLHFEQUFyQyx5QkFBZSxXQUFmLENBQXFDLENBQXhFLEVBQWtEO0FBQUE7QUFBbEQsR0FBNlQsRUFBclAsaURBQStPLEtBQS9PLGVBQStPLENBQXBOLGlEQUFxRSxLQUFyRSxlQUFxRSxxREFBeEMsOEJBQW9CLFNBQXBCLENBQXdDLENBQXJFLEVBQWlEO0FBQUE7QUFBakQsR0FBb04sRUFBL0ksaURBQXNFLEtBQXRFLGVBQXNFLHFEQUF6Qyw4QkFBb0IsVUFBcEIsQ0FBeUMsQ0FBdEUsRUFBaUQ7QUFBQTtBQUFqRCxHQUErSSxFQUF6RSxpREFBbUUsS0FBbkUsZUFBbUUscURBQXRDLDhCQUFvQixPQUFwQixDQUFzQyxDQUFuRSxFQUFpRDtBQUFBO0FBQWpELEdBQXlFLENBQS9PLENBQXFQLENBQXZWLENBQWt2QixFQUEzWixpREFBbVYsS0FBblYsZUFBbVYsQ0FBelQsaURBQW9FLEtBQXBFLGVBQW9FLHFEQUFqQyx5QkFBZSxPQUFmLENBQWlDLENBQXBFLEVBQWtEO0FBQUE7QUFBbEQsR0FBeVQsRUFBclAsaURBQStPLEtBQS9PLGVBQStPLENBQXBOLGlEQUFxRSxLQUFyRSxlQUFxRSxxREFBeEMsOEJBQW9CLFNBQXBCLENBQXdDLENBQXJFLEVBQWlEO0FBQUE7QUFBakQsR0FBb04sRUFBL0ksaURBQXNFLEtBQXRFLGVBQXNFLHFEQUF6Qyw4QkFBb0IsVUFBcEIsQ0FBeUMsQ0FBdEUsRUFBaUQ7QUFBQTtBQUFqRCxHQUErSSxFQUF6RSxpREFBbUUsS0FBbkUsZUFBbUUscURBQXRDLDhCQUFvQixPQUFwQixDQUFzQyxDQUFuRSxFQUFpRDtBQUFBO0FBQWpELEdBQXlFLENBQS9PLENBQXFQLENBQW5WLENBQTJaLEVBQXhFLFdBQXdFLENBQW5vQyxDQUEyOUMsRyxzREFBeFYsaURBQWtWLHlDQUFsVixFQUFrVixJQUFsVixFQUE3aEQsZ0RBQWtrREMsWUFBbGtELEVBQXdqRCxNQUF4akQsSUFBOGpEOzZEQUFqQyxpREFBa1YsS0FBbFYsZUFBa1YsQ0FBcFMsaURBQWtELEtBQWxELGVBQWtELHFEQUFyQixNQUFNLENBQUMsS0FBYyxDQUFsRCxFQUF5QztBQUFBO0FBQXpDLEtBQW9TLEcsc0RBQWxQLGlEQUFrSSx5Q0FBbEksRUFBa0ksSUFBbEksRUFBN25ELGdEQUF1cUQsTUFBTSxJQUFJRCxlQUFVLEdBQWQsQ0FBN3FELEVBQThwRCxLQUE5cEQsSUFBbXFEOytEQUF0QyxpREFBa0ksS0FBbEksZUFBa0ksd0RBQXhELEtBQUssR0FBR0Esb0JBQVUsU0FBVkEsSUFBVSxHQUFWQSxJQUFVLElBQXNDLENBQWxJLEVBQTRGO0FBQUE7QUFBNUYsTztLQUE3bkQsQ0FBNm5ELEU7O0FBQUEsS0FBa1AsR0FBaEgsaURBQTBHLEtBQTFHLGVBQTBHLHFEQUE3RUEsb0JBQVUsU0FBVkEsR0FBVSxHQUFvQixNQUFNLENBQUMsYUFBYSxHQUFsREEsR0FBd0QsTUFBTSxDQUFDLEtBQWMsQ0FBMUcsRUFBaUc7QUFBQTtBQUFqRyxLQUFnSCxDQUFsVixDO0dBQTdoRCxDQUE2aEQsRTs7QUFBQSxHQUF3VixFQUFoL0MsQ0FBclksRzs7QUFBQSxHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBOztBQUVBLFNBQVNFLE9BQVQsR0FBbUI7QUFDZjtBQUNJcGpCLHlFQUFtQjtBQUN0QjtBQUNKLEMsQ0FFRDs7O0FBQ0EsSUFBSzF5QyxJQUFMLEVBQTZDO0FBQ3pDODFELFNBQU87QUFDVjs7QUFDRCxNQUFNMWxCLE9BQU8sR0FBRyxNQUFNO0FBQ2xCLE1BQUtwd0MsSUFBTCxFQUE2QztBQUN6QzhHLDBEQUFJLENBQUUsNERBQUQsR0FDQztBQUNJO0FBRk4sS0FBSjtBQUdIO0FBQ0osQ0FORDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDYkE7QUFDcUg7QUFDN0I7QUFDeEYsOEJBQThCLG1GQUEyQixDQUFDLHdHQUFxQztBQUMvRjtBQUNBLGdEQUFnRCw4QkFBOEIsdUJBQXVCLGNBQWMsR0FBRyxTQUFTLDJFQUEyRSxZQUFZLFlBQVksVUFBVSwrR0FBK0c7QUFDM1Y7QUFDQSxpRUFBZSx1QkFBdUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNQdkM7QUFDcUg7QUFDN0I7QUFDeEYsOEJBQThCLG1GQUEyQixDQUFDLHdHQUFxQztBQUMvRjtBQUNBLG9EQUFvRCx3QkFBd0Isc0JBQXNCLHdCQUF3QixHQUFHLFNBQVMsOEVBQThFLFdBQVcsV0FBVyxXQUFXLHFQQUFxUCw4REFBOEQsMkVBQTJFLGdFQUFnRSx3TEFBd0wsb0JBQW9CLE1BQU0sS0FBSywyRkFBMkYseUJBQXlCLE1BQU0sS0FBSyxvSEFBb0gsZ0JBQWdCLGdEQUFnRCxXQUFXLFFBQVEsSUFBSSxNQUFNLEVBQUUsc0NBQXNDLElBQUksd0JBQXdCLCtCQUErQixxQkFBcUIsb0JBQW9CLHdHQUF3Ryw4QkFBOEIsb0JBQW9CLDBCQUEwQixrQkFBa0IsV0FBVyxVQUFVLE9BQU8sZUFBZSw0QkFBNEIsT0FBTyxTQUFTLDZDQUE2QyxLQUFLLGlCQUFpQixzREFBc0QscUJBQXFCLGlDQUFpQyxNQUFNLG9DQUFvQyxrQ0FBa0MsNkJBQTZCLHF0QkFBcXRCLEVBQUUsS0FBSyxxQkFBcUIsR0FBRyxtQ0FBbUMsK0RBQStELHlDQUF5QyxHQUFHLDBDQUEwQyw4Q0FBOEMscUNBQXFDLEdBQUcsOEJBQThCLGNBQWMscUNBQXFDLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRywwNURBQTA1RDtBQUMvNUo7QUFDQSxpRUFBZSx1QkFBdUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNQdkM7QUFDcUg7QUFDN0I7QUFDeEYsOEJBQThCLG1GQUEyQixDQUFDLHdHQUFxQztBQUMvRjtBQUNBLGlFQUFpRSwyQkFBMkIsbUJBQW1CLG9CQUFvQix5QkFBeUIsaUJBQWlCLGtCQUFrQiw0QkFBNEIsd0JBQXdCLEdBQUcsZ0NBQWdDLDhCQUE4QixnQkFBZ0IsR0FBRyw2QkFBNkIsd0JBQXdCLGtCQUFrQixHQUFHLG1DQUFtQyxzQkFBc0IsdUJBQXVCLGtCQUFrQix3QkFBd0IsR0FBRyxrQ0FBa0Msa0JBQWtCLEdBQUcsaUNBQWlDLGlCQUFpQixHQUFHLDZDQUE2QyxnQ0FBZ0MsbUNBQW1DLEdBQUcsNENBQTRDLGlDQUFpQyxvQ0FBb0MsR0FBRyxvQ0FBb0MsbUJBQW1CLHNCQUFzQix3QkFBd0Isa0JBQWtCLEdBQUcsNEJBQTRCLDJCQUEyQix1QkFBdUIsdUJBQXVCLGlCQUFpQixrQkFBa0Isd0JBQXdCLEdBQUcsdUNBQXVDLHFCQUFxQixHQUFHLGtDQUFrQyxpQkFBaUIsYUFBYSxrQkFBa0Isd0JBQXdCLDRCQUE0QixHQUFHLGtDQUFrQyx1QkFBdUIsaUJBQWlCLGtCQUFrQix3QkFBd0IsR0FBRyxrQ0FBa0MsaUJBQWlCLHdCQUF3QixtQ0FBbUMsa0JBQWtCLDJCQUEyQixHQUFHLHdDQUF3QyxpQkFBaUIscUNBQXFDLGtCQUFrQiw0QkFBNEIsd0JBQXdCLEdBQUcsbUNBQW1DLGlCQUFpQixrQkFBa0IsR0FBRyxrQ0FBa0MsaUJBQWlCLGtCQUFrQiw0QkFBNEIsd0JBQXdCLEdBQUcsa0NBQWtDLHVCQUF1Qix3QkFBd0IsdUJBQXVCLGlCQUFpQixrQkFBa0IsOEJBQThCLHdCQUF3QixHQUFHLHlDQUF5QyxtQkFBbUIsbUNBQW1DLDRCQUE0QixHQUFHLFNBQVMsOEVBQThFLFlBQVksV0FBVyxVQUFVLFdBQVcsVUFBVSxVQUFVLFlBQVksWUFBWSxLQUFLLEtBQUssWUFBWSxXQUFXLEtBQUssS0FBSyxXQUFXLFVBQVUsS0FBSyxLQUFLLFdBQVcsV0FBVyxVQUFVLFdBQVcsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxhQUFhLE1BQU0sS0FBSyxVQUFVLFdBQVcsV0FBVyxVQUFVLEtBQUssS0FBSyxZQUFZLFlBQVksV0FBVyxVQUFVLFVBQVUsV0FBVyxLQUFLLEtBQUssV0FBVyxNQUFNLEtBQUssVUFBVSxVQUFVLFVBQVUsV0FBVyxZQUFZLE1BQU0sS0FBSyxXQUFXLFVBQVUsVUFBVSxXQUFXLEtBQUssS0FBSyxVQUFVLFdBQVcsV0FBVyxVQUFVLFdBQVcsTUFBTSxLQUFLLFVBQVUsV0FBVyxVQUFVLFlBQVksWUFBWSxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsWUFBWSxZQUFZLEtBQUssS0FBSyxXQUFXLFdBQVcsV0FBVyxVQUFVLFVBQVUsWUFBWSxZQUFZLEtBQUssS0FBSyxVQUFVLFdBQVcsWUFBWSxxUEFBcVAsOERBQThELDJFQUEyRSxnRUFBZ0Usd0xBQXdMLG9CQUFvQixNQUFNLEtBQUssMkZBQTJGLHlCQUF5QixNQUFNLEtBQUssb0hBQW9ILGdCQUFnQixnREFBZ0QsV0FBVyxRQUFRLElBQUksTUFBTSxFQUFFLHNDQUFzQyxJQUFJLHdCQUF3QiwrQkFBK0IscUJBQXFCLG9CQUFvQix3R0FBd0csOEJBQThCLG9CQUFvQiwwQkFBMEIsa0JBQWtCLFdBQVcsVUFBVSxPQUFPLGVBQWUsNEJBQTRCLE9BQU8sU0FBUyw2Q0FBNkMsS0FBSyxpQkFBaUIsc0RBQXNELHFCQUFxQixpQ0FBaUMsTUFBTSxvQ0FBb0Msa0NBQWtDLDZCQUE2QixxdEJBQXF0QixFQUFFLEtBQUsscUJBQXFCLEdBQUcsbUNBQW1DLCtEQUErRCx5Q0FBeUMsR0FBRywwQ0FBMEMsOENBQThDLHFDQUFxQyxHQUFHLDhCQUE4QixjQUFjLHFDQUFxQyxFQUFFLGdCQUFnQixFQUFFLEdBQUcsMDVEQUEwNUQ7QUFDeDZQO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTnZDLE1BQThGO0FBQzlGLE1BQW9GO0FBQ3BGLE1BQXFGO0FBQ3JGLE1BQXVHO0FBQ3ZHLE1BQTBJOzs7O0FBSTFJOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxDQUFJOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJGQUFTOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsK0ZBQU07QUFDdkIsNkJBQTZCLHNHQUFrQjs7QUFFL0MsYUFBYSwwR0FBRyxDQUFDLHlIQUFPOzs7O0FBSW9GO0FBQzVHLE9BQU8saUVBQWUseUhBQU8sSUFBSSxnSUFBYyxHQUFHLGdJQUFjLFlBQVksRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoRDdFLE1BQThGO0FBQzlGLE1BQW9GO0FBQ3BGLE1BQXFGO0FBQ3JGLE1BQXVHO0FBQ3ZHLE1BQWtUOzs7O0FBSWxUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxDQUFJOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJGQUFTOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsK0ZBQU07QUFDdkIsNkJBQTZCLHNHQUFrQjs7QUFFL0MsYUFBYSwwR0FBRyxDQUFDLHlSQUFPOzs7O0FBSTRQO0FBQ3BSLE9BQU8saUVBQWUseVJBQU8sSUFBSSxnU0FBYyxHQUFHLGdTQUFjLFlBQVksRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoRDdFLE1BQThGO0FBQzlGLE1BQW9GO0FBQ3BGLE1BQXFGO0FBQ3JGLE1BQXVHO0FBQ3ZHLE1BQThUOzs7O0FBSTlUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxDQUFJOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJGQUFTOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsK0ZBQU07QUFDdkIsNkJBQTZCLHNHQUFrQjs7QUFFL0MsYUFBYSwwR0FBRyxDQUFDLHFTQUFPOzs7O0FBSXdRO0FBQ2hTLE9BQU8saUVBQWUscVNBQU8sSUFBSSw0U0FBYyxHQUFHLDRTQUFjLFlBQVksRUFBQzs7Ozs7Ozs7Ozs7O0FDakRoRTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCOzs7Ozs7Ozs7OztBQzFCYTs7QUFFYjs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQiw2QkFBNkI7QUFDakQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEU7Ozs7Ozs7Ozs7O0FDaEdhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7Ozs7OztBQ1ZhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pELEdBQUc7O0FBRUg7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9DeUY7QUFDL0I7QUFDTDs7QUFFckQsQ0FBcUU7QUFDWTtBQUNqRixnRkFBYSxHQUFHLG1HQUFNO0FBQ3RCLG1GQUFnQjtBQUNoQjtBQUNBLElBQUksS0FBVSxFQUFFLEVBWWY7O0FBRUQsZ0ZBQWE7O0FBRWIsaUVBQWUseUU7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QnFMLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztVQ0FwTTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsZ0NBQWdDLFlBQVk7V0FDNUM7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esd0NBQXdDLHlDQUF5QztXQUNqRjtXQUNBO1dBQ0EsRTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRjtXQUNBO1dBQ0EsQ0FBQyxJOzs7OztXQ1BELHdGOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHNEQUFzRCxrQkFBa0I7V0FDeEU7V0FDQSwrQ0FBK0MsY0FBYztXQUM3RCxFOzs7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUVBO0FBQ0E7QUFFQTZ6Qiw4Q0FBUyxDQUFDbzdCLDZDQUFELENBQVQsQ0FBbUJuNkIsS0FBbkIsQ0FBeUIsTUFBekIsRSIsImZpbGUiOiJhcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFTVBUWV9PQkosIGlzQXJyYXksIGlzTWFwLCBpc0ludGVnZXJLZXksIGlzU3ltYm9sLCBleHRlbmQsIGhhc093biwgaXNPYmplY3QsIGhhc0NoYW5nZWQsIG1ha2VNYXAsIGNhcGl0YWxpemUsIHRvUmF3VHlwZSwgZGVmLCBpc0Z1bmN0aW9uLCBOT09QIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCB0YXJnZXRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBlZmZlY3RTdGFjayA9IFtdO1xyXG5sZXQgYWN0aXZlRWZmZWN0O1xyXG5jb25zdCBJVEVSQVRFX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnaXRlcmF0ZScgOiAnJyk7XHJcbmNvbnN0IE1BUF9LRVlfSVRFUkFURV9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ01hcCBrZXkgaXRlcmF0ZScgOiAnJyk7XHJcbmZ1bmN0aW9uIGlzRWZmZWN0KGZuKSB7XHJcbiAgICByZXR1cm4gZm4gJiYgZm4uX2lzRWZmZWN0ID09PSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGVmZmVjdChmbiwgb3B0aW9ucyA9IEVNUFRZX09CSikge1xyXG4gICAgaWYgKGlzRWZmZWN0KGZuKSkge1xyXG4gICAgICAgIGZuID0gZm4ucmF3O1xyXG4gICAgfVxyXG4gICAgY29uc3QgZWZmZWN0ID0gY3JlYXRlUmVhY3RpdmVFZmZlY3QoZm4sIG9wdGlvbnMpO1xyXG4gICAgaWYgKCFvcHRpb25zLmxhenkpIHtcclxuICAgICAgICBlZmZlY3QoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlZmZlY3Q7XHJcbn1cclxuZnVuY3Rpb24gc3RvcChlZmZlY3QpIHtcclxuICAgIGlmIChlZmZlY3QuYWN0aXZlKSB7XHJcbiAgICAgICAgY2xlYW51cChlZmZlY3QpO1xyXG4gICAgICAgIGlmIChlZmZlY3Qub3B0aW9ucy5vblN0b3ApIHtcclxuICAgICAgICAgICAgZWZmZWN0Lm9wdGlvbnMub25TdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVmZmVjdC5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5sZXQgdWlkID0gMDtcclxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVFZmZlY3QoZm4sIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGVmZmVjdCA9IGZ1bmN0aW9uIHJlYWN0aXZlRWZmZWN0KCkge1xyXG4gICAgICAgIGlmICghZWZmZWN0LmFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFlZmZlY3RTdGFjay5pbmNsdWRlcyhlZmZlY3QpKSB7XHJcbiAgICAgICAgICAgIGNsZWFudXAoZWZmZWN0KTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGVuYWJsZVRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3RTdGFjay5wdXNoKGVmZmVjdCk7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3QgPSBlZmZlY3Q7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIGVmZmVjdFN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0ID0gZWZmZWN0U3RhY2tbZWZmZWN0U3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZWZmZWN0LmlkID0gdWlkKys7XHJcbiAgICBlZmZlY3QuYWxsb3dSZWN1cnNlID0gISFvcHRpb25zLmFsbG93UmVjdXJzZTtcclxuICAgIGVmZmVjdC5faXNFZmZlY3QgPSB0cnVlO1xyXG4gICAgZWZmZWN0LmFjdGl2ZSA9IHRydWU7XHJcbiAgICBlZmZlY3QucmF3ID0gZm47XHJcbiAgICBlZmZlY3QuZGVwcyA9IFtdO1xyXG4gICAgZWZmZWN0Lm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgcmV0dXJuIGVmZmVjdDtcclxufVxyXG5mdW5jdGlvbiBjbGVhbnVwKGVmZmVjdCkge1xyXG4gICAgY29uc3QgeyBkZXBzIH0gPSBlZmZlY3Q7XHJcbiAgICBpZiAoZGVwcy5sZW5ndGgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGVwc1tpXS5kZWxldGUoZWZmZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVwcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG59XHJcbmxldCBzaG91bGRUcmFjayA9IHRydWU7XHJcbmNvbnN0IHRyYWNrU3RhY2sgPSBbXTtcclxuZnVuY3Rpb24gcGF1c2VUcmFja2luZygpIHtcclxuICAgIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XHJcbiAgICBzaG91bGRUcmFjayA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGVuYWJsZVRyYWNraW5nKCkge1xyXG4gICAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcclxuICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiByZXNldFRyYWNraW5nKCkge1xyXG4gICAgY29uc3QgbGFzdCA9IHRyYWNrU3RhY2sucG9wKCk7XHJcbiAgICBzaG91bGRUcmFjayA9IGxhc3QgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBsYXN0O1xyXG59XHJcbmZ1bmN0aW9uIHRyYWNrKHRhcmdldCwgdHlwZSwga2V5KSB7XHJcbiAgICBpZiAoIXNob3VsZFRyYWNrIHx8IGFjdGl2ZUVmZmVjdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICBpZiAoIWRlcHNNYXApIHtcclxuICAgICAgICB0YXJnZXRNYXAuc2V0KHRhcmdldCwgKGRlcHNNYXAgPSBuZXcgTWFwKCkpKTtcclxuICAgIH1cclxuICAgIGxldCBkZXAgPSBkZXBzTWFwLmdldChrZXkpO1xyXG4gICAgaWYgKCFkZXApIHtcclxuICAgICAgICBkZXBzTWFwLnNldChrZXksIChkZXAgPSBuZXcgU2V0KCkpKTtcclxuICAgIH1cclxuICAgIGlmICghZGVwLmhhcyhhY3RpdmVFZmZlY3QpKSB7XHJcbiAgICAgICAgZGVwLmFkZChhY3RpdmVFZmZlY3QpO1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdC5kZXBzLnB1c2goZGVwKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGFjdGl2ZUVmZmVjdC5vcHRpb25zLm9uVHJhY2spIHtcclxuICAgICAgICAgICAgYWN0aXZlRWZmZWN0Lm9wdGlvbnMub25UcmFjayh7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3Q6IGFjdGl2ZUVmZmVjdCxcclxuICAgICAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICBrZXlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0KSB7XHJcbiAgICBjb25zdCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgaWYgKCFkZXBzTWFwKSB7XHJcbiAgICAgICAgLy8gbmV2ZXIgYmVlbiB0cmFja2VkXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZWZmZWN0cyA9IG5ldyBTZXQoKTtcclxuICAgIGNvbnN0IGFkZCA9IChlZmZlY3RzVG9BZGQpID0+IHtcclxuICAgICAgICBpZiAoZWZmZWN0c1RvQWRkKSB7XHJcbiAgICAgICAgICAgIGVmZmVjdHNUb0FkZC5mb3JFYWNoKGVmZmVjdCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0ICE9PSBhY3RpdmVFZmZlY3QgfHwgZWZmZWN0LmFsbG93UmVjdXJzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHMuYWRkKGVmZmVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpZiAodHlwZSA9PT0gXCJjbGVhclwiIC8qIENMRUFSICovKSB7XHJcbiAgICAgICAgLy8gY29sbGVjdGlvbiBiZWluZyBjbGVhcmVkXHJcbiAgICAgICAgLy8gdHJpZ2dlciBhbGwgZWZmZWN0cyBmb3IgdGFyZ2V0XHJcbiAgICAgICAgZGVwc01hcC5mb3JFYWNoKGFkZCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChrZXkgPT09ICdsZW5ndGgnICYmIGlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgIGRlcHNNYXAuZm9yRWFjaCgoZGVwLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2xlbmd0aCcgfHwga2V5ID49IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBhZGQoZGVwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc2NoZWR1bGUgcnVucyBmb3IgU0VUIHwgQUREIHwgREVMRVRFXHJcbiAgICAgICAgaWYgKGtleSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWxzbyBydW4gZm9yIGl0ZXJhdGlvbiBrZXkgb24gQUREIHwgREVMRVRFIHwgTWFwLlNFVFxyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiYWRkXCIgLyogQUREICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSW50ZWdlcktleShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV3IGluZGV4IGFkZGVkIHRvIGFycmF5IC0+IGxlbmd0aCBjaGFuZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KCdsZW5ndGgnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVwiIC8qIERFTEVURSAqLzpcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInNldFwiIC8qIFNFVCAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBydW4gPSAoZWZmZWN0KSA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBlZmZlY3Qub3B0aW9ucy5vblRyaWdnZXIpIHtcclxuICAgICAgICAgICAgZWZmZWN0Lm9wdGlvbnMub25UcmlnZ2VyKHtcclxuICAgICAgICAgICAgICAgIGVmZmVjdCxcclxuICAgICAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgb2xkVGFyZ2V0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWZmZWN0Lm9wdGlvbnMuc2NoZWR1bGVyKSB7XHJcbiAgICAgICAgICAgIGVmZmVjdC5vcHRpb25zLnNjaGVkdWxlcihlZmZlY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWZmZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGVmZmVjdHMuZm9yRWFjaChydW4pO1xyXG59XG5cbmNvbnN0IGlzTm9uVHJhY2thYmxlS2V5cyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgX19wcm90b19fLF9fdl9pc1JlZixfX2lzVnVlYCk7XHJcbmNvbnN0IGJ1aWx0SW5TeW1ib2xzID0gbmV3IFNldChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhTeW1ib2wpXHJcbiAgICAubWFwKGtleSA9PiBTeW1ib2xba2V5XSlcclxuICAgIC5maWx0ZXIoaXNTeW1ib2wpKTtcclxuY29uc3QgZ2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIoKTtcclxuY29uc3Qgc2hhbGxvd0dldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKGZhbHNlLCB0cnVlKTtcclxuY29uc3QgcmVhZG9ubHlHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcih0cnVlKTtcclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIodHJ1ZSwgdHJ1ZSk7XHJcbmNvbnN0IGFycmF5SW5zdHJ1bWVudGF0aW9ucyA9IC8qI19fUFVSRV9fKi8gY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zKCk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5SW5zdHJ1bWVudGF0aW9ucygpIHtcclxuICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSB7fTtcclxuICAgIFsnaW5jbHVkZXMnLCAnaW5kZXhPZicsICdsYXN0SW5kZXhPZiddLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBjb25zdCBtZXRob2QgPSBBcnJheS5wcm90b3R5cGVba2V5XTtcclxuICAgICAgICBpbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICBjb25zdCBhcnIgPSB0b1Jhdyh0aGlzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdHJhY2soYXJyLCBcImdldFwiIC8qIEdFVCAqLywgaSArICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB3ZSBydW4gdGhlIG1ldGhvZCB1c2luZyB0aGUgb3JpZ2luYWwgYXJncyBmaXJzdCAod2hpY2ggbWF5IGJlIHJlYWN0aXZlKVxyXG4gICAgICAgICAgICBjb25zdCByZXMgPSBtZXRob2QuYXBwbHkoYXJyLCBhcmdzKTtcclxuICAgICAgICAgICAgaWYgKHJlcyA9PT0gLTEgfHwgcmVzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhhdCBkaWRuJ3Qgd29yaywgcnVuIGl0IGFnYWluIHVzaW5nIHJhdyB2YWx1ZXMuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KGFyciwgYXJncy5tYXAodG9SYXcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3Vuc2hpZnQnLCAnc3BsaWNlJ10uZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IEFycmF5LnByb3RvdHlwZVtrZXldO1xyXG4gICAgICAgIGluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbnM7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlR2V0dGVyKGlzUmVhZG9ubHkgPSBmYWxzZSwgc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiIC8qIFJBVyAqLyAmJlxyXG4gICAgICAgICAgICByZWNlaXZlciA9PT1cclxuICAgICAgICAgICAgICAgIChpc1JlYWRvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2hhbGxvd1JlYWRvbmx5TWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVhZG9ubHlNYXBcclxuICAgICAgICAgICAgICAgICAgICA6IHNoYWxsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93UmVhY3RpdmVNYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWFjdGl2ZU1hcCkuZ2V0KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIWlzUmVhZG9ubHkgJiYgdGFyZ2V0SXNBcnJheSAmJiBoYXNPd24oYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldChhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIGlmIChpc1N5bWJvbChrZXkpID8gYnVpbHRJblN5bWJvbHMuaGFzKGtleSkgOiBpc05vblRyYWNrYWJsZUtleXMoa2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzUmVhZG9ubHkpIHtcclxuICAgICAgICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiIC8qIEdFVCAqLywga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYWxsb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzUmVmKHJlcykpIHtcclxuICAgICAgICAgICAgLy8gcmVmIHVud3JhcHBpbmcgLSBkb2VzIG5vdCBhcHBseSBmb3IgQXJyYXkgKyBpbnRlZ2VyIGtleS5cclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkVW53cmFwID0gIXRhcmdldElzQXJyYXkgfHwgIWlzSW50ZWdlcktleShrZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2hvdWxkVW53cmFwID8gcmVzLnZhbHVlIDogcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHJldHVybmVkIHZhbHVlIGludG8gYSBwcm94eSBhcyB3ZWxsLiB3ZSBkbyB0aGUgaXNPYmplY3QgY2hlY2tcclxuICAgICAgICAgICAgLy8gaGVyZSB0byBhdm9pZCBpbnZhbGlkIHZhbHVlIHdhcm5pbmcuIEFsc28gbmVlZCB0byBsYXp5IGFjY2VzcyByZWFkb25seVxyXG4gICAgICAgICAgICAvLyBhbmQgcmVhY3RpdmUgaGVyZSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5LlxyXG4gICAgICAgICAgICByZXR1cm4gaXNSZWFkb25seSA/IHJlYWRvbmx5KHJlcykgOiByZWFjdGl2ZShyZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBzZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNldHRlcigpO1xyXG5jb25zdCBzaGFsbG93U2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVTZXR0ZXIodHJ1ZSk7XHJcbmZ1bmN0aW9uIGNyZWF0ZVNldHRlcihzaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBzZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xyXG4gICAgICAgIGxldCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gICAgICAgIGlmICghc2hhbGxvdykge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgICAgICAgICAgb2xkVmFsdWUgPSB0b1JhdyhvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGFkS2V5ID0gaXNBcnJheSh0YXJnZXQpICYmIGlzSW50ZWdlcktleShrZXkpXHJcbiAgICAgICAgICAgID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoXHJcbiAgICAgICAgICAgIDogaGFzT3duKHRhcmdldCwga2V5KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcclxuICAgICAgICAvLyBkb24ndCB0cmlnZ2VyIGlmIHRhcmdldCBpcyBzb21ldGhpbmcgdXAgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBvZiBvcmlnaW5hbFxyXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRvUmF3KHJlY2VpdmVyKSkge1xyXG4gICAgICAgICAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogQUREICovLCBrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiIC8qIFNFVCAqLywga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XHJcbiAgICBjb25zdCBoYWRLZXkgPSBoYXNPd24odGFyZ2V0LCBrZXkpO1xyXG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKHJlc3VsdCAmJiBoYWRLZXkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiAvKiBERUxFVEUgKi8sIGtleSwgdW5kZWZpbmVkLCBvbGRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGhhcyh0YXJnZXQsIGtleSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5oYXModGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKCFpc1N5bWJvbChrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xyXG4gICAgICAgIHRyYWNrKHRhcmdldCwgXCJoYXNcIiAvKiBIQVMgKi8sIGtleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XHJcbiAgICB0cmFjayh0YXJnZXQsIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIGlzQXJyYXkodGFyZ2V0KSA/ICdsZW5ndGgnIDogSVRFUkFURV9LRVkpO1xyXG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xyXG59XHJcbmNvbnN0IG11dGFibGVIYW5kbGVycyA9IHtcclxuICAgIGdldCxcclxuICAgIHNldCxcclxuICAgIGRlbGV0ZVByb3BlcnR5LFxyXG4gICAgaGFzLFxyXG4gICAgb3duS2V5c1xyXG59O1xyXG5jb25zdCByZWFkb25seUhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiByZWFkb25seUdldCxcclxuICAgIHNldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBTZXQgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRGVsZXRlIG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBtdXRhYmxlSGFuZGxlcnMsIHtcclxuICAgIGdldDogc2hhbGxvd0dldCxcclxuICAgIHNldDogc2hhbGxvd1NldFxyXG59KTtcclxuLy8gUHJvcHMgaGFuZGxlcnMgYXJlIHNwZWNpYWwgaW4gdGhlIHNlbnNlIHRoYXQgaXQgc2hvdWxkIG5vdCB1bndyYXAgdG9wLWxldmVsXHJcbi8vIHJlZnMgKGluIG9yZGVyIHRvIGFsbG93IHJlZnMgdG8gYmUgZXhwbGljaXRseSBwYXNzZWQgZG93biksIGJ1dCBzaG91bGRcclxuLy8gcmV0YWluIHRoZSByZWFjdGl2aXR5IG9mIHRoZSBub3JtYWwgcmVhZG9ubHkgb2JqZWN0LlxyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCByZWFkb25seUhhbmRsZXJzLCB7XHJcbiAgICBnZXQ6IHNoYWxsb3dSZWFkb25seUdldFxyXG59KTtcblxuY29uc3QgdG9SZWFjdGl2ZSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhY3RpdmUodmFsdWUpIDogdmFsdWU7XHJcbmNvbnN0IHRvUmVhZG9ubHkgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWRvbmx5KHZhbHVlKSA6IHZhbHVlO1xyXG5jb25zdCB0b1NoYWxsb3cgPSAodmFsdWUpID0+IHZhbHVlO1xyXG5jb25zdCBnZXRQcm90byA9ICh2KSA9PiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHYpO1xyXG5mdW5jdGlvbiBnZXQkMSh0YXJnZXQsIGtleSwgaXNSZWFkb25seSA9IGZhbHNlLCBpc1NoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgLy8gIzE3NzI6IHJlYWRvbmx5KHJlYWN0aXZlKE1hcCkpIHNob3VsZCByZXR1cm4gcmVhZG9ubHkgKyByZWFjdGl2ZSB2ZXJzaW9uXHJcbiAgICAvLyBvZiB0aGUgdmFsdWVcclxuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcclxuICAgICAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiIC8qIEdFVCAqLywgcmF3S2V5KTtcclxuICAgIGNvbnN0IHsgaGFzIH0gPSBnZXRQcm90byhyYXdUYXJnZXQpO1xyXG4gICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcclxuICAgIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIGtleSkpIHtcclxuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KGtleSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCByYXdLZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChyYXdLZXkpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRhcmdldCAhPT0gcmF3VGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gIzM2MDIgcmVhZG9ubHkocmVhY3RpdmUoTWFwKSlcclxuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgbmVzdGVkIHJlYWN0aXZlIGBNYXBgIGNhbiBkbyB0cmFja2luZyBmb3IgaXRzZWxmXHJcbiAgICAgICAgdGFyZ2V0LmdldChrZXkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhcyQxKGtleSwgaXNSZWFkb25seSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiAvKiBIQVMgKi8sIGtleSk7XHJcbiAgICB9XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIgLyogSEFTICovLCByYXdLZXkpO1xyXG4gICAgcmV0dXJuIGtleSA9PT0gcmF3S2V5XHJcbiAgICAgICAgPyB0YXJnZXQuaGFzKGtleSlcclxuICAgICAgICA6IHRhcmdldC5oYXMoa2V5KSB8fCB0YXJnZXQuaGFzKHJhd0tleSk7XHJcbn1cclxuZnVuY3Rpb24gc2l6ZSh0YXJnZXQsIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayh0b1Jhdyh0YXJnZXQpLCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBJVEVSQVRFX0tFWSk7XHJcbiAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCAnc2l6ZScsIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gYWRkKHZhbHVlKSB7XHJcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgcHJvdG8gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gICAgY29uc3QgaGFkS2V5ID0gcHJvdG8uaGFzLmNhbGwodGFyZ2V0LCB2YWx1ZSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIHRhcmdldC5hZGQodmFsdWUpO1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIEFERCAqLywgdmFsdWUsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcbmZ1bmN0aW9uIHNldCQxKGtleSwgdmFsdWUpIHtcclxuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCB7IGhhcywgZ2V0IH0gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcclxuICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgdGFyZ2V0LnNldChrZXksIHZhbHVlKTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogQUREICovLCBrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiIC8qIFNFVCAqLywga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuZnVuY3Rpb24gZGVsZXRlRW50cnkoa2V5KSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XHJcbiAgICBsZXQgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQgPyBnZXQuY2FsbCh0YXJnZXQsIGtleSkgOiB1bmRlZmluZWQ7XHJcbiAgICAvLyBmb3J3YXJkIHRoZSBvcGVyYXRpb24gYmVmb3JlIHF1ZXVlaW5nIHJlYWN0aW9uc1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmRlbGV0ZShrZXkpO1xyXG4gICAgaWYgKGhhZEtleSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiIC8qIERFTEVURSAqLywga2V5LCB1bmRlZmluZWQsIG9sZFZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY2xlYXIoKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IGhhZEl0ZW1zID0gdGFyZ2V0LnNpemUgIT09IDA7XHJcbiAgICBjb25zdCBvbGRUYXJnZXQgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICA/IGlzTWFwKHRhcmdldClcclxuICAgICAgICAgICAgPyBuZXcgTWFwKHRhcmdldClcclxuICAgICAgICAgICAgOiBuZXcgU2V0KHRhcmdldClcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIC8vIGZvcndhcmQgdGhlIG9wZXJhdGlvbiBiZWZvcmUgcXVldWVpbmcgcmVhY3Rpb25zXHJcbiAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcclxuICAgIGlmIChoYWRJdGVtcykge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImNsZWFyXCIgLyogQ0xFQVIgKi8sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGRUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGb3JFYWNoKGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcclxuICAgICAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gb2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XHJcbiAgICAgICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBJVEVSQVRFX0tFWSk7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGltcG9ydGFudDogbWFrZSBzdXJlIHRoZSBjYWxsYmFjayBpc1xyXG4gICAgICAgICAgICAvLyAxLiBpbnZva2VkIHdpdGggdGhlIHJlYWN0aXZlIG1hcCBhcyBgdGhpc2AgYW5kIDNyZCBhcmdcclxuICAgICAgICAgICAgLy8gMi4gdGhlIHZhbHVlIHJlY2VpdmVkIHNob3VsZCBiZSBhIGNvcnJlc3BvbmRpbmcgcmVhY3RpdmUvcmVhZG9ubHkuXHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHdyYXAodmFsdWUpLCB3cmFwKGtleSksIG9ic2VydmVkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldElzTWFwID0gaXNNYXAocmF3VGFyZ2V0KTtcclxuICAgICAgICBjb25zdCBpc1BhaXIgPSBtZXRob2QgPT09ICdlbnRyaWVzJyB8fCAobWV0aG9kID09PSBTeW1ib2wuaXRlcmF0b3IgJiYgdGFyZ2V0SXNNYXApO1xyXG4gICAgICAgIGNvbnN0IGlzS2V5T25seSA9IG1ldGhvZCA9PT0gJ2tleXMnICYmIHRhcmdldElzTWFwO1xyXG4gICAgICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0YXJnZXRbbWV0aG9kXSguLi5hcmdzKTtcclxuICAgICAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmXHJcbiAgICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgaXNLZXlPbmx5ID8gTUFQX0tFWV9JVEVSQVRFX0tFWSA6IElURVJBVEVfS0VZKTtcclxuICAgICAgICAvLyByZXR1cm4gYSB3cmFwcGVkIGl0ZXJhdG9yIHdoaWNoIHJldHVybnMgb2JzZXJ2ZWQgdmVyc2lvbnMgb2YgdGhlXHJcbiAgICAgICAgLy8gdmFsdWVzIGVtaXR0ZWQgZnJvbSB0aGUgcmVhbCBpdGVyYXRvclxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdG9yIHByb3RvY29sXHJcbiAgICAgICAgICAgIG5leHQoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgPyB7IHZhbHVlLCBkb25lIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlzUGFpciA/IFt3cmFwKHZhbHVlWzBdKSwgd3JhcCh2YWx1ZVsxXSldIDogd3JhcCh2YWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBpdGVyYWJsZSBwcm90b2NvbFxyXG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHlNZXRob2QodHlwZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhcmdzWzBdID8gYG9uIGtleSBcIiR7YXJnc1swXX1cIiBgIDogYGA7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtjYXBpdGFsaXplKHR5cGUpfSBvcGVyYXRpb24gJHtrZXl9ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdG9SYXcodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJkZWxldGVcIiAvKiBERUxFVEUgKi8gPyBmYWxzZSA6IHRoaXM7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoKSB7XHJcbiAgICBjb25zdCBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgICAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzOiBoYXMkMSxcclxuICAgICAgICBhZGQsXHJcbiAgICAgICAgc2V0OiBzZXQkMSxcclxuICAgICAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxyXG4gICAgICAgIGNsZWFyLFxyXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIGZhbHNlKVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgICAgIGdldChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzOiBoYXMkMSxcclxuICAgICAgICBhZGQsXHJcbiAgICAgICAgc2V0OiBzZXQkMSxcclxuICAgICAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxyXG4gICAgICAgIGNsZWFyLFxyXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIHRydWUpXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgICAgIGdldChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYXMkMS5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIgLyogQUREICovKSxcclxuICAgICAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIgLyogU0VUICovKSxcclxuICAgICAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIgLyogREVMRVRFICovKSxcclxuICAgICAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiIC8qIENMRUFSICovKSxcclxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIGZhbHNlKVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgICAgICAgZ2V0KGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhcyhrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhcyQxLmNhbGwodGhpcywga2V5LCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiAvKiBBREQgKi8pLFxyXG4gICAgICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiAvKiBTRVQgKi8pLFxyXG4gICAgICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiAvKiBERUxFVEUgKi8pLFxyXG4gICAgICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIgLyogQ0xFQVIgKi8pLFxyXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgdHJ1ZSlcclxuICAgIH07XHJcbiAgICBjb25zdCBpdGVyYXRvck1ldGhvZHMgPSBbJ2tleXMnLCAndmFsdWVzJywgJ2VudHJpZXMnLCBTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaXRlcmF0b3JNZXRob2RzLmZvckVhY2gobWV0aG9kID0+IHtcclxuICAgICAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMsXHJcbiAgICAgICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zLFxyXG4gICAgICAgIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zLFxyXG4gICAgICAgIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNcclxuICAgIF07XHJcbn1cclxuY29uc3QgW211dGFibGVJbnN0cnVtZW50YXRpb25zLCByZWFkb25seUluc3RydW1lbnRhdGlvbnMsIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zLCBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXSA9IC8qICNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoKTtcclxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGlzUmVhZG9ubHksIHNoYWxsb3cpIHtcclxuICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSBzaGFsbG93XHJcbiAgICAgICAgPyBpc1JlYWRvbmx5XHJcbiAgICAgICAgICAgID8gc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgICAgICA6IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgOiBpc1JlYWRvbmx5XHJcbiAgICAgICAgICAgID8gcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgICAgIDogbXV0YWJsZUluc3RydW1lbnRhdGlvbnM7XHJcbiAgICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiIC8qIFJBVyAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoaGFzT3duKGluc3RydW1lbnRhdGlvbnMsIGtleSkgJiYga2V5IGluIHRhcmdldFxyXG4gICAgICAgICAgICA/IGluc3RydW1lbnRhdGlvbnNcclxuICAgICAgICAgICAgOiB0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXHJcbn07XHJcbmNvbnN0IHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCB0cnVlKVxyXG59O1xyXG5jb25zdCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICAgIGdldDogLyojX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXHJcbn07XHJcbmNvbnN0IHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICAgIGdldDogLyojX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgdHJ1ZSlcclxufTtcclxuZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSkge1xyXG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgIGlmIChyYXdLZXkgIT09IGtleSAmJiBoYXMuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHRhcmdldCk7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBSZWFjdGl2ZSAke3R5cGV9IGNvbnRhaW5zIGJvdGggdGhlIHJhdyBhbmQgcmVhY3RpdmUgYCArXHJcbiAgICAgICAgICAgIGB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBvYmplY3Qke3R5cGUgPT09IGBNYXBgID8gYCBhcyBrZXlzYCA6IGBgfSwgYCArXHJcbiAgICAgICAgICAgIGB3aGljaCBjYW4gbGVhZCB0byBpbmNvbnNpc3RlbmNpZXMuIGAgK1xyXG4gICAgICAgICAgICBgQXZvaWQgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgYCArXHJcbiAgICAgICAgICAgIGBvZiBhbiBvYmplY3QgYW5kIG9ubHkgdXNlIHRoZSByZWFjdGl2ZSB2ZXJzaW9uIGlmIHBvc3NpYmxlLmApO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHJlYWN0aXZlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3Qgc2hhbGxvd1JlYWN0aXZlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgcmVhZG9ubHlNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcclxuICAgIHN3aXRjaCAocmF3VHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ09iamVjdCc6XHJcbiAgICAgICAgY2FzZSAnQXJyYXknOlxyXG4gICAgICAgICAgICByZXR1cm4gMSAvKiBDT01NT04gKi87XHJcbiAgICAgICAgY2FzZSAnTWFwJzpcclxuICAgICAgICBjYXNlICdTZXQnOlxyXG4gICAgICAgIGNhc2UgJ1dlYWtNYXAnOlxyXG4gICAgICAgIGNhc2UgJ1dlYWtTZXQnOlxyXG4gICAgICAgICAgICByZXR1cm4gMiAvKiBDT0xMRUNUSU9OICovO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAwIC8qIElOVkFMSUQgKi87XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlW1wiX192X3NraXBcIiAvKiBTS0lQICovXSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSlcclxuICAgICAgICA/IDAgLyogSU5WQUxJRCAqL1xyXG4gICAgICAgIDogdGFyZ2V0VHlwZU1hcCh0b1Jhd1R5cGUodmFsdWUpKTtcclxufVxyXG5mdW5jdGlvbiByZWFjdGl2ZSh0YXJnZXQpIHtcclxuICAgIC8vIGlmIHRyeWluZyB0byBvYnNlcnZlIGEgcmVhZG9ubHkgcHJveHksIHJldHVybiB0aGUgcmVhZG9ubHkgdmVyc2lvbi5cclxuICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0W1wiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqL10pIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgZmFsc2UsIG11dGFibGVIYW5kbGVycywgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycywgcmVhY3RpdmVNYXApO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBzaGFsbG93bHktcmVhY3RpdmUgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290XHJcbiAqIGxldmVsIHByb3BlcnRpZXMgYXJlIHJlYWN0aXZlLiBJdCBhbHNvIGRvZXMgbm90IGF1dG8tdW53cmFwIHJlZnMgKGV2ZW4gYXQgdGhlXHJcbiAqIHJvb3QgbGV2ZWwpLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hhbGxvd1JlYWN0aXZlKHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgZmFsc2UsIHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzLCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzLCBzaGFsbG93UmVhY3RpdmVNYXApO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgcmVhZG9ubHkgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LiBOb3RlIHRoZSByZXR1cm5lZCBjb3B5IGlzIG5vdFxyXG4gKiBtYWRlIHJlYWN0aXZlLCBidXQgYHJlYWRvbmx5YCBjYW4gYmUgY2FsbGVkIG9uIGFuIGFscmVhZHkgcmVhY3RpdmUgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCB0cnVlLCByZWFkb25seUhhbmRsZXJzLCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycywgcmVhZG9ubHlNYXApO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcmVhY3RpdmUtY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290IGxldmVsXHJcbiAqIHByb3BlcnRpZXMgYXJlIHJlYWRvbmx5LCBhbmQgZG9lcyBOT1QgdW53cmFwIHJlZnMgbm9yIHJlY3Vyc2l2ZWx5IGNvbnZlcnRcclxuICogcmV0dXJuZWQgcHJvcGVydGllcy5cclxuICogVGhpcyBpcyB1c2VkIGZvciBjcmVhdGluZyB0aGUgcHJvcHMgcHJveHkgb2JqZWN0IGZvciBzdGF0ZWZ1bCBjb21wb25lbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hhbGxvd1JlYWRvbmx5KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMsIHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycywgc2hhbGxvd1JlYWRvbmx5TWFwKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHksIGJhc2VIYW5kbGVycywgY29sbGVjdGlvbkhhbmRsZXJzLCBwcm94eU1hcCkge1xyXG4gICAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWN0aXZlOiAke1N0cmluZyh0YXJnZXQpfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLy8gdGFyZ2V0IGlzIGFscmVhZHkgYSBQcm94eSwgcmV0dXJuIGl0LlxyXG4gICAgLy8gZXhjZXB0aW9uOiBjYWxsaW5nIHJlYWRvbmx5KCkgb24gYSByZWFjdGl2ZSBvYmplY3RcclxuICAgIGlmICh0YXJnZXRbXCJfX3ZfcmF3XCIgLyogUkFXICovXSAmJlxyXG4gICAgICAgICEoaXNSZWFkb25seSAmJiB0YXJnZXRbXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIElTX1JFQUNUSVZFICovXSkpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLy8gdGFyZ2V0IGFscmVhZHkgaGFzIGNvcnJlc3BvbmRpbmcgUHJveHlcclxuICAgIGNvbnN0IGV4aXN0aW5nUHJveHkgPSBwcm94eU1hcC5nZXQodGFyZ2V0KTtcclxuICAgIGlmIChleGlzdGluZ1Byb3h5KSB7XHJcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUHJveHk7XHJcbiAgICB9XHJcbiAgICAvLyBvbmx5IGEgd2hpdGVsaXN0IG9mIHZhbHVlIHR5cGVzIGNhbiBiZSBvYnNlcnZlZC5cclxuICAgIGNvbnN0IHRhcmdldFR5cGUgPSBnZXRUYXJnZXRUeXBlKHRhcmdldCk7XHJcbiAgICBpZiAodGFyZ2V0VHlwZSA9PT0gMCAvKiBJTlZBTElEICovKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHRhcmdldCwgdGFyZ2V0VHlwZSA9PT0gMiAvKiBDT0xMRUNUSU9OICovID8gY29sbGVjdGlvbkhhbmRsZXJzIDogYmFzZUhhbmRsZXJzKTtcclxuICAgIHByb3h5TWFwLnNldCh0YXJnZXQsIHByb3h5KTtcclxuICAgIHJldHVybiBwcm94eTtcclxufVxyXG5mdW5jdGlvbiBpc1JlYWN0aXZlKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNSZWFkb25seSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZVtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dKTtcclxuICAgIH1cclxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi9dKTtcclxufVxyXG5mdW5jdGlvbiBpc1JlYWRvbmx5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovXSk7XHJcbn1cclxuZnVuY3Rpb24gaXNQcm94eSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWUpIHx8IGlzUmVhZG9ubHkodmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHRvUmF3KG9ic2VydmVkKSB7XHJcbiAgICByZXR1cm4gKChvYnNlcnZlZCAmJiB0b1JhdyhvYnNlcnZlZFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dKSkgfHwgb2JzZXJ2ZWQpO1xyXG59XHJcbmZ1bmN0aW9uIG1hcmtSYXcodmFsdWUpIHtcclxuICAgIGRlZih2YWx1ZSwgXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi8sIHRydWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XG5cbmNvbnN0IGNvbnZlcnQgPSAodmFsKSA9PiBpc09iamVjdCh2YWwpID8gcmVhY3RpdmUodmFsKSA6IHZhbDtcclxuZnVuY3Rpb24gaXNSZWYocikge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4ociAmJiByLl9fdl9pc1JlZiA9PT0gdHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gcmVmKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBzaGFsbG93UmVmKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcclxufVxyXG5jbGFzcyBSZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKF9yYXdWYWx1ZSwgX3NoYWxsb3cpIHtcclxuICAgICAgICB0aGlzLl9yYXdWYWx1ZSA9IF9yYXdWYWx1ZTtcclxuICAgICAgICB0aGlzLl9zaGFsbG93ID0gX3NoYWxsb3c7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3NoYWxsb3cgPyBfcmF3VmFsdWUgOiBjb252ZXJ0KF9yYXdWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgdHJhY2sodG9SYXcodGhpcyksIFwiZ2V0XCIgLyogR0VUICovLCAndmFsdWUnKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQodG9SYXcobmV3VmFsKSwgdGhpcy5fcmF3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gbmV3VmFsO1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX3NoYWxsb3cgPyBuZXdWYWwgOiBjb252ZXJ0KG5ld1ZhbCk7XHJcbiAgICAgICAgICAgIHRyaWdnZXIodG9SYXcodGhpcyksIFwic2V0XCIgLyogU0VUICovLCAndmFsdWUnLCBuZXdWYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWYocmF3VmFsdWUsIHNoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgaWYgKGlzUmVmKHJhd1ZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiByYXdWYWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUmVmSW1wbChyYXdWYWx1ZSwgc2hhbGxvdyk7XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlclJlZihyZWYpIHtcclxuICAgIHRyaWdnZXIodG9SYXcocmVmKSwgXCJzZXRcIiAvKiBTRVQgKi8sICd2YWx1ZScsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHJlZi52YWx1ZSA6IHZvaWQgMCk7XHJcbn1cclxuZnVuY3Rpb24gdW5yZWYocmVmKSB7XHJcbiAgICByZXR1cm4gaXNSZWYocmVmKSA/IHJlZi52YWx1ZSA6IHJlZjtcclxufVxyXG5jb25zdCBzaGFsbG93VW53cmFwSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6ICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHVucmVmKFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikpLFxyXG4gICAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgaWYgKGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gcHJveHlSZWZzKG9iamVjdFdpdGhSZWZzKSB7XHJcbiAgICByZXR1cm4gaXNSZWFjdGl2ZShvYmplY3RXaXRoUmVmcylcclxuICAgICAgICA/IG9iamVjdFdpdGhSZWZzXHJcbiAgICAgICAgOiBuZXcgUHJveHkob2JqZWN0V2l0aFJlZnMsIHNoYWxsb3dVbndyYXBIYW5kbGVycyk7XHJcbn1cclxuY2xhc3MgQ3VzdG9tUmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5KSB7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IGZhY3RvcnkoKCkgPT4gdHJhY2sodGhpcywgXCJnZXRcIiAvKiBHRVQgKi8sICd2YWx1ZScpLCAoKSA9PiB0cmlnZ2VyKHRoaXMsIFwic2V0XCIgLyogU0VUICovLCAndmFsdWUnKSk7XHJcbiAgICAgICAgdGhpcy5fZ2V0ID0gZ2V0O1xyXG4gICAgICAgIHRoaXMuX3NldCA9IHNldDtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KCk7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0KG5ld1ZhbCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3VzdG9tUmVmKGZhY3RvcnkpIHtcclxuICAgIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcclxufVxyXG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1Byb3h5KG9iamVjdCkpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYHRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmV0ID0gaXNBcnJheShvYmplY3QpID8gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpIDoge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcclxuICAgICAgICByZXRba2V5XSA9IHRvUmVmKG9iamVjdCwga2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuY2xhc3MgT2JqZWN0UmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihfb2JqZWN0LCBfa2V5KSB7XHJcbiAgICAgICAgdGhpcy5fb2JqZWN0ID0gX29iamVjdDtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb2JqZWN0W3RoaXMuX2tleV07XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgdGhpcy5fb2JqZWN0W3RoaXMuX2tleV0gPSBuZXdWYWw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9SZWYob2JqZWN0LCBrZXkpIHtcclxuICAgIHJldHVybiBpc1JlZihvYmplY3Rba2V5XSlcclxuICAgICAgICA/IG9iamVjdFtrZXldXHJcbiAgICAgICAgOiBuZXcgT2JqZWN0UmVmSW1wbChvYmplY3QsIGtleSk7XHJcbn1cblxuY2xhc3MgQ29tcHV0ZWRSZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGdldHRlciwgX3NldHRlciwgaXNSZWFkb25seSkge1xyXG4gICAgICAgIHRoaXMuX3NldHRlciA9IF9zZXR0ZXI7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmVmZmVjdCA9IGVmZmVjdChnZXR0ZXIsIHtcclxuICAgICAgICAgICAgbGF6eTogdHJ1ZSxcclxuICAgICAgICAgICAgc2NoZWR1bGVyOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIodG9SYXcodGhpcyksIFwic2V0XCIgLyogU0VUICovLCAndmFsdWUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovXSA9IGlzUmVhZG9ubHk7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgLy8gdGhlIGNvbXB1dGVkIHJlZiBtYXkgZ2V0IHdyYXBwZWQgYnkgb3RoZXIgcHJveGllcyBlLmcuIHJlYWRvbmx5KCkgIzMzNzZcclxuICAgICAgICBjb25zdCBzZWxmID0gdG9SYXcodGhpcyk7XHJcbiAgICAgICAgaWYgKHNlbGYuX2RpcnR5KSB7XHJcbiAgICAgICAgICAgIHNlbGYuX3ZhbHVlID0gdGhpcy5lZmZlY3QoKTtcclxuICAgICAgICAgICAgc2VsZi5fZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhY2soc2VsZiwgXCJnZXRcIiAvKiBHRVQgKi8sICd2YWx1ZScpO1xyXG4gICAgICAgIHJldHVybiBzZWxmLl92YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3NldHRlcihuZXdWYWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zKSB7XHJcbiAgICBsZXQgZ2V0dGVyO1xyXG4gICAgbGV0IHNldHRlcjtcclxuICAgIGlmIChpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucykpIHtcclxuICAgICAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnM7XHJcbiAgICAgICAgc2V0dGVyID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgID8gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCB2YWx1ZSBpcyByZWFkb25seScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDogTk9PUDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucy5nZXQ7XHJcbiAgICAgICAgc2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLnNldDtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucykgfHwgIWdldHRlck9yT3B0aW9ucy5zZXQpO1xyXG59XG5cbmV4cG9ydCB7IElURVJBVEVfS0VZLCBjb21wdXRlZCwgY3VzdG9tUmVmLCBlZmZlY3QsIGVuYWJsZVRyYWNraW5nLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgbWFya1JhdywgcGF1c2VUcmFja2luZywgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgcmVzZXRUcmFja2luZywgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0cmFjaywgdHJpZ2dlciwgdHJpZ2dlclJlZiwgdW5yZWYgfTtcbiIsImltcG9ydCB7IHBhdXNlVHJhY2tpbmcsIHJlc2V0VHJhY2tpbmcsIGlzUmVmLCB0b1JhdywgaXNSZWFjdGl2ZSwgZWZmZWN0LCBzdG9wLCByZWYsIHJlYWN0aXZlLCBzaGFsbG93UmVhY3RpdmUsIHRyaWdnZXIsIGlzUHJveHksIHNoYWxsb3dSZWFkb25seSwgdHJhY2ssIG1hcmtSYXcsIHByb3h5UmVmcywgY29tcHV0ZWQgYXMgY29tcHV0ZWQkMSwgaXNSZWFkb25seSB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5leHBvcnQgeyBjdXN0b21SZWYsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBtYXJrUmF3LCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRyaWdnZXJSZWYsIHVucmVmIH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0Z1bmN0aW9uIGFzIGlzRnVuY3Rpb24kMSwgaXNQcm9taXNlIGFzIGlzUHJvbWlzZSQxLCBpc0FycmF5LCBleHRlbmQsIGhhc093biwgRU1QVFlfT0JKLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCBoeXBoZW5hdGUsIGNhbWVsaXplLCBpc09uLCBpc01vZGVsTGlzdGVuZXIsIHJlbW92ZSwgTk9PUCwgaGFzQ2hhbmdlZCwgaXNPYmplY3QgYXMgaXNPYmplY3QkMSwgaXNTZXQsIGlzTWFwLCBpc1BsYWluT2JqZWN0LCBpbnZva2VBcnJheUZucywgZGVmLCBpc1Jlc2VydmVkUHJvcCwgRU1QVFlfQVJSLCBjYXBpdGFsaXplLCB0b1Jhd1R5cGUsIG1ha2VNYXAsIE5PLCBnZXRHbG9iYWxUaGlzLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplU3R5bGUsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcbmV4cG9ydCB7IGNhbWVsaXplLCBjYXBpdGFsaXplLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3RhY2sgPSBbXTtcclxuZnVuY3Rpb24gcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKSB7XHJcbiAgICBzdGFjay5wdXNoKHZub2RlKTtcclxufVxyXG5mdW5jdGlvbiBwb3BXYXJuaW5nQ29udGV4dCgpIHtcclxuICAgIHN0YWNrLnBvcCgpO1xyXG59XHJcbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XHJcbiAgICAvLyBhdm9pZCBwcm9wcyBmb3JtYXR0aW5nIG9yIHdhcm4gaGFuZGxlciB0cmFja2luZyBkZXBzIHRoYXQgbWlnaHQgYmUgbXV0YXRlZFxyXG4gICAgLy8gZHVyaW5nIHBhdGNoLCBsZWFkaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgIGNvbnN0IGluc3RhbmNlID0gc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uY29tcG9uZW50IDogbnVsbDtcclxuICAgIGNvbnN0IGFwcFdhcm5IYW5kbGVyID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcud2FybkhhbmRsZXI7XHJcbiAgICBjb25zdCB0cmFjZSA9IGdldENvbXBvbmVudFRyYWNlKCk7XHJcbiAgICBpZiAoYXBwV2FybkhhbmRsZXIpIHtcclxuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoYXBwV2FybkhhbmRsZXIsIGluc3RhbmNlLCAxMSAvKiBBUFBfV0FSTl9IQU5ETEVSICovLCBbXHJcbiAgICAgICAgICAgIG1zZyArIGFyZ3Muam9pbignJyksXHJcbiAgICAgICAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5LFxyXG4gICAgICAgICAgICB0cmFjZVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoeyB2bm9kZSB9KSA9PiBgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgdm5vZGUudHlwZSl9PmApXHJcbiAgICAgICAgICAgICAgICAuam9pbignXFxuJyksXHJcbiAgICAgICAgICAgIHRyYWNlXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCB3YXJuQXJncyA9IFtgW1Z1ZSB3YXJuXTogJHttc2d9YCwgLi4uYXJnc107XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHRyYWNlLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAvLyBhdm9pZCBzcGFtbWluZyBjb25zb2xlIGR1cmluZyB0ZXN0c1xyXG4gICAgICAgICAgICAhZmFsc2UpIHtcclxuICAgICAgICAgICAgd2FybkFyZ3MucHVzaChgXFxuYCwgLi4uZm9ybWF0VHJhY2UodHJhY2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS53YXJuKC4uLndhcm5BcmdzKTtcclxuICAgIH1cclxuICAgIHJlc2V0VHJhY2tpbmcoKTtcclxufVxyXG5mdW5jdGlvbiBnZXRDb21wb25lbnRUcmFjZSgpIHtcclxuICAgIGxldCBjdXJyZW50Vk5vZGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICAgIGlmICghY3VycmVudFZOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgLy8gd2UgY2FuJ3QganVzdCB1c2UgdGhlIHN0YWNrIGJlY2F1c2UgaXQgd2lsbCBiZSBpbmNvbXBsZXRlIGR1cmluZyB1cGRhdGVzXHJcbiAgICAvLyB0aGF0IGRpZCBub3Qgc3RhcnQgZnJvbSB0aGUgcm9vdC4gUmUtY29uc3RydWN0IHRoZSBwYXJlbnQgY2hhaW4gdXNpbmdcclxuICAgIC8vIGluc3RhbmNlIHBhcmVudCBwb2ludGVycy5cclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRTdGFjayA9IFtdO1xyXG4gICAgd2hpbGUgKGN1cnJlbnRWTm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGxhc3QgPSBub3JtYWxpemVkU3RhY2tbMF07XHJcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC52bm9kZSA9PT0gY3VycmVudFZOb2RlKSB7XHJcbiAgICAgICAgICAgIGxhc3QucmVjdXJzZUNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub3JtYWxpemVkU3RhY2sucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB2bm9kZTogY3VycmVudFZOb2RlLFxyXG4gICAgICAgICAgICAgICAgcmVjdXJzZUNvdW50OiAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IGN1cnJlbnRWTm9kZS5jb21wb25lbnQgJiYgY3VycmVudFZOb2RlLmNvbXBvbmVudC5wYXJlbnQ7XHJcbiAgICAgICAgY3VycmVudFZOb2RlID0gcGFyZW50SW5zdGFuY2UgJiYgcGFyZW50SW5zdGFuY2Uudm5vZGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZFN0YWNrO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdFRyYWNlKHRyYWNlKSB7XHJcbiAgICBjb25zdCBsb2dzID0gW107XHJcbiAgICB0cmFjZS5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xyXG4gICAgICAgIGxvZ3MucHVzaCguLi4oaSA9PT0gMCA/IFtdIDogW2BcXG5gXSksIC4uLmZvcm1hdFRyYWNlRW50cnkoZW50cnkpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGxvZ3M7XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0VHJhY2VFbnRyeSh7IHZub2RlLCByZWN1cnNlQ291bnQgfSkge1xyXG4gICAgY29uc3QgcG9zdGZpeCA9IHJlY3Vyc2VDb3VudCA+IDAgPyBgLi4uICgke3JlY3Vyc2VDb3VudH0gcmVjdXJzaXZlIGNhbGxzKWAgOiBgYDtcclxuICAgIGNvbnN0IGlzUm9vdCA9IHZub2RlLmNvbXBvbmVudCA/IHZub2RlLmNvbXBvbmVudC5wYXJlbnQgPT0gbnVsbCA6IGZhbHNlO1xyXG4gICAgY29uc3Qgb3BlbiA9IGAgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bm9kZS5jb21wb25lbnQsIHZub2RlLnR5cGUsIGlzUm9vdCl9YDtcclxuICAgIGNvbnN0IGNsb3NlID0gYD5gICsgcG9zdGZpeDtcclxuICAgIHJldHVybiB2bm9kZS5wcm9wc1xyXG4gICAgICAgID8gW29wZW4sIC4uLmZvcm1hdFByb3BzKHZub2RlLnByb3BzKSwgY2xvc2VdXHJcbiAgICAgICAgOiBbb3BlbiArIGNsb3NlXTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRQcm9wcyhwcm9wcykge1xyXG4gICAgY29uc3QgcmVzID0gW107XHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xyXG4gICAga2V5cy5zbGljZSgwLCAzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgcmVzLnB1c2goLi4uZm9ybWF0UHJvcChrZXksIHByb3BzW2tleV0pKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGtleXMubGVuZ3RoID4gMykge1xyXG4gICAgICAgIHJlcy5wdXNoKGAgLi4uYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdFByb3Aoa2V5LCB2YWx1ZSwgcmF3KSB7XHJcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcclxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fFxyXG4gICAgICAgIHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUgPSBmb3JtYXRQcm9wKGtleSwgdG9SYXcodmFsdWUudmFsdWUpLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1SZWY8YCwgdmFsdWUsIGA+YF07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uJDEodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIFtgJHtrZXl9PWZuJHt2YWx1ZS5uYW1lID8gYDwke3ZhbHVlLm5hbWV9PmAgOiBgYH1gXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PWAsIHZhbHVlXTtcclxuICAgIH1cclxufVxuXG5jb25zdCBFcnJvclR5cGVTdHJpbmdzID0ge1xyXG4gICAgW1wic3BcIiAvKiBTRVJWRVJfUFJFRkVUQ0ggKi9dOiAnc2VydmVyUHJlZmV0Y2ggaG9vaycsXHJcbiAgICBbXCJiY1wiIC8qIEJFRk9SRV9DUkVBVEUgKi9dOiAnYmVmb3JlQ3JlYXRlIGhvb2snLFxyXG4gICAgW1wiY1wiIC8qIENSRUFURUQgKi9dOiAnY3JlYXRlZCBob29rJyxcclxuICAgIFtcImJtXCIgLyogQkVGT1JFX01PVU5UICovXTogJ2JlZm9yZU1vdW50IGhvb2snLFxyXG4gICAgW1wibVwiIC8qIE1PVU5URUQgKi9dOiAnbW91bnRlZCBob29rJyxcclxuICAgIFtcImJ1XCIgLyogQkVGT1JFX1VQREFURSAqL106ICdiZWZvcmVVcGRhdGUgaG9vaycsXHJcbiAgICBbXCJ1XCIgLyogVVBEQVRFRCAqL106ICd1cGRhdGVkJyxcclxuICAgIFtcImJ1bVwiIC8qIEJFRk9SRV9VTk1PVU5UICovXTogJ2JlZm9yZVVubW91bnQgaG9vaycsXHJcbiAgICBbXCJ1bVwiIC8qIFVOTU9VTlRFRCAqL106ICd1bm1vdW50ZWQgaG9vaycsXHJcbiAgICBbXCJhXCIgLyogQUNUSVZBVEVEICovXTogJ2FjdGl2YXRlZCBob29rJyxcclxuICAgIFtcImRhXCIgLyogREVBQ1RJVkFURUQgKi9dOiAnZGVhY3RpdmF0ZWQgaG9vaycsXHJcbiAgICBbXCJlY1wiIC8qIEVSUk9SX0NBUFRVUkVEICovXTogJ2Vycm9yQ2FwdHVyZWQgaG9vaycsXHJcbiAgICBbXCJydGNcIiAvKiBSRU5ERVJfVFJBQ0tFRCAqL106ICdyZW5kZXJUcmFja2VkIGhvb2snLFxyXG4gICAgW1wicnRnXCIgLyogUkVOREVSX1RSSUdHRVJFRCAqL106ICdyZW5kZXJUcmlnZ2VyZWQgaG9vaycsXHJcbiAgICBbMCAvKiBTRVRVUF9GVU5DVElPTiAqL106ICdzZXR1cCBmdW5jdGlvbicsXHJcbiAgICBbMSAvKiBSRU5ERVJfRlVOQ1RJT04gKi9dOiAncmVuZGVyIGZ1bmN0aW9uJyxcclxuICAgIFsyIC8qIFdBVENIX0dFVFRFUiAqL106ICd3YXRjaGVyIGdldHRlcicsXHJcbiAgICBbMyAvKiBXQVRDSF9DQUxMQkFDSyAqL106ICd3YXRjaGVyIGNhbGxiYWNrJyxcclxuICAgIFs0IC8qIFdBVENIX0NMRUFOVVAgKi9dOiAnd2F0Y2hlciBjbGVhbnVwIGZ1bmN0aW9uJyxcclxuICAgIFs1IC8qIE5BVElWRV9FVkVOVF9IQU5ETEVSICovXTogJ25hdGl2ZSBldmVudCBoYW5kbGVyJyxcclxuICAgIFs2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovXTogJ2NvbXBvbmVudCBldmVudCBoYW5kbGVyJyxcclxuICAgIFs3IC8qIFZOT0RFX0hPT0sgKi9dOiAndm5vZGUgaG9vaycsXHJcbiAgICBbOCAvKiBESVJFQ1RJVkVfSE9PSyAqL106ICdkaXJlY3RpdmUgaG9vaycsXHJcbiAgICBbOSAvKiBUUkFOU0lUSU9OX0hPT0sgKi9dOiAndHJhbnNpdGlvbiBob29rJyxcclxuICAgIFsxMCAvKiBBUFBfRVJST1JfSEFORExFUiAqL106ICdhcHAgZXJyb3JIYW5kbGVyJyxcclxuICAgIFsxMSAvKiBBUFBfV0FSTl9IQU5ETEVSICovXTogJ2FwcCB3YXJuSGFuZGxlcicsXHJcbiAgICBbMTIgLyogRlVOQ1RJT05fUkVGICovXTogJ3JlZiBmdW5jdGlvbicsXHJcbiAgICBbMTMgLyogQVNZTkNfQ09NUE9ORU5UX0xPQURFUiAqL106ICdhc3luYyBjb21wb25lbnQgbG9hZGVyJyxcclxuICAgIFsxNCAvKiBTQ0hFRFVMRVIgKi9dOiAnc2NoZWR1bGVyIGZsdXNoLiBUaGlzIGlzIGxpa2VseSBhIFZ1ZSBpbnRlcm5hbHMgYnVnLiAnICtcclxuICAgICAgICAnUGxlYXNlIG9wZW4gYW4gaXNzdWUgYXQgaHR0cHM6Ly9uZXctaXNzdWUudnVlanMub3JnLz9yZXBvPXZ1ZWpzL3Z1ZS1uZXh0J1xyXG59O1xyXG5mdW5jdGlvbiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XHJcbiAgICBsZXQgcmVzO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXMgPSBhcmdzID8gZm4oLi4uYXJncykgOiBmbigpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uJDEoZm4pKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncyk7XHJcbiAgICAgICAgaWYgKHJlcyAmJiBpc1Byb21pc2UkMShyZXMpKSB7XHJcbiAgICAgICAgICAgIHJlcy5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFsdWVzLnB1c2goY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm5baV0sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWVzO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XHJcbiAgICBjb25zdCBjb250ZXh0Vk5vZGUgPSBpbnN0YW5jZSA/IGluc3RhbmNlLnZub2RlIDogbnVsbDtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIGxldCBjdXIgPSBpbnN0YW5jZS5wYXJlbnQ7XHJcbiAgICAgICAgLy8gdGhlIGV4cG9zZWQgaW5zdGFuY2UgaXMgdGhlIHJlbmRlciBwcm94eSB0byBrZWVwIGl0IGNvbnNpc3RlbnQgd2l0aCAyLnhcclxuICAgICAgICBjb25zdCBleHBvc2VkSW5zdGFuY2UgPSBpbnN0YW5jZS5wcm94eTtcclxuICAgICAgICAvLyBpbiBwcm9kdWN0aW9uIHRoZSBob29rIHJlY2VpdmVzIG9ubHkgdGhlIGVycm9yIGNvZGVcclxuICAgICAgICBjb25zdCBlcnJvckluZm8gPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBFcnJvclR5cGVTdHJpbmdzW3R5cGVdIDogdHlwZTtcclxuICAgICAgICB3aGlsZSAoY3VyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ2FwdHVyZWRIb29rcyA9IGN1ci5lYztcclxuICAgICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvckNhcHR1cmVkSG9va3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzW2ldKGVyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm8pID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFwcC1sZXZlbCBoYW5kbGluZ1xyXG4gICAgICAgIGNvbnN0IGFwcEVycm9ySGFuZGxlciA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmVycm9ySGFuZGxlcjtcclxuICAgICAgICBpZiAoYXBwRXJyb3JIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhhcHBFcnJvckhhbmRsZXIsIG51bGwsIDEwIC8qIEFQUF9FUlJPUl9IQU5ETEVSICovLCBbZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mb10pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYpO1xyXG59XHJcbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSBFcnJvclR5cGVTdHJpbmdzW3R5cGVdO1xyXG4gICAgICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcclxuICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGNvbnRleHRWTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdhcm4oYFVuaGFuZGxlZCBlcnJvciR7aW5mbyA/IGAgZHVyaW5nIGV4ZWN1dGlvbiBvZiAke2luZm99YCA6IGBgfWApO1xyXG4gICAgICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcclxuICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY3Jhc2ggaW4gZGV2IGJ5IGRlZmF1bHQgc28gaXQncyBtb3JlIG5vdGljZWFibGVcclxuICAgICAgICBpZiAodGhyb3dJbkRldikge1xyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gcmVjb3ZlciBpbiBwcm9kIHRvIHJlZHVjZSB0aGUgaW1wYWN0IG9uIGVuZC11c2VyXHJcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgfVxyXG59XG5cbmxldCBpc0ZsdXNoaW5nID0gZmFsc2U7XHJcbmxldCBpc0ZsdXNoUGVuZGluZyA9IGZhbHNlO1xyXG5jb25zdCBxdWV1ZSA9IFtdO1xyXG5sZXQgZmx1c2hJbmRleCA9IDA7XHJcbmNvbnN0IHBlbmRpbmdQcmVGbHVzaENicyA9IFtdO1xyXG5sZXQgYWN0aXZlUHJlRmx1c2hDYnMgPSBudWxsO1xyXG5sZXQgcHJlRmx1c2hJbmRleCA9IDA7XHJcbmNvbnN0IHBlbmRpbmdQb3N0Rmx1c2hDYnMgPSBbXTtcclxubGV0IGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XHJcbmxldCBwb3N0Rmx1c2hJbmRleCA9IDA7XHJcbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5sZXQgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XHJcbmxldCBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBudWxsO1xyXG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSAxMDA7XHJcbmZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XHJcbiAgICBjb25zdCBwID0gY3VycmVudEZsdXNoUHJvbWlzZSB8fCByZXNvbHZlZFByb21pc2U7XHJcbiAgICByZXR1cm4gZm4gPyBwLnRoZW4odGhpcyA/IGZuLmJpbmQodGhpcykgOiBmbikgOiBwO1xyXG59XHJcbi8vICMyNzY4XHJcbi8vIFVzZSBiaW5hcnktc2VhcmNoIHRvIGZpbmQgYSBzdWl0YWJsZSBwb3NpdGlvbiBpbiB0aGUgcXVldWUsXHJcbi8vIHNvIHRoYXQgdGhlIHF1ZXVlIG1haW50YWlucyB0aGUgaW5jcmVhc2luZyBvcmRlciBvZiBqb2IncyBpZCxcclxuLy8gd2hpY2ggY2FuIHByZXZlbnQgdGhlIGpvYiBmcm9tIGJlaW5nIHNraXBwZWQgYW5kIGFsc28gY2FuIGF2b2lkIHJlcGVhdGVkIHBhdGNoaW5nLlxyXG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uSW5kZXgoam9iKSB7XHJcbiAgICAvLyB0aGUgc3RhcnQgaW5kZXggc2hvdWxkIGJlIGBmbHVzaEluZGV4ICsgMWBcclxuICAgIGxldCBzdGFydCA9IGZsdXNoSW5kZXggKyAxO1xyXG4gICAgbGV0IGVuZCA9IHF1ZXVlLmxlbmd0aDtcclxuICAgIGNvbnN0IGpvYklkID0gZ2V0SWQoam9iKTtcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIGNvbnN0IG1pZGRsZSA9IChzdGFydCArIGVuZCkgPj4+IDE7XHJcbiAgICAgICAgY29uc3QgbWlkZGxlSm9iSWQgPSBnZXRJZChxdWV1ZVttaWRkbGVdKTtcclxuICAgICAgICBtaWRkbGVKb2JJZCA8IGpvYklkID8gKHN0YXJ0ID0gbWlkZGxlICsgMSkgOiAoZW5kID0gbWlkZGxlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdGFydDtcclxufVxyXG5mdW5jdGlvbiBxdWV1ZUpvYihqb2IpIHtcclxuICAgIC8vIHRoZSBkZWR1cGUgc2VhcmNoIHVzZXMgdGhlIHN0YXJ0SW5kZXggYXJndW1lbnQgb2YgQXJyYXkuaW5jbHVkZXMoKVxyXG4gICAgLy8gYnkgZGVmYXVsdCB0aGUgc2VhcmNoIGluZGV4IGluY2x1ZGVzIHRoZSBjdXJyZW50IGpvYiB0aGF0IGlzIGJlaW5nIHJ1blxyXG4gICAgLy8gc28gaXQgY2Fubm90IHJlY3Vyc2l2ZWx5IHRyaWdnZXIgaXRzZWxmIGFnYWluLlxyXG4gICAgLy8gaWYgdGhlIGpvYiBpcyBhIHdhdGNoKCkgY2FsbGJhY2ssIHRoZSBzZWFyY2ggd2lsbCBzdGFydCB3aXRoIGEgKzEgaW5kZXggdG9cclxuICAgIC8vIGFsbG93IGl0IHJlY3Vyc2l2ZWx5IHRyaWdnZXIgaXRzZWxmIC0gaXQgaXMgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0b1xyXG4gICAgLy8gZW5zdXJlIGl0IGRvZXNuJ3QgZW5kIHVwIGluIGFuIGluZmluaXRlIGxvb3AuXHJcbiAgICBpZiAoKCFxdWV1ZS5sZW5ndGggfHxcclxuICAgICAgICAhcXVldWUuaW5jbHVkZXMoam9iLCBpc0ZsdXNoaW5nICYmIGpvYi5hbGxvd1JlY3Vyc2UgPyBmbHVzaEluZGV4ICsgMSA6IGZsdXNoSW5kZXgpKSAmJlxyXG4gICAgICAgIGpvYiAhPT0gY3VycmVudFByZUZsdXNoUGFyZW50Sm9iKSB7XHJcbiAgICAgICAgY29uc3QgcG9zID0gZmluZEluc2VydGlvbkluZGV4KGpvYik7XHJcbiAgICAgICAgaWYgKHBvcyA+IC0xKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlLnNwbGljZShwb3MsIDAsIGpvYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGpvYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXVlRmx1c2goKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBxdWV1ZUZsdXNoKCkge1xyXG4gICAgaWYgKCFpc0ZsdXNoaW5nICYmICFpc0ZsdXNoUGVuZGluZykge1xyXG4gICAgICAgIGlzRmx1c2hQZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gcmVzb2x2ZWRQcm9taXNlLnRoZW4oZmx1c2hKb2JzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbnZhbGlkYXRlSm9iKGpvYikge1xyXG4gICAgY29uc3QgaSA9IHF1ZXVlLmluZGV4T2Yoam9iKTtcclxuICAgIGlmIChpID4gZmx1c2hJbmRleCkge1xyXG4gICAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBxdWV1ZUNiKGNiLCBhY3RpdmVRdWV1ZSwgcGVuZGluZ1F1ZXVlLCBpbmRleCkge1xyXG4gICAgaWYgKCFpc0FycmF5KGNiKSkge1xyXG4gICAgICAgIGlmICghYWN0aXZlUXVldWUgfHxcclxuICAgICAgICAgICAgIWFjdGl2ZVF1ZXVlLmluY2x1ZGVzKGNiLCBjYi5hbGxvd1JlY3Vyc2UgPyBpbmRleCArIDEgOiBpbmRleCkpIHtcclxuICAgICAgICAgICAgcGVuZGluZ1F1ZXVlLnB1c2goY2IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGlmIGNiIGlzIGFuIGFycmF5LCBpdCBpcyBhIGNvbXBvbmVudCBsaWZlY3ljbGUgaG9vayB3aGljaCBjYW4gb25seSBiZVxyXG4gICAgICAgIC8vIHRyaWdnZXJlZCBieSBhIGpvYiwgd2hpY2ggaXMgYWxyZWFkeSBkZWR1cGVkIGluIHRoZSBtYWluIHF1ZXVlLCBzb1xyXG4gICAgICAgIC8vIHdlIGNhbiBza2lwIGR1cGxpY2F0ZSBjaGVjayBoZXJlIHRvIGltcHJvdmUgcGVyZlxyXG4gICAgICAgIHBlbmRpbmdRdWV1ZS5wdXNoKC4uLmNiKTtcclxuICAgIH1cclxuICAgIHF1ZXVlRmx1c2goKTtcclxufVxyXG5mdW5jdGlvbiBxdWV1ZVByZUZsdXNoQ2IoY2IpIHtcclxuICAgIHF1ZXVlQ2IoY2IsIGFjdGl2ZVByZUZsdXNoQ2JzLCBwZW5kaW5nUHJlRmx1c2hDYnMsIHByZUZsdXNoSW5kZXgpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlUG9zdEZsdXNoQ2IoY2IpIHtcclxuICAgIHF1ZXVlQ2IoY2IsIGFjdGl2ZVBvc3RGbHVzaENicywgcGVuZGluZ1Bvc3RGbHVzaENicywgcG9zdEZsdXNoSW5kZXgpO1xyXG59XHJcbmZ1bmN0aW9uIGZsdXNoUHJlRmx1c2hDYnMoc2VlbiwgcGFyZW50Sm9iID0gbnVsbCkge1xyXG4gICAgaWYgKHBlbmRpbmdQcmVGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBwYXJlbnRKb2I7XHJcbiAgICAgICAgYWN0aXZlUHJlRmx1c2hDYnMgPSBbLi4ubmV3IFNldChwZW5kaW5nUHJlRmx1c2hDYnMpXTtcclxuICAgICAgICBwZW5kaW5nUHJlRmx1c2hDYnMubGVuZ3RoID0gMDtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChwcmVGbHVzaEluZGV4ID0gMDsgcHJlRmx1c2hJbmRleCA8IGFjdGl2ZVByZUZsdXNoQ2JzLmxlbmd0aDsgcHJlRmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBhY3RpdmVQcmVGbHVzaENic1twcmVGbHVzaEluZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGl2ZVByZUZsdXNoQ2JzW3ByZUZsdXNoSW5kZXhdKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjdGl2ZVByZUZsdXNoQ2JzID0gbnVsbDtcclxuICAgICAgICBwcmVGbHVzaEluZGV4ID0gMDtcclxuICAgICAgICBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBudWxsO1xyXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGZsdXNoIHVudGlsIGl0IGRyYWluc1xyXG4gICAgICAgIGZsdXNoUHJlRmx1c2hDYnMoc2VlbiwgcGFyZW50Sm9iKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmbHVzaFBvc3RGbHVzaENicyhzZWVuKSB7XHJcbiAgICBpZiAocGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBkZWR1cGVkID0gWy4uLm5ldyBTZXQocGVuZGluZ1Bvc3RGbHVzaENicyldO1xyXG4gICAgICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoID0gMDtcclxuICAgICAgICAvLyAjMTk0NyBhbHJlYWR5IGhhcyBhY3RpdmUgcXVldWUsIG5lc3RlZCBmbHVzaFBvc3RGbHVzaENicyBjYWxsXHJcbiAgICAgICAgaWYgKGFjdGl2ZVBvc3RGbHVzaENicykge1xyXG4gICAgICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMucHVzaCguLi5kZWR1cGVkKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBkZWR1cGVkO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMuc29ydCgoYSwgYikgPT4gZ2V0SWQoYSkgLSBnZXRJZChiKSk7XHJcbiAgICAgICAgZm9yIChwb3N0Rmx1c2hJbmRleCA9IDA7IHBvc3RGbHVzaEluZGV4IDwgYWN0aXZlUG9zdEZsdXNoQ2JzLmxlbmd0aDsgcG9zdEZsdXNoSW5kZXgrKykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcclxuICAgICAgICBwb3N0Rmx1c2hJbmRleCA9IDA7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgZ2V0SWQgPSAoam9iKSA9PiBqb2IuaWQgPT0gbnVsbCA/IEluZmluaXR5IDogam9iLmlkO1xyXG5mdW5jdGlvbiBmbHVzaEpvYnMoc2Vlbikge1xyXG4gICAgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcclxuICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGZsdXNoUHJlRmx1c2hDYnMoc2Vlbik7XHJcbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cclxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxyXG4gICAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xyXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkIHNvIGl0cyByZW5kZXIgZWZmZWN0IHdpbGwgaGF2ZSBzbWFsbGVyXHJcbiAgICAvLyAgICBwcmlvcml0eSBudW1iZXIpXHJcbiAgICAvLyAyLiBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHVwZGF0ZSxcclxuICAgIC8vICAgIGl0cyB1cGRhdGUgY2FuIGJlIHNraXBwZWQuXHJcbiAgICBxdWV1ZS5zb3J0KChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm9yIChmbHVzaEluZGV4ID0gMDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoam9iICYmIGpvYi5hY3RpdmUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBqb2IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoam9iLCBudWxsLCAxNCAvKiBTQ0hFRFVMRVIgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgZmx1c2hJbmRleCA9IDA7XHJcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcclxuICAgICAgICBmbHVzaFBvc3RGbHVzaENicyhzZWVuKTtcclxuICAgICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgLy8gc29tZSBwb3N0Rmx1c2hDYiBxdWV1ZWQgam9icyFcclxuICAgICAgICAvLyBrZWVwIGZsdXNoaW5nIHVudGlsIGl0IGRyYWlucy5cclxuICAgICAgICBpZiAocXVldWUubGVuZ3RoIHx8XHJcbiAgICAgICAgICAgIHBlbmRpbmdQcmVGbHVzaENicy5sZW5ndGggfHxcclxuICAgICAgICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZmx1c2hKb2JzKHNlZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgZm4pIHtcclxuICAgIGlmICghc2Vlbi5oYXMoZm4pKSB7XHJcbiAgICAgICAgc2Vlbi5zZXQoZm4sIDEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY291bnQgPSBzZWVuLmdldChmbik7XHJcbiAgICAgICAgaWYgKGNvdW50ID4gUkVDVVJTSU9OX0xJTUlUKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gZm4ub3duZXJJbnN0YW5jZTtcclxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGluc3RhbmNlICYmIGdldENvbXBvbmVudE5hbWUoaW5zdGFuY2UudHlwZSk7XHJcbiAgICAgICAgICAgIHdhcm4oYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQke2NvbXBvbmVudE5hbWUgPyBgIGluIGNvbXBvbmVudCA8JHtjb21wb25lbnROYW1lfT5gIDogYGB9LiBgICtcclxuICAgICAgICAgICAgICAgIGBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBgICtcclxuICAgICAgICAgICAgICAgIGBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgYCArXHJcbiAgICAgICAgICAgICAgICBgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNlZW4uc2V0KGZuLCBjb3VudCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxubGV0IGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcclxuY29uc3QgaG1yRGlydHlDb21wb25lbnRzID0gbmV3IFNldCgpO1xyXG4vLyBFeHBvc2UgdGhlIEhNUiBydW50aW1lIG9uIHRoZSBnbG9iYWwgb2JqZWN0XHJcbi8vIFRoaXMgbWFrZXMgaXQgZW50aXJlbHkgdHJlZS1zaGFrYWJsZSB3aXRob3V0IHBvbGx1dGluZyB0aGUgZXhwb3J0cyBhbmQgbWFrZXNcclxuLy8gaXQgZWFzaWVyIHRvIGJlIHVzZWQgaW4gdG9vbGluZ3MgbGlrZSB2dWUtbG9hZGVyXHJcbi8vIE5vdGU6IGZvciBhIGNvbXBvbmVudCB0byBiZSBlbGlnaWJsZSBmb3IgSE1SIGl0IGFsc28gbmVlZHMgdGhlIF9faG1ySWQgb3B0aW9uXHJcbi8vIHRvIGJlIHNldCBzbyB0aGF0IGl0cyBpbnN0YW5jZXMgY2FuIGJlIHJlZ2lzdGVyZWQgLyByZW1vdmVkLlxyXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICBjb25zdCBnbG9iYWxPYmplY3QgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgID8gZ2xvYmFsXHJcbiAgICAgICAgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgPyBzZWxmXHJcbiAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgID8gd2luZG93XHJcbiAgICAgICAgICAgICAgICA6IHt9O1xyXG4gICAgZ2xvYmFsT2JqZWN0Ll9fVlVFX0hNUl9SVU5USU1FX18gPSB7XHJcbiAgICAgICAgY3JlYXRlUmVjb3JkOiB0cnlXcmFwKGNyZWF0ZVJlY29yZCksXHJcbiAgICAgICAgcmVyZW5kZXI6IHRyeVdyYXAocmVyZW5kZXIpLFxyXG4gICAgICAgIHJlbG9hZDogdHJ5V3JhcChyZWxvYWQpXHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcclxuZnVuY3Rpb24gcmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGlkID0gaW5zdGFuY2UudHlwZS5fX2htcklkO1xyXG4gICAgbGV0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xyXG4gICAgaWYgKCFyZWNvcmQpIHtcclxuICAgICAgICBjcmVhdGVSZWNvcmQoaWQsIGluc3RhbmNlLnR5cGUpO1xyXG4gICAgICAgIHJlY29yZCA9IG1hcC5nZXQoaWQpO1xyXG4gICAgfVxyXG4gICAgcmVjb3JkLmluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xyXG59XHJcbmZ1bmN0aW9uIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcclxuICAgIG1hcC5nZXQoaW5zdGFuY2UudHlwZS5fX2htcklkKS5pbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWNvcmQoaWQsIGNvbXBvbmVudCkge1xyXG4gICAgaWYgKCFjb21wb25lbnQpIHtcclxuICAgICAgICB3YXJuKGBITVIgQVBJIHVzYWdlIGlzIG91dCBvZiBkYXRlLlxcbmAgK1xyXG4gICAgICAgICAgICBgUGxlYXNlIHVwZ3JhZGUgdnVlLWxvYWRlci92aXRlL3JvbGx1cC1wbHVnaW4tdnVlIG9yIG90aGVyIHJlbGV2YW50IGAgK1xyXG4gICAgICAgICAgICBgZGVwZW5kZW5jeSB0aGF0IGhhbmRsZXMgVnVlIFNGQyBjb21waWxhdGlvbi5gKTtcclxuICAgICAgICBjb21wb25lbnQgPSB7fTtcclxuICAgIH1cclxuICAgIGlmIChtYXAuaGFzKGlkKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIG1hcC5zZXQoaWQsIHtcclxuICAgICAgICBjb21wb25lbnQ6IGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSA/IGNvbXBvbmVudC5fX3ZjY09wdHMgOiBjb21wb25lbnQsXHJcbiAgICAgICAgaW5zdGFuY2VzOiBuZXcgU2V0KClcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcmVyZW5kZXIoaWQsIG5ld1JlbmRlcikge1xyXG4gICAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBpZiAobmV3UmVuZGVyKVxyXG4gICAgICAgIHJlY29yZC5jb21wb25lbnQucmVuZGVyID0gbmV3UmVuZGVyO1xyXG4gICAgLy8gQXJyYXkuZnJvbSBjcmVhdGVzIGEgc25hcHNob3Qgd2hpY2ggYXZvaWRzIHRoZSBzZXQgYmVpbmcgbXV0YXRlZCBkdXJpbmdcclxuICAgIC8vIHVwZGF0ZXNcclxuICAgIEFycmF5LmZyb20ocmVjb3JkLmluc3RhbmNlcykuZm9yRWFjaChpbnN0YW5jZSA9PiB7XHJcbiAgICAgICAgaWYgKG5ld1JlbmRlcikge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSBuZXdSZW5kZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlckNhY2hlID0gW107XHJcbiAgICAgICAgLy8gdGhpcyBmbGFnIGZvcmNlcyBjaGlsZCBjb21wb25lbnRzIHdpdGggc2xvdCBjb250ZW50IHRvIHVwZGF0ZVxyXG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xyXG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlbG9hZChpZCwgbmV3Q29tcCkge1xyXG4gICAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICAvLyBBcnJheS5mcm9tIGNyZWF0ZXMgYSBzbmFwc2hvdCB3aGljaCBhdm9pZHMgdGhlIHNldCBiZWluZyBtdXRhdGVkIGR1cmluZ1xyXG4gICAgLy8gdXBkYXRlc1xyXG4gICAgY29uc3QgeyBjb21wb25lbnQsIGluc3RhbmNlcyB9ID0gcmVjb3JkO1xyXG4gICAgaWYgKCFobXJEaXJ0eUNvbXBvbmVudHMuaGFzKGNvbXBvbmVudCkpIHtcclxuICAgICAgICAvLyAxLiBVcGRhdGUgZXhpc3RpbmcgY29tcCBkZWZpbml0aW9uIHRvIG1hdGNoIG5ldyBvbmVcclxuICAgICAgICBuZXdDb21wID0gaXNDbGFzc0NvbXBvbmVudChuZXdDb21wKSA/IG5ld0NvbXAuX192Y2NPcHRzIDogbmV3Q29tcDtcclxuICAgICAgICBleHRlbmQoY29tcG9uZW50LCBuZXdDb21wKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ19fZmlsZScgJiYgIShrZXkgaW4gbmV3Q29tcCkpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb21wb25lbnRba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAyLiBNYXJrIGNvbXBvbmVudCBkaXJ0eS4gVGhpcyBmb3JjZXMgdGhlIHJlbmRlcmVyIHRvIHJlcGxhY2UgdGhlIGNvbXBvbmVudFxyXG4gICAgICAgIC8vIG9uIHBhdGNoLlxyXG4gICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5hZGQoY29tcG9uZW50KTtcclxuICAgICAgICAvLyAzLiBNYWtlIHN1cmUgdG8gdW5tYXJrIHRoZSBjb21wb25lbnQgYWZ0ZXIgdGhlIHJlbG9hZC5cclxuICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKCgpID0+IHtcclxuICAgICAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmRlbGV0ZShjb21wb25lbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgQXJyYXkuZnJvbShpbnN0YW5jZXMpLmZvckVhY2goaW5zdGFuY2UgPT4ge1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgLy8gNC4gRm9yY2UgdGhlIHBhcmVudCBpbnN0YW5jZSB0byByZS1yZW5kZXIuIFRoaXMgd2lsbCBjYXVzZSBhbGwgdXBkYXRlZFxyXG4gICAgICAgICAgICAvLyBjb21wb25lbnRzIHRvIGJlIHVubW91bnRlZCBhbmQgcmUtbW91bnRlZC4gUXVldWUgdGhlIHVwZGF0ZSBzbyB0aGF0IHdlXHJcbiAgICAgICAgICAgIC8vIGRvbid0IGVuZCB1cCBmb3JjaW5nIHRoZSBzYW1lIHBhcmVudCB0byByZS1yZW5kZXIgbXVsdGlwbGUgdGltZXMuXHJcbiAgICAgICAgICAgIHF1ZXVlSm9iKGluc3RhbmNlLnBhcmVudC51cGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCkge1xyXG4gICAgICAgICAgICAvLyByb290IGluc3RhbmNlIG1vdW50ZWQgdmlhIGNyZWF0ZUFwcCgpIGhhcyBhIHJlbG9hZCBtZXRob2RcclxuICAgICAgICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLy8gcm9vdCBpbnN0YW5jZSBpbnNpZGUgdHJlZSBjcmVhdGVkIHZpYSByYXcgcmVuZGVyKCkuIEZvcmNlIHJlbG9hZC5cclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbSE1SXSBSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcclxuICAgIHJldHVybiAoaWQsIGFyZykgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbihpZCwgYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbSE1SXSBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBgICtcclxuICAgICAgICAgICAgICAgIGBGdWxsIHJlbG9hZCByZXF1aXJlZC5gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmxldCBkZXZ0b29scztcclxuZnVuY3Rpb24gc2V0RGV2dG9vbHNIb29rKGhvb2spIHtcclxuICAgIGRldnRvb2xzID0gaG9vaztcclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKSB7XHJcbiAgICAvLyBUT0RPIHF1ZXVlIGlmIGRldnRvb2xzIGlzIHVuZGVmaW5lZFxyXG4gICAgaWYgKCFkZXZ0b29scylcclxuICAgICAgICByZXR1cm47XHJcbiAgICBkZXZ0b29scy5lbWl0KFwiYXBwOmluaXRcIiAvKiBBUFBfSU5JVCAqLywgYXBwLCB2ZXJzaW9uLCB7XHJcbiAgICAgICAgRnJhZ21lbnQsXHJcbiAgICAgICAgVGV4dCxcclxuICAgICAgICBDb21tZW50OiBDb21tZW50JDEsXHJcbiAgICAgICAgU3RhdGljXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc1VubW91bnRBcHAoYXBwKSB7XHJcbiAgICBpZiAoIWRldnRvb2xzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGRldnRvb2xzLmVtaXQoXCJhcHA6dW5tb3VudFwiIC8qIEFQUF9VTk1PVU5UICovLCBhcHApO1xyXG59XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50QWRkZWQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDphZGRlZFwiIC8qIENPTVBPTkVOVF9BRERFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnVwZGF0ZWRcIiAvKiBDT01QT05FTlRfVVBEQVRFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnJlbW92ZWRcIiAvKiBDT01QT05FTlRfUkVNT1ZFRCAqLyk7XHJcbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhob29rKSB7XHJcbiAgICByZXR1cm4gKGNvbXBvbmVudCkgPT4ge1xyXG4gICAgICAgIGlmICghZGV2dG9vbHMpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBkZXZ0b29scy5lbWl0KGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LnBhcmVudCA/IGNvbXBvbmVudC5wYXJlbnQudWlkIDogdW5kZWZpbmVkLCBjb21wb25lbnQpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBkZXZ0b29sc1BlcmZTdGFydCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOnN0YXJ0XCIgLyogUEVSRk9STUFOQ0VfU1RBUlQgKi8pO1xyXG5jb25zdCBkZXZ0b29sc1BlcmZFbmQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjplbmRcIiAvKiBQRVJGT1JNQU5DRV9FTkQgKi8pO1xyXG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhob29rKSB7XHJcbiAgICByZXR1cm4gKGNvbXBvbmVudCwgdHlwZSwgdGltZSkgPT4ge1xyXG4gICAgICAgIGlmICghZGV2dG9vbHMpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBkZXZ0b29scy5lbWl0KGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LCB0eXBlLCB0aW1lKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZGV2dG9vbHNDb21wb25lbnRFbWl0KGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcykge1xyXG4gICAgaWYgKCFkZXZ0b29scylcclxuICAgICAgICByZXR1cm47XHJcbiAgICBkZXZ0b29scy5lbWl0KFwiY29tcG9uZW50OmVtaXRcIiAvKiBDT01QT05FTlRfRU1JVCAqLywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpO1xyXG59XG5cbmNvbnN0IGRlcHJlY2F0aW9uRGF0YSA9IHtcclxuICAgIFtcIkdMT0JBTF9NT1VOVFwiIC8qIEdMT0JBTF9NT1VOVCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVGhlIGdsb2JhbCBhcHAgYm9vdHN0cmFwcGluZyBBUEkgaGFzIGNoYW5nZWQ6IHZtLiRtb3VudCgpIGFuZCB0aGUgXCJlbFwiIGAgK1xyXG4gICAgICAgICAgICBgb3B0aW9uIGhhdmUgYmVlbiByZW1vdmVkLiBVc2UgY3JlYXRlQXBwKFJvb3RDb21wb25lbnQpLm1vdW50KCkgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZ2xvYmFsLWFwaS5odG1sI21vdW50aW5nLWFwcC1pbnN0YW5jZWBcclxuICAgIH0sXHJcbiAgICBbXCJHTE9CQUxfTU9VTlRfQ09OVEFJTkVSXCIgLyogR0xPQkFMX01PVU5UX0NPTlRBSU5FUiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlIGRldGVjdGVkIGRpcmVjdGl2ZXMgb24gdGhlIG1vdW50IGNvbnRhaW5lci4gYCArXHJcbiAgICAgICAgICAgIGBJbiBWdWUgMywgdGhlIGNvbnRhaW5lciBpcyBubyBsb25nZXIgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSB0ZW1wbGF0ZSBgICtcclxuICAgICAgICAgICAgYGFuZCB3aWxsIG5vdCBiZSBwcm9jZXNzZWQvcmVwbGFjZWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL21vdW50LWNoYW5nZXMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJHTE9CQUxfRVhURU5EXCIgLyogR0xPQkFMX0VYVEVORCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlLmV4dGVuZCgpIGhhcyBiZWVuIHJlbW92ZWQgaW4gVnVlIDMuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIGRlZmluZUNvbXBvbmVudCgpIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvYXBpL2dsb2JhbC1hcGkuaHRtbCNkZWZpbmVjb21wb25lbnRgXHJcbiAgICB9LFxyXG4gICAgW1wiR0xPQkFMX1BST1RPVFlQRVwiIC8qIEdMT0JBTF9QUk9UT1RZUEUgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZS5wcm90b3R5cGUgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZSBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgYXBwLmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2dsb2JhbC1hcGkuaHRtbCN2dWUtcHJvdG90eXBlLXJlcGxhY2VkLWJ5LWNvbmZpZy1nbG9iYWxwcm9wZXJ0aWVzYFxyXG4gICAgfSxcclxuICAgIFtcIkdMT0JBTF9TRVRcIiAvKiBHTE9CQUxfU0VUICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBWdWUuc2V0KCkgaGFzIGJlZW4gcmVtb3ZlZCBhcyBpdCBpcyBubyBsb25nZXIgbmVlZGVkIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYFNpbXBseSB1c2UgbmF0aXZlIEphdmFTY3JpcHQgbXV0YXRpb25zLmBcclxuICAgIH0sXHJcbiAgICBbXCJHTE9CQUxfREVMRVRFXCIgLyogR0xPQkFMX0RFTEVURSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlLmRlbGV0ZSgpIGhhcyBiZWVuIHJlbW92ZWQgYXMgaXQgaXMgbm8gbG9uZ2VyIG5lZWRlZCBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBTaW1wbHkgdXNlIG5hdGl2ZSBKYXZhU2NyaXB0IG11dGF0aW9ucy5gXHJcbiAgICB9LFxyXG4gICAgW1wiR0xPQkFMX09CU0VSVkFCTEVcIiAvKiBHTE9CQUxfT0JTRVJWQUJMRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlLm9ic2VydmFibGUoKSBoYXMgYmVlbiByZW1vdmVkLiBgICtcclxuICAgICAgICAgICAgYFVzZSBcXGBpbXBvcnQgeyByZWFjdGl2ZSB9IGZyb20gXCJ2dWVcIlxcYCBmcm9tIENvbXBvc2l0aW9uIEFQSSBpbnN0ZWFkLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2FwaS9iYXNpYy1yZWFjdGl2aXR5Lmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiR0xPQkFMX1BSSVZBVEVfVVRJTFwiIC8qIEdMT0JBTF9QUklWQVRFX1VUSUwgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZS51dGlsIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSByZWZhY3RvciB0byBhdm9pZCBpdHMgdXNhZ2UgYCArXHJcbiAgICAgICAgICAgIGBzaW5jZSBpdCB3YXMgYW4gaW50ZXJuYWwgQVBJIGV2ZW4gaW4gVnVlIDIuYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTkZJR19TSUxFTlRcIiAvKiBDT05GSUdfU0lMRU5UICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBjb25maWcuc2lsZW50IGhhcyBiZWVuIHJlbW92ZWQgYmVjYXVzZSBpdCBpcyBub3QgZ29vZCBwcmFjdGljZSB0byBgICtcclxuICAgICAgICAgICAgYGludGVudGlvbmFsbHkgc3VwcHJlc3Mgd2FybmluZ3MuIFlvdSBjYW4gdXNlIHlvdXIgYnJvd3NlciBjb25zb2xlJ3MgYCArXHJcbiAgICAgICAgICAgIGBmaWx0ZXIgZmVhdHVyZXMgdG8gZm9jdXMgb24gcmVsZXZhbnQgbWVzc2FnZXMuYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTkZJR19ERVZUT09MU1wiIC8qIENPTkZJR19ERVZUT09MUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgY29uZmlnLmRldnRvb2xzIGhhcyBiZWVuIHJlbW92ZWQuIFRvIGVuYWJsZSBkZXZ0b29scyBmb3IgYCArXHJcbiAgICAgICAgICAgIGBwcm9kdWN0aW9uLCBjb25maWd1cmUgdGhlIF9fVlVFX1BST0RfREVWVE9PTFNfXyBjb21waWxlLXRpbWUgZmxhZy5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLW5leHQvdHJlZS9tYXN0ZXIvcGFja2FnZXMvdnVlI2J1bmRsZXItYnVpbGQtZmVhdHVyZS1mbGFnc2BcclxuICAgIH0sXHJcbiAgICBbXCJDT05GSUdfS0VZX0NPREVTXCIgLyogQ09ORklHX0tFWV9DT0RFUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgY29uZmlnLmtleUNvZGVzIGhhcyBiZWVuIHJlbW92ZWQuIGAgK1xyXG4gICAgICAgICAgICBgSW4gVnVlIDMsIHlvdSBjYW4gZGlyZWN0bHkgdXNlIHRoZSBrZWJhYi1jYXNlIGtleSBuYW1lcyBhcyB2LW9uIG1vZGlmaWVycy5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24va2V5Y29kZS1tb2RpZmllcnMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT05GSUdfUFJPRFVDVElPTl9USVBcIiAvKiBDT05GSUdfUFJPRFVDVElPTl9USVAgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYGNvbmZpZy5wcm9kdWN0aW9uVGlwIGhhcyBiZWVuIHJlbW92ZWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2dsb2JhbC1hcGkuaHRtbCNjb25maWctcHJvZHVjdGlvbnRpcC1yZW1vdmVkYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTkZJR19JR05PUkVEX0VMRU1FTlRTXCIgLyogQ09ORklHX0lHTk9SRURfRUxFTUVOVFMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbXNnID0gYGNvbmZpZy5pZ25vcmVkRWxlbWVudHMgaGFzIGJlZW4gcmVtb3ZlZC5gO1xyXG4gICAgICAgICAgICBpZiAoaXNSdW50aW1lT25seSgpKSB7XHJcbiAgICAgICAgICAgICAgICBtc2cgKz0gYCBQYXNzIHRoZSBcImlzQ3VzdG9tRWxlbWVudFwiIG9wdGlvbiB0byBAdnVlL2NvbXBpbGVyLWRvbSBpbnN0ZWFkLmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtc2cgKz0gYCBVc2UgY29uZmlnLmlzQ3VzdG9tRWxlbWVudCBpbnN0ZWFkLmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1zZztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZ2xvYmFsLWFwaS5odG1sI2NvbmZpZy1pZ25vcmVkZWxlbWVudHMtaXMtbm93LWNvbmZpZy1pc2N1c3RvbWVsZW1lbnRgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09ORklHX1dISVRFU1BBQ0VcIiAvKiBDT05GSUdfV0hJVEVTUEFDRSAqL106IHtcclxuICAgICAgICAvLyB0aGlzIHdhcm5pbmcgaXMgb25seSByZWxldmFudCBpbiB0aGUgZnVsbCBidWlsZCB3aGVuIHVzaW5nIHJ1bnRpbWVcclxuICAgICAgICAvLyBjb21waWxhdGlvbiwgc28gaXQncyBwdXQgaW4gdGhlIHJ1bnRpbWUgY29tcGF0Q29uZmlnIGxpc3QuXHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZSAzIGNvbXBpbGVyJ3Mgd2hpdGVzcGFjZSBvcHRpb24gd2lsbCBkZWZhdWx0IHRvIFwiY29uZGVuc2VcIiBpbnN0ZWFkIG9mIGAgK1xyXG4gICAgICAgICAgICBgXCJwcmVzZXJ2ZVwiLiBUbyBzdXBwcmVzcyB0aGlzIHdhcm5pbmcsIHByb3ZpZGUgYW4gZXhwbGljaXQgdmFsdWUgZm9yIGAgK1xyXG4gICAgICAgICAgICBgXFxgY29uZmlnLmNvbXBpbGVyT3B0aW9ucy53aGl0ZXNwYWNlXFxgLmBcclxuICAgIH0sXHJcbiAgICBbXCJDT05GSUdfT1BUSU9OX01FUkdFX1NUUkFUU1wiIC8qIENPTkZJR19PUFRJT05fTUVSR0VfU1RSQVRTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzIG5vIGxvbmdlciBleHBvc2VzIGludGVybmFsIHN0cmF0ZWdpZXMuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIGN1c3RvbSBtZXJnZSBmdW5jdGlvbnMgaW5zdGVhZC5gXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfU0VUXCIgLyogSU5TVEFOQ0VfU0VUICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2bS4kc2V0KCkgaGFzIGJlZW4gcmVtb3ZlZCBhcyBpdCBpcyBubyBsb25nZXIgbmVlZGVkIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYFNpbXBseSB1c2UgbmF0aXZlIEphdmFTY3JpcHQgbXV0YXRpb25zLmBcclxuICAgIH0sXHJcbiAgICBbXCJJTlNUQU5DRV9ERUxFVEVcIiAvKiBJTlNUQU5DRV9ERUxFVEUgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHZtLiRkZWxldGUoKSBoYXMgYmVlbiByZW1vdmVkIGFzIGl0IGlzIG5vIGxvbmdlciBuZWVkZWQgaW4gVnVlIDMuIGAgK1xyXG4gICAgICAgICAgICBgU2ltcGx5IHVzZSBuYXRpdmUgSmF2YVNjcmlwdCBtdXRhdGlvbnMuYFxyXG4gICAgfSxcclxuICAgIFtcIklOU1RBTkNFX0RFU1RST1lcIiAvKiBJTlNUQU5DRV9ERVNUUk9ZICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2bS4kZGVzdHJveSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhcHAudW5tb3VudCgpIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvYXBpL2FwcGxpY2F0aW9uLWFwaS5odG1sI3VubW91bnRgXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfRVZFTlRfRU1JVFRFUlwiIC8qIElOU1RBTkNFX0VWRU5UX0VNSVRURVIgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHZtLiRvbi8kb25jZS8kb2ZmKCkgaGF2ZSBiZWVuIHJlbW92ZWQuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIGFuIGV4dGVybmFsIGV2ZW50IGVtaXR0ZXIgbGlicmFyeSBpbnN0ZWFkLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9ldmVudHMtYXBpLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfRVZFTlRfSE9PS1NcIiAvKiBJTlNUQU5DRV9FVkVOVF9IT09LUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBldmVudCA9PiBgXCIke2V2ZW50fVwiIGxpZmVjeWNsZSBldmVudHMgYXJlIG5vIGxvbmdlciBzdXBwb3J0ZWQuIEZyb20gdGVtcGxhdGVzLCBgICtcclxuICAgICAgICAgICAgYHVzZSB0aGUgXCJ2bm9kZVwiIHByZWZpeCBpbnN0ZWFkIG9mIFwiaG9vazpcIi4gRm9yIGV4YW1wbGUsIEAke2V2ZW50fSBgICtcclxuICAgICAgICAgICAgYHNob3VsZCBiZSBjaGFuZ2VkIHRvIEB2bm9kZS0ke2V2ZW50LnNsaWNlKDUpfS4gYCArXHJcbiAgICAgICAgICAgIGBGcm9tIEphdmFTY3JpcHQsIHVzZSBDb21wb3NpdGlvbiBBUEkgdG8gZHluYW1pY2FsbHkgcmVnaXN0ZXIgbGlmZWN5Y2xlIGAgK1xyXG4gICAgICAgICAgICBgaG9va3MuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3Zub2RlLWxpZmVjeWNsZS1ldmVudHMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJJTlNUQU5DRV9DSElMRFJFTlwiIC8qIElOU1RBTkNFX0NISUxEUkVOICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2bS4kY2hpbGRyZW4gaGFzIGJlZW4gcmVtb3ZlZC4gQ29uc2lkZXIgcmVmYWN0b3JpbmcgeW91ciBsb2dpYyBgICtcclxuICAgICAgICAgICAgYHRvIGF2b2lkIHJlbHlpbmcgb24gZGlyZWN0IGFjY2VzcyB0byBjaGlsZCBjb21wb25lbnRzLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9jaGlsZHJlbi5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIklOU1RBTkNFX0xJU1RFTkVSU1wiIC8qIElOU1RBTkNFX0xJU1RFTkVSUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgdm0uJGxpc3RlbmVycyBoYXMgYmVlbiByZW1vdmVkLiBJbiBWdWUgMywgcGFyZW50IHYtb24gbGlzdGVuZXJzIGFyZSBgICtcclxuICAgICAgICAgICAgYGluY2x1ZGVkIGluIHZtLiRhdHRycyBhbmQgaXQgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSB0byBzZXBhcmF0ZWx5IHVzZSBgICtcclxuICAgICAgICAgICAgYHYtb249XCIkbGlzdGVuZXJzXCIgaWYgeW91IGFyZSBhbHJlYWR5IHVzaW5nIHYtYmluZD1cIiRhdHRyc1wiLiBgICtcclxuICAgICAgICAgICAgYChOb3RlOiB0aGUgVnVlIDMgYmVoYXZpb3Igb25seSBhcHBsaWVzIGlmIHRoaXMgY29tcGF0IGNvbmZpZyBpcyBkaXNhYmxlZClgLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vbGlzdGVuZXJzLXJlbW92ZWQuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJJTlNUQU5DRV9TQ09QRURfU0xPVFNcIiAvKiBJTlNUQU5DRV9TQ09QRURfU0xPVFMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHZtLiRzY29wZWRTbG90cyBoYXMgYmVlbiByZW1vdmVkLiBVc2Ugdm0uJHNsb3RzIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3Nsb3RzLXVuaWZpY2F0aW9uLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfQVRUUlNfQ0xBU1NfU1RZTEVcIiAvKiBJTlNUQU5DRV9BVFRSU19DTEFTU19TVFlMRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBjb21wb25lbnROYW1lID0+IGBDb21wb25lbnQgPCR7Y29tcG9uZW50TmFtZSB8fFxyXG4gICAgICAgICAgICAnQW5vbnltb3VzJ30+IGhhcyBcXGBpbmhlcml0QXR0cnM6IGZhbHNlXFxgIGJ1dCBpcyBgICtcclxuICAgICAgICAgICAgYHJlbHlpbmcgb24gY2xhc3Mvc3R5bGUgZmFsbHRocm91Z2ggZnJvbSBwYXJlbnQuIEluIFZ1ZSAzLCBjbGFzcy9zdHlsZSBgICtcclxuICAgICAgICAgICAgYGFyZSBub3cgaW5jbHVkZWQgaW4gJGF0dHJzIGFuZCB3aWxsIG5vIGxvbmdlciBmYWxsdGhyb3VnaCB3aGVuIGAgK1xyXG4gICAgICAgICAgICBgaW5oZXJpdEF0dHJzIGlzIGZhbHNlLiBJZiB5b3UgYXJlIGFscmVhZHkgdXNpbmcgdi1iaW5kPVwiJGF0dHJzXCIgb24gYCArXHJcbiAgICAgICAgICAgIGBjb21wb25lbnQgcm9vdCBpdCBzaG91bGQgcmVuZGVyIHRoZSBzYW1lIGVuZCByZXN1bHQuIGAgK1xyXG4gICAgICAgICAgICBgSWYgeW91IGFyZSBiaW5kaW5nICRhdHRycyB0byBhIG5vbi1yb290IGVsZW1lbnQgYW5kIGV4cGVjdGluZyBgICtcclxuICAgICAgICAgICAgYGNsYXNzL3N0eWxlIHRvIGZhbGx0aHJvdWdoIG9uIHJvb3QsIHlvdSB3aWxsIG5lZWQgdG8gbm93IG1hbnVhbGx5IGJpbmQgYCArXHJcbiAgICAgICAgICAgIGB0aGVtIG9uIHJvb3QgdmlhIDpjbGFzcz1cIiRhdHRycy5jbGFzc1wiLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9hdHRycy1pbmNsdWRlcy1jbGFzcy1zdHlsZS5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIk9QVElPTlNfREFUQV9GTlwiIC8qIE9QVElPTlNfREFUQV9GTiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVGhlIFwiZGF0YVwiIG9wdGlvbiBjYW4gbm8gbG9uZ2VyIGJlIGEgcGxhaW4gb2JqZWN0LiBgICtcclxuICAgICAgICAgICAgYEFsd2F5cyB1c2UgYSBmdW5jdGlvbi5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZGF0YS1vcHRpb24uaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJPUFRJT05TX0RBVEFfTUVSR0VcIiAvKiBPUFRJT05TX0RBVEFfTUVSR0UgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGtleSkgPT4gYERldGVjdGVkIGNvbmZsaWN0aW5nIGtleSBcIiR7a2V5fVwiIHdoZW4gbWVyZ2luZyBkYXRhIG9wdGlvbiB2YWx1ZXMuIGAgK1xyXG4gICAgICAgICAgICBgSW4gVnVlIDMsIGRhdGEga2V5cyBhcmUgbWVyZ2VkIHNoYWxsb3dseSBhbmQgd2lsbCBvdmVycmlkZSBvbmUgYW5vdGhlci5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZGF0YS1vcHRpb24uaHRtbCNtaXhpbi1tZXJnZS1iZWhhdmlvci1jaGFuZ2VgXHJcbiAgICB9LFxyXG4gICAgW1wiT1BUSU9OU19CRUZPUkVfREVTVFJPWVwiIC8qIE9QVElPTlNfQkVGT1JFX0RFU1RST1kgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFxcYGJlZm9yZURlc3Ryb3lcXGAgaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBiZWZvcmVVbm1vdW50XFxgLmBcclxuICAgIH0sXHJcbiAgICBbXCJPUFRJT05TX0RFU1RST1lFRFwiIC8qIE9QVElPTlNfREVTVFJPWUVEICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBcXGBkZXN0cm95ZWRcXGAgaGFzIGJlZW4gcmVuYW1lZCB0byBcXGB1bm1vdW50ZWRcXGAuYFxyXG4gICAgfSxcclxuICAgIFtcIldBVENIX0FSUkFZXCIgLyogV0FUQ0hfQVJSQVkgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFwid2F0Y2hcIiBvcHRpb24gb3Igdm0uJHdhdGNoIG9uIGFuIGFycmF5IHZhbHVlIHdpbGwgbm8gbG9uZ2VyIGAgK1xyXG4gICAgICAgICAgICBgdHJpZ2dlciBvbiBhcnJheSBtdXRhdGlvbiB1bmxlc3MgdGhlIFwiZGVlcFwiIG9wdGlvbiBpcyBzcGVjaWZpZWQuIGAgK1xyXG4gICAgICAgICAgICBgSWYgY3VycmVudCB1c2FnZSBpcyBpbnRlbmRlZCwgeW91IGNhbiBkaXNhYmxlIHRoZSBjb21wYXQgYmVoYXZpb3IgYW5kIGAgK1xyXG4gICAgICAgICAgICBgc3VwcHJlc3MgdGhpcyB3YXJuaW5nIHdpdGg6YCArXHJcbiAgICAgICAgICAgIGBcXG5cXG4gIGNvbmZpZ3VyZUNvbXBhdCh7ICR7XCJXQVRDSF9BUlJBWVwiIC8qIFdBVENIX0FSUkFZICovfTogZmFsc2UgfSlcXG5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vd2F0Y2guaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJQUk9QU19ERUZBVUxUX1RISVNcIiAvKiBQUk9QU19ERUZBVUxUX1RISVMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGtleSkgPT4gYHByb3BzIGRlZmF1bHQgdmFsdWUgZnVuY3Rpb24gbm8gbG9uZ2VyIGhhcyBhY2Nlc3MgdG8gXCJ0aGlzXCIuIFRoZSBjb21wYXQgYCArXHJcbiAgICAgICAgICAgIGBidWlsZCBvbmx5IG9mZmVycyBhY2Nlc3MgdG8gdGhpcy4kb3B0aW9ucy5gICtcclxuICAgICAgICAgICAgYChmb3VuZCBpbiBwcm9wIFwiJHtrZXl9XCIpYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3Byb3BzLWRlZmF1bHQtdGhpcy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNVU1RPTV9ESVJcIiAvKiBDVVNUT01fRElSICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IChsZWdhY3lIb29rLCBuZXdIb29rKSA9PiBgQ3VzdG9tIGRpcmVjdGl2ZSBob29rIFwiJHtsZWdhY3lIb29rfVwiIGhhcyBiZWVuIHJlbW92ZWQuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIFwiJHtuZXdIb29rfVwiIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2N1c3RvbS1kaXJlY3RpdmVzLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiVl9GT1JfUkVGXCIgLyogVl9GT1JfUkVGICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBSZWYgdXNhZ2Ugb24gdi1mb3Igbm8gbG9uZ2VyIGNyZWF0ZXMgYXJyYXkgcmVmIHZhbHVlcyBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBDb25zaWRlciB1c2luZyBmdW5jdGlvbiByZWZzIG9yIHJlZmFjdG9yIHRvIGF2b2lkIHJlZiB1c2FnZSBhbHRvZ2V0aGVyLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9hcnJheS1yZWZzLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiVl9PTl9LRVlDT0RFX01PRElGSUVSXCIgLyogVl9PTl9LRVlDT0RFX01PRElGSUVSICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBVc2luZyBrZXlDb2RlIGFzIHYtb24gbW9kaWZpZXIgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gYCArXHJcbiAgICAgICAgICAgIGBVc2Uga2ViYWItY2FzZSBrZXkgbmFtZSBtb2RpZmllcnMgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24va2V5Y29kZS1tb2RpZmllcnMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJBVFRSX0ZBTFNFX1ZBTFVFXCIgLyogQVRUUl9GQUxTRV9WQUxVRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiAobmFtZSkgPT4gYEF0dHJpYnV0ZSBcIiR7bmFtZX1cIiB3aXRoIHYtYmluZCB2YWx1ZSBcXGBmYWxzZVxcYCB3aWxsIHJlbmRlciBgICtcclxuICAgICAgICAgICAgYCR7bmFtZX09XCJmYWxzZVwiIGluc3RlYWQgb2YgcmVtb3ZpbmcgaXQgaW4gVnVlIDMuIFRvIHJlbW92ZSB0aGUgYXR0cmlidXRlLCBgICtcclxuICAgICAgICAgICAgYHVzZSBcXGBudWxsXFxgIG9yIFxcYHVuZGVmaW5lZFxcYCBpbnN0ZWFkLiBJZiB0aGUgdXNhZ2UgaXMgaW50ZW5kZWQsIGAgK1xyXG4gICAgICAgICAgICBgeW91IGNhbiBkaXNhYmxlIHRoZSBjb21wYXQgYmVoYXZpb3IgYW5kIHN1cHByZXNzIHRoaXMgd2FybmluZyB3aXRoOmAgK1xyXG4gICAgICAgICAgICBgXFxuXFxuICBjb25maWd1cmVDb21wYXQoeyAke1wiQVRUUl9GQUxTRV9WQUxVRVwiIC8qIEFUVFJfRkFMU0VfVkFMVUUgKi99OiBmYWxzZSB9KVxcbmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9hdHRyaWJ1dGUtY29lcmNpb24uaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJBVFRSX0VOVU1FUkFURURfQ09FUkNJT05cIiAvKiBBVFRSX0VOVU1FUkFURURfQ09FUkNJT04gKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKG5hbWUsIHZhbHVlLCBjb2VyY2VkKSA9PiBgRW51bWVyYXRlZCBhdHRyaWJ1dGUgXCIke25hbWV9XCIgd2l0aCB2LWJpbmQgdmFsdWUgXFxgJHt2YWx1ZX1cXGAgd2lsbCBgICtcclxuICAgICAgICAgICAgYCR7dmFsdWUgPT09IG51bGwgPyBgYmUgcmVtb3ZlZGAgOiBgcmVuZGVyIHRoZSB2YWx1ZSBhcy1pc2B9IGluc3RlYWQgb2YgY29lcmNpbmcgdGhlIHZhbHVlIHRvIFwiJHtjb2VyY2VkfVwiIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYEFsd2F5cyB1c2UgZXhwbGljaXQgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiIHZhbHVlcyBmb3IgZW51bWVyYXRlZCBhdHRyaWJ1dGVzLiBgICtcclxuICAgICAgICAgICAgYElmIHRoZSB1c2FnZSBpcyBpbnRlbmRlZCwgYCArXHJcbiAgICAgICAgICAgIGB5b3UgY2FuIGRpc2FibGUgdGhlIGNvbXBhdCBiZWhhdmlvciBhbmQgc3VwcHJlc3MgdGhpcyB3YXJuaW5nIHdpdGg6YCArXHJcbiAgICAgICAgICAgIGBcXG5cXG4gIGNvbmZpZ3VyZUNvbXBhdCh7ICR7XCJBVFRSX0VOVU1FUkFURURfQ09FUkNJT05cIiAvKiBBVFRSX0VOVU1FUkFURURfQ09FUkNJT04gKi99OiBmYWxzZSB9KVxcbmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9hdHRyaWJ1dGUtY29lcmNpb24uaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJUUkFOU0lUSU9OX0NMQVNTRVNcIiAvKiBUUkFOU0lUSU9OX0NMQVNTRVMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYGAgLy8gdGhpcyBmZWF0dXJlIGNhbm5vdCBiZSBydW50aW1lLWRldGVjdGVkXHJcbiAgICB9LFxyXG4gICAgW1wiVFJBTlNJVElPTl9HUk9VUF9ST09UXCIgLyogVFJBTlNJVElPTl9HUk9VUF9ST09UICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGA8VHJhbnNpdGlvbkdyb3VwPiBubyBsb25nZXIgcmVuZGVycyBhIHJvb3QgPHNwYW4+IGVsZW1lbnQgYnkgYCArXHJcbiAgICAgICAgICAgIGBkZWZhdWx0IGlmIG5vIFwidGFnXCIgcHJvcCBpcyBzcGVjaWZpZWQuIElmIHlvdSBkbyBub3QgcmVseSBvbiB0aGUgc3BhbiBgICtcclxuICAgICAgICAgICAgYGZvciBzdHlsaW5nLCB5b3UgY2FuIGRpc2FibGUgdGhlIGNvbXBhdCBiZWhhdmlvciBhbmQgc3VwcHJlc3MgdGhpcyBgICtcclxuICAgICAgICAgICAgYHdhcm5pbmcgd2l0aDpgICtcclxuICAgICAgICAgICAgYFxcblxcbiAgY29uZmlndXJlQ29tcGF0KHsgJHtcIlRSQU5TSVRJT05fR1JPVVBfUk9PVFwiIC8qIFRSQU5TSVRJT05fR1JPVVBfUk9PVCAqL306IGZhbHNlIH0pXFxuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3RyYW5zaXRpb24tZ3JvdXAuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QT05FTlRfQVNZTkNcIiAvKiBDT01QT05FTlRfQVNZTkMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGNvbXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoYEFzeW5jIGNvbXBvbmVudCR7bmFtZSA/IGAgPCR7bmFtZX0+YCA6IGBzYH0gc2hvdWxkIGJlIGV4cGxpY2l0bHkgY3JlYXRlZCB2aWEgXFxgZGVmaW5lQXN5bmNDb21wb25lbnQoKVxcYCBgICtcclxuICAgICAgICAgICAgICAgIGBpbiBWdWUgMy4gUGxhaW4gZnVuY3Rpb25zIHdpbGwgYmUgdHJlYXRlZCBhcyBmdW5jdGlvbmFsIGNvbXBvbmVudHMgaW4gYCArXHJcbiAgICAgICAgICAgICAgICBgbm9uLWNvbXBhdCBidWlsZC4gSWYgeW91IGhhdmUgYWxyZWFkeSBtaWdyYXRlZCBhbGwgYXN5bmMgY29tcG9uZW50IGAgK1xyXG4gICAgICAgICAgICAgICAgYHVzYWdlIGFuZCBpbnRlbmQgdG8gdXNlIHBsYWluIGZ1bmN0aW9ucyBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLCBgICtcclxuICAgICAgICAgICAgICAgIGB5b3UgY2FuIGRpc2FibGUgdGhlIGNvbXBhdCBiZWhhdmlvciBhbmQgc3VwcHJlc3MgdGhpcyBgICtcclxuICAgICAgICAgICAgICAgIGB3YXJuaW5nIHdpdGg6YCArXHJcbiAgICAgICAgICAgICAgICBgXFxuXFxuICBjb25maWd1cmVDb21wYXQoeyAke1wiQ09NUE9ORU5UX0FTWU5DXCIgLyogQ09NUE9ORU5UX0FTWU5DICovfTogZmFsc2UgfSlcXG5gKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vYXN5bmMtY29tcG9uZW50cy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBPTkVOVF9GVU5DVElPTkFMXCIgLyogQ09NUE9ORU5UX0ZVTkNUSU9OQUwgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGNvbXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoYEZ1bmN0aW9uYWwgY29tcG9uZW50JHtuYW1lID8gYCA8JHtuYW1lfT5gIDogYHNgfSBzaG91bGQgYmUgZGVmaW5lZCBhcyBhIHBsYWluIGZ1bmN0aW9uIGluIFZ1ZSAzLiBUaGUgXCJmdW5jdGlvbmFsXCIgYCArXHJcbiAgICAgICAgICAgICAgICBgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQuIE5PVEU6IEJlZm9yZSBtaWdyYXRpbmcgdG8gdXNlIHBsYWluIGAgK1xyXG4gICAgICAgICAgICAgICAgYGZ1bmN0aW9ucyBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLCBmaXJzdCBtYWtlIHN1cmUgdGhhdCBhbGwgYXN5bmMgYCArXHJcbiAgICAgICAgICAgICAgICBgY29tcG9uZW50cyB1c2FnZSBoYXZlIGJlZW4gbWlncmF0ZWQgYW5kIGl0cyBjb21wYXQgYmVoYXZpb3IgaGFzIGAgK1xyXG4gICAgICAgICAgICAgICAgYGJlZW4gZGlzYWJsZWQuYCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2Z1bmN0aW9uYWwtY29tcG9uZW50cy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBPTkVOVF9WX01PREVMXCIgLyogQ09NUE9ORU5UX1ZfTU9ERUwgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGNvbXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29uZmlnTXNnID0gYG9wdC1pbiB0byBgICtcclxuICAgICAgICAgICAgICAgIGBWdWUgMyBiZWhhdmlvciBvbiBhIHBlci1jb21wb25lbnQgYmFzaXMgd2l0aCBcXGBjb21wYXRDb25maWc6IHsgJHtcIkNPTVBPTkVOVF9WX01PREVMXCIgLyogQ09NUE9ORU5UX1ZfTU9ERUwgKi99OiBmYWxzZSB9XFxgLmA7XHJcbiAgICAgICAgICAgIGlmIChjb21wLnByb3BzICYmIGlzQXJyYXkoY29tcC5wcm9wcylcclxuICAgICAgICAgICAgICAgID8gY29tcC5wcm9wcy5pbmNsdWRlcygnbW9kZWxWYWx1ZScpXHJcbiAgICAgICAgICAgICAgICA6IGhhc093bihjb21wLnByb3BzLCAnbW9kZWxWYWx1ZScpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGBDb21wb25lbnQgZGVsY2FyZXMgXCJtb2RlbFZhbHVlXCIgcHJvcCwgd2hpY2ggaXMgVnVlIDMgdXNhZ2UsIGJ1dCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgaXMgcnVubmluZyB1bmRlciBWdWUgMiBjb21wYXQgdi1tb2RlbCBiZWhhdmlvci4gWW91IGNhbiAke2NvbmZpZ01zZ31gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKGB2LW1vZGVsIHVzYWdlIG9uIGNvbXBvbmVudCBoYXMgY2hhbmdlZCBpbiBWdWUgMy4gQ29tcG9uZW50IHRoYXQgZXhwZWN0cyBgICtcclxuICAgICAgICAgICAgICAgIGB0byB3b3JrIHdpdGggdi1tb2RlbCBzaG91bGQgbm93IHVzZSB0aGUgXCJtb2RlbFZhbHVlXCIgcHJvcCBhbmQgZW1pdCB0aGUgYCArXHJcbiAgICAgICAgICAgICAgICBgXCJ1cGRhdGU6bW9kZWxWYWx1ZVwiIGV2ZW50LiBZb3UgY2FuIHVwZGF0ZSB0aGUgdXNhZ2UgYW5kIHRoZW4gJHtjb25maWdNc2d9YCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3YtbW9kZWwuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJSRU5ERVJfRlVOQ1RJT05cIiAvKiBSRU5ERVJfRlVOQ1RJT04gKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZSAzJ3MgcmVuZGVyIGZ1bmN0aW9uIEFQSSBoYXMgY2hhbmdlZC4gYCArXHJcbiAgICAgICAgICAgIGBZb3UgY2FuIG9wdC1pbiB0byB0aGUgbmV3IEFQSSB3aXRoOmAgK1xyXG4gICAgICAgICAgICBgXFxuXFxuICBjb25maWd1cmVDb21wYXQoeyAke1wiUkVOREVSX0ZVTkNUSU9OXCIgLyogUkVOREVSX0ZVTkNUSU9OICovfTogZmFsc2UgfSlcXG5gICtcclxuICAgICAgICAgICAgYFxcbiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBwZXItY29tcG9uZW50IHZpYSB0aGUgXCJjb21wYXRDb25maWdcIiBvcHRpb24uKWAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9yZW5kZXItZnVuY3Rpb24tYXBpLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiRklMVEVSU1wiIC8qIEZJTFRFUlMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYGZpbHRlcnMgaGF2ZSBiZWVuIHJlbW92ZWQgaW4gVnVlIDMuIGAgK1xyXG4gICAgICAgICAgICBgVGhlIFwifFwiIHN5bWJvbCB3aWxsIGJlIHRyZWF0ZWQgYXMgbmF0aXZlIEphdmFTY3JpcHQgYml0d2lzZSBPUiBvcGVyYXRvci4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgbWV0aG9kIGNhbGxzIG9yIGNvbXB1dGVkIHByb3BlcnRpZXMgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZmlsdGVycy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIlBSSVZBVEVfQVBJU1wiIC8qIFBSSVZBVEVfQVBJUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBuYW1lID0+IGBcIiR7bmFtZX1cIiBpcyBhIFZ1ZSAyIHByaXZhdGUgQVBJIHRoYXQgbm8gbG9uZ2VyIGV4aXN0cyBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBJZiB5b3UgYXJlIHNlZWluZyB0aGlzIHdhcm5pbmcgb25seSBkdWUgdG8gYSBkZXBlbmRlbmN5LCB5b3UgY2FuIGAgK1xyXG4gICAgICAgICAgICBgc3VwcHJlc3MgdGhpcyB3YXJuaW5nIHZpYSB7IFBSSVZBVEVfQVBJUzogJ3N1cHJlc3Mtd2FybmluZycgfS5gXHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGluc3RhbmNlV2FybmVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuY29uc3Qgd2FybkNvdW50ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuZnVuY3Rpb24gd2FybkRlcHJlY2F0aW9uKGtleSwgaW5zdGFuY2UsIC4uLmFyZ3MpIHtcclxuICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZSB8fCBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIC8vIGNoZWNrIHVzZXIgY29uZmlnXHJcbiAgICBjb25zdCBjb25maWcgPSBnZXRDb21wYXRDb25maWdGb3JLZXkoa2V5LCBpbnN0YW5jZSk7XHJcbiAgICBpZiAoY29uZmlnID09PSAnc3VwcHJlc3Mtd2FybmluZycpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBkdXBLZXkgPSBrZXkgKyBhcmdzLmpvaW4oJycpO1xyXG4gICAgbGV0IGNvbXBJZCA9IGluc3RhbmNlICYmIGZvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpO1xyXG4gICAgaWYgKGNvbXBJZCA9PT0gJ0Fub255bW91cycgJiYgaW5zdGFuY2UpIHtcclxuICAgICAgICBjb21wSWQgPSBpbnN0YW5jZS51aWQ7XHJcbiAgICB9XHJcbiAgICAvLyBza2lwIGlmIHRoZSBzYW1lIHdhcm5pbmcgaXMgZW1pdHRlZCBmb3IgdGhlIHNhbWUgY29tcG9uZW50IHR5cGVcclxuICAgIGNvbnN0IGNvbXBvbmVudER1cEtleSA9IGR1cEtleSArIGNvbXBJZDtcclxuICAgIGlmIChjb21wb25lbnREdXBLZXkgaW4gaW5zdGFuY2VXYXJuZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpbnN0YW5jZVdhcm5lZFtjb21wb25lbnREdXBLZXldID0gdHJ1ZTtcclxuICAgIC8vIHNhbWUgd2FybmluZywgYnV0IGRpZmZlcmVudCBjb21wb25lbnQuIHNraXAgdGhlIGxvbmcgbWVzc2FnZSBhbmQganVzdFxyXG4gICAgLy8gbG9nIHRoZSBrZXkgYW5kIGNvdW50LlxyXG4gICAgaWYgKGR1cEtleSBpbiB3YXJuQ291bnQpIHtcclxuICAgICAgICB3YXJuKGAoZGVwcmVjYXRpb24gJHtrZXl9KSAoJHsrK3dhcm5Db3VudFtkdXBLZXldICsgMX0pYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgd2FybkNvdW50W2R1cEtleV0gPSAwO1xyXG4gICAgY29uc3QgeyBtZXNzYWdlLCBsaW5rIH0gPSBkZXByZWNhdGlvbkRhdGFba2V5XTtcclxuICAgIHdhcm4oYChkZXByZWNhdGlvbiAke2tleX0pICR7dHlwZW9mIG1lc3NhZ2UgPT09ICdmdW5jdGlvbicgPyBtZXNzYWdlKC4uLmFyZ3MpIDogbWVzc2FnZX0ke2xpbmsgPyBgXFxuICBEZXRhaWxzOiAke2xpbmt9YCA6IGBgfWApO1xyXG4gICAgaWYgKCFpc0NvbXBhdEVuYWJsZWQoa2V5LCBpbnN0YW5jZSwgdHJ1ZSkpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBeIFRoZSBhYm92ZSBkZXByZWNhdGlvbidzIGNvbXBhdCBiZWhhdmlvciBpcyBkaXNhYmxlZCBhbmQgd2lsbCBsaWtlbHkgYCArXHJcbiAgICAgICAgICAgIGBsZWFkIHRvIHJ1bnRpbWUgZXJyb3JzLmApO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGdsb2JhbENvbXBhdENvbmZpZyA9IHtcclxuICAgIE1PREU6IDJcclxufTtcclxuZnVuY3Rpb24gZ2V0Q29tcGF0Q29uZmlnRm9yS2V5KGtleSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGluc3RhbmNlQ29uZmlnID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZS5jb21wYXRDb25maWc7XHJcbiAgICBpZiAoaW5zdGFuY2VDb25maWcgJiYga2V5IGluIGluc3RhbmNlQ29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlQ29uZmlnW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2xvYmFsQ29tcGF0Q29uZmlnW2tleV07XHJcbn1cclxuZnVuY3Rpb24gaXNDb21wYXRFbmFibGVkKGtleSwgaW5zdGFuY2UsIGVuYWJsZUZvckJ1aWx0SW4gPSBmYWxzZSkge1xyXG4gICAgLy8gc2tpcCBjb21wYXQgZm9yIGJ1aWx0LWluIGNvbXBvbmVudHNcclxuICAgIGlmICghZW5hYmxlRm9yQnVpbHRJbiAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlLl9faXNCdWlsdEluKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF3TW9kZSA9IGdldENvbXBhdENvbmZpZ0ZvcktleSgnTU9ERScsIGluc3RhbmNlKSB8fCAyO1xyXG4gICAgY29uc3QgdmFsID0gZ2V0Q29tcGF0Q29uZmlnRm9yS2V5KGtleSwgaW5zdGFuY2UpO1xyXG4gICAgY29uc3QgbW9kZSA9IGlzRnVuY3Rpb24kMShyYXdNb2RlKVxyXG4gICAgICAgID8gcmF3TW9kZShpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlKVxyXG4gICAgICAgIDogcmF3TW9kZTtcclxuICAgIGlmIChtb2RlID09PSAyKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbCAhPT0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gJ3N1cHByZXNzLXdhcm5pbmcnO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGVtaXQoaW5zdGFuY2UsIGV2ZW50LCAuLi5yYXdBcmdzKSB7XHJcbiAgICBjb25zdCBwcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCB7IGVtaXRzT3B0aW9ucywgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKGVtaXRzT3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIShldmVudCBpbiBlbWl0c09wdGlvbnMpICYmXHJcbiAgICAgICAgICAgICAgICAhKGZhbHNlICkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJvcHNPcHRpb25zIHx8ICEodG9IYW5kbGVyS2V5KGV2ZW50KSBpbiBwcm9wc09wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGVtaXR0ZWQgZXZlbnQgXCIke2V2ZW50fVwiIGJ1dCBpdCBpcyBuZWl0aGVyIGRlY2xhcmVkIGluIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgdGhlIGVtaXRzIG9wdGlvbiBub3IgYXMgYW4gXCIke3RvSGFuZGxlcktleShldmVudCl9XCIgcHJvcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbiQxKHZhbGlkYXRvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdG9yKC4uLnJhd0FyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBJbnZhbGlkIGV2ZW50IGFyZ3VtZW50czogZXZlbnQgdmFsaWRhdGlvbiBmYWlsZWQgZm9yIGV2ZW50IFwiJHtldmVudH1cIi5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgYXJncyA9IHJhd0FyZ3M7XHJcbiAgICBjb25zdCBpc01vZGVsTGlzdGVuZXIgPSBldmVudC5zdGFydHNXaXRoKCd1cGRhdGU6Jyk7XHJcbiAgICAvLyBmb3Igdi1tb2RlbCB1cGRhdGU6eHh4IGV2ZW50cywgYXBwbHkgbW9kaWZpZXJzIG9uIGFyZ3NcclxuICAgIGNvbnN0IG1vZGVsQXJnID0gaXNNb2RlbExpc3RlbmVyICYmIGV2ZW50LnNsaWNlKDcpO1xyXG4gICAgaWYgKG1vZGVsQXJnICYmIG1vZGVsQXJnIGluIHByb3BzKSB7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzS2V5ID0gYCR7bW9kZWxBcmcgPT09ICdtb2RlbFZhbHVlJyA/ICdtb2RlbCcgOiBtb2RlbEFyZ31Nb2RpZmllcnNgO1xyXG4gICAgICAgIGNvbnN0IHsgbnVtYmVyLCB0cmltIH0gPSBwcm9wc1ttb2RpZmllcnNLZXldIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICBhcmdzID0gcmF3QXJncy5tYXAoYSA9PiBhLnRyaW0oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG51bWJlcikge1xyXG4gICAgICAgICAgICBhcmdzID0gcmF3QXJncy5tYXAodG9OdW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgZGV2dG9vbHNDb21wb25lbnRFbWl0KGluc3RhbmNlLCBldmVudCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgcHJvcHNbdG9IYW5kbGVyS2V5KGxvd2VyQ2FzZUV2ZW50KV0pIHtcclxuICAgICAgICAgICAgd2FybihgRXZlbnQgXCIke2xvd2VyQ2FzZUV2ZW50fVwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IGAgK1xyXG4gICAgICAgICAgICAgICAgYCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9IGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcIiR7ZXZlbnR9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgYE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIGAgK1xyXG4gICAgICAgICAgICAgICAgYHYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBgICtcclxuICAgICAgICAgICAgICAgIGBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7aHlwaGVuYXRlKGV2ZW50KX1cIiBpbnN0ZWFkIG9mIFwiJHtldmVudH1cIi5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgaGFuZGxlck5hbWU7XHJcbiAgICBsZXQgaGFuZGxlciA9IHByb3BzWyhoYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShldmVudCkpXSB8fFxyXG4gICAgICAgIC8vIGFsc28gdHJ5IGNhbWVsQ2FzZSBldmVudCBoYW5kbGVyICgjMjI0OSlcclxuICAgICAgICBwcm9wc1soaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKSldO1xyXG4gICAgLy8gZm9yIHYtbW9kZWwgdXBkYXRlOnh4eCBldmVudHMsIGFsc28gdHJpZ2dlciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRcclxuICAgIC8vIGZvciBwcm9wcyBwYXNzZWQgdmlhIGtlYmFiLWNhc2VcclxuICAgIGlmICghaGFuZGxlciAmJiBpc01vZGVsTGlzdGVuZXIpIHtcclxuICAgICAgICBoYW5kbGVyID0gcHJvcHNbKGhhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGh5cGhlbmF0ZShldmVudCkpKV07XHJcbiAgICB9XHJcbiAgICBpZiAoaGFuZGxlcikge1xyXG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhhbmRsZXIsIGluc3RhbmNlLCA2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9uY2VIYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgKyBgT25jZWBdO1xyXG4gICAgaWYgKG9uY2VIYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZS5lbWl0dGVkKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmVtaXR0ZWQgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSA9IHRydWU7XHJcbiAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcob25jZUhhbmRsZXIsIGluc3RhbmNlLCA2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovLCBhcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVFbWl0c09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQuZW1pdHNDYWNoZTtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcclxuICAgIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCByYXcgPSBjb21wLmVtaXRzO1xyXG4gICAgbGV0IG5vcm1hbGl6ZWQgPSB7fTtcclxuICAgIC8vIGFwcGx5IG1peGluL2V4dGVuZHMgcHJvcHNcclxuICAgIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XHJcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbiQxKGNvbXApKSB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5kRW1pdHMgPSAocmF3KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGcm9tRXh0ZW5kID0gbm9ybWFsaXplRW1pdHNPcHRpb25zKHJhdywgYXBwQ29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkRnJvbUV4dGVuZCkge1xyXG4gICAgICAgICAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgbm9ybWFsaXplZEZyb21FeHRlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5leHRlbmRzKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZEVtaXRzKGNvbXAuZXh0ZW5kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLm1peGlucykge1xyXG4gICAgICAgICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xyXG4gICAgICAgIGNhY2hlLnNldChjb21wLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgICAgICByYXcuZm9yRWFjaChrZXkgPT4gKG5vcm1hbGl6ZWRba2V5XSA9IG51bGwpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV4dGVuZChub3JtYWxpemVkLCByYXcpO1xyXG4gICAgfVxyXG4gICAgY2FjaGUuc2V0KGNvbXAsIG5vcm1hbGl6ZWQpO1xyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbn1cclxuLy8gQ2hlY2sgaWYgYW4gaW5jb21pbmcgcHJvcCBrZXkgaXMgYSBkZWNsYXJlZCBlbWl0IGV2ZW50IGxpc3RlbmVyLlxyXG4vLyBlLmcuIFdpdGggYGVtaXRzOiB7IGNsaWNrOiBudWxsIH1gLCBwcm9wcyBuYW1lZCBgb25DbGlja2AgYW5kIGBvbmNsaWNrYCBhcmVcclxuLy8gYm90aCBjb25zaWRlcmVkIG1hdGNoZWQgbGlzdGVuZXJzLlxyXG5mdW5jdGlvbiBpc0VtaXRMaXN0ZW5lcihvcHRpb25zLCBrZXkpIHtcclxuICAgIGlmICghb3B0aW9ucyB8fCAhaXNPbihrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAga2V5ID0ga2V5LnNsaWNlKDIpLnJlcGxhY2UoL09uY2UkLywgJycpO1xyXG4gICAgcmV0dXJuIChoYXNPd24ob3B0aW9ucywga2V5WzBdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkpIHx8XHJcbiAgICAgICAgaGFzT3duKG9wdGlvbnMsIGh5cGhlbmF0ZShrZXkpKSB8fFxyXG4gICAgICAgIGhhc093bihvcHRpb25zLCBrZXkpKTtcclxufVxuXG4vKipcclxuICogbWFyayB0aGUgY3VycmVudCByZW5kZXJpbmcgaW5zdGFuY2UgZm9yIGFzc2V0IHJlc29sdXRpb24gKGUuZy5cclxuICogcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSkgZHVyaW5nIHJlbmRlclxyXG4gKi9cclxubGV0IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XHJcbmxldCBjdXJyZW50U2NvcGVJZCA9IG51bGw7XHJcbi8qKlxyXG4gKiBOb3RlOiByZW5kZXJpbmcgY2FsbHMgbWF5YmUgbmVzdGVkLiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0aGUgcGFyZW50IHJlbmRlcmluZ1xyXG4gKiBpbnN0YW5jZSBpZiBwcmVzZW50LCB3aGljaCBzaG91bGQgYmUgcmVzdG9yZWQgYWZ0ZXIgdGhlIHJlbmRlciBpcyBkb25lOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBjb25zdCBwcmV2ID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGkpXHJcbiAqIC8vIC4uLnJlbmRlclxyXG4gKiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldilcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHByZXYgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgIGN1cnJlbnRTY29wZUlkID0gKGluc3RhbmNlICYmIGluc3RhbmNlLnR5cGUuX19zY29wZUlkKSB8fCBudWxsO1xyXG4gICAgcmV0dXJuIHByZXY7XHJcbn1cclxuLyoqXHJcbiAqIFNldCBzY29wZSBpZCB3aGVuIGNyZWF0aW5nIGhvaXN0ZWQgdm5vZGVzLlxyXG4gKiBAcHJpdmF0ZSBjb21waWxlciBoZWxwZXJcclxuICovXHJcbmZ1bmN0aW9uIHB1c2hTY29wZUlkKGlkKSB7XHJcbiAgICBjdXJyZW50U2NvcGVJZCA9IGlkO1xyXG59XHJcbi8qKlxyXG4gKiBUZWNobmljYWxseSB3ZSBubyBsb25nZXIgbmVlZCB0aGlzIGFmdGVyIDMuMC44IGJ1dCB3ZSBuZWVkIHRvIGtlZXAgdGhlIHNhbWVcclxuICogQVBJIGZvciBiYWNrd2FyZHMgY29tcGF0IHcvIGNvZGUgZ2VuZXJhdGVkIGJ5IGNvbXBpbGVycy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHBvcFNjb3BlSWQoKSB7XHJcbiAgICBjdXJyZW50U2NvcGVJZCA9IG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIE9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHdpdGhTY29wZUlkID0gKF9pZCkgPT4gd2l0aEN0eDtcclxuLyoqXHJcbiAqIFdyYXAgYSBzbG90IGZ1bmN0aW9uIHRvIG1lbW9pemUgY3VycmVudCByZW5kZXJpbmcgaW5zdGFuY2VcclxuICogQHByaXZhdGUgY29tcGlsZXIgaGVscGVyXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoQ3R4KGZuLCBjdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIGlzTm9uU2NvcGVkU2xvdCAvLyBmYWxzZSBvbmx5XHJcbikge1xyXG4gICAgaWYgKCFjdHgpXHJcbiAgICAgICAgcmV0dXJuIGZuO1xyXG4gICAgLy8gYWxyZWFkeSBub3JtYWxpemVkXHJcbiAgICBpZiAoZm4uX24pIHtcclxuICAgICAgICByZXR1cm4gZm47XHJcbiAgICB9XHJcbiAgICBjb25zdCByZW5kZXJGbldpdGhDb250ZXh0ID0gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAvLyBJZiBhIHVzZXIgY2FsbHMgYSBjb21waWxlZCBzbG90IGluc2lkZSBhIHRlbXBsYXRlIGV4cHJlc3Npb24gKCMxNzQ1KSwgaXRcclxuICAgICAgICAvLyBjYW4gbWVzcyB1cCBibG9jayB0cmFja2luZywgc28gYnkgZGVmYXVsdCB3ZSBkaXNhYmxlIGJsb2NrIHRyYWNraW5nIGFuZFxyXG4gICAgICAgIC8vIGZvcmNlIGJhaWwgb3V0IHdoZW4gaW52b2tpbmcgYSBjb21waWxlZCBzbG90IChpbmRpY2F0ZWQgYnkgdGhlIC5fZCBmbGFnKS5cclxuICAgICAgICAvLyBUaGlzIGlzbid0IG5lY2Vzc2FyeSBpZiByZW5kZXJpbmcgYSBjb21waWxlZCBgPHNsb3Q+YCwgc28gd2UgZmxpcCB0aGVcclxuICAgICAgICAvLyAuX2QgZmxhZyBvZmYgd2hlbiBpbnZva2luZyB0aGUgd3JhcHBlZCBmbiBpbnNpZGUgYHJlbmRlclNsb3RgLlxyXG4gICAgICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XHJcbiAgICAgICAgICAgIHNldEJsb2NrVHJhY2tpbmcoLTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcmV2SW5zdGFuY2UgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoY3R4KTtcclxuICAgICAgICBjb25zdCByZXMgPSBmbiguLi5hcmdzKTtcclxuICAgICAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldkluc3RhbmNlKTtcclxuICAgICAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xyXG4gICAgICAgICAgICBzZXRCbG9ja1RyYWNraW5nKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoY3R4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICAvLyBtYXJrIG5vcm1hbGl6ZWQgdG8gYXZvaWQgZHVwbGljYXRlZCB3cmFwcGluZ1xyXG4gICAgcmVuZGVyRm5XaXRoQ29udGV4dC5fbiA9IHRydWU7XHJcbiAgICAvLyBtYXJrIHRoaXMgYXMgY29tcGlsZWQgYnkgZGVmYXVsdFxyXG4gICAgLy8gdGhpcyBpcyB1c2VkIGluIHZub2RlLnRzIC0+IG5vcm1hbGl6ZUNoaWxkcmVuKCkgdG8gc2V0IHRoZSBzbG90XHJcbiAgICAvLyByZW5kZXJpbmcgZmxhZy5cclxuICAgIHJlbmRlckZuV2l0aENvbnRleHQuX2MgPSB0cnVlO1xyXG4gICAgLy8gZGlzYWJsZSBibG9jayB0cmFja2luZyBieSBkZWZhdWx0XHJcbiAgICByZW5kZXJGbldpdGhDb250ZXh0Ll9kID0gdHJ1ZTtcclxuICAgIHJldHVybiByZW5kZXJGbldpdGhDb250ZXh0O1xyXG59XG5cbi8qKlxyXG4gKiBkZXYgb25seSBmbGFnIHRvIHRyYWNrIHdoZXRoZXIgJGF0dHJzIHdhcyB1c2VkIGR1cmluZyByZW5kZXIuXHJcbiAqIElmICRhdHRycyB3YXMgdXNlZCBkdXJpbmcgcmVuZGVyIHRoZW4gdGhlIHdhcm5pbmcgZm9yIGZhaWxlZCBhdHRyc1xyXG4gKiBmYWxsdGhyb3VnaCBjYW4gYmUgc3VwcHJlc3NlZC5cclxuICovXHJcbmxldCBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XHJcbmZ1bmN0aW9uIG1hcmtBdHRyc0FjY2Vzc2VkKCkge1xyXG4gICAgYWNjZXNzZWRBdHRycyA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyB0eXBlOiBDb21wb25lbnQsIHZub2RlLCBwcm94eSwgd2l0aFByb3h5LCBwcm9wcywgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSwgc2xvdHMsIGF0dHJzLCBlbWl0LCByZW5kZXIsIHJlbmRlckNhY2hlLCBkYXRhLCBzZXR1cFN0YXRlLCBjdHgsIGluaGVyaXRBdHRycyB9ID0gaW5zdGFuY2U7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgY29uc3QgcHJldiA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBsZXQgZmFsbHRocm91Z2hBdHRycztcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgLy8gd2l0aFByb3h5IGlzIGEgcHJveHkgd2l0aCBhIGRpZmZlcmVudCBgaGFzYCB0cmFwIG9ubHkgZm9yXHJcbiAgICAgICAgICAgIC8vIHJ1bnRpbWUtY29tcGlsZWQgcmVuZGVyIGZ1bmN0aW9ucyB1c2luZyBgd2l0aGAgYmxvY2suXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3h5VG9Vc2UgPSB3aXRoUHJveHkgfHwgcHJveHk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKHJlbmRlci5jYWxsKHByb3h5VG9Vc2UsIHByb3h5VG9Vc2UsIHJlbmRlckNhY2hlLCBwcm9wcywgc2V0dXBTdGF0ZSwgZGF0YSwgY3R4KSk7XHJcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBhdHRycztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWxcclxuICAgICAgICAgICAgY29uc3QgcmVuZGVyID0gQ29tcG9uZW50O1xyXG4gICAgICAgICAgICAvLyBpbiBkZXYsIG1hcmsgYXR0cnMgYWNjZXNzZWQgaWYgb3B0aW9uYWwgcHJvcHMgKGF0dHJzID09PSBwcm9wcylcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBhdHRycyA9PT0gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUocmVuZGVyLmxlbmd0aCA+IDFcclxuICAgICAgICAgICAgICAgID8gcmVuZGVyKHByb3BzLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7IGF0dHJzLCBzbG90cywgZW1pdCB9KVxyXG4gICAgICAgICAgICAgICAgOiByZW5kZXIocHJvcHMsIG51bGwgLyogd2Uga25vdyBpdCBkb2Vzbid0IG5lZWQgaXQgKi8pKTtcclxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IENvbXBvbmVudC5wcm9wc1xyXG4gICAgICAgICAgICAgICAgPyBhdHRyc1xyXG4gICAgICAgICAgICAgICAgOiBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2goYXR0cnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhdHRyIG1lcmdpbmdcclxuICAgICAgICAvLyBpbiBkZXYgbW9kZSwgY29tbWVudHMgYXJlIHByZXNlcnZlZCwgYW5kIGl0J3MgcG9zc2libGUgZm9yIGEgdGVtcGxhdGVcclxuICAgICAgICAvLyB0byBoYXZlIGNvbW1lbnRzIGFsb25nIHNpZGUgdGhlIHJvb3QgZWxlbWVudCB3aGljaCBtYWtlcyBpdCBhIGZyYWdtZW50XHJcbiAgICAgICAgbGV0IHJvb3QgPSByZXN1bHQ7XHJcbiAgICAgICAgbGV0IHNldFJvb3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICByZXN1bHQucGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLykge1xyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmFsbHRocm91Z2hBdHRycyAmJiBpbmhlcml0QXR0cnMgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmYWxsdGhyb3VnaEF0dHJzKTtcclxuICAgICAgICAgICAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHJvb3Q7XHJcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzT3B0aW9ucyAmJiBrZXlzLnNvbWUoaXNNb2RlbExpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHYtbW9kZWwgbGlzdGVuZXIgKG9uVXBkYXRlOnh4eCkgaGFzIGEgY29ycmVzcG9uZGluZyBkZWNsYXJlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wLCBpdCBpbmRpY2F0ZXMgdGhpcyBjb21wb25lbnQgZXhwZWN0cyB0byBoYW5kbGUgdi1tb2RlbCBhbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIG5vdCBmYWxsdGhyb3VnaC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVsYXRlZDogIzE1NDMsICMxNjQzLCAjMTk4OVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gZmlsdGVyTW9kZWxMaXN0ZW5lcnMoZmFsbHRocm91Z2hBdHRycywgcHJvcHNPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgZmFsbHRocm91Z2hBdHRycyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWFjY2Vzc2VkQXR0cnMgJiYgcm9vdC50eXBlICE9PSBDb21tZW50JDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudEF0dHJzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0cmFBdHRycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYWxsQXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGFsbEF0dHJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdi1tb2RlbCBoYW5kbGVycyB3aGVuIHRoZXkgZmFpbCB0byBmYWxsdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBgb25gLCBsb3dlcmNhc2UgZmlyc3QgbGV0dGVyIHRvIHJlZmxlY3QgZXZlbnQgY2FzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjdXJhdGVseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50QXR0cnMucHVzaChrZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmFBdHRycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgRXh0cmFuZW91cyBub24tcHJvcHMgYXR0cmlidXRlcyAoYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtleHRyYUF0dHJzLmpvaW4oJywgJyl9KSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50QXR0cnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEV4dHJhbmVvdXMgbm9uLWVtaXRzIGV2ZW50IGxpc3RlbmVycyAoYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtldmVudEF0dHJzLmpvaW4oJywgJyl9KSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgSWYgdGhlIGxpc3RlbmVyIGlzIGludGVuZGVkIHRvIGJlIGEgY29tcG9uZW50IGN1c3RvbSBldmVudCBsaXN0ZW5lciBvbmx5LCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBkZWNsYXJlIGl0IHVzaW5nIHRoZSBcImVtaXRzXCIgb3B0aW9uLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmFsc2UgJiZcclxuICAgICAgICAgICAgaXNDb21wYXRFbmFibGVkKFwiSU5TVEFOQ0VfQVRUUlNfQ0xBU1NfU1RZTEVcIiAvKiBJTlNUQU5DRV9BVFRSU19DTEFTU19TVFlMRSAqLywgaW5zdGFuY2UpICYmXHJcbiAgICAgICAgICAgIHZub2RlLnNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovICYmXHJcbiAgICAgICAgICAgIChyb290LnNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgcm9vdC5zaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykpIDtcclxuICAgICAgICAvLyBpbmhlcml0IGRpcmVjdGl2ZXNcclxuICAgICAgICBpZiAodm5vZGUuZGlycykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBSdW50aW1lIGRpcmVjdGl2ZSB1c2VkIG9uIGNvbXBvbmVudCB3aXRoIG5vbi1lbGVtZW50IHJvb3Qgbm9kZS4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFRoZSBkaXJlY3RpdmVzIHdpbGwgbm90IGZ1bmN0aW9uIGFzIGludGVuZGVkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvb3QuZGlycyA9IHJvb3QuZGlycyA/IHJvb3QuZGlycy5jb25jYXQodm5vZGUuZGlycykgOiB2bm9kZS5kaXJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmhlcml0IHRyYW5zaXRpb24gZGF0YVxyXG4gICAgICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBpbnNpZGUgPFRyYW5zaXRpb24+IHJlbmRlcnMgbm9uLWVsZW1lbnQgcm9vdCBub2RlIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGB0aGF0IGNhbm5vdCBiZSBhbmltYXRlZC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByb290LnRyYW5zaXRpb24gPSB2bm9kZS50cmFuc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNldFJvb3QpIHtcclxuICAgICAgICAgICAgc2V0Um9vdChyb290KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJvb3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGJsb2NrU3RhY2subGVuZ3RoID0gMDtcclxuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAxIC8qIFJFTkRFUl9GVU5DVElPTiAqLyk7XHJcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlVk5vZGUoQ29tbWVudCQxKTtcclxuICAgIH1cclxuICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqIEluIGRldiBtb2RlLCB0ZW1wbGF0ZSByb290IGxldmVsIGNvbW1lbnRzIGFyZSByZW5kZXJlZCwgd2hpY2ggdHVybnMgdGhlXHJcbiAqIHRlbXBsYXRlIGludG8gYSBmcmFnbWVudCByb290LCBidXQgd2UgbmVlZCB0byBsb2NhdGUgdGhlIHNpbmdsZSBlbGVtZW50XHJcbiAqIHJvb3QgZm9yIGF0dHJzIGFuZCBzY29wZSBpZCBwcm9jZXNzaW5nLlxyXG4gKi9cclxuY29uc3QgZ2V0Q2hpbGRSb290ID0gKHZub2RlKSA9PiB7XHJcbiAgICBjb25zdCByYXdDaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgY29uc3QgZHluYW1pY0NoaWxkcmVuID0gdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xyXG4gICAgY29uc3QgY2hpbGRSb290ID0gZmlsdGVyU2luZ2xlUm9vdChyYXdDaGlsZHJlbik7XHJcbiAgICBpZiAoIWNoaWxkUm9vdCkge1xyXG4gICAgICAgIHJldHVybiBbdm5vZGUsIHVuZGVmaW5lZF07XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbmRleCA9IHJhd0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KTtcclxuICAgIGNvbnN0IGR5bmFtaWNJbmRleCA9IGR5bmFtaWNDaGlsZHJlbiA/IGR5bmFtaWNDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCkgOiAtMTtcclxuICAgIGNvbnN0IHNldFJvb3QgPSAodXBkYXRlZFJvb3QpID0+IHtcclxuICAgICAgICByYXdDaGlsZHJlbltpbmRleF0gPSB1cGRhdGVkUm9vdDtcclxuICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGlmIChkeW5hbWljSW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuW2R5bmFtaWNJbmRleF0gPSB1cGRhdGVkUm9vdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh1cGRhdGVkUm9vdC5wYXRjaEZsYWcgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBbLi4uZHluYW1pY0NoaWxkcmVuLCB1cGRhdGVkUm9vdF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFtub3JtYWxpemVWTm9kZShjaGlsZFJvb3QpLCBzZXRSb290XTtcclxufTtcclxuZnVuY3Rpb24gZmlsdGVyU2luZ2xlUm9vdChjaGlsZHJlbikge1xyXG4gICAgbGV0IHNpbmdsZVJvb3Q7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoaXNWTm9kZShjaGlsZCkpIHtcclxuICAgICAgICAgICAgLy8gaWdub3JlIHVzZXIgY29tbWVudFxyXG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gQ29tbWVudCQxIHx8IGNoaWxkLmNoaWxkcmVuID09PSAndi1pZicpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVSb290KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIG1vcmUgdGhhbiAxIG5vbi1jb21tZW50IGNoaWxkLCByZXR1cm4gbm93XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlUm9vdCA9IGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNpbmdsZVJvb3Q7XHJcbn1cclxuY29uc3QgZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoID0gKGF0dHJzKSA9PiB7XHJcbiAgICBsZXQgcmVzO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcclxuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJyB8fCBpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgKHJlcyB8fCAocmVzID0ge30pKVtrZXldID0gYXR0cnNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5jb25zdCBmaWx0ZXJNb2RlbExpc3RlbmVycyA9IChhdHRycywgcHJvcHMpID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcclxuICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpIHx8ICEoa2V5LnNsaWNlKDkpIGluIHByb3BzKSkge1xyXG4gICAgICAgICAgICByZXNba2V5XSA9IGF0dHJzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuY29uc3QgaXNFbGVtZW50Um9vdCA9ICh2bm9kZSkgPT4ge1xyXG4gICAgcmV0dXJuICh2bm9kZS5zaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLyB8fFxyXG4gICAgICAgIHZub2RlLnNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgIHZub2RlLnR5cGUgPT09IENvbW1lbnQkMSAvLyBwb3RlbnRpYWwgdi1pZiBicmFuY2ggc3dpdGNoXHJcbiAgICApO1xyXG59O1xyXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVDb21wb25lbnQocHJldlZOb2RlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkge1xyXG4gICAgY29uc3QgeyBwcm9wczogcHJldlByb3BzLCBjaGlsZHJlbjogcHJldkNoaWxkcmVuLCBjb21wb25lbnQgfSA9IHByZXZWTm9kZTtcclxuICAgIGNvbnN0IHsgcHJvcHM6IG5leHRQcm9wcywgY2hpbGRyZW46IG5leHRDaGlsZHJlbiwgcGF0Y2hGbGFnIH0gPSBuZXh0Vk5vZGU7XHJcbiAgICBjb25zdCBlbWl0cyA9IGNvbXBvbmVudC5lbWl0c09wdGlvbnM7XHJcbiAgICAvLyBQYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uIHdhcyBob3QtdXBkYXRlZC4gU2luY2UgdGhpcyBtYXkgaGF2ZVxyXG4gICAgLy8gY2F1c2VkIHRoZSBjaGlsZCBjb21wb25lbnQncyBzbG90cyBjb250ZW50IHRvIGhhdmUgY2hhbmdlZCwgd2UgbmVlZCB0b1xyXG4gICAgLy8gZm9yY2UgdGhlIGNoaWxkIHRvIHVwZGF0ZSBhcyB3ZWxsLlxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gZm9yY2UgY2hpbGQgdXBkYXRlIGZvciBydW50aW1lIGRpcmVjdGl2ZSBvciB0cmFuc2l0aW9uIG9uIGNvbXBvbmVudCB2bm9kZS5cclxuICAgIGlmIChuZXh0Vk5vZGUuZGlycyB8fCBuZXh0Vk5vZGUudHJhbnNpdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGltaXplZCAmJiBwYXRjaEZsYWcgPj0gMCkge1xyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi8pIHtcclxuICAgICAgICAgICAgLy8gc2xvdCBjb250ZW50IHRoYXQgcmVmZXJlbmNlcyB2YWx1ZXMgdGhhdCBtaWdodCBoYXZlIGNoYW5nZWQsXHJcbiAgICAgICAgICAgIC8vIGUuZy4gaW4gYSB2LWZvclxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDE2IC8qIEZVTExfUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcmVzZW5jZSBvZiB0aGlzIGZsYWcgaW5kaWNhdGVzIHByb3BzIGFyZSBhbHdheXMgbm9uLW51bGxcclxuICAgICAgICAgICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBST1BTICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNQcm9wcyA9IG5leHRWTm9kZS5keW5hbWljUHJvcHM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Byb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBkeW5hbWljUHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWlzRW1pdExpc3RlbmVyKGVtaXRzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyB0aGlzIHBhdGggaXMgb25seSB0YWtlbiBieSBtYW51YWxseSB3cml0dGVuIHJlbmRlciBmdW5jdGlvbnNcclxuICAgICAgICAvLyBzbyBwcmVzZW5jZSBvZiBhbnkgY2hpbGRyZW4gbGVhZHMgdG8gYSBmb3JjZWQgdXBkYXRlXHJcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gfHwgIW5leHRDaGlsZHJlbi4kc3RhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldlByb3BzID09PSBuZXh0UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXByZXZQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gISFuZXh0UHJvcHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbmV4dFByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0c09wdGlvbnMpIHtcclxuICAgIGNvbnN0IG5leHRLZXlzID0gT2JqZWN0LmtleXMobmV4dFByb3BzKTtcclxuICAgIGlmIChuZXh0S2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKHByZXZQcm9wcykubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV4dEtleXNbaV07XHJcbiAgICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJlxyXG4gICAgICAgICAgICAhaXNFbWl0TGlzdGVuZXIoZW1pdHNPcHRpb25zLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVIT0NIb3N0RWwoeyB2bm9kZSwgcGFyZW50IH0sIGVsIC8vIEhvc3ROb2RlXHJcbikge1xyXG4gICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcclxuICAgICAgICAodm5vZGUgPSBwYXJlbnQudm5vZGUpLmVsID0gZWw7XHJcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgIH1cclxufVxuXG5jb25zdCBpc1N1c3BlbnNlID0gKHR5cGUpID0+IHR5cGUuX19pc1N1c3BlbnNlO1xyXG4vLyBTdXNwZW5zZSBleHBvc2VzIGEgY29tcG9uZW50LWxpa2UgQVBJLCBhbmQgaXMgdHJlYXRlZCBsaWtlIGEgY29tcG9uZW50XHJcbi8vIGluIHRoZSBjb21waWxlciwgYnV0IGludGVybmFsbHkgaXQncyBhIHNwZWNpYWwgYnVpbHQtaW4gdHlwZSB0aGF0IGhvb2tzXHJcbi8vIGRpcmVjdGx5IGludG8gdGhlIHJlbmRlcmVyLlxyXG5jb25zdCBTdXNwZW5zZUltcGwgPSB7XHJcbiAgICBuYW1lOiAnU3VzcGVuc2UnLFxyXG4gICAgLy8gSW4gb3JkZXIgdG8gbWFrZSBTdXNwZW5zZSB0cmVlLXNoYWthYmxlLCB3ZSBuZWVkIHRvIGF2b2lkIGltcG9ydGluZyBpdFxyXG4gICAgLy8gZGlyZWN0bHkgaW4gdGhlIHJlbmRlcmVyLiBUaGUgcmVuZGVyZXIgY2hlY2tzIGZvciB0aGUgX19pc1N1c3BlbnNlIGZsYWdcclxuICAgIC8vIG9uIGEgdm5vZGUncyB0eXBlIGFuZCBjYWxscyB0aGUgYHByb2Nlc3NgIG1ldGhvZCwgcGFzc2luZyBpbiByZW5kZXJlclxyXG4gICAgLy8gaW50ZXJuYWxzLlxyXG4gICAgX19pc1N1c3BlbnNlOiB0cnVlLFxyXG4gICAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIFxyXG4gICAgLy8gcGxhdGZvcm0tc3BlY2lmaWMgaW1wbCBwYXNzZWQgZnJvbSByZW5kZXJlclxyXG4gICAgcmVuZGVyZXJJbnRlcm5hbHMpIHtcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtb3VudFN1c3BlbnNlKG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVTdXNwZW5zZSxcclxuICAgIGNyZWF0ZTogY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSxcclxuICAgIG5vcm1hbGl6ZTogbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlblxyXG59O1xyXG4vLyBGb3JjZS1jYXN0ZWQgcHVibGljIHR5cGluZyBmb3IgaCBhbmQgVFNYIHByb3BzIGluZmVyZW5jZVxyXG5jb25zdCBTdXNwZW5zZSA9IChTdXNwZW5zZUltcGxcclxuICAgICk7XHJcbmZ1bmN0aW9uIHRyaWdnZXJFdmVudCh2bm9kZSwgbmFtZSkge1xyXG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzW25hbWVdO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24kMShldmVudExpc3RlbmVyKSkge1xyXG4gICAgICAgIGV2ZW50TGlzdGVuZXIoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykge1xyXG4gICAgY29uc3QgeyBwOiBwYXRjaCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xyXG4gICAgY29uc3QgaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBjb25zdCBzdXNwZW5zZSA9ICh2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudFN1c3BlbnNlLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaGlkZGVuQ29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpKTtcclxuICAgIC8vIHN0YXJ0IG1vdW50aW5nIHRoZSBjb250ZW50IHN1YnRyZWUgaW4gYW4gb2ZmLWRvbSBjb250YWluZXJcclxuICAgIHBhdGNoKG51bGwsIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50KSwgaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKTtcclxuICAgIC8vIG5vdyBjaGVjayBpZiB3ZSBoYXZlIGVuY291bnRlcmVkIGFueSBhc3luYyBkZXBzXHJcbiAgICBpZiAoc3VzcGVuc2UuZGVwcyA+IDApIHtcclxuICAgICAgICAvLyBoYXMgYXN5bmNcclxuICAgICAgICAvLyBpbnZva2UgQGZhbGxiYWNrIGV2ZW50XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KHZub2RlLCAnb25QZW5kaW5nJyk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KHZub2RlLCAnb25GYWxsYmFjaycpO1xyXG4gICAgICAgIC8vIG1vdW50IHRoZSBmYWxsYmFjayB0cmVlXHJcbiAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUuc3NGYWxsYmFjaywgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcclxuICAgICAgICBpc1NWRywgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHZub2RlLnNzRmFsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gU3VzcGVuc2UgaGFzIG5vIGFzeW5jIGRlcHMuIEp1c3QgcmVzb2x2ZS5cclxuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hTdXNwZW5zZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgeyBwOiBwYXRjaCwgdW06IHVubW91bnQsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0pIHtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0gKG4yLnN1c3BlbnNlID0gbjEuc3VzcGVuc2UpO1xyXG4gICAgc3VzcGVuc2Uudm5vZGUgPSBuMjtcclxuICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICBjb25zdCBuZXdCcmFuY2ggPSBuMi5zc0NvbnRlbnQ7XHJcbiAgICBjb25zdCBuZXdGYWxsYmFjayA9IG4yLnNzRmFsbGJhY2s7XHJcbiAgICBjb25zdCB7IGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgaXNJbkZhbGxiYWNrLCBpc0h5ZHJhdGluZyB9ID0gc3VzcGVuc2U7XHJcbiAgICBpZiAocGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XHJcbiAgICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIHBlbmRpbmdCcmFuY2gpKSB7XHJcbiAgICAgICAgICAgIC8vIHNhbWUgcm9vdCB0eXBlIGJ1dCBjb250ZW50IG1heSBoYXZlIGNoYW5nZWQuXHJcbiAgICAgICAgICAgIHBhdGNoKHBlbmRpbmdCcmFuY2gsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNJbkZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0b2dnbGVkIGJlZm9yZSBwZW5kaW5nIHRyZWUgaXMgcmVzb2x2ZWRcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XHJcbiAgICAgICAgICAgIGlmIChpc0h5ZHJhdGluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdG9nZ2xlZCBiZWZvcmUgaHlkcmF0aW9uIGlzIGZpbmlzaGVkLCB0aGUgY3VycmVudCBET00gdHJlZSBpc1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHZhbGlkLiBzZXQgaXQgYXMgdGhlIGFjdGl2ZSBicmFuY2ggc28gaXQgd2lsbCBiZSB1bm1vdW50ZWRcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gcmVzb2x2ZWRcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBwZW5kaW5nQnJhbmNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChwZW5kaW5nQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgcGVuZGluZyBJRC4gdGhpcyBpcyB1c2VkIHRvIGludmFsaWRhdGUgYXN5bmMgY2FsbGJhY2tzXHJcbiAgICAgICAgICAgIC8vIHJlc2V0IHN1c3BlbnNlIHN0YXRlXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmRlcHMgPSAwO1xyXG4gICAgICAgICAgICAvLyBkaXNjYXJkIGVmZmVjdHMgZnJvbSBwZW5kaW5nIGJyYW5jaFxyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgcHJldmlvdXMgY29udGFpbmVyXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBpZiAoaXNJbkZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGluIGZhbGxiYWNrIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRvZ2dsZWQgXCJiYWNrXCIgdG8gY3VycmVudCBhY3RpdmUgYnJhbmNoXHJcbiAgICAgICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSByZXNvbHZlXHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoZWQgdG8gYSAzcmQgYnJhbmNoXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcclxuICAgICAgICAgICAgLy8gcm9vdCBkaWQgbm90IGNoYW5nZSwganVzdCBub3JtYWwgcGF0Y2hcclxuICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0JyYW5jaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyByb290IG5vZGUgdG9nZ2xlZFxyXG4gICAgICAgICAgICAvLyBpbnZva2UgQHBlbmRpbmcgZXZlbnRcclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KG4yLCAnb25QZW5kaW5nJyk7XHJcbiAgICAgICAgICAgIC8vIG1vdW50IHBlbmRpbmcgYnJhbmNoIGluIG9mZi1kb20gY29udGFpbmVyXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCsrO1xyXG4gICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaW5jb21pbmcgYnJhbmNoIGhhcyBubyBhc3luYyBkZXBzLCByZXNvbHZlIG5vdy5cclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdGltZW91dCwgcGVuZGluZ0lkIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0lkID09PSBwZW5kaW5nSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGltZW91dCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5sZXQgaGFzV2FybmVkID0gZmFsc2U7XHJcbmZ1bmN0aW9uIGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudCwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBpc0h5ZHJhdGluZyA9IGZhbHNlKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWZhbHNlICYmICFoYXNXYXJuZWQpIHtcclxuICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgYGNvbnNvbGUuaW5mb2AgY2Fubm90IGJlIG51bGwgZXJyb3JcclxuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShgPFN1c3BlbnNlPiBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBhbmQgaXRzIEFQSSB3aWxsIGxpa2VseSBjaGFuZ2UuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHA6IHBhdGNoLCBtOiBtb3ZlLCB1bTogdW5tb3VudCwgbjogbmV4dCwgbzogeyBwYXJlbnROb2RlLCByZW1vdmUgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgICBjb25zdCB0aW1lb3V0ID0gdG9OdW1iZXIodm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudGltZW91dCk7XHJcbiAgICBjb25zdCBzdXNwZW5zZSA9IHtcclxuICAgICAgICB2bm9kZSxcclxuICAgICAgICBwYXJlbnQsXHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxyXG4gICAgICAgIGlzU1ZHLFxyXG4gICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICBoaWRkZW5Db250YWluZXIsXHJcbiAgICAgICAgYW5jaG9yLFxyXG4gICAgICAgIGRlcHM6IDAsXHJcbiAgICAgICAgcGVuZGluZ0lkOiAwLFxyXG4gICAgICAgIHRpbWVvdXQ6IHR5cGVvZiB0aW1lb3V0ID09PSAnbnVtYmVyJyA/IHRpbWVvdXQgOiAtMSxcclxuICAgICAgICBhY3RpdmVCcmFuY2g6IG51bGwsXHJcbiAgICAgICAgcGVuZGluZ0JyYW5jaDogbnVsbCxcclxuICAgICAgICBpc0luRmFsbGJhY2s6IHRydWUsXHJcbiAgICAgICAgaXNIeWRyYXRpbmcsXHJcbiAgICAgICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGVmZmVjdHM6IFtdLFxyXG4gICAgICAgIHJlc29sdmUocmVzdW1lID0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bWUgJiYgIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgd2l0aG91dCBhIHBlbmRpbmcgYnJhbmNoLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmlzVW5tb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIG9uIGFuIGFscmVhZHkgdW5tb3VudGVkIHN1c3BlbnNlIGJvdW5kYXJ5LmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUsIGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgcGVuZGluZ0lkLCBlZmZlY3RzLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghcmVzdW1lKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxheUVudGVyID0gYWN0aXZlQnJhbmNoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uLm1vZGUgPT09ICdvdXQtaW4nO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVuZGluZ0lkID09PSBzdXNwZW5zZS5wZW5kaW5nSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogRU5URVIgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgaW5pdGlhbCBhbmNob3Igb24gbW91bnRcclxuICAgICAgICAgICAgICAgIGxldCB7IGFuY2hvciB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgICAgICAvLyB1bm1vdW50IGN1cnJlbnQgYWN0aXZlIHRyZWVcclxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZmFsbGJhY2sgdHJlZSB3YXMgbW91bnRlZCwgaXQgbWF5IGhhdmUgYmVlbiBtb3ZlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHBhcnQgb2YgYSBwYXJlbnQgc3VzcGVuc2UuIGdldCB0aGUgbGF0ZXN0IGFuY2hvciBmb3IgaW5zZXJ0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gbmV4dChhY3RpdmVCcmFuY2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQoYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgY29udGVudCBmcm9tIG9mZi1kb20gY29udGFpbmVyIHRvIGFjdHVhbCBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlKHBlbmRpbmdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCAwIC8qIEVOVEVSICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHBlbmRpbmdCcmFuY2gpO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbnVsbDtcclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIGZsdXNoIGJ1ZmZlcmVkIGVmZmVjdHNcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYSBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZVxyXG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gc3VzcGVuc2UucGFyZW50O1xyXG4gICAgICAgICAgICBsZXQgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgcGVuZGluZyBwYXJlbnQgc3VzcGVuc2UsIG1lcmdlIGJ1ZmZlcmVkIHBvc3Qgam9ic1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGludG8gdGhhdCBwYXJlbnRcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZWZmZWN0cy5wdXNoKC4uLmVmZmVjdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5vIHBlbmRpbmcgcGFyZW50IHN1c3BlbnNlLCBmbHVzaCBhbGwgam9ic1xyXG4gICAgICAgICAgICBpZiAoIWhhc1VucmVzb2x2ZWRBbmNlc3Rvcikge1xyXG4gICAgICAgICAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzID0gW107XHJcbiAgICAgICAgICAgIC8vIGludm9rZSBAcmVzb2x2ZSBldmVudFxyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQodm5vZGUsICdvblJlc29sdmUnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZhbGxiYWNrKGZhbGxiYWNrVk5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKCFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyB2bm9kZSwgYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaXNTVkcgfSA9IHN1c3BlbnNlO1xyXG4gICAgICAgICAgICAvLyBpbnZva2UgQGZhbGxiYWNrIGV2ZW50XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgJ29uRmFsbGJhY2snKTtcclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dChhY3RpdmVCcmFuY2gpO1xyXG4gICAgICAgICAgICBjb25zdCBtb3VudEZhbGxiYWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdXNwZW5zZS5pc0luRmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtb3VudCB0aGUgZmFsbGJhY2sgdHJlZVxyXG4gICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgZmFsbGJhY2tWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcclxuICAgICAgICAgICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGZhbGxiYWNrVk5vZGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBkZWxheUVudGVyID0gZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uICYmIGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbi5tb2RlID09PSAnb3V0LWluJztcclxuICAgICAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSBtb3VudEZhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIHVubW91bnQgY3VycmVudCBhY3RpdmUgYnJhbmNoXHJcbiAgICAgICAgICAgIHVubW91bnQoYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIG5vIHN1c3BlbnNlIHNvIHVubW91bnQgaG9va3MgZmlyZSBub3dcclxuICAgICAgICAgICAgdHJ1ZSAvLyBzaG91bGRSZW1vdmVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudEZhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vdmUoY29udGFpbmVyLCBhbmNob3IsIHR5cGUpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmXHJcbiAgICAgICAgICAgICAgICBtb3ZlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHR5cGUpO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG5leHQoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCkge1xyXG4gICAgICAgICAgICBjb25zdCBpc0luUGVuZGluZ1N1c3BlbnNlID0gISFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoO1xyXG4gICAgICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSkge1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuZGVwcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVkRWwgPSBpbnN0YW5jZS52bm9kZS5lbDtcclxuICAgICAgICAgICAgaW5zdGFuY2VcclxuICAgICAgICAgICAgICAgIC5hc3luY0RlcC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMCAvKiBTRVRVUF9GVU5DVElPTiAqLyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihhc3luY1NldHVwUmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIHJldHJ5IHdoZW4gdGhlIHNldHVwKCkgcHJvbWlzZSByZXNvbHZlcy5cclxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgaGF2ZSBiZWVuIHVubW91bnRlZCBiZWZvcmUgcmVzb2x2ZS5cclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkICE9PSBpbnN0YW5jZS5zdXNwZW5zZUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcmV0cnkgZnJvbSB0aGlzIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZub2RlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIGFzeW5jU2V0dXBSZXN1bHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChoeWRyYXRlZEVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgbWF5IGhhdmUgYmVlbiByZXBsYWNlZCBpZiBhbiB1cGRhdGUgaGFwcGVuZWQgYmVmb3JlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzeW5jIGRlcCBpcyByZXNvbHZlZC5cclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5lbCA9IGh5ZHJhdGVkRWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9ICFoeWRyYXRlZEVsICYmIGluc3RhbmNlLnN1YlRyZWUuZWw7XHJcbiAgICAgICAgICAgICAgICBzZXR1cFJlbmRlckVmZmVjdChpbnN0YW5jZSwgdm5vZGUsIFxyXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gbW92ZWQgYmVmb3JlIHJlc29sdmUuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIGh5ZHJhdGlvbiwgaW5zdGFuY2Uuc3ViVHJlZSB3aWxsIGJlIHRoZSBjb21tZW50XHJcbiAgICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlci5cclxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUoaHlkcmF0ZWRFbCB8fCBpbnN0YW5jZS5zdWJUcmVlLmVsKSwgXHJcbiAgICAgICAgICAgICAgICAvLyBhbmNob3Igd2lsbCBub3QgYmUgdXNlZCBpZiB0aGlzIGlzIGh5ZHJhdGlvbiwgc28gb25seSBuZWVkIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgY29tbWVudCBwbGFjZWhvbGRlciBjYXNlLlxyXG4gICAgICAgICAgICAgICAgaHlkcmF0ZWRFbCA/IG51bGwgOiBuZXh0KGluc3RhbmNlLnN1YlRyZWUpLCBzdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUocGxhY2Vob2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlSE9DSG9zdEVsKGluc3RhbmNlLCB2bm9kZS5lbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgZGVjcmVhc2UgZGVwcyBjb3VudCBpZiBzdXNwZW5zZSBpcyBub3QgYWxyZWFkeSByZXNvbHZlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UgJiYgLS1zdXNwZW5zZS5kZXBzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVubW91bnQocGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHN1c3BlbnNlO1xyXG59XHJcbmZ1bmN0aW9uIGh5ZHJhdGVTdXNwZW5zZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZU5vZGUpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSAodm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBub2RlLnBhcmVudE5vZGUsIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBudWxsLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCB0cnVlIC8qIGh5ZHJhdGluZyAqLykpO1xyXG4gICAgLy8gdGhlcmUgYXJlIHR3byBwb3NzaWJsZSBzY2VuYXJpb3MgZm9yIHNlcnZlci1yZW5kZXJlZCBzdXNwZW5zZTpcclxuICAgIC8vIC0gc3VjY2Vzczogc3NyIGNvbnRlbnQgc2hvdWxkIGJlIGZ1bGx5IHJlc29sdmVkXHJcbiAgICAvLyAtIGZhaWx1cmU6IHNzciBjb250ZW50IHNob3VsZCBiZSB0aGUgZmFsbGJhY2sgYnJhbmNoLlxyXG4gICAgLy8gaG93ZXZlciwgb24gdGhlIGNsaWVudCB3ZSBkb24ndCByZWFsbHkga25vdyBpZiBpdCBoYXMgZmFpbGVkIG9yIG5vdFxyXG4gICAgLy8gYXR0ZW1wdCB0byBoeWRyYXRlIHRoZSBET00gYXNzdW1pbmcgaXQgaGFzIHN1Y2NlZWRlZCwgYnV0IHdlIHN0aWxsXHJcbiAgICAvLyBuZWVkIHRvIGNvbnN0cnVjdCBhIHN1c3BlbnNlIGJvdW5kYXJ5IGZpcnN0XHJcbiAgICBjb25zdCByZXN1bHQgPSBoeWRyYXRlTm9kZShub2RlLCAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCksIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgIGlmIChzdXNwZW5zZS5kZXBzID09PSAwKSB7XHJcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbih2bm9kZSkge1xyXG4gICAgY29uc3QgeyBzaGFwZUZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcclxuICAgIGNvbnN0IGlzU2xvdENoaWxkcmVuID0gc2hhcGVGbGFnICYgMzIgLyogU0xPVFNfQ0hJTERSRU4gKi87XHJcbiAgICB2bm9kZS5zc0NvbnRlbnQgPSBub3JtYWxpemVTdXNwZW5zZVNsb3QoaXNTbG90Q2hpbGRyZW4gPyBjaGlsZHJlbi5kZWZhdWx0IDogY2hpbGRyZW4pO1xyXG4gICAgdm5vZGUuc3NGYWxsYmFjayA9IGlzU2xvdENoaWxkcmVuXHJcbiAgICAgICAgPyBub3JtYWxpemVTdXNwZW5zZVNsb3QoY2hpbGRyZW4uZmFsbGJhY2spXHJcbiAgICAgICAgOiBjcmVhdGVWTm9kZShDb21tZW50KTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZVNsb3Qocykge1xyXG4gICAgbGV0IGJsb2NrO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24kMShzKSkge1xyXG4gICAgICAgIGNvbnN0IGlzQ29tcGlsZWRTbG90ID0gcy5fYztcclxuICAgICAgICBpZiAoaXNDb21waWxlZFNsb3QpIHtcclxuICAgICAgICAgICAgLy8gZGlzYWJsZVRyYWNraW5nOiBmYWxzZVxyXG4gICAgICAgICAgICAvLyBhbGxvdyBibG9jayB0cmFja2luZyBmb3IgY29tcGlsZWQgc2xvdHNcclxuICAgICAgICAgICAgLy8gKHNlZSAuL2NvbXBvbmVudFJlbmRlckNvbnRleHQudHMpXHJcbiAgICAgICAgICAgIHMuX2QgPSBmYWxzZTtcclxuICAgICAgICAgICAgb3BlbkJsb2NrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHMgPSBzKCk7XHJcbiAgICAgICAgaWYgKGlzQ29tcGlsZWRTbG90KSB7XHJcbiAgICAgICAgICAgIHMuX2QgPSB0cnVlO1xyXG4gICAgICAgICAgICBibG9jayA9IGN1cnJlbnRCbG9jaztcclxuICAgICAgICAgICAgY2xvc2VCbG9jaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHMpKSB7XHJcbiAgICAgICAgY29uc3Qgc2luZ2xlQ2hpbGQgPSBmaWx0ZXJTaW5nbGVSb290KHMpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXNpbmdsZUNoaWxkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYDxTdXNwZW5zZT4gc2xvdHMgZXhwZWN0IGEgc2luZ2xlIHJvb3Qgbm9kZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcyA9IHNpbmdsZUNoaWxkO1xyXG4gICAgfVxyXG4gICAgcyA9IG5vcm1hbGl6ZVZOb2RlKHMpO1xyXG4gICAgaWYgKGJsb2NrKSB7XHJcbiAgICAgICAgcy5keW5hbWljQ2hpbGRyZW4gPSBibG9jay5maWx0ZXIoYyA9PiBjICE9PSBzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKGZuLCBzdXNwZW5zZSkge1xyXG4gICAgaWYgKHN1c3BlbnNlICYmIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShmbikpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKC4uLmZuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaChmbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihmbik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBicmFuY2gpIHtcclxuICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IGJyYW5jaDtcclxuICAgIGNvbnN0IHsgdm5vZGUsIHBhcmVudENvbXBvbmVudCB9ID0gc3VzcGVuc2U7XHJcbiAgICBjb25zdCBlbCA9ICh2bm9kZS5lbCA9IGJyYW5jaC5lbCk7XHJcbiAgICAvLyBpbiBjYXNlIHN1c3BlbnNlIGlzIHRoZSByb290IG5vZGUgb2YgYSBjb21wb25lbnQsXHJcbiAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgdGhlIEhPQyBlbFxyXG4gICAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQudm5vZGUuZWwgPSBlbDtcclxuICAgICAgICB1cGRhdGVIT0NIb3N0RWwocGFyZW50Q29tcG9uZW50LCBlbCk7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gcHJvdmlkZShrZXksIHZhbHVlKSB7XHJcbiAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgcHJvdmlkZSgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzO1xyXG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgYW4gaW5zdGFuY2UgaW5oZXJpdHMgaXRzIHBhcmVudCdzIHByb3ZpZGVzIG9iamVjdFxyXG4gICAgICAgIC8vIGJ1dCB3aGVuIGl0IG5lZWRzIHRvIHByb3ZpZGUgdmFsdWVzIG9mIGl0cyBvd24sIGl0IGNyZWF0ZXMgaXRzXHJcbiAgICAgICAgLy8gb3duIHByb3ZpZGVzIG9iamVjdCB1c2luZyBwYXJlbnQgcHJvdmlkZXMgb2JqZWN0IGFzIHByb3RvdHlwZS5cclxuICAgICAgICAvLyB0aGlzIHdheSBpbiBgaW5qZWN0YCB3ZSBjYW4gc2ltcGx5IGxvb2sgdXAgaW5qZWN0aW9ucyBmcm9tIGRpcmVjdFxyXG4gICAgICAgIC8vIHBhcmVudCBhbmQgbGV0IHRoZSBwcm90b3R5cGUgY2hhaW4gZG8gdGhlIHdvcmsuXHJcbiAgICAgICAgY29uc3QgcGFyZW50UHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucGFyZW50ICYmIGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XHJcbiAgICAgICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBwcm92aWRlcykge1xyXG4gICAgICAgICAgICBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50UHJvdmlkZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbCBhcyBpbmRleCB0eXBlXHJcbiAgICAgICAgcHJvdmlkZXNba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluamVjdChrZXksIGRlZmF1bHRWYWx1ZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5ID0gZmFsc2UpIHtcclxuICAgIC8vIGZhbGxiYWNrIHRvIGBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VgIHNvIHRoYXQgdGhpcyBjYW4gYmUgY2FsbGVkIGluXHJcbiAgICAvLyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAvLyAjMjQwMFxyXG4gICAgICAgIC8vIHRvIHN1cHBvcnQgYGFwcC51c2VgIHBsdWdpbnMsXHJcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gYXBwQ29udGV4dCdzIGBwcm92aWRlc2AgaWYgdGhlIGludGFuY2UgaXMgYXQgcm9vdFxyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVzID0gaW5zdGFuY2UucGFyZW50ID09IG51bGxcclxuICAgICAgICAgICAgPyBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0ICYmIGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQucHJvdmlkZXNcclxuICAgICAgICAgICAgOiBpbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVzICYmIGtleSBpbiBwcm92aWRlcykge1xyXG4gICAgICAgICAgICAvLyBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbCBhcyBpbmRleCB0eXBlXHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJlYXREZWZhdWx0QXNGYWN0b3J5ICYmIGlzRnVuY3Rpb24kMShkZWZhdWx0VmFsdWUpXHJcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZS5jYWxsKGluc3RhbmNlLnByb3h5KVxyXG4gICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBpbmplY3Rpb24gXCIke1N0cmluZyhrZXkpfVwiIG5vdCBmb3VuZC5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5gKTtcclxuICAgIH1cclxufVxuXG4vLyBTaW1wbGUgZWZmZWN0LlxyXG5mdW5jdGlvbiB3YXRjaEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XHJcbn1cclxuLy8gaW5pdGlhbCB2YWx1ZSBmb3Igd2F0Y2hlcnMgdG8gdHJpZ2dlciBvbiB1bmRlZmluZWQgaW5pdGlhbCB2YWx1ZXNcclxuY29uc3QgSU5JVElBTF9XQVRDSEVSX1ZBTFVFID0ge307XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRnVuY3Rpb24kMShjYikpIHtcclxuICAgICAgICB3YXJuKGBcXGB3YXRjaChmbiwgb3B0aW9ucz8pXFxgIHNpZ25hdHVyZSBoYXMgYmVlbiBtb3ZlZCB0byBhIHNlcGFyYXRlIEFQSS4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgXFxgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KVxcYCBpbnN0ZWFkLiBcXGB3YXRjaFxcYCBub3cgb25seSBgICtcclxuICAgICAgICAgICAgYHN1cHBvcnRzIFxcYHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBkb1dhdGNoKHNvdXJjZSwgY2IsIHsgaW1tZWRpYXRlLCBkZWVwLCBmbHVzaCwgb25UcmFjaywgb25UcmlnZ2VyIH0gPSBFTVBUWV9PQkosIGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjYikge1xyXG4gICAgICAgIGlmIChpbW1lZGlhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3YXJuKGB3YXRjaCgpIFwiaW1tZWRpYXRlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWVwICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgd2Fybihgd2F0Y2goKSBcImRlZXBcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgYCArXHJcbiAgICAgICAgICAgICAgICBgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB3YXJuSW52YWxpZFNvdXJjZSA9IChzKSA9PiB7XHJcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBzb3VyY2U6IGAsIHMsIGBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgZnVuY3Rpb24sIGEgcmVmLCBgICtcclxuICAgICAgICAgICAgYGEgcmVhY3RpdmUgb2JqZWN0LCBvciBhbiBhcnJheSBvZiB0aGVzZSB0eXBlcy5gKTtcclxuICAgIH07XHJcbiAgICBsZXQgZ2V0dGVyO1xyXG4gICAgbGV0IGZvcmNlVHJpZ2dlciA9IGZhbHNlO1xyXG4gICAgbGV0IGlzTXVsdGlTb3VyY2UgPSBmYWxzZTtcclxuICAgIGlmIChpc1JlZihzb3VyY2UpKSB7XHJcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLnZhbHVlO1xyXG4gICAgICAgIGZvcmNlVHJpZ2dlciA9ICEhc291cmNlLl9zaGFsbG93O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShzb3VyY2UpKSB7XHJcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gc291cmNlO1xyXG4gICAgICAgIGRlZXAgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShzb3VyY2UpKSB7XHJcbiAgICAgICAgaXNNdWx0aVNvdXJjZSA9IHRydWU7XHJcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gc291cmNlLnNvbWUoaXNSZWFjdGl2ZSk7XHJcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLm1hcChzID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzUmVmKHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcy52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhdmVyc2Uocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbiQxKHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHMsIGluc3RhbmNlLCAyIC8qIFdBVENIX0dFVFRFUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkludmFsaWRTb3VyY2Uocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24kMShzb3VyY2UpKSB7XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIC8vIGdldHRlciB3aXRoIGNiXHJcbiAgICAgICAgICAgIGdldHRlciA9ICgpID0+IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzb3VyY2UsIGluc3RhbmNlLCAyIC8qIFdBVENIX0dFVFRFUiAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBubyBjYiAtPiBzaW1wbGUgZWZmZWN0XHJcbiAgICAgICAgICAgIGdldHRlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKHNvdXJjZSwgaW5zdGFuY2UsIDMgLyogV0FUQ0hfQ0FMTEJBQ0sgKi8sIFtvbkludmFsaWRhdGVdKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBnZXR0ZXIgPSBOT09QO1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzb3VyY2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNiICYmIGRlZXApIHtcclxuICAgICAgICBjb25zdCBiYXNlR2V0dGVyID0gZ2V0dGVyO1xyXG4gICAgICAgIGdldHRlciA9ICgpID0+IHRyYXZlcnNlKGJhc2VHZXR0ZXIoKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgY2xlYW51cDtcclxuICAgIGxldCBvbkludmFsaWRhdGUgPSAoZm4pID0+IHtcclxuICAgICAgICBjbGVhbnVwID0gcnVubmVyLm9wdGlvbnMub25TdG9wID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCA0IC8qIFdBVENIX0NMRUFOVVAgKi8pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgbGV0IG9sZFZhbHVlID0gaXNNdWx0aVNvdXJjZSA/IFtdIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xyXG4gICAgY29uc3Qgam9iID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICghcnVubmVyLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICAvLyB3YXRjaChzb3VyY2UsIGNiKVxyXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHJ1bm5lcigpO1xyXG4gICAgICAgICAgICBpZiAoZGVlcCB8fFxyXG4gICAgICAgICAgICAgICAgZm9yY2VUcmlnZ2VyIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNNdWx0aVNvdXJjZVxyXG4gICAgICAgICAgICAgICAgICAgID8gbmV3VmFsdWUuc29tZSgodiwgaSkgPT4gaGFzQ2hhbmdlZCh2LCBvbGRWYWx1ZVtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpIHx8XHJcbiAgICAgICAgICAgICAgICAoZmFsc2UgICkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgYmVmb3JlIHJ1bm5pbmcgY2IgYWdhaW5cclxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoY2IsIGluc3RhbmNlLCAzIC8qIFdBVENIX0NBTExCQUNLICovLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyB1bmRlZmluZWQgYXMgdGhlIG9sZCB2YWx1ZSB3aGVuIGl0J3MgY2hhbmdlZCBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gdW5kZWZpbmVkIDogb2xkVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb25JbnZhbGlkYXRlXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHdhdGNoRWZmZWN0XHJcbiAgICAgICAgICAgIHJ1bm5lcigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBpbXBvcnRhbnQ6IG1hcmsgdGhlIGpvYiBhcyBhIHdhdGNoZXIgY2FsbGJhY2sgc28gdGhhdCBzY2hlZHVsZXIga25vd3NcclxuICAgIC8vIGl0IGlzIGFsbG93ZWQgdG8gc2VsZi10cmlnZ2VyICgjMTcyNylcclxuICAgIGpvYi5hbGxvd1JlY3Vyc2UgPSAhIWNiO1xyXG4gICAgbGV0IHNjaGVkdWxlcjtcclxuICAgIGlmIChmbHVzaCA9PT0gJ3N5bmMnKSB7XHJcbiAgICAgICAgc2NoZWR1bGVyID0gam9iOyAvLyB0aGUgc2NoZWR1bGVyIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGRpcmVjdGx5XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnKSB7XHJcbiAgICAgICAgc2NoZWR1bGVyID0gKCkgPT4gcXVldWVQb3N0UmVuZGVyRWZmZWN0KGpvYiwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZGVmYXVsdDogJ3ByZSdcclxuICAgICAgICBzY2hlZHVsZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghaW5zdGFuY2UgfHwgaW5zdGFuY2UuaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVByZUZsdXNoQ2Ioam9iKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHdpdGggJ3ByZScgb3B0aW9uLCB0aGUgZmlyc3QgY2FsbCBtdXN0IGhhcHBlbiBiZWZvcmVcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCBzbyBpdCBpcyBjYWxsZWQgc3luY2hyb25vdXNseS5cclxuICAgICAgICAgICAgICAgIGpvYigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJ1bm5lciA9IGVmZmVjdChnZXR0ZXIsIHtcclxuICAgICAgICBsYXp5OiB0cnVlLFxyXG4gICAgICAgIG9uVHJhY2ssXHJcbiAgICAgICAgb25UcmlnZ2VyLFxyXG4gICAgICAgIHNjaGVkdWxlclxyXG4gICAgfSk7XHJcbiAgICByZWNvcmRJbnN0YW5jZUJvdW5kRWZmZWN0KHJ1bm5lciwgaW5zdGFuY2UpO1xyXG4gICAgLy8gaW5pdGlhbCBydW5cclxuICAgIGlmIChjYikge1xyXG4gICAgICAgIGlmIChpbW1lZGlhdGUpIHtcclxuICAgICAgICAgICAgam9iKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvbGRWYWx1ZSA9IHJ1bm5lcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcpIHtcclxuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QocnVubmVyLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBydW5uZXIoKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgc3RvcChydW5uZXIpO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICByZW1vdmUoaW5zdGFuY2UuZWZmZWN0cywgcnVubmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8vIHRoaXMuJHdhdGNoXHJcbmZ1bmN0aW9uIGluc3RhbmNlV2F0Y2goc291cmNlLCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgcHVibGljVGhpcyA9IHRoaXMucHJveHk7XHJcbiAgICBjb25zdCBnZXR0ZXIgPSBpc1N0cmluZyhzb3VyY2UpXHJcbiAgICAgICAgPyBzb3VyY2UuaW5jbHVkZXMoJy4nKVxyXG4gICAgICAgICAgICA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywgc291cmNlKVxyXG4gICAgICAgICAgICA6ICgpID0+IHB1YmxpY1RoaXNbc291cmNlXVxyXG4gICAgICAgIDogc291cmNlLmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcyk7XHJcbiAgICBsZXQgY2I7XHJcbiAgICBpZiAoaXNGdW5jdGlvbiQxKHZhbHVlKSkge1xyXG4gICAgICAgIGNiID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjYiA9IHZhbHVlLmhhbmRsZXI7XHJcbiAgICAgICAgb3B0aW9ucyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRvV2F0Y2goZ2V0dGVyLCBjYi5iaW5kKHB1YmxpY1RoaXMpLCBvcHRpb25zLCB0aGlzKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQYXRoR2V0dGVyKGN0eCwgcGF0aCkge1xyXG4gICAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGxldCBjdXIgPSBjdHg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGggJiYgY3VyOyBpKyspIHtcclxuICAgICAgICAgICAgY3VyID0gY3VyW3NlZ21lbnRzW2ldXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cjtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2UodmFsdWUsIHNlZW4gPSBuZXcgU2V0KCkpIHtcclxuICAgIGlmICghaXNPYmplY3QkMSh2YWx1ZSkgfHxcclxuICAgICAgICBzZWVuLmhhcyh2YWx1ZSkgfHxcclxuICAgICAgICB2YWx1ZVtcIl9fdl9za2lwXCIgLyogU0tJUCAqL10pIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZWVuLmFkZCh2YWx1ZSk7XHJcbiAgICBpZiAoaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgdHJhdmVyc2UodmFsdWUudmFsdWUsIHNlZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlW2ldLCBzZWVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkgfHwgaXNNYXAodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgodikgPT4ge1xyXG4gICAgICAgICAgICB0cmF2ZXJzZSh2LCBzZWVuKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgdHJhdmVyc2UodmFsdWVba2V5XSwgc2Vlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XG5cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdGF0ZSgpIHtcclxuICAgIGNvbnN0IHN0YXRlID0ge1xyXG4gICAgICAgIGlzTW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgaXNMZWF2aW5nOiBmYWxzZSxcclxuICAgICAgICBpc1VubW91bnRpbmc6IGZhbHNlLFxyXG4gICAgICAgIGxlYXZpbmdWTm9kZXM6IG5ldyBNYXAoKVxyXG4gICAgfTtcclxuICAgIG9uTW91bnRlZCgoKSA9PiB7XHJcbiAgICAgICAgc3RhdGUuaXNNb3VudGVkID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcclxuICAgICAgICBzdGF0ZS5pc1VubW91bnRpbmcgPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbn1cclxuY29uc3QgVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IgPSBbRnVuY3Rpb24sIEFycmF5XTtcclxuY29uc3QgQmFzZVRyYW5zaXRpb25JbXBsID0ge1xyXG4gICAgbmFtZTogYEJhc2VUcmFuc2l0aW9uYCxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgbW9kZTogU3RyaW5nLFxyXG4gICAgICAgIGFwcGVhcjogQm9vbGVhbixcclxuICAgICAgICBwZXJzaXN0ZWQ6IEJvb2xlYW4sXHJcbiAgICAgICAgLy8gZW50ZXJcclxuICAgICAgICBvbkJlZm9yZUVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFmdGVyRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uRW50ZXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIC8vIGxlYXZlXHJcbiAgICAgICAgb25CZWZvcmVMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25MZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BZnRlckxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkxlYXZlQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICAvLyBhcHBlYXJcclxuICAgICAgICBvbkJlZm9yZUFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQWZ0ZXJBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvclxyXG4gICAgfSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XHJcbiAgICAgICAgbGV0IHByZXZUcmFuc2l0aW9uS2V5O1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQgb3IgY29tcG9uZW50LiBVc2UgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBuZWVkIHRvIHRyYWNrIHJlYWN0aXZpdHkgZm9yIHRoZXNlIHByb3BzIHNvIHVzZSB0aGUgcmF3XHJcbiAgICAgICAgICAgIC8vIHByb3BzIGZvciBhIGJpdCBiZXR0ZXIgcGVyZlxyXG4gICAgICAgICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgeyBtb2RlIH0gPSByYXdQcm9wcztcclxuICAgICAgICAgICAgLy8gY2hlY2sgbW9kZVxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG1vZGUgJiYgIVsnaW4tb3V0JywgJ291dC1pbicsICdkZWZhdWx0J10uaW5jbHVkZXMobW9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYGludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICR7bW9kZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50IGNoaWxkcmVuIGhhcyBhIGd1YXJhbnRlZWQgbGVuZ3RoIG9mIDEuXHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc0xlYXZpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiA8dHJhbnNpdGlvbj48a2VlcC1hbGl2ZS8+PC90cmFuc2l0aW9uPiwgd2UgbmVlZCB0b1xyXG4gICAgICAgICAgICAvLyBjb21wYXJlIHRoZSB0eXBlIG9mIHRoZSBrZXB0LWFsaXZlIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBjb25zdCBpbm5lckNoaWxkID0gZ2V0S2VlcEFsaXZlQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBlbnRlckhvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCByYXdQcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIGVudGVySG9va3MpO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRDaGlsZCA9IGluc3RhbmNlLnN1YlRyZWU7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZElubmVyQ2hpbGQgPSBvbGRDaGlsZCAmJiBnZXRLZWVwQWxpdmVDaGlsZChvbGRDaGlsZCk7XHJcbiAgICAgICAgICAgIGxldCB0cmFuc2l0aW9uS2V5Q2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCB7IGdldFRyYW5zaXRpb25LZXkgfSA9IGlubmVyQ2hpbGQudHlwZTtcclxuICAgICAgICAgICAgaWYgKGdldFRyYW5zaXRpb25LZXkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldFRyYW5zaXRpb25LZXkoKTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2VHJhbnNpdGlvbktleSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09IHByZXZUcmFuc2l0aW9uS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbktleUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtb2RlXHJcbiAgICAgICAgICAgIGlmIChvbGRJbm5lckNoaWxkICYmXHJcbiAgICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQkMSAmJlxyXG4gICAgICAgICAgICAgICAgKCFpc1NhbWVWTm9kZVR5cGUoaW5uZXJDaGlsZCwgb2xkSW5uZXJDaGlsZCkgfHwgdHJhbnNpdGlvbktleUNoYW5nZWQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZWF2aW5nSG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKG9sZElubmVyQ2hpbGQsIHJhd1Byb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIG9sZCB0cmVlJ3MgaG9va3MgaW4gY2FzZSBvZiBkeW5hbWljIHRyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhvbGRJbm5lckNoaWxkLCBsZWF2aW5nSG9va3MpO1xyXG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGJldHdlZW4gZGlmZmVyZW50IHZpZXdzXHJcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xyXG4gICAgICAgICAgICAgICAgICAgIGxlYXZpbmdIb29rcy5hZnRlckxlYXZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0JyAmJiBpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQkMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlYXZpbmdIb29rcy5kZWxheUxlYXZlID0gKGVsLCBlYXJseVJlbW92ZSwgZGVsYXllZExlYXZlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIG9sZElubmVyQ2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVbU3RyaW5nKG9sZElubmVyQ2hpbGQua2V5KV0gPSBvbGRJbm5lckNoaWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXJseSByZW1vdmFsIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFybHlSZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVudGVySG9va3MuZGVsYXllZExlYXZlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZSA9IGRlbGF5ZWRMZWF2ZTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG4vLyBleHBvcnQgdGhlIHB1YmxpYyB0eXBlIGZvciBoL3RzeCBpbmZlcmVuY2VcclxuLy8gYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcclxuY29uc3QgQmFzZVRyYW5zaXRpb24gPSBCYXNlVHJhbnNpdGlvbkltcGw7XHJcbmZ1bmN0aW9uIGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKSB7XHJcbiAgICBjb25zdCB7IGxlYXZpbmdWTm9kZXMgfSA9IHN0YXRlO1xyXG4gICAgbGV0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGxlYXZpbmdWTm9kZXMuZ2V0KHZub2RlLnR5cGUpO1xyXG4gICAgaWYgKCFsZWF2aW5nVk5vZGVzQ2FjaGUpIHtcclxuICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgIGxlYXZpbmdWTm9kZXMuc2V0KHZub2RlLnR5cGUsIGxlYXZpbmdWTm9kZXNDYWNoZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVhdmluZ1ZOb2Rlc0NhY2hlO1xyXG59XHJcbi8vIFRoZSB0cmFuc2l0aW9uIGhvb2tzIGFyZSBhdHRhY2hlZCB0byB0aGUgdm5vZGUgYXMgdm5vZGUudHJhbnNpdGlvblxyXG4vLyBhbmQgd2lsbCBiZSBjYWxsZWQgYXQgYXBwcm9wcmlhdGUgdGltaW5nIGluIHRoZSByZW5kZXJlci5cclxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyh2bm9kZSwgcHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyBhcHBlYXIsIG1vZGUsIHBlcnNpc3RlZCA9IGZhbHNlLCBvbkJlZm9yZUVudGVyLCBvbkVudGVyLCBvbkFmdGVyRW50ZXIsIG9uRW50ZXJDYW5jZWxsZWQsIG9uQmVmb3JlTGVhdmUsIG9uTGVhdmUsIG9uQWZ0ZXJMZWF2ZSwgb25MZWF2ZUNhbmNlbGxlZCwgb25CZWZvcmVBcHBlYXIsIG9uQXBwZWFyLCBvbkFmdGVyQXBwZWFyLCBvbkFwcGVhckNhbmNlbGxlZCB9ID0gcHJvcHM7XHJcbiAgICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcclxuICAgIGNvbnN0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKTtcclxuICAgIGNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcclxuICAgICAgICBob29rICYmXHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA5IC8qIFRSQU5TSVRJT05fSE9PSyAqLywgYXJncyk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaG9va3MgPSB7XHJcbiAgICAgICAgbW9kZSxcclxuICAgICAgICBwZXJzaXN0ZWQsXHJcbiAgICAgICAgYmVmb3JlRW50ZXIoZWwpIHtcclxuICAgICAgICAgICAgbGV0IGhvb2sgPSBvbkJlZm9yZUVudGVyO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcGVhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2sgPSBvbkJlZm9yZUFwcGVhciB8fCBvbkJlZm9yZUVudGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZvciBzYW1lIGVsZW1lbnQgKHYtc2hvdylcclxuICAgICAgICAgICAgaWYgKGVsLl9sZWF2ZUNiKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYih0cnVlIC8qIGNhbmNlbGxlZCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZm9yIHRvZ2dsZWQgZWxlbWVudCB3aXRoIHNhbWUga2V5ICh2LWlmKVxyXG4gICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGUgPSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XTtcclxuICAgICAgICAgICAgaWYgKGxlYXZpbmdWTm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgaXNTYW1lVk5vZGVUeXBlKHZub2RlLCBsZWF2aW5nVk5vZGUpICYmXHJcbiAgICAgICAgICAgICAgICBsZWF2aW5nVk5vZGUuZWwuX2xlYXZlQ2IpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIGVhcmx5IHJlbW92YWwgKG5vdCBjYW5jZWxsZWQpXHJcbiAgICAgICAgICAgICAgICBsZWF2aW5nVk5vZGUuZWwuX2xlYXZlQ2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWxsSG9vayhob29rLCBbZWxdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyKGVsKSB7XHJcbiAgICAgICAgICAgIGxldCBob29rID0gb25FbnRlcjtcclxuICAgICAgICAgICAgbGV0IGFmdGVySG9vayA9IG9uQWZ0ZXJFbnRlcjtcclxuICAgICAgICAgICAgbGV0IGNhbmNlbEhvb2sgPSBvbkVudGVyQ2FuY2VsbGVkO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcGVhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2sgPSBvbkFwcGVhciB8fCBvbkVudGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGFmdGVySG9vayA9IG9uQWZ0ZXJBcHBlYXIgfHwgb25BZnRlckVudGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEhvb2sgPSBvbkFwcGVhckNhbmNlbGxlZCB8fCBvbkVudGVyQ2FuY2VsbGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgZG9uZSA9IChlbC5fZW50ZXJDYiA9IChjYW5jZWxsZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhjYW5jZWxIb29rLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKGFmdGVySG9vaywgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaG9va3MuZGVsYXllZExlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9va3MuZGVsYXllZExlYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbC5fZW50ZXJDYiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChob29rKSB7XHJcbiAgICAgICAgICAgICAgICBob29rKGVsLCBkb25lKTtcclxuICAgICAgICAgICAgICAgIGlmIChob29rLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsZWF2ZShlbCwgcmVtb3ZlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IFN0cmluZyh2bm9kZS5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoZWwuX2VudGVyQ2IpIHtcclxuICAgICAgICAgICAgICAgIGVsLl9lbnRlckNiKHRydWUgLyogY2FuY2VsbGVkICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNVbm1vdW50aW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVMZWF2ZSwgW2VsXSk7XHJcbiAgICAgICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgZG9uZSA9IChlbC5fbGVhdmVDYiA9IChjYW5jZWxsZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2sob25BZnRlckxlYXZlLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldID09PSB2bm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldID0gdm5vZGU7XHJcbiAgICAgICAgICAgIGlmIChvbkxlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICBvbkxlYXZlKGVsLCBkb25lKTtcclxuICAgICAgICAgICAgICAgIGlmIChvbkxlYXZlLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9uZSh2bm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyh2bm9kZSwgcHJvcHMsIHN0YXRlLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBob29rcztcclxufVxyXG4vLyB0aGUgcGxhY2Vob2xkZXIgcmVhbGx5IG9ubHkgaGFuZGxlcyBvbmUgc3BlY2lhbCBjYXNlOiBLZWVwQWxpdmVcclxuLy8gaW4gdGhlIGNhc2Ugb2YgYSBLZWVwQWxpdmUgaW4gYSBsZWF2ZSBwaGFzZSB3ZSBuZWVkIHRvIHJldHVybiBhIEtlZXBBbGl2ZVxyXG4vLyBwbGFjZWhvbGRlciB3aXRoIGVtcHR5IGNvbnRlbnQgdG8gYXZvaWQgdGhlIEtlZXBBbGl2ZSBpbnN0YW5jZSBmcm9tIGJlaW5nXHJcbi8vIHVubW91bnRlZC5cclxuZnVuY3Rpb24gZW1wdHlQbGFjZWhvbGRlcih2bm9kZSkge1xyXG4gICAgaWYgKGlzS2VlcEFsaXZlKHZub2RlKSkge1xyXG4gICAgICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRLZWVwQWxpdmVDaGlsZCh2bm9kZSkge1xyXG4gICAgcmV0dXJuIGlzS2VlcEFsaXZlKHZub2RlKVxyXG4gICAgICAgID8gdm5vZGUuY2hpbGRyZW5cclxuICAgICAgICAgICAgPyB2bm9kZS5jaGlsZHJlblswXVxyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZFxyXG4gICAgICAgIDogdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCBob29rcykge1xyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovICYmIHZub2RlLmNvbXBvbmVudCkge1xyXG4gICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgaG9va3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgdm5vZGUuc3NDb250ZW50LnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0NvbnRlbnQpO1xyXG4gICAgICAgIHZub2RlLnNzRmFsbGJhY2sudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzRmFsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdm5vZGUudHJhbnNpdGlvbiA9IGhvb2tzO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZHJlbiwga2VlcENvbW1lbnQgPSBmYWxzZSkge1xyXG4gICAgbGV0IHJldCA9IFtdO1xyXG4gICAgbGV0IGtleWVkRnJhZ21lbnRDb3VudCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAvLyBoYW5kbGUgZnJhZ21lbnQgY2hpbGRyZW4gY2FzZSwgZS5nLiB2LWZvclxyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQucGF0Y2hGbGFnICYgMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovKVxyXG4gICAgICAgICAgICAgICAga2V5ZWRGcmFnbWVudENvdW50Kys7XHJcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkLmNoaWxkcmVuLCBrZWVwQ29tbWVudCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb21tZW50IHBsYWNlaG9sZGVycyBzaG91bGQgYmUgc2tpcHBlZCwgZS5nLiB2LWlmXHJcbiAgICAgICAgZWxzZSBpZiAoa2VlcENvbW1lbnQgfHwgY2hpbGQudHlwZSAhPT0gQ29tbWVudCQxKSB7XHJcbiAgICAgICAgICAgIHJldC5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAjMTEyNiBpZiBhIHRyYW5zaXRpb24gY2hpbGRyZW4gbGlzdCBjb250YWlucyBtdWx0aXBsZSBzdWIgZnJhZ21lbnRzLCB0aGVzZVxyXG4gICAgLy8gZnJhZ21lbnRzIHdpbGwgYmUgbWVyZ2VkIGludG8gYSBmbGF0IGNoaWxkcmVuIGFycmF5LiBTaW5jZSBlYWNoIHYtZm9yXHJcbiAgICAvLyBmcmFnbWVudCBtYXkgY29udGFpbiBkaWZmZXJlbnQgc3RhdGljIGJpbmRpbmdzIGluc2lkZSwgd2UgbmVlZCB0byBkZS1vcFxyXG4gICAgLy8gdGhlc2UgY2hpbGRyZW4gdG8gZm9yY2UgZnVsbCBkaWZmcyB0byBlbnN1cmUgY29ycmVjdCBiZWhhdmlvci5cclxuICAgIGlmIChrZXllZEZyYWdtZW50Q291bnQgPiAxKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmV0W2ldLnBhdGNoRmxhZyA9IC0yIC8qIEJBSUwgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxuXG4vLyBpbXBsZW1lbnRhdGlvbiwgY2xvc2UgdG8gbm8tb3BcclxuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uJDEob3B0aW9ucykgPyB7IHNldHVwOiBvcHRpb25zLCBuYW1lOiBvcHRpb25zLm5hbWUgfSA6IG9wdGlvbnM7XHJcbn1cblxuY29uc3QgaXNBc3luY1dyYXBwZXIgPSAoaSkgPT4gISFpLnR5cGUuX19hc3luY0xvYWRlcjtcclxuZnVuY3Rpb24gZGVmaW5lQXN5bmNDb21wb25lbnQoc291cmNlKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbiQxKHNvdXJjZSkpIHtcclxuICAgICAgICBzb3VyY2UgPSB7IGxvYWRlcjogc291cmNlIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGxvYWRlciwgbG9hZGluZ0NvbXBvbmVudCwgZXJyb3JDb21wb25lbnQsIGRlbGF5ID0gMjAwLCB0aW1lb3V0LCAvLyB1bmRlZmluZWQgPSBuZXZlciB0aW1lcyBvdXRcclxuICAgIHN1c3BlbnNpYmxlID0gdHJ1ZSwgb25FcnJvcjogdXNlck9uRXJyb3IgfSA9IHNvdXJjZTtcclxuICAgIGxldCBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XHJcbiAgICBsZXQgcmVzb2x2ZWRDb21wO1xyXG4gICAgbGV0IHJldHJpZXMgPSAwO1xyXG4gICAgY29uc3QgcmV0cnkgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0cmllcysrO1xyXG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gbG9hZCgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgbGV0IHRoaXNSZXF1ZXN0O1xyXG4gICAgICAgIHJldHVybiAocGVuZGluZ1JlcXVlc3QgfHxcclxuICAgICAgICAgICAgKHRoaXNSZXF1ZXN0ID0gcGVuZGluZ1JlcXVlc3QgPSBsb2FkZXIoKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICBlcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodXNlck9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyUmV0cnkgPSAoKSA9PiByZXNvbHZlKHJldHJ5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyRmFpbCA9ICgpID0+IHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyT25FcnJvcihlcnIsIHVzZXJSZXRyeSwgdXNlckZhaWwsIHJldHJpZXMgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKChjb21wKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpc1JlcXVlc3QgIT09IHBlbmRpbmdSZXF1ZXN0ICYmIHBlbmRpbmdSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY29tcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEFzeW5jIGNvbXBvbmVudCBsb2FkZXIgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYElmIHlvdSBhcmUgdXNpbmcgcmV0cnkoKSwgbWFrZSBzdXJlIHRvIHJldHVybiBpdHMgcmV0dXJuIHZhbHVlLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaW50ZXJvcCBtb2R1bGUgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXAgJiZcclxuICAgICAgICAgICAgICAgICAgICAoY29tcC5fX2VzTW9kdWxlIHx8IGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29tcCAmJiAhaXNPYmplY3QkMShjb21wKSAmJiAhaXNGdW5jdGlvbiQxKGNvbXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFzeW5jIGNvbXBvbmVudCBsb2FkIHJlc3VsdDogJHtjb21wfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRDb21wID0gY29tcDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wO1xyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBkZWZpbmVDb21wb25lbnQoe1xyXG4gICAgICAgIG5hbWU6ICdBc3luY0NvbXBvbmVudFdyYXBwZXInLFxyXG4gICAgICAgIF9fYXN5bmNMb2FkZXI6IGxvYWQsXHJcbiAgICAgICAgZ2V0IF9fYXN5bmNSZXNvbHZlZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQ29tcDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldHVwKCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgICAgICAgICAgLy8gYWxyZWFkeSByZXNvbHZlZFxyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAxMyAvKiBBU1lOQ19DT01QT05FTlRfTE9BREVSICovLCAhZXJyb3JDb21wb25lbnQgLyogZG8gbm90IHRocm93IGluIGRldiBpZiB1c2VyIHByb3ZpZGVkIGVycm9yIGNvbXBvbmVudCAqLyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIHN1c3BlbnNlLWNvbnRyb2xsZWQgb3IgU1NSLlxyXG4gICAgICAgICAgICBpZiAoKHN1c3BlbnNpYmxlICYmIGluc3RhbmNlLnN1c3BlbnNlKSB8fFxyXG4gICAgICAgICAgICAgICAgKGZhbHNlICkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkKClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihjb21wID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKGNvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBlcnJvckNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYWRlZCA9IHJlZihmYWxzZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gcmVmKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ZWQgPSByZWYoISFkZWxheSk7XHJcbiAgICAgICAgICAgIGlmIChkZWxheSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZC52YWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9hZGVkLnZhbHVlICYmICFlcnJvci52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYEFzeW5jIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0fW1zLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvYWQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbG9hZGVkLnZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQgJiYgaXNLZWVwQWxpdmUoaW5zdGFuY2UucGFyZW50LnZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcmVudCBpcyBrZWVwLWFsaXZlLCBmb3JjZSB1cGRhdGUgc28gdGhlIGxvYWRlZCBjb21wb25lbnQnc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5hbWUgaXMgdGFrZW4gaW50byBhY2NvdW50XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChsb2FkZWQudmFsdWUgJiYgcmVzb2x2ZWRDb21wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLnZhbHVlICYmIGVycm9yQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG9hZGluZ0NvbXBvbmVudCAmJiAhZGVsYXllZC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShsb2FkaW5nQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbm5lckNvbXAoY29tcCwgeyB2bm9kZTogeyByZWYsIHByb3BzLCBjaGlsZHJlbiB9IH0pIHtcclxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoY29tcCwgcHJvcHMsIGNoaWxkcmVuKTtcclxuICAgIC8vIGVuc3VyZSBpbm5lciBjb21wb25lbnQgaW5oZXJpdHMgdGhlIGFzeW5jIHdyYXBwZXIncyByZWYgb3duZXJcclxuICAgIHZub2RlLnJlZiA9IHJlZjtcclxuICAgIHJldHVybiB2bm9kZTtcclxufVxuXG5jb25zdCBpc0tlZXBBbGl2ZSA9ICh2bm9kZSkgPT4gdm5vZGUudHlwZS5fX2lzS2VlcEFsaXZlO1xyXG5jb25zdCBLZWVwQWxpdmVJbXBsID0ge1xyXG4gICAgbmFtZTogYEtlZXBBbGl2ZWAsXHJcbiAgICAvLyBNYXJrZXIgZm9yIHNwZWNpYWwgaGFuZGxpbmcgaW5zaWRlIHRoZSByZW5kZXJlci4gV2UgYXJlIG5vdCB1c2luZyBhID09PVxyXG4gICAgLy8gY2hlY2sgZGlyZWN0bHkgb24gS2VlcEFsaXZlIGluIHRoZSByZW5kZXJlciwgYmVjYXVzZSBpbXBvcnRpbmcgaXQgZGlyZWN0bHlcclxuICAgIC8vIHdvdWxkIHByZXZlbnQgaXQgZnJvbSBiZWluZyB0cmVlLXNoYWtlbi5cclxuICAgIF9faXNLZWVwQWxpdmU6IHRydWUsXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIGluY2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxyXG4gICAgICAgIGV4Y2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxyXG4gICAgICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxyXG4gICAgfSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIC8vIEtlZXBBbGl2ZSBjb21tdW5pY2F0ZXMgd2l0aCB0aGUgaW5zdGFudGlhdGVkIHJlbmRlcmVyIHZpYSB0aGVcclxuICAgICAgICAvLyBjdHggd2hlcmUgdGhlIHJlbmRlcmVyIHBhc3NlcyBpbiBpdHMgaW50ZXJuYWxzLFxyXG4gICAgICAgIC8vIGFuZCB0aGUgS2VlcEFsaXZlIGluc3RhbmNlIGV4cG9zZXMgYWN0aXZhdGUvZGVhY3RpdmF0ZSBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICAgICAgLy8gVGhlIHdob2xlIHBvaW50IG9mIHRoaXMgaXMgdG8gYXZvaWQgaW1wb3J0aW5nIEtlZXBBbGl2ZSBkaXJlY3RseSBpbiB0aGVcclxuICAgICAgICAvLyByZW5kZXJlciB0byBmYWNpbGl0YXRlIHRyZWUtc2hha2luZy5cclxuICAgICAgICBjb25zdCBzaGFyZWRDb250ZXh0ID0gaW5zdGFuY2UuY3R4O1xyXG4gICAgICAgIC8vIGlmIHRoZSBpbnRlcm5hbCByZW5kZXJlciBpcyBub3QgcmVnaXN0ZXJlZCwgaXQgaW5kaWNhdGVzIHRoYXQgdGhpcyBpcyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcsXHJcbiAgICAgICAgLy8gZm9yIEtlZXBBbGl2ZSwgd2UganVzdCBuZWVkIHRvIHJlbmRlciBpdHMgY2hpbGRyZW5cclxuICAgICAgICBpZiAoIXNoYXJlZENvbnRleHQucmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNsb3RzLmRlZmF1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLl9fdl9jYWNoZSA9IGNhY2hlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJlbnRTdXNwZW5zZSA9IGluc3RhbmNlLnN1c3BlbnNlO1xyXG4gICAgICAgIGNvbnN0IHsgcmVuZGVyZXI6IHsgcDogcGF0Y2gsIG06IG1vdmUsIHVtOiBfdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSB9ID0gc2hhcmVkQ29udGV4dDtcclxuICAgICAgICBjb25zdCBzdG9yYWdlQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgc2hhcmVkQ29udGV4dC5hY3RpdmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIG1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCAwIC8qIEVOVEVSICovLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIC8vIGluIGNhc2UgcHJvcHMgaGF2ZSBjaGFuZ2VkXHJcbiAgICAgICAgICAgIHBhdGNoKGluc3RhbmNlLnZub2RlLCB2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHZub2RlLnNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzRGVhY3RpdmF0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UuYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlTW91bnRlZDtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZUhvb2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZS5wYXJlbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNvbXBvbmVudHMgdHJlZVxyXG4gICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHNoYXJlZENvbnRleHQuZGVhY3RpdmF0ZSA9ICh2bm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgbW92ZSh2bm9kZSwgc3RvcmFnZUNvbnRhaW5lciwgbnVsbCwgMSAvKiBMRUFWRSAqLywgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UuZGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZVVubW91bnRlZDtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZUhvb2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZS5wYXJlbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzRGVhY3RpdmF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY29tcG9uZW50cyB0cmVlXHJcbiAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSkge1xyXG4gICAgICAgICAgICAvLyByZXNldCB0aGUgc2hhcGVGbGFnIHNvIGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWRcclxuICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xyXG4gICAgICAgICAgICBfdW5tb3VudCh2bm9kZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcHJ1bmVDYWNoZShmaWx0ZXIpIHtcclxuICAgICAgICAgICAgY2FjaGUuZm9yRWFjaCgodm5vZGUsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodm5vZGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiAoIWZpbHRlciB8fCAhZmlsdGVyKG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5KGtleSkge1xyXG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50IHx8IGNhY2hlZC50eXBlICE9PSBjdXJyZW50LnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoY2FjaGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSBpbnN0YW5jZSBzaG91bGQgbm8gbG9uZ2VyIGJlIGtlcHQtYWxpdmUuXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCB1bm1vdW50IGl0IG5vdyBidXQgaXQgbWlnaHQgYmUgbGF0ZXIsIHNvIHJlc2V0IGl0cyBmbGFnIG5vdy5cclxuICAgICAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhY2hlLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwcnVuZSBjYWNoZSBvbiBpbmNsdWRlL2V4Y2x1ZGUgcHJvcCBjaGFuZ2VcclxuICAgICAgICB3YXRjaCgoKSA9PiBbcHJvcHMuaW5jbHVkZSwgcHJvcHMuZXhjbHVkZV0sIChbaW5jbHVkZSwgZXhjbHVkZV0pID0+IHtcclxuICAgICAgICAgICAgaW5jbHVkZSAmJiBwcnVuZUNhY2hlKG5hbWUgPT4gbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSk7XHJcbiAgICAgICAgICAgIGV4Y2x1ZGUgJiYgcHJ1bmVDYWNoZShuYW1lID0+ICFtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKTtcclxuICAgICAgICB9LCBcclxuICAgICAgICAvLyBwcnVuZSBwb3N0LXJlbmRlciBhZnRlciBgY3VycmVudGAgaGFzIGJlZW4gdXBkYXRlZFxyXG4gICAgICAgIHsgZmx1c2g6ICdwb3N0JywgZGVlcDogdHJ1ZSB9KTtcclxuICAgICAgICAvLyBjYWNoZSBzdWIgdHJlZSBhZnRlciByZW5kZXJcclxuICAgICAgICBsZXQgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcclxuICAgICAgICBjb25zdCBjYWNoZVN1YnRyZWUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGZpeCAjMTYyMSwgdGhlIHBlbmRpbmdDYWNoZUtleSBjb3VsZCBiZSAwXHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nQ2FjaGVLZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGUuc2V0KHBlbmRpbmdDYWNoZUtleSwgZ2V0SW5uZXJDaGlsZChpbnN0YW5jZS5zdWJUcmVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIG9uTW91bnRlZChjYWNoZVN1YnRyZWUpO1xyXG4gICAgICAgIG9uVXBkYXRlZChjYWNoZVN1YnRyZWUpO1xyXG4gICAgICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNhY2hlLmZvckVhY2goY2FjaGVkID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3ViVHJlZSwgc3VzcGVuc2UgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHN1YlRyZWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZC50eXBlID09PSB2bm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBpbnN0YW5jZSB3aWxsIGJlIHVubW91bnRlZCBhcyBwYXJ0IG9mIGtlZXAtYWxpdmUncyB1bm1vdW50XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpbnZva2UgaXRzIGRlYWN0aXZhdGVkIGhvb2sgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkYSwgc3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVubW91bnQoY2FjaGVkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFzbG90cy5kZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgY29uc3QgcmF3Vk5vZGUgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBLZWVwQWxpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgY29tcG9uZW50IGNoaWxkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVk5vZGUocmF3Vk5vZGUpIHx8XHJcbiAgICAgICAgICAgICAgICAoIShyYXdWTm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLykgJiZcclxuICAgICAgICAgICAgICAgICAgICAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHJhd1ZOb2RlKTtcclxuICAgICAgICAgICAgY29uc3QgY29tcCA9IHZub2RlLnR5cGU7XHJcbiAgICAgICAgICAgIC8vIGZvciBhc3luYyBjb21wb25lbnRzLCBuYW1lIGNoZWNrIHNob3VsZCBiZSBiYXNlZCBpbiBpdHMgbG9hZGVkXHJcbiAgICAgICAgICAgIC8vIGlubmVyIGNvbXBvbmVudCBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoaXNBc3luY1dyYXBwZXIodm5vZGUpXHJcbiAgICAgICAgICAgICAgICA/IHZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkIHx8IHt9XHJcbiAgICAgICAgICAgICAgICA6IGNvbXApO1xyXG4gICAgICAgICAgICBjb25zdCB7IGluY2x1ZGUsIGV4Y2x1ZGUsIG1heCB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGlmICgoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxyXG4gICAgICAgICAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHZub2RlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsID8gY29tcCA6IHZub2RlLmtleTtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkVk5vZGUgPSBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgLy8gY2xvbmUgdm5vZGUgaWYgaXQncyByZXVzZWQgYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gbXV0YXRlIGl0XHJcbiAgICAgICAgICAgIGlmICh2bm9kZS5lbCkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICByYXdWTm9kZS5zc0NvbnRlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAjMTUxMyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgcmV0dXJuZWQgdm5vZGUgdG8gYmUgY2xvbmVkIGR1ZSB0byBhdHRyXHJcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoIG9yIHNjb3BlSWQsIHNvIHRoZSB2bm9kZSBoZXJlIG1heSBub3QgYmUgdGhlIGZpbmFsIHZub2RlXHJcbiAgICAgICAgICAgIC8vIHRoYXQgaXMgbW91bnRlZC4gSW5zdGVhZCBvZiBjYWNoaW5nIGl0IGRpcmVjdGx5LCB3ZSBzdG9yZSB0aGUgcGVuZGluZ1xyXG4gICAgICAgICAgICAvLyBrZXkgYW5kIGNhY2hlIGBpbnN0YW5jZS5zdWJUcmVlYCAodGhlIG5vcm1hbGl6ZWQgdm5vZGUpIGluXHJcbiAgICAgICAgICAgIC8vIGJlZm9yZU1vdW50L2JlZm9yZVVwZGF0ZSBob29rcy5cclxuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkVk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvcHkgb3ZlciBtb3VudGVkIHN0YXRlXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5lbCA9IGNhY2hlZFZOb2RlLmVsO1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gY2FjaGVkVk5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgdHJhbnNpdGlvbiBob29rcyBvbiBzdWJUcmVlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCB2bm9kZS50cmFuc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHZub2RlIGJlaW5nIG1vdW50ZWQgYXMgZnJlc2hcclxuICAgICAgICAgICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi87XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoaXMga2V5IHRoZSBmcmVzaGVzdFxyXG4gICAgICAgICAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4ICYmIGtleXMuc2l6ZSA+IHBhcnNlSW50KG1heCwgMTApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhdm9pZCB2bm9kZSBiZWluZyB1bm1vdW50ZWRcclxuICAgICAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbi8vIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxyXG4vLyBhbHNvIHRvIGF2b2lkIGlubGluZSBpbXBvcnQoKSBpbiBnZW5lcmF0ZWQgZC50cyBmaWxlc1xyXG5jb25zdCBLZWVwQWxpdmUgPSBLZWVwQWxpdmVJbXBsO1xyXG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcclxuICAgIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uc29tZSgocCkgPT4gbWF0Y2hlcyhwLCBuYW1lKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1N0cmluZyhwYXR0ZXJuKSkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGF0dGVybi50ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gb25BY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XHJcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJhXCIgLyogQUNUSVZBVEVEICovLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIG9uRGVhY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XHJcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJkYVwiIC8qIERFQUNUSVZBVEVEICovLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCB0eXBlLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgIC8vIGNhY2hlIHRoZSBkZWFjdGl2YXRlIGJyYW5jaCBjaGVjayB3cmFwcGVyIGZvciBpbmplY3RlZCBob29rcyBzbyB0aGUgc2FtZVxyXG4gICAgLy8gaG9vayBjYW4gYmUgcHJvcGVybHkgZGVkdXBlZCBieSB0aGUgc2NoZWR1bGVyLiBcIl9fd2RjXCIgc3RhbmRzIGZvciBcIndpdGhcclxuICAgIC8vIGRlYWN0aXZhdGlvbiBjaGVja1wiLlxyXG4gICAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2RjIHx8XHJcbiAgICAgICAgKGhvb2suX193ZGMgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgZmlyZSB0aGUgaG9vayBpZiB0aGUgdGFyZ2V0IGluc3RhbmNlIGlzIE5PVCBpbiBhIGRlYWN0aXZhdGVkIGJyYW5jaC5cclxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5pc0RlYWN0aXZhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhvb2soKTtcclxuICAgICAgICB9KTtcclxuICAgIGluamVjdEhvb2sodHlwZSwgd3JhcHBlZEhvb2ssIHRhcmdldCk7XHJcbiAgICAvLyBJbiBhZGRpdGlvbiB0byByZWdpc3RlcmluZyBpdCBvbiB0aGUgdGFyZ2V0IGluc3RhbmNlLCB3ZSB3YWxrIHVwIHRoZSBwYXJlbnRcclxuICAgIC8vIGNoYWluIGFuZCByZWdpc3RlciBpdCBvbiBhbGwgYW5jZXN0b3IgaW5zdGFuY2VzIHRoYXQgYXJlIGtlZXAtYWxpdmUgcm9vdHMuXHJcbiAgICAvLyBUaGlzIGF2b2lkcyB0aGUgbmVlZCB0byB3YWxrIHRoZSBlbnRpcmUgY29tcG9uZW50IHRyZWUgd2hlbiBpbnZva2luZyB0aGVzZVxyXG4gICAgLy8gaG9va3MsIGFuZCBtb3JlIGltcG9ydGFudGx5LCBhdm9pZHMgdGhlIG5lZWQgdG8gdHJhY2sgY2hpbGQgY29tcG9uZW50cyBpblxyXG4gICAgLy8gYXJyYXlzLlxyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0LnBhcmVudDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50LnBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAoaXNLZWVwQWxpdmUoY3VycmVudC5wYXJlbnQudm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpbmplY3RUb0tlZXBBbGl2ZVJvb3Qod3JhcHBlZEhvb2ssIHR5cGUsIHRhcmdldCwgY3VycmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbmplY3RUb0tlZXBBbGl2ZVJvb3QoaG9vaywgdHlwZSwgdGFyZ2V0LCBrZWVwQWxpdmVSb290KSB7XHJcbiAgICAvLyBpbmplY3RIb29rIHdyYXBzIHRoZSBvcmlnaW5hbCBmb3IgZXJyb3IgaGFuZGxpbmcsIHNvIG1ha2Ugc3VyZSB0byByZW1vdmVcclxuICAgIC8vIHRoZSB3cmFwcGVkIHZlcnNpb24uXHJcbiAgICBjb25zdCBpbmplY3RlZCA9IGluamVjdEhvb2sodHlwZSwgaG9vaywga2VlcEFsaXZlUm9vdCwgdHJ1ZSAvKiBwcmVwZW5kICovKTtcclxuICAgIG9uVW5tb3VudGVkKCgpID0+IHtcclxuICAgICAgICByZW1vdmUoa2VlcEFsaXZlUm9vdFt0eXBlXSwgaW5qZWN0ZWQpO1xyXG4gICAgfSwgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiByZXNldFNoYXBlRmxhZyh2bm9kZSkge1xyXG4gICAgbGV0IHNoYXBlRmxhZyA9IHZub2RlLnNoYXBlRmxhZztcclxuICAgIGlmIChzaGFwZUZsYWcgJiAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovKSB7XHJcbiAgICAgICAgc2hhcGVGbGFnIC09IDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XHJcbiAgICB9XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgNTEyIC8qIENPTVBPTkVOVF9LRVBUX0FMSVZFICovKSB7XHJcbiAgICAgICAgc2hhcGVGbGFnIC09IDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLztcclxuICAgIH1cclxuICAgIHZub2RlLnNoYXBlRmxhZyA9IHNoYXBlRmxhZztcclxufVxyXG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkKHZub2RlKSB7XHJcbiAgICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovID8gdm5vZGUuc3NDb250ZW50IDogdm5vZGU7XHJcbn1cblxuZnVuY3Rpb24gaW5qZWN0SG9vayh0eXBlLCBob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UsIHByZXBlbmQgPSBmYWxzZSkge1xyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IGhvb2tzID0gdGFyZ2V0W3R5cGVdIHx8ICh0YXJnZXRbdHlwZV0gPSBbXSk7XHJcbiAgICAgICAgLy8gY2FjaGUgdGhlIGVycm9yIGhhbmRsaW5nIHdyYXBwZXIgZm9yIGluamVjdGVkIGhvb2tzIHNvIHRoZSBzYW1lIGhvb2tcclxuICAgICAgICAvLyBjYW4gYmUgcHJvcGVybHkgZGVkdXBlZCBieSB0aGUgc2NoZWR1bGVyLiBcIl9fd2VoXCIgc3RhbmRzIGZvciBcIndpdGggZXJyb3JcclxuICAgICAgICAvLyBoYW5kbGluZ1wiLlxyXG4gICAgICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dlaCB8fFxyXG4gICAgICAgICAgICAoaG9vay5fX3dlaCA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzVW5tb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZSB0cmFja2luZyBpbnNpZGUgYWxsIGxpZmVjeWNsZSBob29rc1xyXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhleSBjYW4gcG90ZW50aWFsbHkgYmUgY2FsbGVkIGluc2lkZSBlZmZlY3RzLlxyXG4gICAgICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGN1cnJlbnRJbnN0YW5jZSBkdXJpbmcgaG9vayBpbnZvY2F0aW9uLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhc3N1bWVzIHRoZSBob29rIGRvZXMgbm90IHN5bmNocm9ub3VzbHkgdHJpZ2dlciBvdGhlciBob29rcywgd2hpY2hcclxuICAgICAgICAgICAgICAgIC8vIGNhbiBvbmx5IGJlIGZhbHNlIHdoZW4gdGhlIHVzZXIgZG9lcyBzb21ldGhpbmcgcmVhbGx5IGZ1bmt5LlxyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCB0YXJnZXQsIHR5cGUsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHByZXBlbmQpIHtcclxuICAgICAgICAgICAgaG9va3MudW5zaGlmdCh3cmFwcGVkSG9vayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBob29rcy5wdXNoKHdyYXBwZWRIb29rKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRIb29rO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgYXBpTmFtZSA9IHRvSGFuZGxlcktleShFcnJvclR5cGVTdHJpbmdzW3R5cGVdLnJlcGxhY2UoLyBob29rJC8sICcnKSk7XHJcbiAgICAgICAgd2FybihgJHthcGlOYW1lfSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGAgK1xyXG4gICAgICAgICAgICBgYXNzb2NpYXRlZCB3aXRoLiBgICtcclxuICAgICAgICAgICAgYExpZmVjeWNsZSBpbmplY3Rpb24gQVBJcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBleGVjdXRpb24gb2Ygc2V0dXAoKS5gICtcclxuICAgICAgICAgICAgKGAgSWYgeW91IGFyZSB1c2luZyBhc3luYyBzZXR1cCgpLCBtYWtlIHN1cmUgdG8gcmVnaXN0ZXIgbGlmZWN5Y2xlIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBob29rcyBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0IHN0YXRlbWVudC5gXHJcbiAgICAgICAgICAgICAgICApKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBjcmVhdGVIb29rID0gKGxpZmVjeWNsZSkgPT4gKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkgPT4gXHJcbi8vIHBvc3QtY3JlYXRlIGxpZmVjeWNsZSByZWdpc3RyYXRpb25zIGFyZSBub29wcyBkdXJpbmcgU1NSIChleGNlcHQgZm9yIHNlcnZlclByZWZldGNoKVxyXG4oIWlzSW5TU1JDb21wb25lbnRTZXR1cCB8fCBsaWZlY3ljbGUgPT09IFwic3BcIiAvKiBTRVJWRVJfUFJFRkVUQ0ggKi8pICYmXHJcbiAgICBpbmplY3RIb29rKGxpZmVjeWNsZSwgaG9vaywgdGFyZ2V0KTtcclxuY29uc3Qgb25CZWZvcmVNb3VudCA9IGNyZWF0ZUhvb2soXCJibVwiIC8qIEJFRk9SRV9NT1VOVCAqLyk7XHJcbmNvbnN0IG9uTW91bnRlZCA9IGNyZWF0ZUhvb2soXCJtXCIgLyogTU9VTlRFRCAqLyk7XHJcbmNvbnN0IG9uQmVmb3JlVXBkYXRlID0gY3JlYXRlSG9vayhcImJ1XCIgLyogQkVGT1JFX1VQREFURSAqLyk7XHJcbmNvbnN0IG9uVXBkYXRlZCA9IGNyZWF0ZUhvb2soXCJ1XCIgLyogVVBEQVRFRCAqLyk7XHJcbmNvbnN0IG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUhvb2soXCJidW1cIiAvKiBCRUZPUkVfVU5NT1VOVCAqLyk7XHJcbmNvbnN0IG9uVW5tb3VudGVkID0gY3JlYXRlSG9vayhcInVtXCIgLyogVU5NT1VOVEVEICovKTtcclxuY29uc3Qgb25TZXJ2ZXJQcmVmZXRjaCA9IGNyZWF0ZUhvb2soXCJzcFwiIC8qIFNFUlZFUl9QUkVGRVRDSCAqLyk7XHJcbmNvbnN0IG9uUmVuZGVyVHJpZ2dlcmVkID0gY3JlYXRlSG9vayhcInJ0Z1wiIC8qIFJFTkRFUl9UUklHR0VSRUQgKi8pO1xyXG5jb25zdCBvblJlbmRlclRyYWNrZWQgPSBjcmVhdGVIb29rKFwicnRjXCIgLyogUkVOREVSX1RSQUNLRUQgKi8pO1xyXG5mdW5jdGlvbiBvbkVycm9yQ2FwdHVyZWQoaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICBpbmplY3RIb29rKFwiZWNcIiAvKiBFUlJPUl9DQVBUVVJFRCAqLywgaG9vaywgdGFyZ2V0KTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkge1xyXG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgcmV0dXJuICh0eXBlLCBrZXkpID0+IHtcclxuICAgICAgICBpZiAoY2FjaGVba2V5XSkge1xyXG4gICAgICAgICAgICB3YXJuKGAke3R5cGV9IHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluICR7Y2FjaGVba2V5XX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjYWNoZVtrZXldID0gdHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmxldCBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XHJcbmZ1bmN0aW9uIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKTtcclxuICAgIGNvbnN0IHB1YmxpY1RoaXMgPSBpbnN0YW5jZS5wcm94eTtcclxuICAgIGNvbnN0IGN0eCA9IGluc3RhbmNlLmN0eDtcclxuICAgIC8vIGRvIG5vdCBjYWNoZSBwcm9wZXJ0eSBhY2Nlc3Mgb24gcHVibGljIHByb3h5IGR1cmluZyBzdGF0ZSBpbml0aWFsaXphdGlvblxyXG4gICAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSBmYWxzZTtcclxuICAgIC8vIGNhbGwgYmVmb3JlQ3JlYXRlIGZpcnN0IGJlZm9yZSBhY2Nlc3Npbmcgb3RoZXIgb3B0aW9ucyBzaW5jZVxyXG4gICAgLy8gdGhlIGhvb2sgbWF5IG11dGF0ZSByZXNvbHZlZCBvcHRpb25zICgjMjc5MSlcclxuICAgIGlmIChvcHRpb25zLmJlZm9yZUNyZWF0ZSkge1xyXG4gICAgICAgIGNhbGxIb29rKG9wdGlvbnMuYmVmb3JlQ3JlYXRlLCBpbnN0YW5jZSwgXCJiY1wiIC8qIEJFRk9SRV9DUkVBVEUgKi8pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBcclxuICAgIC8vIHN0YXRlXHJcbiAgICBkYXRhOiBkYXRhT3B0aW9ucywgY29tcHV0ZWQ6IGNvbXB1dGVkT3B0aW9ucywgbWV0aG9kcywgd2F0Y2g6IHdhdGNoT3B0aW9ucywgcHJvdmlkZTogcHJvdmlkZU9wdGlvbnMsIGluamVjdDogaW5qZWN0T3B0aW9ucywgXHJcbiAgICAvLyBsaWZlY3ljbGVcclxuICAgIGNyZWF0ZWQsIGJlZm9yZU1vdW50LCBtb3VudGVkLCBiZWZvcmVVcGRhdGUsIHVwZGF0ZWQsIGFjdGl2YXRlZCwgZGVhY3RpdmF0ZWQsIGJlZm9yZURlc3Ryb3ksIGJlZm9yZVVubW91bnQsIGRlc3Ryb3llZCwgdW5tb3VudGVkLCByZW5kZXIsIHJlbmRlclRyYWNrZWQsIHJlbmRlclRyaWdnZXJlZCwgZXJyb3JDYXB0dXJlZCwgc2VydmVyUHJlZmV0Y2gsIFxyXG4gICAgLy8gcHVibGljIEFQSVxyXG4gICAgZXhwb3NlLCBpbmhlcml0QXR0cnMsIFxyXG4gICAgLy8gYXNzZXRzXHJcbiAgICBjb21wb25lbnRzLCBkaXJlY3RpdmVzLCBmaWx0ZXJzIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3QgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIDogbnVsbDtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCBbcHJvcHNPcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcclxuICAgICAgICBpZiAocHJvcHNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiUHJvcHNcIiAvKiBQUk9QUyAqLywga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG9wdGlvbnMgaW5pdGlhbGl6YXRpb24gb3JkZXIgKHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBWdWUgMik6XHJcbiAgICAvLyAtIHByb3BzIChhbHJlYWR5IGRvbmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uKVxyXG4gICAgLy8gLSBpbmplY3RcclxuICAgIC8vIC0gbWV0aG9kc1xyXG4gICAgLy8gLSBkYXRhIChkZWZlcnJlZCBzaW5jZSBpdCByZWxpZXMgb24gYHRoaXNgIGFjY2VzcylcclxuICAgIC8vIC0gY29tcHV0ZWRcclxuICAgIC8vIC0gd2F0Y2ggKGRlZmVycmVkIHNpbmNlIGl0IHJlbGllcyBvbiBgdGhpc2AgYWNjZXNzKVxyXG4gICAgaWYgKGluamVjdE9wdGlvbnMpIHtcclxuICAgICAgICByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyk7XHJcbiAgICB9XHJcbiAgICBpZiAobWV0aG9kcykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1ldGhvZHMpIHtcclxuICAgICAgICAgICAgY29uc3QgbWV0aG9kSGFuZGxlciA9IG1ldGhvZHNba2V5XTtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24kMShtZXRob2RIYW5kbGVyKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW4gZGV2IG1vZGUsIHdlIHVzZSB0aGUgYGNyZWF0ZVJlbmRlckNvbnRleHRgIGZ1bmN0aW9uIHRvIGRlZmluZSBtZXRob2RzIHRvIHRoZSBwcm94eSB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhvc2UgYXJlIHJlYWQtb25seSBidXQgcmVjb25maWd1cmFibGUsIHNvIGl0IG5lZWRzIHRvIGJlIHJlZGVmaW5lZCBoZXJlXHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eFtrZXldID0gbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIk1ldGhvZHNcIiAvKiBNRVRIT0RTICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIHR5cGUgXCIke3R5cGVvZiBtZXRob2RIYW5kbGVyfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYERpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YU9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0Z1bmN0aW9uJDEoZGF0YU9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFRoZSBkYXRhIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24uIGAgK1xyXG4gICAgICAgICAgICAgICAgYFBsYWluIG9iamVjdCB1c2FnZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhID0gZGF0YU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzUHJvbWlzZSQxKGRhdGEpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGRhdGEoKSByZXR1cm5lZCBhIFByb21pc2UgLSBub3RlIGRhdGEoKSBjYW5ub3QgYmUgYXN5bmM7IElmIHlvdSBgICtcclxuICAgICAgICAgICAgICAgIGBpbnRlbmQgdG8gcGVyZm9ybSBkYXRhIGZldGNoaW5nIGJlZm9yZSBjb21wb25lbnQgcmVuZGVycywgdXNlIGAgK1xyXG4gICAgICAgICAgICAgICAgYGFzeW5jIHNldHVwKCkgKyA8U3VzcGVuc2U+LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzT2JqZWN0JDEoZGF0YSkpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYGRhdGEoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmRhdGEgPSByZWFjdGl2ZShkYXRhKTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkRhdGFcIiAvKiBEQVRBICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cG9zZSBkYXRhIG9uIGN0eCBkdXJpbmcgZGV2XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gJyQnICYmIGtleVswXSAhPT0gJ18nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gZGF0YVtrZXldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHN0YXRlIGluaXRpYWxpemF0aW9uIGNvbXBsZXRlIGF0IHRoaXMgcG9pbnQgLSBzdGFydCBjYWNoaW5nIGFjY2Vzc1xyXG4gICAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xyXG4gICAgaWYgKGNvbXB1dGVkT3B0aW9ucykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkT3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCBvcHQgPSBjb21wdXRlZE9wdGlvbnNba2V5XTtcclxuICAgICAgICAgICAgY29uc3QgZ2V0ID0gaXNGdW5jdGlvbiQxKG9wdClcclxuICAgICAgICAgICAgICAgID8gb3B0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbiQxKG9wdC5nZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBvcHQuZ2V0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgICAgICA6IE5PT1A7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZ2V0ID09PSBOT09QKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGhhcyBubyBnZXR0ZXIuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2V0ID0gIWlzRnVuY3Rpb24kMShvcHQpICYmIGlzRnVuY3Rpb24kMShvcHQuc2V0KVxyXG4gICAgICAgICAgICAgICAgPyBvcHQuc2V0LmJpbmQocHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgIDogKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgPyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYFdyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgcmVhZG9ubHkuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIDogTk9PUDtcclxuICAgICAgICAgICAgY29uc3QgYyA9IGNvbXB1dGVkKHtcclxuICAgICAgICAgICAgICAgIGdldCxcclxuICAgICAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBjLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgc2V0OiB2ID0+IChjLnZhbHVlID0gdilcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkNvbXB1dGVkXCIgLyogQ09NUFVURUQgKi8sIGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAod2F0Y2hPcHRpb25zKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gd2F0Y2hPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGNyZWF0ZVdhdGNoZXIod2F0Y2hPcHRpb25zW2tleV0sIGN0eCwgcHVibGljVGhpcywga2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocHJvdmlkZU9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlcyA9IGlzRnVuY3Rpb24kMShwcm92aWRlT3B0aW9ucylcclxuICAgICAgICAgICAgPyBwcm92aWRlT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgIDogcHJvdmlkZU9wdGlvbnM7XHJcbiAgICAgICAgUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIHByb3ZpZGUoa2V5LCBwcm92aWRlc1trZXldKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChjcmVhdGVkKSB7XHJcbiAgICAgICAgY2FsbEhvb2soY3JlYXRlZCwgaW5zdGFuY2UsIFwiY1wiIC8qIENSRUFURUQgKi8pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJMaWZlY3ljbGVIb29rKHJlZ2lzdGVyLCBob29rKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcclxuICAgICAgICAgICAgaG9vay5mb3JFYWNoKF9ob29rID0+IHJlZ2lzdGVyKF9ob29rLmJpbmQocHVibGljVGhpcykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaG9vaykge1xyXG4gICAgICAgICAgICByZWdpc3Rlcihob29rLmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZU1vdW50LCBiZWZvcmVNb3VudCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Nb3VudGVkLCBtb3VudGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVwZGF0ZSwgYmVmb3JlVXBkYXRlKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVwZGF0ZWQsIHVwZGF0ZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQWN0aXZhdGVkLCBhY3RpdmF0ZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRGVhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkVycm9yQ2FwdHVyZWQsIGVycm9yQ2FwdHVyZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJhY2tlZCwgcmVuZGVyVHJhY2tlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmlnZ2VyZWQsIHJlbmRlclRyaWdnZXJlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVbm1vdW50LCBiZWZvcmVVbm1vdW50KTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVubW91bnRlZCwgdW5tb3VudGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblNlcnZlclByZWZldGNoLCBzZXJ2ZXJQcmVmZXRjaCk7XHJcbiAgICBpZiAoaXNBcnJheShleHBvc2UpKSB7XHJcbiAgICAgICAgaWYgKGV4cG9zZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgZXhwb3NlZCA9IGluc3RhbmNlLmV4cG9zZWQgfHwgKGluc3RhbmNlLmV4cG9zZWQgPSB7fSk7XHJcbiAgICAgICAgICAgIGV4cG9zZS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3NlZCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNUaGlzW2tleV0sXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0OiB2YWwgPT4gKHB1YmxpY1RoaXNba2V5XSA9IHZhbClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWluc3RhbmNlLmV4cG9zZWQpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG9wdGlvbnMgdGhhdCBhcmUgaGFuZGxlZCB3aGVuIGNyZWF0aW5nIHRoZSBpbnN0YW5jZSBidXQgYWxzbyBuZWVkIHRvIGJlXHJcbiAgICAvLyBhcHBsaWVkIGZyb20gbWl4aW5zXHJcbiAgICBpZiAocmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCkge1xyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IHJlbmRlcjtcclxuICAgIH1cclxuICAgIGlmIChpbmhlcml0QXR0cnMgIT0gbnVsbCkge1xyXG4gICAgICAgIGluc3RhbmNlLmluaGVyaXRBdHRycyA9IGluaGVyaXRBdHRycztcclxuICAgIH1cclxuICAgIC8vIGFzc2V0IG9wdGlvbnMuXHJcbiAgICBpZiAoY29tcG9uZW50cylcclxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRzID0gY29tcG9uZW50cztcclxuICAgIGlmIChkaXJlY3RpdmVzKVxyXG4gICAgICAgIGluc3RhbmNlLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gTk9PUCkge1xyXG4gICAgaWYgKGlzQXJyYXkoaW5qZWN0T3B0aW9ucykpIHtcclxuICAgICAgICBpbmplY3RPcHRpb25zID0gbm9ybWFsaXplSW5qZWN0KGluamVjdE9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0T3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG9wdCA9IGluamVjdE9wdGlvbnNba2V5XTtcclxuICAgICAgICBpZiAoaXNPYmplY3QkMShvcHQpKSB7XHJcbiAgICAgICAgICAgIGlmICgnZGVmYXVsdCcgaW4gb3B0KSB7XHJcbiAgICAgICAgICAgICAgICBjdHhba2V5XSA9IGluamVjdChvcHQuZnJvbSB8fCBrZXksIG9wdC5kZWZhdWx0LCB0cnVlIC8qIHRyZWF0IGRlZmF1bHQgZnVuY3Rpb24gYXMgZmFjdG9yeSAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdHhba2V5XSA9IGluamVjdChvcHQuZnJvbSB8fCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdHhba2V5XSA9IGluamVjdChvcHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkluamVjdFwiIC8qIElOSkVDVCAqLywga2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2FsbEhvb2soaG9vaywgaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGlzQXJyYXkoaG9vaylcclxuICAgICAgICA/IGhvb2subWFwKGggPT4gaC5iaW5kKGluc3RhbmNlLnByb3h5KSlcclxuICAgICAgICA6IGhvb2suYmluZChpbnN0YW5jZS5wcm94eSksIGluc3RhbmNlLCB0eXBlKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyKHJhdywgY3R4LCBwdWJsaWNUaGlzLCBrZXkpIHtcclxuICAgIGNvbnN0IGdldHRlciA9IGtleS5pbmNsdWRlcygnLicpXHJcbiAgICAgICAgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIGtleSlcclxuICAgICAgICA6ICgpID0+IHB1YmxpY1RoaXNba2V5XTtcclxuICAgIGlmIChpc1N0cmluZyhyYXcpKSB7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGN0eFtyYXddO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uJDEoaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXd9XCJgLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uJDEocmF3KSkge1xyXG4gICAgICAgIHdhdGNoKGdldHRlciwgcmF3LmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QkMShyYXcpKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgICAgICByYXcuZm9yRWFjaChyID0+IGNyZWF0ZVdhdGNoZXIociwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBpc0Z1bmN0aW9uJDEocmF3LmhhbmRsZXIpXHJcbiAgICAgICAgICAgICAgICA/IHJhdy5oYW5kbGVyLmJpbmQocHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgIDogY3R4W3Jhdy5oYW5kbGVyXTtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24kMShoYW5kbGVyKSkge1xyXG4gICAgICAgICAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyLCByYXcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhdy5oYW5kbGVyfVwiYCwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIG9wdGlvbjogXCIke2tleX1cImAsIHJhdyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlc29sdmUgbWVyZ2VkIG9wdGlvbnMgYW5kIGNhY2hlIGl0IG9uIHRoZSBjb21wb25lbnQuXHJcbiAqIFRoaXMgaXMgZG9uZSBvbmx5IG9uY2UgcGVyLWNvbXBvbmVudCBzaW5jZSB0aGUgbWVyZ2luZyBkb2VzIG5vdCBpbnZvbHZlXHJcbiAqIGluc3RhbmNlcy5cclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCBiYXNlID0gaW5zdGFuY2UudHlwZTtcclxuICAgIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gYmFzZTtcclxuICAgIGNvbnN0IHsgbWl4aW5zOiBnbG9iYWxNaXhpbnMsIG9wdGlvbnNDYWNoZTogY2FjaGUsIGNvbmZpZzogeyBvcHRpb25NZXJnZVN0cmF0ZWdpZXMgfSB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dDtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChiYXNlKTtcclxuICAgIGxldCByZXNvbHZlZDtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICByZXNvbHZlZCA9IGNhY2hlZDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFnbG9iYWxNaXhpbnMubGVuZ3RoICYmICFtaXhpbnMgJiYgIWV4dGVuZHNPcHRpb25zKSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXNvbHZlZCA9IGJhc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVzb2x2ZWQgPSB7fTtcclxuICAgICAgICBpZiAoZ2xvYmFsTWl4aW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBnbG9iYWxNaXhpbnMuZm9yRWFjaChtID0+IG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgbSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzLCB0cnVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgYmFzZSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzKTtcclxuICAgIH1cclxuICAgIGNhY2hlLnNldChiYXNlLCByZXNvbHZlZCk7XHJcbiAgICByZXR1cm4gcmVzb2x2ZWQ7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHRvLCBmcm9tLCBzdHJhdHMsIGFzTWl4aW4gPSBmYWxzZSkge1xyXG4gICAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBmcm9tO1xyXG4gICAgaWYgKGV4dGVuZHNPcHRpb25zKSB7XHJcbiAgICAgICAgbWVyZ2VPcHRpb25zKHRvLCBleHRlbmRzT3B0aW9ucywgc3RyYXRzLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGlmIChtaXhpbnMpIHtcclxuICAgICAgICBtaXhpbnMuZm9yRWFjaCgobSkgPT4gbWVyZ2VPcHRpb25zKHRvLCBtLCBzdHJhdHMsIHRydWUpKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcclxuICAgICAgICBpZiAoYXNNaXhpbiAmJiBrZXkgPT09ICdleHBvc2UnKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgXCJleHBvc2VcIiBvcHRpb24gaXMgaWdub3JlZCB3aGVuIGRlY2xhcmVkIGluIG1peGlucyBvciBleHRlbmRzLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgSXQgc2hvdWxkIG9ubHkgYmUgZGVjbGFyZWQgaW4gdGhlIGJhc2UgY29tcG9uZW50IGl0c2VsZi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cmF0ID0gaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0c1trZXldIHx8IChzdHJhdHMgJiYgc3RyYXRzW2tleV0pO1xyXG4gICAgICAgICAgICB0b1trZXldID0gc3RyYXQgPyBzdHJhdCh0b1trZXldLCBmcm9tW2tleV0pIDogZnJvbVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0bztcclxufVxyXG5jb25zdCBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzID0ge1xyXG4gICAgZGF0YTogbWVyZ2VEYXRhRm4sXHJcbiAgICBwcm9wczogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgZW1pdHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICAgIC8vIG9iamVjdHNcclxuICAgIG1ldGhvZHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICAgIGNvbXB1dGVkOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICAvLyBsaWZlY3ljbGVcclxuICAgIGJlZm9yZUNyZWF0ZTogbWVyZ2VBc0FycmF5LFxyXG4gICAgY3JlYXRlZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgYmVmb3JlTW91bnQ6IG1lcmdlQXNBcnJheSxcclxuICAgIG1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIGJlZm9yZVVwZGF0ZTogbWVyZ2VBc0FycmF5LFxyXG4gICAgdXBkYXRlZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgYmVmb3JlRGVzdHJveTogbWVyZ2VBc0FycmF5LFxyXG4gICAgZGVzdHJveWVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBhY3RpdmF0ZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIGRlYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBlcnJvckNhcHR1cmVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBzZXJ2ZXJQcmVmZXRjaDogbWVyZ2VBc0FycmF5LFxyXG4gICAgLy8gYXNzZXRzXHJcbiAgICBjb21wb25lbnRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICBkaXJlY3RpdmVzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICAvLyB3YXRjaFxyXG4gICAgd2F0Y2g6IG1lcmdlV2F0Y2hPcHRpb25zLFxyXG4gICAgLy8gcHJvdmlkZSAvIGluamVjdFxyXG4gICAgcHJvdmlkZTogbWVyZ2VEYXRhRm4sXHJcbiAgICBpbmplY3Q6IG1lcmdlSW5qZWN0XHJcbn07XHJcbmZ1bmN0aW9uIG1lcmdlRGF0YUZuKHRvLCBmcm9tKSB7XHJcbiAgICBpZiAoIWZyb20pIHtcclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICB9XHJcbiAgICBpZiAoIXRvKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb207XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xyXG4gICAgICAgIHJldHVybiAoZXh0ZW5kKShpc0Z1bmN0aW9uJDEodG8pID8gdG8uY2FsbCh0aGlzLCB0aGlzKSA6IHRvLCBpc0Z1bmN0aW9uJDEoZnJvbSkgPyBmcm9tLmNhbGwodGhpcywgdGhpcykgOiBmcm9tKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VJbmplY3QodG8sIGZyb20pIHtcclxuICAgIHJldHVybiBtZXJnZU9iamVjdE9wdGlvbnMobm9ybWFsaXplSW5qZWN0KHRvKSwgbm9ybWFsaXplSW5qZWN0KGZyb20pKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QocmF3KSB7XHJcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzW3Jhd1tpXV0gPSByYXdbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmF3O1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlQXNBcnJheSh0bywgZnJvbSkge1xyXG4gICAgcmV0dXJuIHRvID8gWy4uLm5ldyBTZXQoW10uY29uY2F0KHRvLCBmcm9tKSldIDogZnJvbTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZU9iamVjdE9wdGlvbnModG8sIGZyb20pIHtcclxuICAgIHJldHVybiB0byA/IGV4dGVuZChleHRlbmQoT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8pLCBmcm9tKSA6IGZyb207XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VXYXRjaE9wdGlvbnModG8sIGZyb20pIHtcclxuICAgIGlmICghdG8pXHJcbiAgICAgICAgcmV0dXJuIGZyb207XHJcbiAgICBpZiAoIWZyb20pXHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgY29uc3QgbWVyZ2VkID0gZXh0ZW5kKE9iamVjdC5jcmVhdGUobnVsbCksIHRvKTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcclxuICAgICAgICBtZXJnZWRba2V5XSA9IG1lcmdlQXNBcnJheSh0b1trZXldLCBmcm9tW2tleV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lcmdlZDtcclxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBpc1N0YXRlZnVsLCAvLyByZXN1bHQgb2YgYml0d2lzZSBmbGFnIGNvbXBhcmlzb25cclxuaXNTU1IgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgcHJvcHMgPSB7fTtcclxuICAgIGNvbnN0IGF0dHJzID0ge307XHJcbiAgICBkZWYoYXR0cnMsIEludGVybmFsT2JqZWN0S2V5LCAxKTtcclxuICAgIGluc3RhbmNlLnByb3BzRGVmYXVsdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcclxuICAgIC8vIGVuc3VyZSBhbGwgZGVjbGFyZWQgcHJvcCBrZXlzIGFyZSBwcmVzZW50XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gcHJvcHMpKSB7XHJcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gdmFsaWRhdGlvblxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTdGF0ZWZ1bCkge1xyXG4gICAgICAgIC8vIHN0YXRlZnVsXHJcbiAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBpc1NTUiA/IHByb3BzIDogc2hhbGxvd1JlYWN0aXZlKHByb3BzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UudHlwZS5wcm9wcykge1xyXG4gICAgICAgICAgICAvLyBmdW5jdGlvbmFsIHcvIG9wdGlvbmFsIHByb3BzLCBwcm9wcyA9PT0gYXR0cnNcclxuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBhdHRycztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWwgdy8gZGVjbGFyZWQgcHJvcHNcclxuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbnN0YW5jZS5hdHRycyA9IGF0dHJzO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcmF3UHJldlByb3BzLCBvcHRpbWl6ZWQpIHtcclxuICAgIGNvbnN0IHsgcHJvcHMsIGF0dHJzLCB2bm9kZTogeyBwYXRjaEZsYWcgfSB9ID0gaW5zdGFuY2U7XHJcbiAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICBjb25zdCBbb3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICBpZiAoXHJcbiAgICAvLyBhbHdheXMgZm9yY2UgZnVsbCBkaWZmIGluIGRldlxyXG4gICAgLy8gLSAjMTk0MiBpZiBobXIgaXMgZW5hYmxlZCB3aXRoIHNmYyBjb21wb25lbnRcclxuICAgIC8vIC0gdml0ZSM4NzIgbm9uLXNmYyBjb21wb25lbnQgdXNlZCBieSBzZmMgY29tcG9uZW50XHJcbiAgICAhKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgIChpbnN0YW5jZS50eXBlLl9faG1ySWQgfHxcclxuICAgICAgICAgICAgKGluc3RhbmNlLnBhcmVudCAmJiBpbnN0YW5jZS5wYXJlbnQudHlwZS5fX2htcklkKSkpICYmXHJcbiAgICAgICAgKG9wdGltaXplZCB8fCBwYXRjaEZsYWcgPiAwKSAmJlxyXG4gICAgICAgICEocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykpIHtcclxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgOCAvKiBQUk9QUyAqLykge1xyXG4gICAgICAgICAgICAvLyBDb21waWxlci1nZW5lcmF0ZWQgcHJvcHMgJiBubyBrZXlzIGNoYW5nZSwganVzdCBzZXQgdGhlIHVwZGF0ZWRcclxuICAgICAgICAgICAgLy8gdGhlIHByb3BzLlxyXG4gICAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gaW5zdGFuY2Uudm5vZGUuZHluYW1pY1Byb3BzO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBrZXkgPSBwcm9wc1RvVXBkYXRlW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gUFJPUFMgZmxhZyBndWFyYW50ZWVzIHJhd1Byb3BzIHRvIGJlIG5vbi1udWxsXHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dHIgLyBwcm9wcyBzZXBhcmF0aW9uIHdhcyBkb25lIG9uIGluaXQgYW5kIHdpbGwgYmUgY29uc2lzdGVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgY29kZSBwYXRoLCBzbyBqdXN0IGNoZWNrIGlmIGF0dHJzIGhhdmUgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093bihhdHRycywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW2NhbWVsaXplZEtleV0gPSByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHJhd0N1cnJlbnRQcm9wcywgY2FtZWxpemVkS2V5LCB2YWx1ZSwgaW5zdGFuY2UsIGZhbHNlIC8qIGlzQWJzZW50ICovKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGZ1bGwgcHJvcHMgdXBkYXRlLlxyXG4gICAgICAgIGlmIChzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpKSB7XHJcbiAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluIGNhc2Ugb2YgZHluYW1pYyBwcm9wcywgY2hlY2sgaWYgd2UgbmVlZCB0byBkZWxldGUga2V5cyBmcm9tXHJcbiAgICAgICAgLy8gdGhlIHByb3BzIG9iamVjdFxyXG4gICAgICAgIGxldCBrZWJhYktleTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdDdXJyZW50UHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKCFyYXdQcm9wcyB8fFxyXG4gICAgICAgICAgICAgICAgLy8gZm9yIGNhbWVsQ2FzZVxyXG4gICAgICAgICAgICAgICAgKCFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoZSBvcmlnaW5hbCBwcm9wcyB3YXMgcGFzc2VkIGluIGFzIGtlYmFiLWNhc2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgY29udmVydGVkIHRvIGNhbWVsQ2FzZSAoIzk1NSlcclxuICAgICAgICAgICAgICAgICAgICAoKGtlYmFiS2V5ID0gaHlwaGVuYXRlKGtleSkpID09PSBrZXkgfHwgIWhhc093bihyYXdQcm9wcywga2ViYWJLZXkpKSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhd1ByZXZQcm9wcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgY2FtZWxDYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChyYXdQcmV2UHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3Iga2ViYWItY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3UHJldlByb3BzW2tlYmFiS2V5XSAhPT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCByYXdDdXJyZW50UHJvcHMsIGtleSwgdW5kZWZpbmVkLCBpbnN0YW5jZSwgdHJ1ZSAvKiBpc0Fic2VudCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgZnVuY3Rpb25hbCBjb21wb25lbnQgdy9vIHByb3BzIGRlY2xhcmF0aW9uLCBwcm9wcyBhbmRcclxuICAgICAgICAvLyBhdHRycyBwb2ludCB0byB0aGUgc2FtZSBvYmplY3Qgc28gaXQgc2hvdWxkIGFscmVhZHkgaGF2ZSBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgICAgaWYgKGF0dHJzICE9PSByYXdDdXJyZW50UHJvcHMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcmF3UHJvcHMgfHwgIWhhc093bihyYXdQcm9wcywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB0cmlnZ2VyIHVwZGF0ZXMgZm9yICRhdHRycyBpbiBjYXNlIGl0J3MgdXNlZCBpbiBjb21wb25lbnQgc2xvdHNcclxuICAgIGlmIChoYXNBdHRyc0NoYW5nZWQpIHtcclxuICAgICAgICB0cmlnZ2VyKGluc3RhbmNlLCBcInNldFwiIC8qIFNFVCAqLywgJyRhdHRycycpO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSB7XHJcbiAgICBjb25zdCBbb3B0aW9ucywgbmVlZENhc3RLZXlzXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcclxuICAgIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgIGxldCByYXdDYXN0VmFsdWVzO1xyXG4gICAgaWYgKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIHJhd1Byb3BzKSB7XHJcbiAgICAgICAgICAgIC8vIGtleSwgcmVmIGFyZSByZXNlcnZlZCBhbmQgbmV2ZXIgcGFzc2VkIGRvd25cclxuICAgICAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgLy8gcHJvcCBvcHRpb24gbmFtZXMgYXJlIGNhbWVsaXplZCBkdXJpbmcgbm9ybWFsaXphdGlvbiwgc28gdG8gc3VwcG9ydFxyXG4gICAgICAgICAgICAvLyBrZWJhYiAtPiBjYW1lbCBjb252ZXJzaW9uIGhlcmUgd2UgbmVlZCB0byBjYW1lbGl6ZSB0aGUga2V5LlxyXG4gICAgICAgICAgICBsZXQgY2FtZWxLZXk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCAoY2FtZWxLZXkgPSBjYW1lbGl6ZShrZXkpKSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbmVlZENhc3RLZXlzIHx8ICFuZWVkQ2FzdEtleXMuaW5jbHVkZXMoY2FtZWxLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbY2FtZWxLZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAocmF3Q2FzdFZhbHVlcyB8fCAocmF3Q2FzdFZhbHVlcyA9IHt9KSlbY2FtZWxLZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobmVlZENhc3RLZXlzKSB7XHJcbiAgICAgICAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgICAgIGNvbnN0IGNhc3RWYWx1ZXMgPSByYXdDYXN0VmFsdWVzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRDYXN0S2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBuZWVkQ2FzdEtleXNbaV07XHJcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHJhd0N1cnJlbnRQcm9wcywga2V5LCBjYXN0VmFsdWVzW2tleV0sIGluc3RhbmNlLCAhaGFzT3duKGNhc3RWYWx1ZXMsIGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBoYXNBdHRyc0NoYW5nZWQ7XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCBwcm9wcywga2V5LCB2YWx1ZSwgaW5zdGFuY2UsIGlzQWJzZW50KSB7XHJcbiAgICBjb25zdCBvcHQgPSBvcHRpb25zW2tleV07XHJcbiAgICBpZiAob3B0ICE9IG51bGwpIHtcclxuICAgICAgICBjb25zdCBoYXNEZWZhdWx0ID0gaGFzT3duKG9wdCwgJ2RlZmF1bHQnKTtcclxuICAgICAgICAvLyBkZWZhdWx0IHZhbHVlc1xyXG4gICAgICAgIGlmIChoYXNEZWZhdWx0ICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0LmRlZmF1bHQ7XHJcbiAgICAgICAgICAgIGlmIChvcHQudHlwZSAhPT0gRnVuY3Rpb24gJiYgaXNGdW5jdGlvbiQxKGRlZmF1bHRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvcHNEZWZhdWx0cyB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIHByb3BzRGVmYXVsdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV0gPSBkZWZhdWx0VmFsdWUuY2FsbChudWxsLCBwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYm9vbGVhbiBjYXN0aW5nXHJcbiAgICAgICAgaWYgKG9wdFswIC8qIHNob3VsZENhc3QgKi9dKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0Fic2VudCAmJiAhaGFzRGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gJiZcclxuICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGNhY2hlID0gYXBwQ29udGV4dC5wcm9wc0NhY2hlO1xyXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCByYXcgPSBjb21wLnByb3BzO1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xyXG4gICAgY29uc3QgbmVlZENhc3RLZXlzID0gW107XHJcbiAgICAvLyBhcHBseSBtaXhpbi9leHRlbmRzIHByb3BzXHJcbiAgICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xyXG4gICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24kMShjb21wKSkge1xyXG4gICAgICAgIGNvbnN0IGV4dGVuZFByb3BzID0gKHJhdykgPT4ge1xyXG4gICAgICAgICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgW3Byb3BzLCBrZXlzXSA9IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhyYXcsIGFwcENvbnRleHQsIHRydWUpO1xyXG4gICAgICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgcHJvcHMpO1xyXG4gICAgICAgICAgICBpZiAoa2V5cylcclxuICAgICAgICAgICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKC4uLmtleXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZFByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAuZXh0ZW5kcykge1xyXG4gICAgICAgICAgICBleHRlbmRQcm9wcyhjb21wLmV4dGVuZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5taXhpbnMpIHtcclxuICAgICAgICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcclxuICAgICAgICBjYWNoZS5zZXQoY29tcCwgRU1QVFlfQVJSKTtcclxuICAgICAgICByZXR1cm4gRU1QVFlfQVJSO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzU3RyaW5nKHJhd1tpXSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYHByb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC5gLCByYXdbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShyYXdbaV0pO1xyXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9IEVNUFRZX09CSjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJhdykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzT2JqZWN0JDEocmF3KSkge1xyXG4gICAgICAgICAgICB3YXJuKGBpbnZhbGlkIHByb3BzIG9wdGlvbnNgLCByYXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByYXcpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSByYXdba2V5XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSAobm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24kMShvcHQpID8geyB0eXBlOiBvcHQgfSA6IG9wdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wWzAgLyogc2hvdWxkQ2FzdCAqL10gPSBib29sZWFuSW5kZXggPiAtMTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wWzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcm9wIG5lZWRzIGJvb2xlYW4gY2FzdGluZyBvciBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvb2xlYW5JbmRleCA+IC0xIHx8IGhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKG5vcm1hbGl6ZWRLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHJlcyA9IFtub3JtYWxpemVkLCBuZWVkQ2FzdEtleXNdO1xyXG4gICAgY2FjaGUuc2V0KGNvbXAsIHJlcyk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcE5hbWUoa2V5KSB7XHJcbiAgICBpZiAoa2V5WzBdICE9PSAnJCcpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYEludmFsaWQgcHJvcCBuYW1lOiBcIiR7a2V5fVwiIGlzIGEgcmVzZXJ2ZWQgcHJvcGVydHkuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLy8gdXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIHR5cGUgY29uc3RydWN0b3JzXHJcbi8vIHNvIHRoYXQgaXQgd29ya3MgYWNyb3NzIHZtcyAvIGlmcmFtZXMuXHJcbmZ1bmN0aW9uIGdldFR5cGUoY3Rvcikge1xyXG4gICAgY29uc3QgbWF0Y2ggPSBjdG9yICYmIGN0b3IudG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcclxuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lVHlwZShhLCBiKSB7XHJcbiAgICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXgodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xyXG4gICAgaWYgKGlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcclxuICAgICAgICByZXR1cm4gZXhwZWN0ZWRUeXBlcy5maW5kSW5kZXgodCA9PiBpc1NhbWVUeXBlKHQsIHR5cGUpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24kMShleHBlY3RlZFR5cGVzKSkge1xyXG4gICAgICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhyYXdQcm9wcywgcHJvcHMsIGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCByZXNvbHZlZFZhbHVlcyA9IHRvUmF3KHByb3BzKTtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF07XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IG9wdCA9IG9wdGlvbnNba2V5XTtcclxuICAgICAgICBpZiAob3B0ID09IG51bGwpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIHZhbGlkYXRlUHJvcChrZXksIHJlc29sdmVkVmFsdWVzW2tleV0sIG9wdCwgIWhhc093bihyYXdQcm9wcywga2V5KSAmJiAhaGFzT3duKHJhd1Byb3BzLCBoeXBoZW5hdGUoa2V5KSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKG5hbWUsIHZhbHVlLCBwcm9wLCBpc0Fic2VudCkge1xyXG4gICAgY29uc3QgeyB0eXBlLCByZXF1aXJlZCwgdmFsaWRhdG9yIH0gPSBwcm9wO1xyXG4gICAgLy8gcmVxdWlyZWQhXHJcbiAgICBpZiAocmVxdWlyZWQgJiYgaXNBYnNlbnQpIHtcclxuICAgICAgICB3YXJuKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBtaXNzaW5nIGJ1dCBvcHRpb25hbFxyXG4gICAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyB0eXBlIGNoZWNrXHJcbiAgICBpZiAodHlwZSAhPSBudWxsICYmIHR5cGUgIT09IHRydWUpIHtcclxuICAgICAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHR5cGVzID0gaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xyXG4gICAgICAgIC8vIHZhbHVlIGlzIHZhbGlkIGFzIGxvbmcgYXMgb25lIG9mIHRoZSBzcGVjaWZpZWQgdHlwZXMgbWF0Y2hcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aCAmJiAhaXNWYWxpZDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsaWQsIGV4cGVjdGVkVHlwZSB9ID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZXNbaV0pO1xyXG4gICAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goZXhwZWN0ZWRUeXBlIHx8ICcnKTtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbGlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgd2FybihnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGN1c3RvbSB2YWxpZGF0b3JcclxuICAgIGlmICh2YWxpZGF0b3IgJiYgIXZhbGlkYXRvcih2YWx1ZSkpIHtcclxuICAgICAgICB3YXJuKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaXNTaW1wbGVUeXBlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdTdHJpbmcsTnVtYmVyLEJvb2xlYW4sRnVuY3Rpb24sU3ltYm9sLEJpZ0ludCcpO1xyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcclxuICAgIGxldCB2YWxpZDtcclxuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XHJcbiAgICBpZiAoaXNTaW1wbGVUeXBlKGV4cGVjdGVkVHlwZSkpIHtcclxuICAgICAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xyXG4gICAgICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcclxuICAgICAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcclxuICAgICAgICB2YWxpZCA9IGlzT2JqZWN0JDEodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XHJcbiAgICAgICAgdmFsaWQgPSBpc0FycmF5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2YWxpZCxcclxuICAgICAgICBleHBlY3RlZFR5cGVcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcclxuICAgIGxldCBtZXNzYWdlID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke25hbWV9XCIuYCArXHJcbiAgICAgICAgYCBFeHBlY3RlZCAke2V4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJyl9YDtcclxuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XHJcbiAgICBjb25zdCByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xyXG4gICAgY29uc3QgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XHJcbiAgICBjb25zdCByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcclxuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxyXG4gICAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiZcclxuICAgICAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xyXG4gICAgICAgIG1lc3NhZ2UgKz0gYCB3aXRoIHZhbHVlICR7ZXhwZWN0ZWRWYWx1ZX1gO1xyXG4gICAgfVxyXG4gICAgbWVzc2FnZSArPSBgLCBnb3QgJHtyZWNlaXZlZFR5cGV9IGA7XHJcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcclxuICAgIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xyXG4gICAgICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtyZWNlaXZlZFZhbHVlfS5gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lc3NhZ2U7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBzdHlsZVZhbHVlKHZhbHVlLCB0eXBlKSB7XHJcbiAgICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gYFwiJHt2YWx1ZX1cImA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiBgJHtOdW1iZXIodmFsdWUpfWA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYCR7dmFsdWV9YDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSh0eXBlKSB7XHJcbiAgICBjb25zdCBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcclxuICAgIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoZWxlbSA9PiB0eXBlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW0pO1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gaXNCb29sZWFuKC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiBhcmdzLnNvbWUoZWxlbSA9PiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJyk7XHJcbn1cblxuY29uc3QgaXNJbnRlcm5hbEtleSA9IChrZXkpID0+IGtleVswXSA9PT0gJ18nIHx8IGtleSA9PT0gJyRzdGFibGUnO1xyXG5jb25zdCBub3JtYWxpemVTbG90VmFsdWUgPSAodmFsdWUpID0+IGlzQXJyYXkodmFsdWUpXHJcbiAgICA/IHZhbHVlLm1hcChub3JtYWxpemVWTm9kZSlcclxuICAgIDogW25vcm1hbGl6ZVZOb2RlKHZhbHVlKV07XHJcbmNvbnN0IG5vcm1hbGl6ZVNsb3QgPSAoa2V5LCByYXdTbG90LCBjdHgpID0+IHtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB3aXRoQ3R4KChwcm9wcykgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFNsb3QgXCIke2tleX1cIiBpbnZva2VkIG91dHNpZGUgb2YgdGhlIHJlbmRlciBmdW5jdGlvbjogYCArXHJcbiAgICAgICAgICAgICAgICBgdGhpcyB3aWxsIG5vdCB0cmFjayBkZXBlbmRlbmNpZXMgdXNlZCBpbiB0aGUgc2xvdC4gYCArXHJcbiAgICAgICAgICAgICAgICBgSW52b2tlIHRoZSBzbG90IGZ1bmN0aW9uIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub3JtYWxpemVTbG90VmFsdWUocmF3U2xvdChwcm9wcykpO1xyXG4gICAgfSwgY3R4KTtcclxuICAgIG5vcm1hbGl6ZWQuX2MgPSBmYWxzZTtcclxuICAgIHJldHVybiBub3JtYWxpemVkO1xyXG59O1xyXG5jb25zdCBub3JtYWxpemVPYmplY3RTbG90cyA9IChyYXdTbG90cywgc2xvdHMsIGluc3RhbmNlKSA9PiB7XHJcbiAgICBjb25zdCBjdHggPSByYXdTbG90cy5fY3R4O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3U2xvdHMpIHtcclxuICAgICAgICBpZiAoaXNJbnRlcm5hbEtleShrZXkpKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Nsb3RzW2tleV07XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24kMSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgc2xvdHNba2V5XSA9IG5vcm1hbGl6ZVNsb3Qoa2V5LCB2YWx1ZSwgY3R4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAhKGZhbHNlICkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3Igc2xvdCBcIiR7a2V5fVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHNsb3RzW2tleV0gPSAoKSA9PiBub3JtYWxpemVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgbm9ybWFsaXplVk5vZGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAhaXNLZWVwQWxpdmUoaW5zdGFuY2Uudm5vZGUpICYmXHJcbiAgICAgICAgIShmYWxzZSApKSB7XHJcbiAgICAgICAgd2FybihgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBkZWZhdWx0IHNsb3QuIGAgK1xyXG4gICAgICAgICAgICBgUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKGNoaWxkcmVuKTtcclxuICAgIGluc3RhbmNlLnNsb3RzLmRlZmF1bHQgPSAoKSA9PiBub3JtYWxpemVkO1xyXG59O1xyXG5jb25zdCBpbml0U2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XHJcbiAgICBpZiAoaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgMzIgLyogU0xPVFNfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcclxuICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICAvLyB1c2VycyBjYW4gZ2V0IHRoZSBzaGFsbG93IHJlYWRvbmx5IHZlcnNpb24gb2YgdGhlIHNsb3RzIG9iamVjdCB0aHJvdWdoIGB0aGlzLiRzbG90c2AsXHJcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCBhdm9pZCB0aGUgcHJveHkgb2JqZWN0IHBvbGx1dGluZyB0aGUgc2xvdHMgb2YgdGhlIGludGVybmFsIGluc3RhbmNlXHJcbiAgICAgICAgICAgIGluc3RhbmNlLnNsb3RzID0gdG9SYXcoY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAvLyBtYWtlIGNvbXBpbGVyIG1hcmtlciBub24tZW51bWVyYWJsZVxyXG4gICAgICAgICAgICBkZWYoY2hpbGRyZW4sICdfJywgdHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgKGluc3RhbmNlLnNsb3RzID0ge30pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpbnN0YW5jZS5zbG90cyA9IHt9O1xyXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgICAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVmKGluc3RhbmNlLnNsb3RzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XHJcbn07XHJcbmNvbnN0IHVwZGF0ZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICBjb25zdCB7IHZub2RlLCBzbG90cyB9ID0gaW5zdGFuY2U7XHJcbiAgICBsZXQgbmVlZERlbGV0aW9uQ2hlY2sgPSB0cnVlO1xyXG4gICAgbGV0IGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IEVNUFRZX09CSjtcclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAzMiAvKiBTTE9UU19DSElMRFJFTiAqLykge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xyXG4gICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbXBpbGVkIHNsb3RzLlxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBhcmVudCB3YXMgSE1SIHVwZGF0ZWQgc28gc2xvdCBjb250ZW50IG1heSBoYXZlIGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSB1cGRhdGUgc2xvdHMgYW5kIG1hcmsgaW5zdGFuY2UgZm9yIGhtciBhcyB3ZWxsXHJcbiAgICAgICAgICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSAvKiBTVEFCTEUgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVkIEFORCBzdGFibGUuXHJcbiAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIHVwZGF0ZSwgYW5kIHNraXAgc3RhbGUgc2xvdHMgcmVtb3ZhbC5cclxuICAgICAgICAgICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb21waWxlZCBidXQgZHluYW1pYyAodi1pZi92LWZvciBvbiBzbG90cykgLSB1cGRhdGUgc2xvdHMsIGJ1dCBza2lwXHJcbiAgICAgICAgICAgICAgICAvLyBub3JtYWxpemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKHNsb3RzLCBjaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAvLyAjMjg5M1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiByZW5kZXJpbmcgdGhlIG9wdGltaXplZCBzbG90cyBieSBtYW51YWxseSB3cml0dGVuIHJlbmRlciBmdW5jdGlvbixcclxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZGVsZXRlIHRoZSBgc2xvdHMuX2AgZmxhZyBpZiBuZWNlc3NhcnkgdG8gbWFrZSBzdWJzZXF1ZW50IHVwZGF0ZXMgcmVsaWFibGUsXHJcbiAgICAgICAgICAgICAgICAvLyBpLmUuIGxldCB0aGUgYHJlbmRlclNsb3RgIGNyZWF0ZSB0aGUgYmFpbGVkIEZyYWdtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGltaXplZCAmJiB0eXBlID09PSAxIC8qIFNUQUJMRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzbG90cy5fO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9ICFjaGlsZHJlbi4kc3RhYmxlO1xyXG4gICAgICAgICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBjaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgLy8gbm9uIHNsb3Qgb2JqZWN0IGNoaWxkcmVuIChkaXJlY3QgdmFsdWUpIHBhc3NlZCB0byBhIGNvbXBvbmVudFxyXG4gICAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcclxuICAgICAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSB7IGRlZmF1bHQ6IDEgfTtcclxuICAgIH1cclxuICAgIC8vIGRlbGV0ZSBzdGFsZSBzbG90c1xyXG4gICAgaWYgKG5lZWREZWxldGlvbkNoZWNrKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0ludGVybmFsS2V5KGtleSkgJiYgIShrZXkgaW4gZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHNsb3RzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XG5cbi8qKlxyXG5SdW50aW1lIGhlbHBlciBmb3IgYXBwbHlpbmcgZGlyZWN0aXZlcyB0byBhIHZub2RlLiBFeGFtcGxlIHVzYWdlOlxyXG5cbmNvbnN0IGNvbXAgPSByZXNvbHZlQ29tcG9uZW50KCdjb21wJylcclxuY29uc3QgZm9vID0gcmVzb2x2ZURpcmVjdGl2ZSgnZm9vJylcclxuY29uc3QgYmFyID0gcmVzb2x2ZURpcmVjdGl2ZSgnYmFyJylcclxuXG5yZXR1cm4gd2l0aERpcmVjdGl2ZXMoaChjb21wKSwgW1xyXG4gIFtmb28sIHRoaXMueF0sXHJcbiAgW2JhciwgdGhpcy55XVxyXG5dKVxyXG4qL1xyXG5jb25zdCBpc0J1aWx0SW5EaXJlY3RpdmUgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ2JpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0Jyk7XHJcbmZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKSB7XHJcbiAgICBpZiAoaXNCdWlsdEluRGlyZWN0aXZlKG5hbWUpKSB7XHJcbiAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBkaXJlY3RpdmUgaWRzIGFzIGN1c3RvbSBkaXJlY3RpdmUgaWQ6ICcgKyBuYW1lKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWRkcyBkaXJlY3RpdmVzIHRvIGEgVk5vZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoRGlyZWN0aXZlcyh2bm9kZSwgZGlyZWN0aXZlcykge1xyXG4gICAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlID09PSBudWxsKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHdpdGhEaXJlY3RpdmVzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHJlbmRlciBmdW5jdGlvbnMuYCk7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBpbnRlcm5hbEluc3RhbmNlLnByb3h5O1xyXG4gICAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzIHx8ICh2bm9kZS5kaXJzID0gW10pO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IFtkaXIsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyA9IEVNUFRZX09CSl0gPSBkaXJlY3RpdmVzW2ldO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uJDEoZGlyKSkge1xyXG4gICAgICAgICAgICBkaXIgPSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudGVkOiBkaXIsXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkOiBkaXJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmluZGluZ3MucHVzaCh7XHJcbiAgICAgICAgICAgIGRpcixcclxuICAgICAgICAgICAgaW5zdGFuY2UsXHJcbiAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICBvbGRWYWx1ZTogdm9pZCAwLFxyXG4gICAgICAgICAgICBhcmcsXHJcbiAgICAgICAgICAgIG1vZGlmaWVyc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIHByZXZWTm9kZSwgaW5zdGFuY2UsIG5hbWUpIHtcclxuICAgIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycztcclxuICAgIGNvbnN0IG9sZEJpbmRpbmdzID0gcHJldlZOb2RlICYmIHByZXZWTm9kZS5kaXJzO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcclxuICAgICAgICBpZiAob2xkQmluZGluZ3MpIHtcclxuICAgICAgICAgICAgYmluZGluZy5vbGRWYWx1ZSA9IG9sZEJpbmRpbmdzW2ldLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaG9vayA9IGJpbmRpbmcuZGlyW25hbWVdO1xyXG4gICAgICAgIGlmIChob29rKSB7XHJcbiAgICAgICAgICAgIC8vIGRpc2FibGUgdHJhY2tpbmcgaW5zaWRlIGFsbCBsaWZlY3ljbGUgaG9va3NcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBjYW4gcG90ZW50aWFsbHkgYmUgY2FsbGVkIGluc2lkZSBlZmZlY3RzLlxyXG4gICAgICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA4IC8qIERJUkVDVElWRV9IT09LICovLCBbXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5lbCxcclxuICAgICAgICAgICAgICAgIGJpbmRpbmcsXHJcbiAgICAgICAgICAgICAgICB2bm9kZSxcclxuICAgICAgICAgICAgICAgIHByZXZWTm9kZVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBjcmVhdGVBcHBDb250ZXh0KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhcHA6IG51bGwsXHJcbiAgICAgICAgY29uZmlnOiB7XHJcbiAgICAgICAgICAgIGlzTmF0aXZlVGFnOiBOTyxcclxuICAgICAgICAgICAgcGVyZm9ybWFuY2U6IGZhbHNlLFxyXG4gICAgICAgICAgICBnbG9iYWxQcm9wZXJ0aWVzOiB7fSxcclxuICAgICAgICAgICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiB7fSxcclxuICAgICAgICAgICAgZXJyb3JIYW5kbGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHdhcm5IYW5kbGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGNvbXBpbGVyT3B0aW9uczoge31cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1peGluczogW10sXHJcbiAgICAgICAgY29tcG9uZW50czoge30sXHJcbiAgICAgICAgZGlyZWN0aXZlczoge30sXHJcbiAgICAgICAgcHJvdmlkZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXHJcbiAgICAgICAgb3B0aW9uc0NhY2hlOiBuZXcgV2Vha01hcCgpLFxyXG4gICAgICAgIHByb3BzQ2FjaGU6IG5ldyBXZWFrTWFwKCksXHJcbiAgICAgICAgZW1pdHNDYWNoZTogbmV3IFdlYWtNYXAoKVxyXG4gICAgfTtcclxufVxyXG5sZXQgdWlkID0gMDtcclxuZnVuY3Rpb24gY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFwcChyb290Q29tcG9uZW50LCByb290UHJvcHMgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHJvb3RQcm9wcyAhPSBudWxsICYmICFpc09iamVjdCQxKHJvb3RQcm9wcykpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHJvb3QgcHJvcHMgcGFzc2VkIHRvIGFwcC5tb3VudCgpIG11c3QgYmUgYW4gb2JqZWN0LmApO1xyXG4gICAgICAgICAgICByb290UHJvcHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xyXG4gICAgICAgIGNvbnN0IGluc3RhbGxlZFBsdWdpbnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IChjb250ZXh0LmFwcCA9IHtcclxuICAgICAgICAgICAgX3VpZDogdWlkKyssXHJcbiAgICAgICAgICAgIF9jb21wb25lbnQ6IHJvb3RDb21wb25lbnQsXHJcbiAgICAgICAgICAgIF9wcm9wczogcm9vdFByb3BzLFxyXG4gICAgICAgICAgICBfY29udGFpbmVyOiBudWxsLFxyXG4gICAgICAgICAgICBfY29udGV4dDogY29udGV4dCxcclxuICAgICAgICAgICAgX2luc3RhbmNlOiBudWxsLFxyXG4gICAgICAgICAgICB2ZXJzaW9uLFxyXG4gICAgICAgICAgICBnZXQgY29uZmlnKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uZmlnO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQgY29uZmlnKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBhcHAuY29uZmlnIGNhbm5vdCBiZSByZXBsYWNlZC4gTW9kaWZ5IGluZGl2aWR1YWwgb3B0aW9ucyBpbnN0ZWFkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1c2UocGx1Z2luLCAuLi5vcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5oYXMocGx1Z2luKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBQbHVnaW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHAuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwbHVnaW4gJiYgaXNGdW5jdGlvbiQxKHBsdWdpbi5pbnN0YWxsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmluc3RhbGwoYXBwLCAuLi5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24kMShwbHVnaW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4oYXBwLCAuLi5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEEgcGx1Z2luIG11c3QgZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IHdpdGggYW4gXCJpbnN0YWxsXCIgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBmdW5jdGlvbi5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1peGluKG1peGluKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5taXhpbnMuaW5jbHVkZXMobWl4aW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubWl4aW5zLnB1c2gobWl4aW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignTWl4aW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtaXhpbi5uYW1lID8gYDogJHttaXhpbi5uYW1lfWAgOiAnJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ01peGlucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYnVpbGRzIHN1cHBvcnRpbmcgT3B0aW9ucyBBUEknKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbXBvbmVudChuYW1lLCBjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29udGV4dC5jb25maWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wb25lbnRzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0gPSBjb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkaXJlY3RpdmUobmFtZSwgZGlyZWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFkaXJlY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXJlY3RpdmVzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBEaXJlY3RpdmUgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0gPSBkaXJlY3RpdmU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtb3VudChyb290Q29udGFpbmVyLCBpc0h5ZHJhdGUsIGlzU1ZHKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUocm9vdENvbXBvbmVudCwgcm9vdFByb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBhcHAgY29udGV4dCBvbiB0aGUgcm9vdCBWTm9kZS5cclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgYmUgc2V0IG9uIHRoZSByb290IGluc3RhbmNlIG9uIGluaXRpYWwgbW91bnQuXHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUuYXBwQ29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSE1SIHJvb3QgcmVsb2FkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcihjbG9uZVZOb2RlKHZub2RlKSwgcm9vdENvbnRhaW5lciwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIeWRyYXRlICYmIGh5ZHJhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZSh2bm9kZSwgcm9vdENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXIodm5vZGUsIHJvb3RDb250YWluZXIsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaXNNb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhcHAuX2NvbnRhaW5lciA9IHJvb3RDb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXyA9IGFwcDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZub2RlLmNvbXBvbmVudC5wcm94eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEFwcCBoYXMgYWxyZWFkeSBiZWVuIG1vdW50ZWQuXFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB5b3Ugd2FudCB0byByZW1vdW50IHRoZSBzYW1lIGFwcCwgbW92ZSB5b3VyIGFwcCBjcmVhdGlvbiBsb2dpYyBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGludG8gYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBjcmVhdGUgZnJlc2ggYXBwIGluc3RhbmNlcyBmb3IgZWFjaCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYG1vdW50IC0gZS5nLiBcXGBjb25zdCBjcmVhdGVNeUFwcCA9ICgpID0+IGNyZWF0ZUFwcChBcHApXFxgYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVubW91bnQoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyKG51bGwsIGFwcC5fY29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNVbm1vdW50QXBwKGFwcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhcHAuX2NvbnRhaW5lci5fX3Z1ZV9hcHBfXztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENhbm5vdCB1bm1vdW50IGFuIGFwcCB0aGF0IGlzIG5vdCBtb3VudGVkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcm92aWRlKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5IGluIGNvbnRleHQucHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBcHAgYWxyZWFkeSBwcm92aWRlcyBwcm9wZXJ0eSB3aXRoIGtleSBcIiR7U3RyaW5nKGtleSl9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgSXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIHRoZSBuZXcgdmFsdWUuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3QgYWxsb3cgc3ltYm9scyBhcyBpbmRleCB0eXBlXHJcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzI0NTg3XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgfTtcclxufVxuXG5sZXQgaGFzTWlzbWF0Y2ggPSBmYWxzZTtcclxuY29uc3QgaXNTVkdDb250YWluZXIgPSAoY29udGFpbmVyKSA9PiAvc3ZnLy50ZXN0KGNvbnRhaW5lci5uYW1lc3BhY2VVUkkpICYmIGNvbnRhaW5lci50YWdOYW1lICE9PSAnZm9yZWlnbk9iamVjdCc7XHJcbmNvbnN0IGlzQ29tbWVudCA9IChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4IC8qIENPTU1FTlQgKi87XHJcbi8vIE5vdGU6IGh5ZHJhdGlvbiBpcyBET00tc3BlY2lmaWNcclxuLy8gQnV0IHdlIGhhdmUgdG8gcGxhY2UgaXQgaW4gY29yZSBkdWUgdG8gdGlnaHQgY291cGxpbmcgd2l0aCBjb3JlIC0gc3BsaXR0aW5nXHJcbi8vIGl0IG91dCBjcmVhdGVzIGEgdG9uIG9mIHVubmVjZXNzYXJ5IGNvbXBsZXhpdHkuXHJcbi8vIEh5ZHJhdGlvbiBhbHNvIGRlcGVuZHMgb24gc29tZSByZW5kZXJlciBpbnRlcm5hbCBsb2dpYyB3aGljaCBuZWVkcyB0byBiZVxyXG4vLyBwYXNzZWQgaW4gdmlhIGFyZ3VtZW50cy5cclxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKHJlbmRlcmVySW50ZXJuYWxzKSB7XHJcbiAgICBjb25zdCB7IG10OiBtb3VudENvbXBvbmVudCwgcDogcGF0Y2gsIG86IHsgcGF0Y2hQcm9wLCBuZXh0U2libGluZywgcGFyZW50Tm9kZSwgcmVtb3ZlLCBpbnNlcnQsIGNyZWF0ZUNvbW1lbnQgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgICBjb25zdCBoeWRyYXRlID0gKHZub2RlLCBjb250YWluZXIpID0+IHtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIGh5ZHJhdGUgZXhpc3RpbmcgbWFya3VwIGJ1dCBjb250YWluZXIgaXMgZW1wdHkuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBQZXJmb3JtaW5nIGZ1bGwgbW91bnQgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaGFzTWlzbWF0Y2ggPSBmYWxzZTtcclxuICAgICAgICBoeWRyYXRlTm9kZShjb250YWluZXIuZmlyc3RDaGlsZCwgdm5vZGUsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XHJcbiAgICAgICAgaWYgKGhhc01pc21hdGNoICYmICFmYWxzZSkge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGVycm9yIHNob3VsZCBzaG93IHVwIGluIHByb2R1Y3Rpb25cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSHlkcmF0aW9uIGNvbXBsZXRlZCBidXQgY29udGFpbnMgbWlzbWF0Y2hlcy5gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaHlkcmF0ZU5vZGUgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCBpc0ZyYWdtZW50U3RhcnQgPSBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSAnWyc7XHJcbiAgICAgICAgY29uc3Qgb25NaXNtYXRjaCA9ICgpID0+IGhhbmRsZU1pc21hdGNoKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnRTdGFydCk7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gdm5vZGU7XHJcbiAgICAgICAgY29uc3QgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XHJcbiAgICAgICAgdm5vZGUuZWwgPSBub2RlO1xyXG4gICAgICAgIGxldCBuZXh0Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgVGV4dDpcclxuICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSAzIC8qIFRFWFQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmRhdGEgIT09IHZub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gdGV4dCBtaXNtYXRjaDpgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXFxuLSBDbGllbnQ6ICR7SlNPTi5zdHJpbmdpZnkobm9kZS5kYXRhKX1gICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXFxuLSBTZXJ2ZXI6ICR7SlNPTi5zdHJpbmdpZnkodm5vZGUuY2hpbGRyZW4pfWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIENvbW1lbnQkMTpcclxuICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4IC8qIENPTU1FTlQgKi8gfHwgaXNGcmFnbWVudFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGljOlxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGFuY2hvciwgYWRvcHQgY29udGVudFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3RhdGljIHZub2RlIGhhcyBpdHMgY29udGVudCBzdHJpcHBlZCBkdXJpbmcgYnVpbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRvcHQgaXQgZnJvbSB0aGUgc2VydmVyLXJlbmRlcmVkIEhUTUwuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZFRvQWRvcHRDb250ZW50ID0gIXZub2RlLmNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLnN0YXRpY0NvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRUb0Fkb3B0Q29udGVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuICs9IG5leHROb2RlLm91dGVySFRNTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHZub2RlLnN0YXRpY0NvdW50IC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhuZXh0Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Tm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEZyYWdtZW50OlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUZyYWdtZW50KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLnR5cGUudG9Mb3dlckNhc2UoKSAhPT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRWxlbWVudChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBzZXR0aW5nIHVwIHRoZSByZW5kZXIgZWZmZWN0LCBpZiB0aGUgaW5pdGlhbCB2bm9kZSBhbHJlYWR5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIC5lbCBzZXQsIHRoZSBjb21wb25lbnQgd2lsbCBwZXJmb3JtIGh5ZHJhdGlvbiBpbnN0ZWFkIG9mIG1vdW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gaXRzIHN1Yi10cmVlLlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50Q29tcG9uZW50KHZub2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBiZSBhc3luYywgc28gaW4gdGhlIGNhc2Ugb2YgZnJhZ21lbnRzIHdlIGNhbm5vdCByZWx5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gY29tcG9uZW50J3MgcmVuZGVyZWQgb3V0cHV0IHRvIGRldGVybWluZSB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluc3RlYWQsIHdlIGRvIGEgbG9va2FoZWFkIHRvIGZpbmQgdGhlIGVuZCBhbmNob3Igbm9kZS5cclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGlzRnJhZ21lbnRTdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvcihub2RlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICMzNzg3XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgY29tcG9uZW50IGlzIGFzeW5jLCBpdCBtYXkgZ2V0IG1vdmVkIC8gdW5tb3VudGVkIGJlZm9yZSBpdHNcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbm5lciBjb21wb25lbnQgaXMgbG9hZGVkLCBzbyB3ZSBuZWVkIHRvIGdpdmUgaXQgYSBwbGFjZWhvbGRlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZub2RlIHRoYXQgbWF0Y2hlcyBpdHMgYWRvcHRlZCBET00uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3ViVHJlZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKEZyYWdtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUuYW5jaG9yID0gbmV4dE5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5leHROb2RlLnByZXZpb3VzU2libGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29udGFpbmVyLmxhc3RDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDMgPyBjcmVhdGVUZXh0Vk5vZGUoJycpIDogY3JlYXRlVk5vZGUoJ2RpdicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUuZWwgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5jb21wb25lbnQuc3ViVHJlZSA9IHN1YlRyZWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCAvKiBDT01NRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZUNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIocGFyZW50Tm9kZShub2RlKSksIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBIb3N0Vk5vZGUgdHlwZTonLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVmICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5leHROb2RlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVFbGVtZW50ID0gKGVsLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISF2bm9kZS5keW5hbWljQ2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcGF0Y2hGbGFnLCBzaGFwZUZsYWcsIGRpcnMgfSA9IHZub2RlO1xyXG4gICAgICAgIC8vICM0MDA2IGZvciBmb3JtIGVsZW1lbnRzIHdpdGggbm9uLXN0cmluZyB2LW1vZGVsIHZhbHVlIGJpbmRpbmdzXHJcbiAgICAgICAgLy8gZS5nLiA8b3B0aW9uIDp2YWx1ZT1cIm9ialwiPiwgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIDp0cnVlLXZhbHVlPVwiMVwiPlxyXG4gICAgICAgIGNvbnN0IGZvcmNlUGF0Y2hWYWx1ZSA9ICh0eXBlID09PSAnaW5wdXQnICYmIGRpcnMpIHx8IHR5cGUgPT09ICdvcHRpb24nO1xyXG4gICAgICAgIC8vIHNraXAgcHJvcHMgJiBjaGlsZHJlbiBpZiB0aGlzIGlzIGhvaXN0ZWQgc3RhdGljIG5vZGVzXHJcbiAgICAgICAgaWYgKGZvcmNlUGF0Y2hWYWx1ZSB8fCBwYXRjaEZsYWcgIT09IC0xIC8qIEhPSVNURUQgKi8pIHtcclxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2NyZWF0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmb3JjZVBhdGNoVmFsdWUgfHxcclxuICAgICAgICAgICAgICAgICAgICAhb3B0aW1pemVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHBhdGNoRmxhZyAmIDE2IC8qIEZVTExfUFJPUFMgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnICYgMzIgLyogSFlEUkFURV9FVkVOVFMgKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChmb3JjZVBhdGNoVmFsdWUgJiYga2V5LmVuZHNXaXRoKCd2YWx1ZScpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlzT24oa2V5KSAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLm9uQ2xpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGNsaWNrIGxpc3RlbmVycyAod2hpY2ggaXMgbW9zdCBvZnRlbikgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpbmcgdGhyb3VnaCBwcm9wcy5cclxuICAgICAgICAgICAgICAgICAgICBwYXRjaFByb3AoZWwsICdvbkNsaWNrJywgbnVsbCwgcHJvcHMub25DbGljayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdm5vZGUgLyBkaXJlY3RpdmUgaG9va3NcclxuICAgICAgICAgICAgbGV0IHZub2RlSG9va3M7XHJcbiAgICAgICAgICAgIGlmICgodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlTW91bnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgZGlycykge1xyXG4gICAgICAgICAgICAgICAgcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlSG9va3MgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnbW91bnRlZCcpO1xyXG4gICAgICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiBlbGVtZW50IGhhcyBpbm5lckhUTUwgLyB0ZXh0Q29udGVudFxyXG4gICAgICAgICAgICAgICAgIShwcm9wcyAmJiAocHJvcHMuaW5uZXJIVE1MIHx8IHByb3BzLnRleHRDb250ZW50KSkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKGVsLmZpcnN0Q2hpbGQsIHZub2RlLCBlbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaGFzV2FybmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBpbiA8JHt2bm9kZS50eXBlfT46IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYHNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIG1vcmUgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIFNTUmVkIERPTSBjb250YWlucyBtb3JlIG5vZGVzIHRoYW4gaXQgc2hvdWxkLiBSZW1vdmUgdGhlbS5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXIgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShjdXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLnRleHRDb250ZW50ICE9PSB2bm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIHRleHQgY29udGVudCBtaXNtYXRjaCBpbiA8JHt2bm9kZS50eXBlfT46XFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLSBDbGllbnQ6ICR7ZWwudGV4dENvbnRlbnR9XFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLSBTZXJ2ZXI6ICR7dm5vZGUuY2hpbGRyZW59YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWwubmV4dFNpYmxpbmc7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaHlkcmF0ZUNoaWxkcmVuID0gKG5vZGUsIHBhcmVudFZOb2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhcGFyZW50Vk5vZGUuZHluYW1pY0NoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50Vk5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2hpbGRyZW5baV1cclxuICAgICAgICAgICAgICAgIDogKGNoaWxkcmVuW2ldID0gbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBoeWRyYXRlTm9kZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IFRleHQgJiYgIXZub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBpbiA8JHtjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpfT46IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgc2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgZmV3ZXIgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIFNTUmVkIERPTSBkaWRuJ3QgY29udGFpbiBlbm91Z2ggbm9kZXMuIE1vdW50IHRoZSBtaXNzaW5nIG9uZXMuXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVGcmFnbWVudCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCB7IHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xyXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHNcclxuICAgICAgICAgICAgICAgID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcylcclxuICAgICAgICAgICAgICAgIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XHJcbiAgICAgICAgY29uc3QgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihuZXh0U2libGluZyhub2RlKSwgdm5vZGUsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIGlmIChuZXh0ICYmIGlzQ29tbWVudChuZXh0KSAmJiBuZXh0LmRhdGEgPT09ICddJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciA9IG5leHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZyYWdtZW50IGRpZG4ndCBoeWRyYXRlIHN1Y2Nlc3NmdWxseSwgc2luY2Ugd2UgZGlkbid0IGdldCBhIGVuZCBhbmNob3JcclxuICAgICAgICAgICAgLy8gYmFjay4gVGhpcyBzaG91bGQgaGF2ZSBsZWQgdG8gbm9kZS9jaGlsZHJlbiBtaXNtYXRjaCB3YXJuaW5ncy5cclxuICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgYW5jaG9yIGlzIG1pc3NpbmcsIHdlIG5lZWQgdG8gY3JlYXRlIG9uZSBhbmQgaW5zZXJ0IGl0XHJcbiAgICAgICAgICAgIGluc2VydCgodm5vZGUuYW5jaG9yID0gY3JlYXRlQ29tbWVudChgXWApKSwgY29udGFpbmVyLCBuZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGhhbmRsZU1pc21hdGNoID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnQpID0+IHtcclxuICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiBub2RlIG1pc21hdGNoOlxcbi0gQ2xpZW50IHZub2RlOmAsIHZub2RlLnR5cGUsIGBcXG4tIFNlcnZlciByZW5kZXJlZCBET006YCwgbm9kZSwgbm9kZS5ub2RlVHlwZSA9PT0gMyAvKiBURVhUICovXHJcbiAgICAgICAgICAgICAgICA/IGAodGV4dClgXHJcbiAgICAgICAgICAgICAgICA6IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09ICdbJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gYChzdGFydCBvZiBmcmFnbWVudClgXHJcbiAgICAgICAgICAgICAgICAgICAgOiBgYCk7XHJcbiAgICAgICAgdm5vZGUuZWwgPSBudWxsO1xyXG4gICAgICAgIGlmIChpc0ZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBleGNlc3NpdmUgZnJhZ21lbnQgbm9kZXNcclxuICAgICAgICAgICAgY29uc3QgZW5kID0gbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yKG5vZGUpO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dCAhPT0gZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV4dCA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XHJcbiAgICAgICAgcmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIsIG5leHQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksIHNsb3RTY29wZUlkcyk7XHJcbiAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yID0gKG5vZGUpID0+IHtcclxuICAgICAgICBsZXQgbWF0Y2ggPSAwO1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUgJiYgaXNDb21tZW50KG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSAnWycpXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2grKztcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09ICddJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXTtcclxufVxuXG5sZXQgc3VwcG9ydGVkO1xyXG5sZXQgcGVyZjtcclxuZnVuY3Rpb24gc3RhcnRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgIHBlcmYubWFyayhgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YCk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGRldnRvb2xzUGVyZlN0YXJ0KGluc3RhbmNlLCB0eXBlLCBzdXBwb3J0ZWQgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZW5kTWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcclxuICAgICAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gO1xyXG4gICAgICAgIGNvbnN0IGVuZFRhZyA9IHN0YXJ0VGFnICsgYDplbmRgO1xyXG4gICAgICAgIHBlcmYubWFyayhlbmRUYWcpO1xyXG4gICAgICAgIHBlcmYubWVhc3VyZShgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9PiAke3R5cGV9YCwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcclxuICAgICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgZGV2dG9vbHNQZXJmRW5kKGluc3RhbmNlLCB0eXBlLCBzdXBwb3J0ZWQgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XHJcbiAgICBpZiAoc3VwcG9ydGVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gc3VwcG9ydGVkO1xyXG4gICAgfVxyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlKSB7XHJcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcclxuICAgICAgICBwZXJmID0gd2luZG93LnBlcmZvcm1hbmNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcclxufVxuXG4vKipcclxuICogVGhpcyBpcyBvbmx5IGNhbGxlZCBpbiBlc20tYnVuZGxlciBidWlsZHMuXHJcbiAqIEl0IGlzIGNhbGxlZCB3aGVuIGEgcmVuZGVyZXIgaXMgY3JlYXRlZCwgaW4gYGJhc2VDcmVhdGVSZW5kZXJlcmAgc28gdGhhdFxyXG4gKiBpbXBvcnRpbmcgcnVudGltZS1jb3JlIGlzIHNpZGUtZWZmZWN0cyBmcmVlLlxyXG4gKlxyXG4gKiBpc3RhbmJ1bC1pZ25vcmUtbmV4dFxyXG4gKi9cclxuZnVuY3Rpb24gaW5pdEZlYXR1cmVGbGFncygpIHtcclxuICAgIGxldCBuZWVkV2FybiA9IGZhbHNlO1xyXG4gICAgaWYgKHR5cGVvZiBfX1ZVRV9PUFRJT05TX0FQSV9fICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICBuZWVkV2FybiA9IHRydWU7XHJcbiAgICAgICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX09QVElPTlNfQVBJX18gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18gIT09ICdib29sZWFuJykge1xyXG4gICAgICAgIG5lZWRXYXJuID0gdHJ1ZTtcclxuICAgICAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfUFJPRF9ERVZUT09MU19fID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5lZWRXYXJuKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBZb3UgYXJlIHJ1bm5pbmcgdGhlIGVzbS1idW5kbGVyIGJ1aWxkIG9mIFZ1ZS4gSXQgaXMgcmVjb21tZW5kZWQgdG8gYCArXHJcbiAgICAgICAgICAgIGBjb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGV4cGxpY2l0bHkgcmVwbGFjZSBmZWF0dXJlIGZsYWcgZ2xvYmFscyBgICtcclxuICAgICAgICAgICAgYHdpdGggYm9vbGVhbiBsaXRlcmFscyB0byBnZXQgcHJvcGVyIHRyZWUtc2hha2luZyBpbiB0aGUgZmluYWwgYnVuZGxlLiBgICtcclxuICAgICAgICAgICAgYFNlZSBodHRwOi8vbGluay52dWVqcy5vcmcvZmVhdHVyZS1mbGFncyBmb3IgbW9yZSBkZXRhaWxzLmApO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHByb2RFZmZlY3RPcHRpb25zID0ge1xyXG4gICAgc2NoZWR1bGVyOiBxdWV1ZUpvYixcclxuICAgIC8vICMxODAxLCAjMjA0MyBjb21wb25lbnQgcmVuZGVyIGVmZmVjdHMgc2hvdWxkIGFsbG93IHJlY3Vyc2l2ZSB1cGRhdGVzXHJcbiAgICBhbGxvd1JlY3Vyc2U6IHRydWVcclxufTtcclxuZnVuY3Rpb24gY3JlYXRlRGV2RWZmZWN0T3B0aW9ucyhpbnN0YW5jZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzY2hlZHVsZXI6IHF1ZXVlSm9iLFxyXG4gICAgICAgIGFsbG93UmVjdXJzZTogdHJ1ZSxcclxuICAgICAgICBvblRyYWNrOiBpbnN0YW5jZS5ydGMgPyBlID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0YywgZSkgOiB2b2lkIDAsXHJcbiAgICAgICAgb25UcmlnZ2VyOiBpbnN0YW5jZS5ydGcgPyBlID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0ZywgZSkgOiB2b2lkIDBcclxuICAgIH07XHJcbn1cclxuY29uc3QgcXVldWVQb3N0UmVuZGVyRWZmZWN0ID0gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2VcclxuICAgIDtcclxuY29uc3Qgc2V0UmVmID0gKHJhd1JlZiwgb2xkUmF3UmVmLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIGlzVW5tb3VudCA9IGZhbHNlKSA9PiB7XHJcbiAgICBpZiAoaXNBcnJheShyYXdSZWYpKSB7XHJcbiAgICAgICAgcmF3UmVmLmZvckVhY2goKHIsIGkpID0+IHNldFJlZihyLCBvbGRSYXdSZWYgJiYgKGlzQXJyYXkob2xkUmF3UmVmKSA/IG9sZFJhd1JlZltpXSA6IG9sZFJhd1JlZiksIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgaXNVbm1vdW50KSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhaXNVbm1vdW50KSB7XHJcbiAgICAgICAgLy8gd2hlbiBtb3VudGluZyBhc3luYyBjb21wb25lbnRzLCBub3RoaW5nIG5lZWRzIHRvIGJlIGRvbmUsXHJcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgdGVtcGxhdGUgcmVmIGlzIGZvcndhcmRlZCB0byBpbm5lciBjb21wb25lbnRcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCByZWZWYWx1ZSA9IHZub2RlLnNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovXHJcbiAgICAgICAgPyBnZXRFeHBvc2VQcm94eSh2bm9kZS5jb21wb25lbnQpIHx8IHZub2RlLmNvbXBvbmVudC5wcm94eVxyXG4gICAgICAgIDogdm5vZGUuZWw7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGlzVW5tb3VudCA/IG51bGwgOiByZWZWYWx1ZTtcclxuICAgIGNvbnN0IHsgaTogb3duZXIsIHI6IHJlZiB9ID0gcmF3UmVmO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhb3duZXIpIHtcclxuICAgICAgICB3YXJuKGBNaXNzaW5nIHJlZiBvd25lciBjb250ZXh0LiByZWYgY2Fubm90IGJlIHVzZWQgb24gaG9pc3RlZCB2bm9kZXMuIGAgK1xyXG4gICAgICAgICAgICBgQSB2bm9kZSB3aXRoIHJlZiBtdXN0IGJlIGNyZWF0ZWQgaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2xkUmVmID0gb2xkUmF3UmVmICYmIG9sZFJhd1JlZi5yO1xyXG4gICAgY29uc3QgcmVmcyA9IG93bmVyLnJlZnMgPT09IEVNUFRZX09CSiA/IChvd25lci5yZWZzID0ge30pIDogb3duZXIucmVmcztcclxuICAgIGNvbnN0IHNldHVwU3RhdGUgPSBvd25lci5zZXR1cFN0YXRlO1xyXG4gICAgLy8gZHluYW1pYyByZWYgY2hhbmdlZC4gdW5zZXQgb2xkIHJlZlxyXG4gICAgaWYgKG9sZFJlZiAhPSBudWxsICYmIG9sZFJlZiAhPT0gcmVmKSB7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKG9sZFJlZikpIHtcclxuICAgICAgICAgICAgcmVmc1tvbGRSZWZdID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCBvbGRSZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW29sZFJlZl0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUmVmKG9sZFJlZikpIHtcclxuICAgICAgICAgICAgb2xkUmVmLnZhbHVlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTdHJpbmcocmVmKSkge1xyXG4gICAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIHJlZikpIHtcclxuICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyAjMTc4OTogZm9yIG5vbi1udWxsIHZhbHVlcywgc2V0IHRoZW0gYWZ0ZXIgcmVuZGVyXHJcbiAgICAgICAgLy8gbnVsbCB2YWx1ZXMgbWVhbnMgdGhpcyBpcyB1bm1vdW50IGFuZCBpdCBzaG91bGQgbm90IG92ZXJ3cml0ZSBhbm90aGVyXHJcbiAgICAgICAgLy8gcmVmIHdpdGggdGhlIHNhbWUga2V5XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGRvU2V0LmlkID0gLTE7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkb1NldCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9TZXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlZihyZWYpKSB7XHJcbiAgICAgICAgY29uc3QgZG9TZXQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlZi52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGRvU2V0LmlkID0gLTE7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkb1NldCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9TZXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uJDEocmVmKSkge1xyXG4gICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhyZWYsIG93bmVyLCAxMiAvKiBGVU5DVElPTl9SRUYgKi8sIFt2YWx1ZSwgcmVmc10pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybignSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTonLCB2YWx1ZSwgYCgke3R5cGVvZiB2YWx1ZX0pYCk7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBUaGUgY3JlYXRlUmVuZGVyZXIgZnVuY3Rpb24gYWNjZXB0cyB0d28gZ2VuZXJpYyBhcmd1bWVudHM6XHJcbiAqIEhvc3ROb2RlIGFuZCBIb3N0RWxlbWVudCwgY29ycmVzcG9uZGluZyB0byBOb2RlIGFuZCBFbGVtZW50IHR5cGVzIGluIHRoZVxyXG4gKiBob3N0IGVudmlyb25tZW50LiBGb3IgZXhhbXBsZSwgZm9yIHJ1bnRpbWUtZG9tLCBIb3N0Tm9kZSB3b3VsZCBiZSB0aGUgRE9NXHJcbiAqIGBOb2RlYCBpbnRlcmZhY2UgYW5kIEhvc3RFbGVtZW50IHdvdWxkIGJlIHRoZSBET00gYEVsZW1lbnRgIGludGVyZmFjZS5cclxuICpcclxuICogQ3VzdG9tIHJlbmRlcmVycyBjYW4gcGFzcyBpbiB0aGUgcGxhdGZvcm0gc3BlY2lmaWMgdHlwZXMgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGAganNcclxuICogY29uc3QgeyByZW5kZXIsIGNyZWF0ZUFwcCB9ID0gY3JlYXRlUmVuZGVyZXI8Tm9kZSwgRWxlbWVudD4oe1xyXG4gKiAgIHBhdGNoUHJvcCxcclxuICogICAuLi5ub2RlT3BzXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zKTtcclxufVxyXG4vLyBTZXBhcmF0ZSBBUEkgZm9yIGNyZWF0aW5nIGh5ZHJhdGlvbi1lbmFibGVkIHJlbmRlcmVyLlxyXG4vLyBIeWRyYXRpb24gbG9naWMgaXMgb25seSB1c2VkIHdoZW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uLCBtYWtpbmcgaXRcclxuLy8gdHJlZS1zaGFrYWJsZS5cclxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMpO1xyXG59XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GbnMpIHtcclxuICAgIC8vIGNvbXBpbGUtdGltZSBmZWF0dXJlIGZsYWdzIGNoZWNrXHJcbiAgICB7XHJcbiAgICAgICAgaW5pdEZlYXR1cmVGbGFncygpO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRHbG9iYWxUaGlzKCk7XHJcbiAgICAgICAgdGFyZ2V0Ll9fVlVFX18gPSB0cnVlO1xyXG4gICAgICAgIHNldERldnRvb2xzSG9vayh0YXJnZXQuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGluc2VydDogaG9zdEluc2VydCwgcmVtb3ZlOiBob3N0UmVtb3ZlLCBwYXRjaFByb3A6IGhvc3RQYXRjaFByb3AsIGZvcmNlUGF0Y2hQcm9wOiBob3N0Rm9yY2VQYXRjaFByb3AsIGNyZWF0ZUVsZW1lbnQ6IGhvc3RDcmVhdGVFbGVtZW50LCBjcmVhdGVUZXh0OiBob3N0Q3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudDogaG9zdENyZWF0ZUNvbW1lbnQsIHNldFRleHQ6IGhvc3RTZXRUZXh0LCBzZXRFbGVtZW50VGV4dDogaG9zdFNldEVsZW1lbnRUZXh0LCBwYXJlbnROb2RlOiBob3N0UGFyZW50Tm9kZSwgbmV4dFNpYmxpbmc6IGhvc3ROZXh0U2libGluZywgc2V0U2NvcGVJZDogaG9zdFNldFNjb3BlSWQgPSBOT09QLCBjbG9uZU5vZGU6IGhvc3RDbG9uZU5vZGUsIGluc2VydFN0YXRpY0NvbnRlbnQ6IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50IH0gPSBvcHRpb25zO1xyXG4gICAgLy8gTm90ZTogZnVuY3Rpb25zIGluc2lkZSB0aGlzIGNsb3N1cmUgc2hvdWxkIHVzZSBgY29uc3QgeHh4ID0gKCkgPT4ge31gXHJcbiAgICAvLyBzdHlsZSBpbiBvcmRlciB0byBwcmV2ZW50IGJlaW5nIGlubGluZWQgYnkgbWluaWZpZXJzLlxyXG4gICAgY29uc3QgcGF0Y2ggPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciA9IG51bGwsIHBhcmVudENvbXBvbmVudCA9IG51bGwsIHBhcmVudFN1c3BlbnNlID0gbnVsbCwgaXNTVkcgPSBmYWxzZSwgc2xvdFNjb3BlSWRzID0gbnVsbCwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICAvLyBwYXRjaGluZyAmIG5vdCBzYW1lIHR5cGUsIHVubW91bnQgb2xkIHRyZWVcclxuICAgICAgICBpZiAobjEgJiYgIWlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XHJcbiAgICAgICAgICAgIGFuY2hvciA9IGdldE5leHRIb3N0Tm9kZShuMSk7XHJcbiAgICAgICAgICAgIHVubW91bnQobjEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICBuMSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuMi5wYXRjaEZsYWcgPT09IC0yIC8qIEJBSUwgKi8pIHtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG4yLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcgfSA9IG4yO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFRleHQ6XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzVGV4dChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIENvbW1lbnQkMTpcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFN0YXRpYzpcclxuICAgICAgICAgICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRTdGF0aWNOb2RlKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hTdGF0aWNOb2RlKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBGcmFnbWVudDpcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NGcmFnbWVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0VsZW1lbnQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZS5wcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgVk5vZGUgdHlwZTonLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXQgcmVmXHJcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsICYmIHBhcmVudENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBzZXRSZWYocmVmLCBuMSAmJiBuMS5yZWYsIHBhcmVudFN1c3BlbnNlLCBuMiB8fCBuMSwgIW4yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc1RleHQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoKG4yLmVsID0gaG9zdENyZWF0ZVRleHQobjIuY2hpbGRyZW4pKSwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZWwgPSAobjIuZWwgPSBuMS5lbCk7XHJcbiAgICAgICAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0NvbW1lbnROb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KChuMi5lbCA9IGhvc3RDcmVhdGVDb21tZW50KG4yLmNoaWxkcmVuIHx8ICcnKSksIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gc3VwcG9ydCBmb3IgZHluYW1pYyBjb21tZW50c1xyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3VudFN0YXRpY05vZGUgPSAobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIC8vIHN0YXRpYyBub2RlcyBhcmUgb25seSBwcmVzZW50IHdoZW4gdXNlZCB3aXRoIGNvbXBpbGVyLWRvbS9ydW50aW1lLWRvbVxyXG4gICAgICAgIC8vIHdoaWNoIGd1YXJhbnRlZXMgcHJlc2VuY2Ugb2YgaG9zdEluc2VydFN0YXRpY0NvbnRlbnQuXHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBcclxuICAgICAgICAvLyBwYXNzIGNhY2hlZCBub2RlcyBpZiB0aGUgc3RhdGljIG5vZGUgaXMgYmVpbmcgbW91bnRlZCBtdWx0aXBsZSB0aW1lc1xyXG4gICAgICAgIC8vIHNvIHRoYXQgcnVudGltZS1kb20gY2FuIHNpbXBseSBjbG9uZU5vZGUoKSBpbnN0ZWFkIG9mIGluc2VydGluZyBuZXdcclxuICAgICAgICAvLyBIVE1MXHJcbiAgICAgICAgbjIuc3RhdGljQ2FjaGUpO1xyXG4gICAgICAgIC8vIGZpcnN0IG1vdW50IC0gdGhpcyBpcyB0aGUgb3JpZ25hbCBob2lzdGVkIHZub2RlLiBjYWNoZSBub2Rlcy5cclxuICAgICAgICBpZiAoIW4yLmVsKSB7XHJcbiAgICAgICAgICAgIG4yLnN0YXRpY0NhY2hlID0gbm9kZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG4yLmVsID0gbm9kZXNbMF07XHJcbiAgICAgICAgbjIuYW5jaG9yID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXYgLyBITVIgb25seVxyXG4gICAgICovXHJcbiAgICBjb25zdCBwYXRjaFN0YXRpY05vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGlzU1ZHKSA9PiB7XHJcbiAgICAgICAgLy8gc3RhdGljIG5vZGVzIGFyZSBvbmx5IHBhdGNoZWQgZHVyaW5nIGRldiBmb3IgSE1SXHJcbiAgICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBob3N0TmV4dFNpYmxpbmcobjEuYW5jaG9yKTtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXHJcbiAgICAgICAgICAgIHJlbW92ZVN0YXRpY05vZGUobjEpO1xyXG4gICAgICAgICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgICAgIG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0sIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpID0+IHtcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcclxuICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XHJcbiAgICAgICAgICAgIGVsID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdEluc2VydChhbmNob3IsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0pID0+IHtcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZShlbCk7XHJcbiAgICAgICAgICAgIGVsID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NFbGVtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgbjIudHlwZSA9PT0gJ3N2Zyc7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgbW91bnRFbGVtZW50KG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoRWxlbWVudChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50RWxlbWVudCA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGxldCBlbDtcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHNoYXBlRmxhZywgdHJhbnNpdGlvbiwgcGF0Y2hGbGFnLCBkaXJzIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB2bm9kZS5lbCAmJlxyXG4gICAgICAgICAgICBob3N0Q2xvbmVOb2RlICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID09PSAtMSAvKiBIT0lTVEVEICovKSB7XHJcbiAgICAgICAgICAgIC8vIElmIGEgdm5vZGUgaGFzIG5vbi1udWxsIGVsLCBpdCBtZWFucyBpdCdzIGJlaW5nIHJldXNlZC5cclxuICAgICAgICAgICAgLy8gT25seSBzdGF0aWMgdm5vZGVzIGNhbiBiZSByZXVzZWQsIHNvIGl0cyBtb3VudGVkIERPTSBub2RlcyBzaG91bGQgYmVcclxuICAgICAgICAgICAgLy8gZXhhY3RseSB0aGUgc2FtZSwgYW5kIHdlIGNhbiBzaW1wbHkgZG8gYSBjbG9uZSBoZXJlLlxyXG4gICAgICAgICAgICAvLyBvbmx5IGRvIHRoaXMgaW4gcHJvZHVjdGlvbiBzaW5jZSBjbG9uZWQgdHJlZXMgY2Fubm90IGJlIEhNUiB1cGRhdGVkLlxyXG4gICAgICAgICAgICBlbCA9IHZub2RlLmVsID0gaG9zdENsb25lTm9kZSh2bm9kZS5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbCA9IHZub2RlLmVsID0gaG9zdENyZWF0ZUVsZW1lbnQodm5vZGUudHlwZSwgaXNTVkcsIHByb3BzICYmIHByb3BzLmlzLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIC8vIG1vdW50IGNoaWxkcmVuIGZpcnN0LCBzaW5jZSBzb21lIHByb3BzIG1heSByZWx5IG9uIGNoaWxkIGNvbnRlbnRcclxuICAgICAgICAgICAgLy8gYmVpbmcgYWxyZWFkeSByZW5kZXJlZCwgZS5nLiBgPHNlbGVjdCB2YWx1ZT5gXHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudENoaWxkcmVuKHZub2RlLmNoaWxkcmVuLCBlbCwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcgJiYgdHlwZSAhPT0gJ2ZvcmVpZ25PYmplY3QnLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2NyZWF0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNjb3BlSWRcclxuICAgICAgICAgICAgc2V0U2NvcGVJZChlbCwgdm5vZGUsIHZub2RlLnNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCAnX192bm9kZScsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2bm9kZSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdfX3Z1ZVBhcmVudENvbXBvbmVudCcsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlTW91bnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gIzE1ODMgRm9yIGluc2lkZSBzdXNwZW5zZSArIHN1c3BlbnNlIG5vdCByZXNvbHZlZCBjYXNlLCBlbnRlciBob29rIHNob3VsZCBjYWxsIHdoZW4gc3VzcGVuc2UgcmVzb2x2ZWRcclxuICAgICAgICAvLyAjMTY4OSBGb3IgaW5zaWRlIHN1c3BlbnNlICsgc3VzcGVuc2UgcmVzb2x2ZWQgY2FzZSwganVzdCBjYWxsIGl0XHJcbiAgICAgICAgY29uc3QgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSAoIXBhcmVudFN1c3BlbnNlIHx8IChwYXJlbnRTdXNwZW5zZSAmJiAhcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkpICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xyXG4gICAgICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8XHJcbiAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzIHx8XHJcbiAgICAgICAgICAgIGRpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdtb3VudGVkJyk7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgdm5vZGUsIHNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKHNjb3BlSWQpIHtcclxuICAgICAgICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNjb3BlSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2xvdFNjb3BlSWRzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xvdFNjb3BlSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2xvdFNjb3BlSWRzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHN1YlRyZWUucGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgc3ViVHJlZS5wYXRjaEZsYWcgJiAyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJUcmVlID1cclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJTaW5nbGVSb290KHN1YlRyZWUuY2hpbGRyZW4pIHx8IHN1YlRyZWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZub2RlID09PSBzdWJUcmVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRWTm9kZSA9IHBhcmVudENvbXBvbmVudC52bm9kZTtcclxuICAgICAgICAgICAgICAgIHNldFNjb3BlSWQoZWwsIHBhcmVudFZOb2RlLCBwYXJlbnRWTm9kZS5zY29wZUlkLCBwYXJlbnRWTm9kZS5zbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudC5wYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHN0YXJ0ID0gMCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gKGNoaWxkcmVuW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGNoaWxkcmVuW2ldKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSkpO1xyXG4gICAgICAgICAgICBwYXRjaChudWxsLCBjaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoRWxlbWVudCA9IChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsID0gKG4yLmVsID0gbjEuZWwpO1xyXG4gICAgICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBkaXJzIH0gPSBuMjtcclxuICAgICAgICAvLyAjMTQyNiB0YWtlIHRoZSBvbGQgdm5vZGUncyBwYXRjaCBmbGFnIGludG8gYWNjb3VudCBzaW5jZSB1c2VyIG1heSBjbG9uZSBhXHJcbiAgICAgICAgLy8gY29tcGlsZXItZ2VuZXJhdGVkIHZub2RlLCB3aGljaCBkZS1vcHRzIHRvIEZVTExfUFJPUFNcclxuICAgICAgICBwYXRjaEZsYWcgfD0gbjEucGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLztcclxuICAgICAgICBjb25zdCBvbGRQcm9wcyA9IG4xLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IG4yLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkpIHtcclxuICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlVXBkYXRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9IDA7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICAgICAgICAvLyB0aGUgcHJlc2VuY2Ugb2YgYSBwYXRjaEZsYWcgbWVhbnMgdGhpcyBlbGVtZW50J3MgcmVuZGVyIGNvZGUgd2FzXHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIgYW5kIGNhbiB0YWtlIHRoZSBmYXN0IHBhdGguXHJcbiAgICAgICAgICAgIC8vIGluIHRoaXMgcGF0aCBvbGQgbm9kZSBhbmQgbmV3IG5vZGUgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZVxyXG4gICAgICAgICAgICAvLyAoaS5lLiBhdCB0aGUgZXhhY3Qgc2FtZSBwb3NpdGlvbiBpbiB0aGUgc291cmNlIHRlbXBsYXRlKVxyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBwcm9wcyBjb250YWluIGR5bmFtaWMga2V5cywgZnVsbCBkaWZmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgcGF0Y2hQcm9wcyhlbCwgbjIsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2xhc3NcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgY2xhc3MgYmluZGluZ3MuXHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMiAvKiBDTEFTUyAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRQcm9wcy5jbGFzcyAhPT0gbmV3UHJvcHMuY2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ2NsYXNzJywgbnVsbCwgbmV3UHJvcHMuY2xhc3MsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzdHlsZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBzdHlsZSBiaW5kaW5nc1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDQgLyogU1RZTEUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCAnc3R5bGUnLCBvbGRQcm9wcy5zdHlsZSwgbmV3UHJvcHMuc3R5bGUsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkeW5hbWljIHByb3AvYXR0ciBiaW5kaW5nc1xyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdGhhbiBjbGFzcyBhbmQgc3R5bGUuIFRoZSBrZXlzIG9mIGR5bmFtaWMgcHJvcC9hdHRycyBhcmUgc2F2ZWQgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0ZXIgaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZSBkeW5hbWljIGtleXMgbGlrZSA6W2Zvb109XCJiYXJcIiB3aWxsIGNhdXNlIHRoaXMgb3B0aW1pemF0aW9uIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBiYWlsIG91dCBhbmQgZ28gdGhyb3VnaCBhIGZ1bGwgZGlmZiBiZWNhdXNlIHdlIG5lZWQgdG8gdW5zZXQgdGhlIG9sZCBrZXlcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBST1BTICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZsYWcgaXMgcHJlc2VudCB0aGVuIGR5bmFtaWNQcm9wcyBtdXN0IGJlIG5vbi1udWxsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IG4yLmR5bmFtaWNQcm9wcztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGhvc3RGb3JjZVBhdGNoUHJvcCAmJiBob3N0Rm9yY2VQYXRjaFByb3AoZWwsIGtleSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIGlzU1ZHLCBuMS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0ZXh0XHJcbiAgICAgICAgICAgIC8vIFRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIG9ubHkgZHluYW1pYyB0ZXh0IGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMSAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobjEuY2hpbGRyZW4gIT09IG4yLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCAmJiBkeW5hbWljQ2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyB1bm9wdGltaXplZCwgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoUHJvcHMoZWwsIG4yLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJlQ2hpbGRyZW5TVkcgPSBpc1NWRyAmJiBuMi50eXBlICE9PSAnZm9yZWlnbk9iamVjdCc7XHJcbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGVsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBhcmVDaGlsZHJlblNWRywgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcclxuICAgICAgICAgICAgLy8gZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBlbCwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgYXJlQ2hpbGRyZW5TVkcsIHNsb3RTY29wZUlkcywgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVVcGRhdGVkKSB8fCBkaXJzKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xyXG4gICAgICAgICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCAndXBkYXRlZCcpO1xyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFRoZSBmYXN0IHBhdGggZm9yIGJsb2Nrcy5cclxuICAgIGNvbnN0IHBhdGNoQmxvY2tDaGlsZHJlbiA9IChvbGRDaGlsZHJlbiwgbmV3Q2hpbGRyZW4sIGZhbGxiYWNrQ29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdWTm9kZSA9IG5ld0NoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGNvbnRhaW5lciAocGFyZW50IGVsZW1lbnQpIGZvciB0aGUgcGF0Y2guXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IFxyXG4gICAgICAgICAgICAvLyBvbGRWTm9kZSBtYXkgYmUgYW4gZXJyb3JlZCBhc3luYyBzZXR1cCgpIGNvbXBvbmVudCBpbnNpZGUgU3VzcGVuc2VcclxuICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBub3QgaGF2ZSBhIG1vdW50ZWQgZWxlbWVudFxyXG4gICAgICAgICAgICBvbGRWTm9kZS5lbCAmJlxyXG4gICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIEZyYWdtZW50LCB3ZSBuZWVkIHRvIHByb3ZpZGUgdGhlIGFjdHVhbCBwYXJlbnRcclxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBGcmFnbWVudCBpdHNlbGYgc28gaXQgY2FuIG1vdmUgaXRzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgKG9sZFZOb2RlLnR5cGUgPT09IEZyYWdtZW50IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgbm9kZXMsIHRoZXJlIGlzIGdvaW5nIHRvIGJlIGEgcmVwbGFjZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBhbHNvIHJlcXVpcmVzIHRoZSBjb3JyZWN0IHBhcmVudCBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAhaXNTYW1lVk5vZGVUeXBlKG9sZFZOb2RlLCBuZXdWTm9kZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGEgY29tcG9uZW50LCBpdCBjb3VsZCBjb250YWluIGFueXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZOb2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVk5vZGUuc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pXHJcbiAgICAgICAgICAgICAgICA/IGhvc3RQYXJlbnROb2RlKG9sZFZOb2RlLmVsKVxyXG4gICAgICAgICAgICAgICAgOiAvLyBJbiBvdGhlciBjYXNlcywgdGhlIHBhcmVudCBjb250YWluZXIgaXMgbm90IGFjdHVhbGx5IHVzZWQgc28gd2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHBhc3MgdGhlIGJsb2NrIGVsZW1lbnQgaGVyZSB0byBhdm9pZCBhIERPTSBwYXJlbnROb2RlIGNhbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tDb250YWluZXI7XHJcbiAgICAgICAgICAgIHBhdGNoKG9sZFZOb2RlLCBuZXdWTm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hQcm9wcyA9IChlbCwgdm5vZGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpID0+IHtcclxuICAgICAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBzdHJpbmcgaXMgbm90IHZhbGlkIHByb3BcclxuICAgICAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSBwcmV2IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGhvc3RGb3JjZVBhdGNoUHJvcCAmJiBob3N0Rm9yY2VQYXRjaFByb3AoZWwsIGtleSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9sZFByb3BzICE9PSBFTVBUWV9PQkopIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpICYmICEoa2V5IGluIG5ld1Byb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIG9sZFByb3BzW2tleV0sIG51bGwsIGlzU1ZHLCB2bm9kZS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0ZyYWdtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50U3RhcnRBbmNob3IgPSAobjIuZWwgPSBuMSA/IG4xLmVsIDogaG9zdENyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICBjb25zdCBmcmFnbWVudEVuZEFuY2hvciA9IChuMi5hbmNob3IgPSBuMSA/IG4xLmFuY2hvciA6IGhvc3RDcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IG4yO1xyXG4gICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIHNsb3QgZnJhZ21lbnQgd2l0aCA6c2xvdHRlZCBzY29wZSBpZHNcclxuICAgICAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcclxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzXHJcbiAgICAgICAgICAgICAgICA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpXHJcbiAgICAgICAgICAgICAgICA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgLy8gSE1SIHVwZGF0ZWQsIGZvcmNlIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICBwYXRjaEZsYWcgPSAwO1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaG9zdEluc2VydChmcmFnbWVudFN0YXJ0QW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRFbmRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgLy8gYSBmcmFnbWVudCBjYW4gb25seSBoYXZlIGFycmF5IGNoaWxkcmVuXHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgYXJlIGVpdGhlciBnZW5lcmF0ZWQgYnkgdGhlIGNvbXBpbGVyLCBvciBpbXBsaWNpdGx5IGNyZWF0ZWRcclxuICAgICAgICAgICAgLy8gZnJvbSBhcnJheXMuXHJcbiAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4objIuY2hpbGRyZW4sIGNvbnRhaW5lciwgZnJhZ21lbnRFbmRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnICYgNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gJiZcclxuICAgICAgICAgICAgICAgIC8vICMyNzE1IHRoZSBwcmV2aW91cyBmcmFnbWVudCBjb3VsZCd2ZSBiZWVuIGEgQkFJTGVkIG9uZSBhcyBhIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgLy8gb2YgcmVuZGVyU2xvdCgpIHdpdGggbm8gdmFsaWQgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgLy8gYSBzdGFibGUgZnJhZ21lbnQgKHRlbXBsYXRlIHJvb3Qgb3IgPHRlbXBsYXRlIHYtZm9yPikgZG9lc24ndCBuZWVkIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBwYXRjaCBjaGlsZHJlbiBvcmRlciwgYnV0IGl0IG1heSBjb250YWluIGR5bmFtaWNDaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihuMS5keW5hbWljQ2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgIC8vICMyMDgwIGlmIHRoZSBzdGFibGUgZnJhZ21lbnQgaGFzIGEga2V5LCBpdCdzIGEgPHRlbXBsYXRlIHYtZm9yPiB0aGF0IG1heVxyXG4gICAgICAgICAgICAgICAgLy8gIGdldCBtb3ZlZCBhcm91bmQuIE1ha2Ugc3VyZSBhbGwgcm9vdCBsZXZlbCB2bm9kZXMgaW5oZXJpdCBlbC5cclxuICAgICAgICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxyXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlIGNvbXBvbmVudCBpcyBiZWluZyBtb3ZlZC5cclxuICAgICAgICAgICAgICAgIG4yLmtleSAhPSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHBhcmVudENvbXBvbmVudCAmJiBuMiA9PT0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUgLyogc2hhbGxvdyAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBrZXllZCAvIHVua2V5ZWQsIG9yIG1hbnVhbCBmcmFnbWVudHMuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3Iga2V5ZWQgJiB1bmtleWVkLCBzaW5jZSB0aGV5IGFyZSBjb21waWxlciBnZW5lcmF0ZWQgZnJvbSB2LWZvcixcclxuICAgICAgICAgICAgICAgIC8vIGVhY2ggY2hpbGQgaXMgZ3VhcmFudGVlZCB0byBiZSBhIGJsb2NrIHNvIHRoZSBmcmFnbWVudCB3aWxsIG5ldmVyXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGR5bmFtaWNDaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjb250YWluZXIsIGZyYWdtZW50RW5kQW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NDb21wb25lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbjIuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChuMi5zaGFwZUZsYWcgJiA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudC5jdHguYWN0aXZhdGUobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1vdW50Q29tcG9uZW50KG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50Q29tcG9uZW50ID0gKGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IChpbml0aWFsVk5vZGUuY29tcG9uZW50ID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UoaW5pdGlhbFZOb2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgcmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChpbml0aWFsVk5vZGUpO1xyXG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmplY3QgcmVuZGVyZXIgaW50ZXJuYWxzIGZvciBrZWVwQWxpdmVcclxuICAgICAgICBpZiAoaXNLZWVwQWxpdmUoaW5pdGlhbFZOb2RlKSkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5jdHgucmVuZGVyZXIgPSBpbnRlcm5hbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlc29sdmUgcHJvcHMgYW5kIHNsb3RzIGZvciBzZXR1cCBjb250ZXh0XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0dXBDb21wb25lbnQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldHVwKCkgaXMgYXN5bmMuIFRoaXMgY29tcG9uZW50IHJlbGllcyBvbiBhc3luYyBsb2dpYyB0byBiZSByZXNvbHZlZFxyXG4gICAgICAgIC8vIGJlZm9yZSBwcm9jZWVkaW5nXHJcbiAgICAgICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwKSB7XHJcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCk7XHJcbiAgICAgICAgICAgIC8vIEdpdmUgaXQgYSBwbGFjZWhvbGRlciBpZiB0aGlzIGlzIG5vdCBoeWRyYXRpb25cclxuICAgICAgICAgICAgLy8gVE9ETyBoYW5kbGUgc2VsZi1kZWZpbmVkIGZhbGxiYWNrXHJcbiAgICAgICAgICAgIGlmICghaW5pdGlhbFZOb2RlLmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IChpbnN0YW5jZS5zdWJUcmVlID0gY3JlYXRlVk5vZGUoQ29tbWVudCQxKSk7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobnVsbCwgcGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdXBkYXRlQ29tcG9uZW50ID0gKG4xLCBuMiwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAobjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50KTtcclxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKSkge1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXAgJiZcclxuICAgICAgICAgICAgICAgICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhc3luYyAmIHN0aWxsIHBlbmRpbmcgLSBqdXN0IHVwZGF0ZSBwcm9wcyBhbmQgc2xvdHNcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjb21wb25lbnQncyByZWFjdGl2ZSBlZmZlY3QgZm9yIHJlbmRlciBpc24ndCBzZXQtdXAgeWV0XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG4yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbCB1cGRhdGVcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLm5leHQgPSBuMjtcclxuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGNoaWxkIGNvbXBvbmVudCBpcyBhbHNvIHF1ZXVlZCwgcmVtb3ZlIGl0IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUgdXBkYXRpbmcgdGhlIHNhbWUgY2hpbGQgY29tcG9uZW50IGluIHRoZSBzYW1lIGZsdXNoLlxyXG4gICAgICAgICAgICAgICAgaW52YWxpZGF0ZUpvYihpbnN0YW5jZS51cGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UudXBkYXRlIGlzIHRoZSByZWFjdGl2ZSBlZmZlY3QgcnVubmVyLlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG5vIHVwZGF0ZSBuZWVkZWQuIGp1c3QgY29weSBvdmVyIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgbjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBpbnN0YW5jZS52bm9kZSA9IG4yO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBzZXR1cFJlbmRlckVmZmVjdCA9IChpbnN0YW5jZSwgaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICAvLyBjcmVhdGUgcmVhY3RpdmUgZWZmZWN0IGZvciByZW5kZXJpbmdcclxuICAgICAgICBpbnN0YW5jZS51cGRhdGUgPSBlZmZlY3QoZnVuY3Rpb24gY29tcG9uZW50RWZmZWN0KCkge1xyXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJtLCBtLCBwYXJlbnQgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlTW91bnQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKGJtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoYm0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZUJlZm9yZU1vdW50XHJcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIGluaXRpYWxWTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgaHlkcmF0ZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBoYXMgYWRvcHRlZCBob3N0IG5vZGUgLSBwZXJmb3JtIGh5ZHJhdGlvbiBpbnN0ZWFkIG9mIG1vdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVTdWJUcmVlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZU5vZGUoZWwsIGluc3RhbmNlLnN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlcihpbml0aWFsVk5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZS50eXBlLl9fYXN5bmNMb2FkZXIoKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiB3ZSBhcmUgbW92aW5nIHRoZSByZW5kZXIgY2FsbCBpbnRvIGFuIGFzeW5jIGNhbGxiYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBtZWFucyBpdCB3b24ndCB0cmFjayBkZXBlbmRlbmNpZXMgLSBidXQgaXQncyBvayBiZWNhdXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgc2VydmVyLXJlbmRlcmVkIGFzeW5jIHdyYXBwZXIgaXMgYWxyZWFkeSBpbiByZXNvbHZlZCBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaXQgd2lsbCBuZXZlciBuZWVkIHRvIGNoYW5nZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4gIWluc3RhbmNlLmlzVW5tb3VudGVkICYmIGh5ZHJhdGVTdWJUcmVlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZVN1YlRyZWUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJUcmVlID0gKGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZS5lbCA9IHN1YlRyZWUuZWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtb3VudGVkIGhvb2tcclxuICAgICAgICAgICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVNb3VudGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBzY29wZWRJbml0aWFsVk5vZGUpLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhY3RpdmF0ZWQgaG9vayBmb3Iga2VlcC1hbGl2ZSByb290cy5cclxuICAgICAgICAgICAgICAgIC8vICMxNzQyIGFjdGl2YXRlZCBob29rIG11c3QgYmUgYWNjZXNzZWQgYWZ0ZXIgZmlyc3QgcmVuZGVyXHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgaG9vayBtYXkgYmUgaW5qZWN0ZWQgYnkgYSBjaGlsZCBrZWVwLWFsaXZlXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFZOb2RlLnNoYXBlRmxhZyAmIDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChpbnN0YW5jZS5hLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vICMyNDU4OiBkZWZlcmVuY2UgbW91bnQtb25seSBvYmplY3QgcGFyYW1ldGVycyB0byBwcmV2ZW50IG1lbWxlYWtzXHJcbiAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlQ29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRyaWdnZXJlZCBieSBtdXRhdGlvbiBvZiBjb21wb25lbnQncyBvd24gc3RhdGUgKG5leHQ6IG51bGwpXHJcbiAgICAgICAgICAgICAgICAvLyBPUiBwYXJlbnQgY2FsbGluZyBwcm9jZXNzQ29tcG9uZW50IChuZXh0OiBWTm9kZSlcclxuICAgICAgICAgICAgICAgIGxldCB7IG5leHQsIGJ1LCB1LCBwYXJlbnQsIHZub2RlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcclxuICAgICAgICAgICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG5leHQgfHwgaW5zdGFuY2Uudm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuZXh0LCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHZub2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlVXBkYXRlIGhvb2tcclxuICAgICAgICAgICAgICAgIGlmIChidSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVCZWZvcmVVcGRhdGVcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IG5leHRUcmVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXRjaChwcmV2VHJlZSwgbmV4dFRyZWUsIFxyXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIHRlbGVwb3J0XHJcbiAgICAgICAgICAgICAgICBob3N0UGFyZW50Tm9kZShwcmV2VHJlZS5lbCksIFxyXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yIG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIGZyYWdtZW50XHJcbiAgICAgICAgICAgICAgICBnZXROZXh0SG9zdE5vZGUocHJldlRyZWUpLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5OZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VsZi10cmlnZ2VyZWQgdXBkYXRlLiBJbiBjYXNlIG9mIEhPQywgdXBkYXRlIHBhcmVudCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBlbC4gSE9DIGlzIGluZGljYXRlZCBieSBwYXJlbnQgaW5zdGFuY2UncyBzdWJUcmVlIHBvaW50aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gY2hpbGQgY29tcG9uZW50J3Mgdm5vZGVcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZWQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKHUpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZVVwZGF0ZWRcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVVcGRhdGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjcmVhdGVEZXZFZmZlY3RPcHRpb25zKGluc3RhbmNlKSA6IHByb2RFZmZlY3RPcHRpb25zKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlLm93bmVySW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyID0gKGluc3RhbmNlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG5leHRWTm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcclxuICAgICAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcztcclxuICAgICAgICBpbnN0YW5jZS52bm9kZSA9IG5leHRWTm9kZTtcclxuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbnVsbDtcclxuICAgICAgICB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgbmV4dFZOb2RlLnByb3BzLCBwcmV2UHJvcHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgdXBkYXRlU2xvdHMoaW5zdGFuY2UsIG5leHRWTm9kZS5jaGlsZHJlbiwgb3B0aW1pemVkKTtcclxuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgLy8gcHJvcHMgdXBkYXRlIG1heSBoYXZlIHRyaWdnZXJlZCBwcmUtZmx1c2ggd2F0Y2hlcnMuXHJcbiAgICAgICAgLy8gZmx1c2ggdGhlbSBiZWZvcmUgdGhlIHJlbmRlciB1cGRhdGUuXHJcbiAgICAgICAgZmx1c2hQcmVGbHVzaENicyh1bmRlZmluZWQsIGluc3RhbmNlLnVwZGF0ZSk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoQ2hpbGRyZW4gPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCBjMSA9IG4xICYmIG4xLmNoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IHByZXZTaGFwZUZsYWcgPSBuMSA/IG4xLnNoYXBlRmxhZyA6IDA7XHJcbiAgICAgICAgY29uc3QgYzIgPSBuMi5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCB7IHBhdGNoRmxhZywgc2hhcGVGbGFnIH0gPSBuMjtcclxuICAgICAgICAvLyBmYXN0IHBhdGhcclxuICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGVpdGhlciBmdWxseS1rZXllZCBvciBtaXhlZCAoc29tZSBrZXllZCBzb21lIG5vdClcclxuICAgICAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHBhdGNoRmxhZyBtZWFucyBjaGlsZHJlbiBhcmUgZ3VhcmFudGVlZCB0byBiZSBhcnJheXNcclxuICAgICAgICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhdGNoRmxhZyAmIDI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1bmtleWVkXHJcbiAgICAgICAgICAgICAgICBwYXRjaFVua2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoaWxkcmVuIGhhcyAzIHBvc3NpYmlsaXRpZXM6IHRleHQsIGFycmF5IG9yIG5vIGNoaWxkcmVuLlxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgLy8gdGV4dCBjaGlsZHJlbiBmYXN0IHBhdGhcclxuICAgICAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYzIgIT09IGMxKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCBjMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIHByZXYgY2hpbGRyZW4gd2FzIGFycmF5XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0d28gYXJyYXlzLCBjYW5ub3QgYXNzdW1lIGFueXRoaW5nLCBkbyBmdWxsIGRpZmZcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG5ldyBjaGlsZHJlbiwganVzdCB1bm1vdW50IG9sZFxyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmV2IGNoaWxkcmVuIHdhcyB0ZXh0IE9SIG51bGxcclxuICAgICAgICAgICAgICAgIC8vIG5ldyBjaGlsZHJlbiBpcyBhcnJheSBPUiBudWxsXHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1vdW50IG5ldyBpZiBhcnJheVxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hVbmtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgYzEgPSBjMSB8fCBFTVBUWV9BUlI7XHJcbiAgICAgICAgYzIgPSBjMiB8fCBFTVBUWV9BUlI7XHJcbiAgICAgICAgY29uc3Qgb2xkTGVuZ3RoID0gYzEubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGMyLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBjb21tb25MZW5ndGggPSBNYXRoLm1pbihvbGRMZW5ndGgsIG5ld0xlbmd0aCk7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbW1vbkxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltpXSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcclxuICAgICAgICAgICAgcGF0Y2goYzFbaV0sIG5leHRDaGlsZCwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGRcclxuICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlLCBmYWxzZSwgY29tbW9uTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG1vdW50IG5ld1xyXG4gICAgICAgICAgICBtb3VudENoaWxkcmVuKGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBjb21tb25MZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBjYW4gYmUgYWxsLWtleWVkIG9yIG1peGVkXHJcbiAgICBjb25zdCBwYXRjaEtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGNvbnN0IGwyID0gYzIubGVuZ3RoO1xyXG4gICAgICAgIGxldCBlMSA9IGMxLmxlbmd0aCAtIDE7IC8vIHByZXYgZW5kaW5nIGluZGV4XHJcbiAgICAgICAgbGV0IGUyID0gbDIgLSAxOyAvLyBuZXh0IGVuZGluZyBpbmRleFxyXG4gICAgICAgIC8vIDEuIHN5bmMgZnJvbSBzdGFydFxyXG4gICAgICAgIC8vIChhIGIpIGNcclxuICAgICAgICAvLyAoYSBiKSBkIGVcclxuICAgICAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4xID0gYzFbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IG4yID0gKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKG4xLCBuMiwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAyLiBzeW5jIGZyb20gZW5kXHJcbiAgICAgICAgLy8gYSAoYiBjKVxyXG4gICAgICAgIC8vIGQgZSAoYiBjKVxyXG4gICAgICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgY29uc3QgbjEgPSBjMVtlMV07XHJcbiAgICAgICAgICAgIGNvbnN0IG4yID0gKGMyW2UyXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltlMl0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2UyXSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKG4xLCBuMiwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZTEtLTtcclxuICAgICAgICAgICAgZTItLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4gY29tbW9uIHNlcXVlbmNlICsgbW91bnRcclxuICAgICAgICAvLyAoYSBiKVxyXG4gICAgICAgIC8vIChhIGIpIGNcclxuICAgICAgICAvLyBpID0gMiwgZTEgPSAxLCBlMiA9IDJcclxuICAgICAgICAvLyAoYSBiKVxyXG4gICAgICAgIC8vIGMgKGEgYilcclxuICAgICAgICAvLyBpID0gMCwgZTEgPSAtMSwgZTIgPSAwXHJcbiAgICAgICAgaWYgKGkgPiBlMSkge1xyXG4gICAgICAgICAgICBpZiAoaSA8PSBlMikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvcyA9IGUyICsgMTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRQb3MgPCBsMiA/IGMyW25leHRQb3NdLmVsIDogcGFyZW50QW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChudWxsLCAoYzJbaV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNC4gY29tbW9uIHNlcXVlbmNlICsgdW5tb3VudFxyXG4gICAgICAgIC8vIChhIGIpIGNcclxuICAgICAgICAvLyAoYSBiKVxyXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDIsIGUyID0gMVxyXG4gICAgICAgIC8vIGEgKGIgYylcclxuICAgICAgICAvLyAoYiBjKVxyXG4gICAgICAgIC8vIGkgPSAwLCBlMSA9IDAsIGUyID0gLTFcclxuICAgICAgICBlbHNlIGlmIChpID4gZTIpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGkgPD0gZTEpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoYzFbaV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDUuIHVua25vd24gc2VxdWVuY2VcclxuICAgICAgICAvLyBbaSAuLi4gZTEgKyAxXTogYSBiIFtjIGQgZV0gZiBnXHJcbiAgICAgICAgLy8gW2kgLi4uIGUyICsgMV06IGEgYiBbZSBkIGMgaF0gZiBnXHJcbiAgICAgICAgLy8gaSA9IDIsIGUxID0gNCwgZTIgPSA1XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHMxID0gaTsgLy8gcHJldiBzdGFydGluZyBpbmRleFxyXG4gICAgICAgICAgICBjb25zdCBzMiA9IGk7IC8vIG5leHQgc3RhcnRpbmcgaW5kZXhcclxuICAgICAgICAgICAgLy8gNS4xIGJ1aWxkIGtleTppbmRleCBtYXAgZm9yIG5ld0NoaWxkcmVuXHJcbiAgICAgICAgICAgIGNvbnN0IGtleVRvTmV3SW5kZXhNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IHMyOyBpIDw9IGUyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZC5rZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5VG9OZXdJbmRleE1hcC5oYXMobmV4dENoaWxkLmtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgRHVwbGljYXRlIGtleXMgZm91bmQgZHVyaW5nIHVwZGF0ZTpgLCBKU09OLnN0cmluZ2lmeShuZXh0Q2hpbGQua2V5KSwgYE1ha2Ugc3VyZSBrZXlzIGFyZSB1bmlxdWUuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGtleVRvTmV3SW5kZXhNYXAuc2V0KG5leHRDaGlsZC5rZXksIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDUuMiBsb29wIHRocm91Z2ggb2xkIGNoaWxkcmVuIGxlZnQgdG8gYmUgcGF0Y2hlZCBhbmQgdHJ5IHRvIHBhdGNoXHJcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIG5vZGVzICYgcmVtb3ZlIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50XHJcbiAgICAgICAgICAgIGxldCBqO1xyXG4gICAgICAgICAgICBsZXQgcGF0Y2hlZCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvQmVQYXRjaGVkID0gZTIgLSBzMiArIDE7XHJcbiAgICAgICAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyB1c2VkIHRvIHRyYWNrIHdoZXRoZXIgYW55IG5vZGUgaGFzIG1vdmVkXHJcbiAgICAgICAgICAgIGxldCBtYXhOZXdJbmRleFNvRmFyID0gMDtcclxuICAgICAgICAgICAgLy8gd29ya3MgYXMgTWFwPG5ld0luZGV4LCBvbGRJbmRleD5cclxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IG9sZEluZGV4IGlzIG9mZnNldCBieSArMVxyXG4gICAgICAgICAgICAvLyBhbmQgb2xkSW5kZXggPSAwIGlzIGEgc3BlY2lhbCB2YWx1ZSBpbmRpY2F0aW5nIHRoZSBuZXcgbm9kZSBoYXNcclxuICAgICAgICAgICAgLy8gbm8gY29ycmVzcG9uZGluZyBvbGQgbm9kZS5cclxuICAgICAgICAgICAgLy8gdXNlZCBmb3IgZGV0ZXJtaW5pbmcgbG9uZ2VzdCBzdGFibGUgc3Vic2VxdWVuY2VcclxuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXhUb09sZEluZGV4TWFwID0gbmV3IEFycmF5KHRvQmVQYXRjaGVkKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvQmVQYXRjaGVkOyBpKyspXHJcbiAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBzMTsgaSA8PSBlMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaGVkID49IHRvQmVQYXRjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG5ldyBjaGlsZHJlbiBoYXZlIGJlZW4gcGF0Y2hlZCBzbyB0aGlzIGNhbiBvbmx5IGJlIGEgcmVtb3ZhbFxyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBuZXdJbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2Q2hpbGQua2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGtleVRvTmV3SW5kZXhNYXAuZ2V0KHByZXZDaGlsZC5rZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8ga2V5LWxlc3Mgbm9kZSwgdHJ5IHRvIGxvY2F0ZSBhIGtleS1sZXNzIG5vZGUgb2YgdGhlIHNhbWUgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IHMyOyBqIDw9IGUyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtqIC0gczJdID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NhbWVWTm9kZVR5cGUocHJldkNoaWxkLCBjMltqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbbmV3SW5kZXggLSBzMl0gPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXggPj0gbWF4TmV3SW5kZXhTb0Zhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhOZXdJbmRleFNvRmFyID0gbmV3SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKHByZXZDaGlsZCwgYzJbbmV3SW5kZXhdLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hlZCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDUuMyBtb3ZlIGFuZCBtb3VudFxyXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBsb25nZXN0IHN0YWJsZSBzdWJzZXF1ZW5jZSBvbmx5IHdoZW4gbm9kZXMgaGF2ZSBtb3ZlZFxyXG4gICAgICAgICAgICBjb25zdCBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZSA9IG1vdmVkXHJcbiAgICAgICAgICAgICAgICA/IGdldFNlcXVlbmNlKG5ld0luZGV4VG9PbGRJbmRleE1hcClcclxuICAgICAgICAgICAgICAgIDogRU1QVFlfQVJSO1xyXG4gICAgICAgICAgICBqID0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgLy8gbG9vcGluZyBiYWNrd2FyZHMgc28gdGhhdCB3ZSBjYW4gdXNlIGxhc3QgcGF0Y2hlZCBub2RlIGFzIGFuY2hvclxyXG4gICAgICAgICAgICBmb3IgKGkgPSB0b0JlUGF0Y2hlZCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBzMiArIGk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltuZXh0SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dEluZGV4ICsgMSA8IGwyID8gYzJbbmV4dEluZGV4ICsgMV0uZWwgOiBwYXJlbnRBbmNob3I7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW91bnQgbmV3XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpZjpcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBzdGFibGUgc3Vic2VxdWVuY2UgKGUuZy4gYSByZXZlcnNlKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9SIGN1cnJlbnQgbm9kZSBpcyBub3QgYW1vbmcgdGhlIHN0YWJsZSBzZXF1ZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBpICE9PSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZVtqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlKG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIDIgLyogUkVPUkRFUiAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdmUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSwgcGFyZW50U3VzcGVuc2UgPSBudWxsKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBlbCwgdHlwZSwgdHJhbnNpdGlvbiwgY2hpbGRyZW4sIHNoYXBlRmxhZyB9ID0gdm5vZGU7XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIG1vdmUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICB2bm9kZS5zdXNwZW5zZS5tb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgIHR5cGUubW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGludGVybmFscyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KHZub2RlLmFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcclxuICAgICAgICAgICAgbW92ZVN0YXRpY05vZGUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzaW5nbGUgbm9kZXNcclxuICAgICAgICBjb25zdCBuZWVkVHJhbnNpdGlvbiA9IG1vdmVUeXBlICE9PSAyIC8qIFJFT1JERVIgKi8gJiZcclxuICAgICAgICAgICAgc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb247XHJcbiAgICAgICAgaWYgKG5lZWRUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChtb3ZlVHlwZSA9PT0gMCAvKiBFTlRFUiAqLykge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gdHJhbnNpdGlvbi5lbnRlcihlbCksIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUsIGFmdGVyTGVhdmUgfSA9IHRyYW5zaXRpb247XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdmUgPSAoKSA9PiBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoZWwsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWxheUxlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXlMZWF2ZShlbCwgcmVtb3ZlLCBwZXJmb3JtTGVhdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybUxlYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdW5tb3VudCA9ICh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCByZWYsIGNoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIHNoYXBlRmxhZywgcGF0Y2hGbGFnLCBkaXJzIH0gPSB2bm9kZTtcclxuICAgICAgICAvLyB1bnNldCByZWZcclxuICAgICAgICBpZiAocmVmICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8pIHtcclxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5kZWFjdGl2YXRlKHZub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzaG91bGRJbnZva2VEaXJzID0gc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmIGRpcnM7XHJcbiAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVVbm1vdW50KSkge1xyXG4gICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIHVubW91bnRDb21wb25lbnQodm5vZGUuY29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuc3VzcGVuc2UudW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRJbnZva2VEaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVVbm1vdW50Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50eXBlLnJlbW92ZSh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkLCBpbnRlcm5hbHMsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkeW5hbWljQ2hpbGRyZW4gJiZcclxuICAgICAgICAgICAgICAgIC8vICMxMTUzOiBmYXN0IHBhdGggc2hvdWxkIG5vdCBiZSB0YWtlbiBmb3Igbm9uLXN0YWJsZSAodi1mb3IpIGZyYWdtZW50c1xyXG4gICAgICAgICAgICAgICAgKHR5cGUgIT09IEZyYWdtZW50IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZhc3QgcGF0aCBmb3IgYmxvY2sgbm9kZXM6IG9ubHkgbmVlZCB0byB1bm1vdW50IGR5bmFtaWMgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oZHluYW1pY0NoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHR5cGUgPT09IEZyYWdtZW50ICYmXHJcbiAgICAgICAgICAgICAgICAocGF0Y2hGbGFnICYgMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnICYgMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi8pKSB8fFxyXG4gICAgICAgICAgICAgICAgKCFvcHRpbWl6ZWQgJiYgc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkb1JlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKHZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVVbm1vdW50ZWQpIHx8IHNob3VsZEludm9rZURpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIHNob3VsZEludm9rZURpcnMgJiZcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICd1bm1vdW50ZWQnKTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBlbCwgYW5jaG9yLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgcmVtb3ZlRnJhZ21lbnQoZWwsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xyXG4gICAgICAgICAgICByZW1vdmVTdGF0aWNOb2RlKHZub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwZXJmb3JtUmVtb3ZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGVsKTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkICYmIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5hZnRlckxlYXZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgdHJhbnNpdGlvbiAmJlxyXG4gICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4gbGVhdmUoZWwsIHBlcmZvcm1SZW1vdmUpO1xyXG4gICAgICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsYXlMZWF2ZSh2bm9kZS5lbCwgcGVyZm9ybVJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwZXJmb3JtUmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZUZyYWdtZW50ID0gKGN1ciwgZW5kKSA9PiB7XHJcbiAgICAgICAgLy8gRm9yIGZyYWdtZW50cywgZGlyZWN0bHkgcmVtb3ZlIGFsbCBjb250YWluZWQgRE9NIG5vZGVzLlxyXG4gICAgICAgIC8vIChmcmFnbWVudCBjaGlsZCBub2RlcyBjYW5ub3QgaGF2ZSB0cmFuc2l0aW9uKVxyXG4gICAgICAgIGxldCBuZXh0O1xyXG4gICAgICAgIHdoaWxlIChjdXIgIT09IGVuZCkge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGN1cik7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoY3VyKTtcclxuICAgICAgICAgICAgY3VyID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdFJlbW92ZShlbmQpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnRDb21wb25lbnQgPSAoaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IGJ1bSwgZWZmZWN0cywgdXBkYXRlLCBzdWJUcmVlLCB1bSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgLy8gYmVmb3JlVW5tb3VudCBob29rXHJcbiAgICAgICAgaWYgKGJ1bSkge1xyXG4gICAgICAgICAgICBpbnZva2VBcnJheUZucyhidW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWZmZWN0cykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVmZmVjdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHN0b3AoZWZmZWN0c1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdXBkYXRlIG1heSBiZSBudWxsIGlmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgaXRzIGFzeW5jXHJcbiAgICAgICAgLy8gc2V0dXAgaGFzIHJlc29sdmVkLlxyXG4gICAgICAgIGlmICh1cGRhdGUpIHtcclxuICAgICAgICAgICAgc3RvcCh1cGRhdGUpO1xyXG4gICAgICAgICAgICB1bm1vdW50KHN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1bm1vdW50ZWQgaG9va1xyXG4gICAgICAgIGlmICh1bSkge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodW0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAvLyBBIGNvbXBvbmVudCB3aXRoIGFzeW5jIGRlcCBpbnNpZGUgYSBwZW5kaW5nIHN1c3BlbnNlIGlzIHVubW91bnRlZCBiZWZvcmVcclxuICAgICAgICAvLyBpdHMgYXN5bmMgZGVwIHJlc29sdmVzLiBUaGlzIHNob3VsZCByZW1vdmUgdGhlIGRlcCBmcm9tIHRoZSBzdXNwZW5zZSwgYW5kXHJcbiAgICAgICAgLy8gY2F1c2UgdGhlIHN1c3BlbnNlIHRvIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgdGhhdCB3YXMgdGhlIGxhc3QgZGVwLlxyXG4gICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJlxyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmXHJcbiAgICAgICAgICAgICFwYXJlbnRTdXNwZW5zZS5pc1VubW91bnRlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5hc3luY0RlcCAmJlxyXG4gICAgICAgICAgICAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5zdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UsIHN0YXJ0ID0gMCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHVubW91bnQoY2hpbGRyZW5baV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXROZXh0SG9zdE5vZGUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBob3N0TmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCkpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbmRlciA9ICh2bm9kZSwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNvbnRhaW5lci5fdm5vZGUsIG51bGwsIG51bGwsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaChjb250YWluZXIuX3Zub2RlIHx8IG51bGwsIHZub2RlLCBjb250YWluZXIsIG51bGwsIG51bGwsIG51bGwsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcclxuICAgICAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaW50ZXJuYWxzID0ge1xyXG4gICAgICAgIHA6IHBhdGNoLFxyXG4gICAgICAgIHVtOiB1bm1vdW50LFxyXG4gICAgICAgIG06IG1vdmUsXHJcbiAgICAgICAgcjogcmVtb3ZlLFxyXG4gICAgICAgIG10OiBtb3VudENvbXBvbmVudCxcclxuICAgICAgICBtYzogbW91bnRDaGlsZHJlbixcclxuICAgICAgICBwYzogcGF0Y2hDaGlsZHJlbixcclxuICAgICAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcclxuICAgICAgICBuOiBnZXROZXh0SG9zdE5vZGUsXHJcbiAgICAgICAgbzogb3B0aW9uc1xyXG4gICAgfTtcclxuICAgIGxldCBoeWRyYXRlO1xyXG4gICAgbGV0IGh5ZHJhdGVOb2RlO1xyXG4gICAgaWYgKGNyZWF0ZUh5ZHJhdGlvbkZucykge1xyXG4gICAgICAgIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV0gPSBjcmVhdGVIeWRyYXRpb25GbnMoaW50ZXJuYWxzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVuZGVyLFxyXG4gICAgICAgIGh5ZHJhdGUsXHJcbiAgICAgICAgY3JlYXRlQXBwOiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpbnZva2VWTm9kZUhvb2soaG9vaywgaW5zdGFuY2UsIHZub2RlLCBwcmV2Vk5vZGUgPSBudWxsKSB7XHJcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgNyAvKiBWTk9ERV9IT09LICovLCBbXHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgcHJldlZOb2RlXHJcbiAgICBdKTtcclxufVxyXG4vKipcclxuICogIzExNTZcclxuICogV2hlbiBhIGNvbXBvbmVudCBpcyBITVItZW5hYmxlZCwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBhbGwgc3RhdGljIG5vZGVzXHJcbiAqIGluc2lkZSBhIGJsb2NrIGFsc28gaW5oZXJpdCB0aGUgRE9NIGVsZW1lbnQgZnJvbSB0aGUgcHJldmlvdXMgdHJlZSBzbyB0aGF0XHJcbiAqIEhNUiB1cGRhdGVzICh3aGljaCBhcmUgZnVsbCB1cGRhdGVzKSBjYW4gcmV0cmlldmUgdGhlIGVsZW1lbnQgZm9yIHBhdGNoaW5nLlxyXG4gKlxyXG4gKiAjMjA4MFxyXG4gKiBJbnNpZGUga2V5ZWQgYHRlbXBsYXRlYCBmcmFnbWVudCBzdGF0aWMgY2hpbGRyZW4sIGlmIGEgZnJhZ21lbnQgaXMgbW92ZWQsXHJcbiAqIHRoZSBjaGlsZHJlbiB3aWxsIGFsd2F5cyBtb3ZlZCBzbyB0aGF0IG5lZWQgaW5oZXJpdCBlbCBmb3JtIHByZXZpb3VzIG5vZGVzXHJcbiAqIHRvIGVuc3VyZSBjb3JyZWN0IG1vdmVkIHBvc2l0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHNoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgY2gxID0gbjEuY2hpbGRyZW47XHJcbiAgICBjb25zdCBjaDIgPSBuMi5jaGlsZHJlbjtcclxuICAgIGlmIChpc0FycmF5KGNoMSkgJiYgaXNBcnJheShjaDIpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaDEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBvbmx5IGNhbGxlZCBpbiB0aGUgb3B0aW1pemVkIHBhdGggc28gYXJyYXkgY2hpbGRyZW4gYXJlXHJcbiAgICAgICAgICAgIC8vIGd1YXJhbnRlZWQgdG8gYmUgdm5vZGVzXHJcbiAgICAgICAgICAgIGNvbnN0IGMxID0gY2gxW2ldO1xyXG4gICAgICAgICAgICBsZXQgYzIgPSBjaDJbaV07XHJcbiAgICAgICAgICAgIGlmIChjMi5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiYgIWMyLmR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGMyLnBhdGNoRmxhZyA8PSAwIHx8IGMyLnBhdGNoRmxhZyA9PT0gMzIgLyogSFlEUkFURV9FVkVOVFMgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjMiA9IGNoMltpXSA9IGNsb25lSWZNb3VudGVkKGNoMltpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYzIuZWwgPSBjMS5lbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghc2hhbGxvdylcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKGMxLCBjMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYWxzbyBpbmhlcml0IGZvciBjb21tZW50IG5vZGVzLCBidXQgbm90IHBsYWNlaG9sZGVycyAoZS5nLiB2LWlmIHdoaWNoXHJcbiAgICAgICAgICAgIC8vIHdvdWxkIGhhdmUgcmVjZWl2ZWQgLmVsIGR1cmluZyBibG9jayBwYXRjaClcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjMi50eXBlID09PSBDb21tZW50JDEgJiYgIWMyLmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvbmdlc3RfaW5jcmVhc2luZ19zdWJzZXF1ZW5jZVxyXG5mdW5jdGlvbiBnZXRTZXF1ZW5jZShhcnIpIHtcclxuICAgIGNvbnN0IHAgPSBhcnIuc2xpY2UoKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFswXTtcclxuICAgIGxldCBpLCBqLCB1LCB2LCBjO1xyXG4gICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGFyckkgPSBhcnJbaV07XHJcbiAgICAgICAgaWYgKGFyckkgIT09IDApIHtcclxuICAgICAgICAgICAgaiA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPCBhcnJJKSB7XHJcbiAgICAgICAgICAgICAgICBwW2ldID0gajtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdSA9IDA7XHJcbiAgICAgICAgICAgIHYgPSByZXN1bHQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgd2hpbGUgKHUgPCB2KSB7XHJcbiAgICAgICAgICAgICAgICBjID0gKCh1ICsgdikgLyAyKSB8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IGMgKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFyckkgPCBhcnJbcmVzdWx0W3VdXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbdV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdSA9IHJlc3VsdC5sZW5ndGg7XHJcbiAgICB2ID0gcmVzdWx0W3UgLSAxXTtcclxuICAgIHdoaWxlICh1LS0gPiAwKSB7XHJcbiAgICAgICAgcmVzdWx0W3VdID0gdjtcclxuICAgICAgICB2ID0gcFt2XTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cblxuY29uc3QgaXNUZWxlcG9ydCA9ICh0eXBlKSA9PiB0eXBlLl9faXNUZWxlcG9ydDtcclxuY29uc3QgaXNUZWxlcG9ydERpc2FibGVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuZGlzYWJsZWQgPT09ICcnKTtcclxuY29uc3QgaXNUYXJnZXRTVkcgPSAodGFyZ2V0KSA9PiB0eXBlb2YgU1ZHRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcclxuY29uc3QgcmVzb2x2ZVRhcmdldCA9IChwcm9wcywgc2VsZWN0KSA9PiB7XHJcbiAgICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHByb3BzICYmIHByb3BzLnRvO1xyXG4gICAgaWYgKGlzU3RyaW5nKHRhcmdldFNlbGVjdG9yKSkge1xyXG4gICAgICAgIGlmICghc2VsZWN0KSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQ3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmluZyB0YXJnZXQgZm9yIFRlbGVwb3J0cy4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYChtaXNzaW5nIHF1ZXJ5U2VsZWN0b3IgcmVuZGVyZXIgb3B0aW9uKWApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdCh0YXJnZXRTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbG9jYXRlIFRlbGVwb3J0IHRhcmdldCB3aXRoIHNlbGVjdG9yIFwiJHt0YXJnZXRTZWxlY3Rvcn1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBOb3RlIHRoZSB0YXJnZXQgZWxlbWVudCBtdXN0IGV4aXN0IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgLSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGkuZS4gdGhlIHRhcmdldCBjYW5ub3QgYmUgcmVuZGVyZWQgYnkgdGhlIGNvbXBvbmVudCBpdHNlbGYsIGFuZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGlkZWFsbHkgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGVudGlyZSBWdWUgY29tcG9uZW50IHRyZWUuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICF0YXJnZXRTZWxlY3RvciAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBJbnZhbGlkIFRlbGVwb3J0IHRhcmdldDogJHt0YXJnZXRTZWxlY3Rvcn1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFNlbGVjdG9yO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XHJcbiAgICBfX2lzVGVsZXBvcnQ6IHRydWUsXHJcbiAgICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKSB7XHJcbiAgICAgICAgY29uc3QgeyBtYzogbW91bnRDaGlsZHJlbiwgcGM6IHBhdGNoQ2hpbGRyZW4sIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLCBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9IH0gPSBpbnRlcm5hbHM7XHJcbiAgICAgICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjIucHJvcHMpO1xyXG4gICAgICAgIGxldCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiB9ID0gbjI7XHJcbiAgICAgICAgLy8gIzMzMDJcclxuICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBpbnNlcnQgYW5jaG9ycyBpbiB0aGUgbWFpbiB2aWV3XHJcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gKG4yLmVsID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbW1lbnQoJ3RlbGVwb3J0IHN0YXJ0JylcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBjb25zdCBtYWluQW5jaG9yID0gKG4yLmFuY2hvciA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDb21tZW50KCd0ZWxlcG9ydCBlbmQnKVxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgICAgIGluc2VydChwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBpbnNlcnQobWFpbkFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAobjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSAobjIudGFyZ2V0QW5jaG9yID0gY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnQodGFyZ2V0QW5jaG9yLCB0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgLy8gIzI2NTIgd2UgY291bGQgYmUgdGVsZXBvcnRpbmcgZnJvbSBhIG5vbi1TVkcgdHJlZSBpbnRvIGFuIFNWRyB0cmVlXHJcbiAgICAgICAgICAgICAgICBpc1NWRyA9IGlzU1ZHIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gbW91bnQ6JywgdGFyZ2V0LCBgKCR7dHlwZW9mIHRhcmdldH0pYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbW91bnQgPSAoY29udGFpbmVyLCBhbmNob3IpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFRlbGVwb3J0ICphbHdheXMqIGhhcyBBcnJheSBjaGlsZHJlbi4gVGhpcyBpcyBlbmZvcmNlZCBpbiBib3RoIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZXIgYW5kIHZub2RlIGNoaWxkcmVuIG5vcm1hbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudChjb250YWluZXIsIG1haW5BbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgY29udGVudFxyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBjb25zdCBtYWluQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xLmFuY2hvcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChuMi50YXJnZXQgPSBuMS50YXJnZXQpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSAobjIudGFyZ2V0QW5jaG9yID0gbjEudGFyZ2V0QW5jaG9yKTtcclxuICAgICAgICAgICAgY29uc3Qgd2FzRGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjEucHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29udGFpbmVyID0gd2FzRGlzYWJsZWQgPyBjb250YWluZXIgOiB0YXJnZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3IgPSB3YXNEaXNhYmxlZCA/IG1haW5BbmNob3IgOiB0YXJnZXRBbmNob3I7XHJcbiAgICAgICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KTtcclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgLy8gZmFzdCBwYXRoIHdoZW4gdGhlIHRlbGVwb3J0IGhhcHBlbnMgdG8gYmUgYSBibG9jayByb290XHJcbiAgICAgICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGN1cnJlbnRDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpbiBibG9jayB0cmVlIG1vZGUgd2UgbmVlZCB0byBtYWtlIHN1cmUgYWxsIHJvb3QtbGV2ZWwgbm9kZXNcclxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSB0ZWxlcG9ydCBpbmhlcml0IHByZXZpb3VzIERPTSByZWZlcmVuY2VzIHNvIHRoYXQgdGhleSBjYW5cclxuICAgICAgICAgICAgICAgIC8vIGJlIG1vdmVkIGluIGZ1dHVyZSBwYXRjaGVzLlxyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjdXJyZW50Q29udGFpbmVyLCBjdXJyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXdhc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlZCAtPiBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byBtYWluIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgY29udGFpbmVyLCBtYWluQW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVE9HR0xFICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHRhcmdldCBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICBpZiAoKG4yLnByb3BzICYmIG4yLnByb3BzLnRvKSAhPT0gKG4xLnByb3BzICYmIG4xLnByb3BzLnRvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSAobjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgbmV4dFRhcmdldCwgbnVsbCwgaW50ZXJuYWxzLCAwIC8qIFRBUkdFVF9DSEFOR0UgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOicsIHRhcmdldCwgYCgke3R5cGVvZiB0YXJnZXR9KWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdhc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgLT4gZW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byB0ZWxlcG9ydCB0YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIHRhcmdldCwgdGFyZ2V0QW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVE9HR0xFICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgeyB1bTogdW5tb3VudCwgbzogeyByZW1vdmU6IGhvc3RSZW1vdmUgfSB9LCBkb1JlbW92ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgYW5jaG9yLCB0YXJnZXRBbmNob3IsIHRhcmdldCwgcHJvcHMgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZSh0YXJnZXRBbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhbiB1bm1vdW50ZWQgdGVsZXBvcnQgc2hvdWxkIGFsd2F5cyByZW1vdmUgaXRzIGNoaWxkcmVuIGlmIG5vdCBkaXNhYmxlZFxyXG4gICAgICAgIGlmIChkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGFuY2hvcik7XHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChjaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSwgISFjaGlsZC5keW5hbWljQ2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdmU6IG1vdmVUZWxlcG9ydCxcclxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVUZWxlcG9ydFxyXG59O1xyXG5mdW5jdGlvbiBtb3ZlVGVsZXBvcnQodm5vZGUsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCB7IG86IHsgaW5zZXJ0IH0sIG06IG1vdmUgfSwgbW92ZVR5cGUgPSAyIC8qIFJFT1JERVIgKi8pIHtcclxuICAgIC8vIG1vdmUgdGFyZ2V0IGFuY2hvciBpZiB0aGlzIGlzIGEgdGFyZ2V0IGNoYW5nZS5cclxuICAgIGlmIChtb3ZlVHlwZSA9PT0gMCAvKiBUQVJHRVRfQ0hBTkdFICovKSB7XHJcbiAgICAgICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBlbCwgYW5jaG9yLCBzaGFwZUZsYWcsIGNoaWxkcmVuLCBwcm9wcyB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMiAvKiBSRU9SREVSICovO1xyXG4gICAgLy8gbW92ZSBtYWluIHZpZXcgYW5jaG9yIGlmIHRoaXMgaXMgYSByZS1vcmRlci5cclxuICAgIGlmIChpc1Jlb3JkZXIpIHtcclxuICAgICAgICBpbnNlcnQoZWwsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxuICAgIC8vIGlmIHRoaXMgaXMgYSByZS1vcmRlciBhbmQgdGVsZXBvcnQgaXMgZW5hYmxlZCAoY29udGVudCBpcyBpbiB0YXJnZXQpXHJcbiAgICAvLyBkbyBub3QgbW92ZSBjaGlsZHJlbi4gU28gdGhlIG9wcG9zaXRlIGlzOiBvbmx5IG1vdmUgY2hpbGRyZW4gaWYgdGhpc1xyXG4gICAgLy8gaXMgbm90IGEgcmVvcmRlciwgb3IgdGhlIHRlbGVwb3J0IGlzIGRpc2FibGVkXHJcbiAgICBpZiAoIWlzUmVvcmRlciB8fCBpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XHJcbiAgICAgICAgLy8gVGVsZXBvcnQgaGFzIGVpdGhlciBBcnJheSBjaGlsZHJlbiBvciBubyBjaGlsZHJlbi5cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIDIgLyogUkVPUkRFUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBtb3ZlIG1haW4gdmlldyBhbmNob3IgaWYgdGhpcyBpcyBhIHJlLW9yZGVyLlxyXG4gICAgaWYgKGlzUmVvcmRlcikge1xyXG4gICAgICAgIGluc2VydChhbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoeWRyYXRlVGVsZXBvcnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IG86IHsgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHF1ZXJ5U2VsZWN0b3IgfSB9LCBoeWRyYXRlQ2hpbGRyZW4pIHtcclxuICAgIGNvbnN0IHRhcmdldCA9ICh2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KHZub2RlLnByb3BzLCBxdWVyeVNlbGVjdG9yKSk7XHJcbiAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gaWYgbXVsdGlwbGUgdGVsZXBvcnRzIHJlbmRlcmVkIHRvIHRoZSBzYW1lIHRhcmdldCBlbGVtZW50LCB3ZSBuZWVkIHRvXHJcbiAgICAgICAgLy8gcGljayB1cCBmcm9tIHdoZXJlIHRoZSBsYXN0IHRlbGVwb3J0IGZpbmlzaGVkIGluc3RlYWQgb2YgdGhlIGZpcnN0IG5vZGVcclxuICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gdGFyZ2V0Ll9scGEgfHwgdGFyZ2V0LmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1RlbGVwb3J0RGlzYWJsZWQodm5vZGUucHJvcHMpKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4obmV4dFNpYmxpbmcobm9kZSksIHZub2RlLCBwYXJlbnROb2RlKG5vZGUpLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4odGFyZ2V0Tm9kZSwgdm5vZGUsIHRhcmdldCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhcmdldC5fbHBhID1cclxuICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZS5hbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yKTtcclxufVxyXG4vLyBGb3JjZS1jYXN0ZWQgcHVibGljIHR5cGluZyBmb3IgaCBhbmQgVFNYIHByb3BzIGluZmVyZW5jZVxyXG5jb25zdCBUZWxlcG9ydCA9IFRlbGVwb3J0SW1wbDtcblxuY29uc3QgQ09NUE9ORU5UUyA9ICdjb21wb25lbnRzJztcclxuY29uc3QgRElSRUNUSVZFUyA9ICdkaXJlY3RpdmVzJztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KG5hbWUsIG1heWJlU2VsZlJlZmVyZW5jZSkge1xyXG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBuYW1lLCB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UpIHx8IG5hbWU7XHJcbn1cclxuY29uc3QgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCA9IFN5bWJvbCgpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgaWYgKGlzU3RyaW5nKGNvbXBvbmVudCkpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIGNvbXBvbmVudCwgZmFsc2UpIHx8IGNvbXBvbmVudDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGludmFsaWQgdHlwZXMgd2lsbCBmYWxsdGhyb3VnaCB0byBjcmVhdGVWTm9kZSBhbmQgcmFpc2Ugd2FybmluZ1xyXG4gICAgICAgIHJldHVybiAoY29tcG9uZW50IHx8IE5VTExfRFlOQU1JQ19DT01QT05FTlQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZURpcmVjdGl2ZShuYW1lKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KERJUkVDVElWRVMsIG5hbWUpO1xyXG59XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB8fCBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgICAgIC8vIGV4cGxpY2l0IHNlbGYgbmFtZSBoYXMgaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgICAgIGlmICh0eXBlID09PSBDT01QT05FTlRTKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGZOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoc2VsZk5hbWUgJiZcclxuICAgICAgICAgICAgICAgIChzZWxmTmFtZSA9PT0gbmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGZOYW1lID09PSBjYW1lbGl6ZShuYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGZOYW1lID09PSBjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb21wb25lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzID0gXHJcbiAgICAgICAgLy8gbG9jYWwgcmVnaXN0cmF0aW9uXHJcbiAgICAgICAgLy8gY2hlY2sgaW5zdGFuY2VbdHlwZV0gZmlyc3Qgd2hpY2ggaXMgcmVzb2x2ZWQgZm9yIG9wdGlvbnMgQVBJXHJcbiAgICAgICAgcmVzb2x2ZShpbnN0YW5jZVt0eXBlXSB8fCBDb21wb25lbnRbdHlwZV0sIG5hbWUpIHx8XHJcbiAgICAgICAgICAgIC8vIGdsb2JhbCByZWdpc3RyYXRpb25cclxuICAgICAgICAgICAgcmVzb2x2ZShpbnN0YW5jZS5hcHBDb250ZXh0W3R5cGVdLCBuYW1lKTtcclxuICAgICAgICBpZiAoIXJlcyAmJiBtYXliZVNlbGZSZWZlcmVuY2UpIHtcclxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gaW1wbGljaXQgc2VsZi1yZWZlcmVuY2VcclxuICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byByZXNvbHZlICR7dHlwZS5zbGljZSgwLCAtMSl9OiAke25hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGByZXNvbHZlJHtjYXBpdGFsaXplKHR5cGUuc2xpY2UoMCwgLTEpKX0gYCArXHJcbiAgICAgICAgICAgIGBjYW4gb25seSBiZSB1c2VkIGluIHJlbmRlcigpIG9yIHNldHVwKCkuYCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZShyZWdpc3RyeSwgbmFtZSkge1xyXG4gICAgcmV0dXJuIChyZWdpc3RyeSAmJlxyXG4gICAgICAgIChyZWdpc3RyeVtuYW1lXSB8fFxyXG4gICAgICAgICAgICByZWdpc3RyeVtjYW1lbGl6ZShuYW1lKV0gfHxcclxuICAgICAgICAgICAgcmVnaXN0cnlbY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSldKSk7XHJcbn1cblxuY29uc3QgRnJhZ21lbnQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ0ZyYWdtZW50JyA6IHVuZGVmaW5lZCk7XHJcbmNvbnN0IFRleHQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ1RleHQnIDogdW5kZWZpbmVkKTtcclxuY29uc3QgQ29tbWVudCQxID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdDb21tZW50JyA6IHVuZGVmaW5lZCk7XHJcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnU3RhdGljJyA6IHVuZGVmaW5lZCk7XHJcbi8vIFNpbmNlIHYtaWYgYW5kIHYtZm9yIGFyZSB0aGUgdHdvIHBvc3NpYmxlIHdheXMgbm9kZSBzdHJ1Y3R1cmUgY2FuIGR5bmFtaWNhbGx5XHJcbi8vIGNoYW5nZSwgb25jZSB3ZSBjb25zaWRlciB2LWlmIGJyYW5jaGVzIGFuZCBlYWNoIHYtZm9yIGZyYWdtZW50IGEgYmxvY2ssIHdlXHJcbi8vIGNhbiBkaXZpZGUgYSB0ZW1wbGF0ZSBpbnRvIG5lc3RlZCBibG9ja3MsIGFuZCB3aXRoaW4gZWFjaCBibG9jayB0aGUgbm9kZVxyXG4vLyBzdHJ1Y3R1cmUgd291bGQgYmUgc3RhYmxlLiBUaGlzIGFsbG93cyB1cyB0byBza2lwIG1vc3QgY2hpbGRyZW4gZGlmZmluZ1xyXG4vLyBhbmQgb25seSB3b3JyeSBhYm91dCB0aGUgZHluYW1pYyBub2RlcyAoaW5kaWNhdGVkIGJ5IHBhdGNoIGZsYWdzKS5cclxuY29uc3QgYmxvY2tTdGFjayA9IFtdO1xyXG5sZXQgY3VycmVudEJsb2NrID0gbnVsbDtcclxuLyoqXHJcbiAqIE9wZW4gYSBibG9jay5cclxuICogVGhpcyBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYC4gSXQgY2Fubm90IGJlIHBhcnQgb2YgYGNyZWF0ZUJsb2NrYFxyXG4gKiBiZWNhdXNlIHRoZSBjaGlsZHJlbiBvZiB0aGUgYmxvY2sgYXJlIGV2YWx1YXRlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYCBpdHNlbGZcclxuICogaXMgY2FsbGVkLiBUaGUgZ2VuZXJhdGVkIGNvZGUgdHlwaWNhbGx5IGxvb2tzIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gKiAgIHJldHVybiAob3BlbkJsb2NrKCksY3JlYXRlQmxvY2soJ2RpdicsIG51bGwsIFsuLi5dKSlcclxuICogfVxyXG4gKiBgYGBcclxuICogZGlzYWJsZVRyYWNraW5nIGlzIHRydWUgd2hlbiBjcmVhdGluZyBhIHYtZm9yIGZyYWdtZW50IGJsb2NrLCBzaW5jZSBhIHYtZm9yXHJcbiAqIGZyYWdtZW50IGFsd2F5cyBkaWZmcyBpdHMgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBvcGVuQmxvY2soZGlzYWJsZVRyYWNraW5nID0gZmFsc2UpIHtcclxuICAgIGJsb2NrU3RhY2sucHVzaCgoY3VycmVudEJsb2NrID0gZGlzYWJsZVRyYWNraW5nID8gbnVsbCA6IFtdKSk7XHJcbn1cclxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcclxuICAgIGJsb2NrU3RhY2sucG9wKCk7XHJcbiAgICBjdXJyZW50QmxvY2sgPSBibG9ja1N0YWNrW2Jsb2NrU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbDtcclxufVxyXG4vLyBXaGV0aGVyIHdlIHNob3VsZCBiZSB0cmFja2luZyBkeW5hbWljIGNoaWxkIG5vZGVzIGluc2lkZSBhIGJsb2NrLlxyXG4vLyBPbmx5IHRyYWNrcyB3aGVuIHRoaXMgdmFsdWUgaXMgPiAwXHJcbi8vIFdlIGFyZSBub3QgdXNpbmcgYSBzaW1wbGUgYm9vbGVhbiBiZWNhdXNlIHRoaXMgdmFsdWUgbWF5IG5lZWQgdG8gYmVcclxuLy8gaW5jcmVtZW50ZWQvZGVjcmVtZW50ZWQgYnkgbmVzdGVkIHVzYWdlIG9mIHYtb25jZSAoc2VlIGJlbG93KVxyXG5sZXQgaXNCbG9ja1RyZWVFbmFibGVkID0gMTtcclxuLyoqXHJcbiAqIEJsb2NrIHRyYWNraW5nIHNvbWV0aW1lcyBuZWVkcyB0byBiZSBkaXNhYmxlZCwgZm9yIGV4YW1wbGUgZHVyaW5nIHRoZVxyXG4gKiBjcmVhdGlvbiBvZiBhIHRyZWUgdGhhdCBuZWVkcyB0byBiZSBjYWNoZWQgYnkgdi1vbmNlLiBUaGUgY29tcGlsZXIgZ2VuZXJhdGVzXHJcbiAqIGNvZGUgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGAganNcclxuICogX2NhY2hlWzFdIHx8IChcclxuICogICBzZXRCbG9ja1RyYWNraW5nKC0xKSxcclxuICogICBfY2FjaGVbMV0gPSBjcmVhdGVWTm9kZSguLi4pLFxyXG4gKiAgIHNldEJsb2NrVHJhY2tpbmcoMSksXHJcbiAqICAgX2NhY2hlWzFdXHJcbiAqIClcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRCbG9ja1RyYWNraW5nKHZhbHVlKSB7XHJcbiAgICBpc0Jsb2NrVHJlZUVuYWJsZWQgKz0gdmFsdWU7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGJsb2NrIHJvb3Qgdm5vZGUuIFRha2VzIHRoZSBzYW1lIGV4YWN0IGFyZ3VtZW50cyBhcyBgY3JlYXRlVk5vZGVgLlxyXG4gKiBBIGJsb2NrIHJvb3Qga2VlcHMgdHJhY2sgb2YgZHluYW1pYyBub2RlcyB3aXRoaW4gdGhlIGJsb2NrIGluIHRoZVxyXG4gKiBgZHluYW1pY0NoaWxkcmVuYCBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMpIHtcclxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgdHJ1ZSAvKiBpc0Jsb2NrOiBwcmV2ZW50IGEgYmxvY2sgZnJvbSB0cmFja2luZyBpdHNlbGYgKi8pO1xyXG4gICAgLy8gc2F2ZSBjdXJyZW50IGJsb2NrIGNoaWxkcmVuIG9uIHRoZSBibG9jayB2bm9kZVxyXG4gICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID1cclxuICAgICAgICBpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwID8gY3VycmVudEJsb2NrIHx8IEVNUFRZX0FSUiA6IG51bGw7XHJcbiAgICAvLyBjbG9zZSBibG9ja1xyXG4gICAgY2xvc2VCbG9jaygpO1xyXG4gICAgLy8gYSBibG9jayBpcyBhbHdheXMgZ29pbmcgdG8gYmUgcGF0Y2hlZCwgc28gdHJhY2sgaXQgYXMgYSBjaGlsZCBvZiBpdHNcclxuICAgIC8vIHBhcmVudCBibG9ja1xyXG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XHJcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIGlzVk5vZGUodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlLl9fdl9pc1ZOb2RlID09PSB0cnVlIDogZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgIG4yLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovICYmXHJcbiAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmhhcyhuMi50eXBlKSkge1xyXG4gICAgICAgIC8vIEhNUiBvbmx5OiBpZiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGhvdC11cGRhdGVkLCBmb3JjZSBhIHJlbG9hZC5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbjEudHlwZSA9PT0gbjIudHlwZSAmJiBuMS5rZXkgPT09IG4yLmtleTtcclxufVxyXG5sZXQgdm5vZGVBcmdzVHJhbnNmb3JtZXI7XHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBBUEkgZm9yIHJlZ2lzdGVyaW5nIGFuIGFyZ3VtZW50cyB0cmFuc2Zvcm0gZm9yIGNyZWF0ZVZOb2RlXHJcbiAqIHVzZWQgZm9yIGNyZWF0aW5nIHN0dWJzIGluIHRoZSB0ZXN0LXV0aWxzXHJcbiAqIEl0IGlzICppbnRlcm5hbCogYnV0IG5lZWRzIHRvIGJlIGV4cG9zZWQgZm9yIHRlc3QtdXRpbHMgdG8gcGljayB1cCBwcm9wZXJcclxuICogdHlwaW5nc1xyXG4gKi9cclxuZnVuY3Rpb24gdHJhbnNmb3JtVk5vZGVBcmdzKHRyYW5zZm9ybWVyKSB7XHJcbiAgICB2bm9kZUFyZ3NUcmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyO1xyXG59XHJcbmNvbnN0IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gPSAoLi4uYXJncykgPT4ge1xyXG4gICAgcmV0dXJuIF9jcmVhdGVWTm9kZSguLi4odm5vZGVBcmdzVHJhbnNmb3JtZXJcclxuICAgICAgICA/IHZub2RlQXJnc1RyYW5zZm9ybWVyKGFyZ3MsIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSlcclxuICAgICAgICA6IGFyZ3MpKTtcclxufTtcclxuY29uc3QgSW50ZXJuYWxPYmplY3RLZXkgPSBgX192SW50ZXJuYWxgO1xyXG5jb25zdCBub3JtYWxpemVLZXkgPSAoeyBrZXkgfSkgPT4ga2V5ICE9IG51bGwgPyBrZXkgOiBudWxsO1xyXG5jb25zdCBub3JtYWxpemVSZWYgPSAoeyByZWYgfSkgPT4ge1xyXG4gICAgcmV0dXJuIChyZWYgIT0gbnVsbFxyXG4gICAgICAgID8gaXNTdHJpbmcocmVmKSB8fCBpc1JlZihyZWYpIHx8IGlzRnVuY3Rpb24kMShyZWYpXHJcbiAgICAgICAgICAgID8geyBpOiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIHI6IHJlZiB9XHJcbiAgICAgICAgICAgIDogcmVmXHJcbiAgICAgICAgOiBudWxsKTtcclxufTtcclxuY29uc3QgY3JlYXRlVk5vZGUgPSAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICA/IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm1cclxuICAgIDogX2NyZWF0ZVZOb2RlKTtcclxuZnVuY3Rpb24gX2NyZWF0ZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBpc0Jsb2NrTm9kZSA9IGZhbHNlKSB7XHJcbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXR5cGUpIHtcclxuICAgICAgICAgICAgd2FybihgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHR5cGUgPSBDb21tZW50JDE7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNWTm9kZSh0eXBlKSkge1xyXG4gICAgICAgIC8vIGNyZWF0ZVZOb2RlIHJlY2VpdmluZyBhbiBleGlzdGluZyB2bm9kZS4gVGhpcyBoYXBwZW5zIGluIGNhc2VzIGxpa2VcclxuICAgICAgICAvLyA8Y29tcG9uZW50IDppcz1cInZub2RlXCIvPlxyXG4gICAgICAgIC8vICMyMDc4IG1ha2Ugc3VyZSB0byBtZXJnZSByZWZzIGR1cmluZyB0aGUgY2xvbmUgaW5zdGVhZCBvZiBvdmVyd3JpdGluZyBpdFxyXG4gICAgICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodHlwZSwgcHJvcHMsIHRydWUgLyogbWVyZ2VSZWY6IHRydWUgKi8pO1xyXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgICAgICBub3JtYWxpemVDaGlsZHJlbihjbG9uZWQsIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcclxuICAgIH1cclxuICAgIC8vIGNsYXNzIGNvbXBvbmVudCBub3JtYWxpemF0aW9uLlxyXG4gICAgaWYgKGlzQ2xhc3NDb21wb25lbnQodHlwZSkpIHtcclxuICAgICAgICB0eXBlID0gdHlwZS5fX3ZjY09wdHM7XHJcbiAgICB9XHJcbiAgICAvLyBjbGFzcyAmIHN0eWxlIG5vcm1hbGl6YXRpb24uXHJcbiAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAvLyBmb3IgcmVhY3RpdmUgb3IgcHJveHkgb2JqZWN0cywgd2UgbmVlZCB0byBjbG9uZSBpdCB0byBlbmFibGUgbXV0YXRpb24uXHJcbiAgICAgICAgaWYgKGlzUHJveHkocHJvcHMpIHx8IEludGVybmFsT2JqZWN0S2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgIHByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xyXG4gICAgICAgIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XHJcbiAgICAgICAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNPYmplY3QkMShzdHlsZSkpIHtcclxuICAgICAgICAgICAgLy8gcmVhY3RpdmUgc3RhdGUgb2JqZWN0cyBuZWVkIHRvIGJlIGNsb25lZCBzaW5jZSB0aGV5IGFyZSBsaWtlbHkgdG8gYmVcclxuICAgICAgICAgICAgLy8gbXV0YXRlZFxyXG4gICAgICAgICAgICBpZiAoaXNQcm94eShzdHlsZSkgJiYgIWlzQXJyYXkoc3R5bGUpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZSA9IGV4dGVuZCh7fSwgc3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGVuY29kZSB0aGUgdm5vZGUgdHlwZSBpbmZvcm1hdGlvbiBpbnRvIGEgYml0bWFwXHJcbiAgICBjb25zdCBzaGFwZUZsYWcgPSBpc1N0cmluZyh0eXBlKVxyXG4gICAgICAgID8gMSAvKiBFTEVNRU5UICovXHJcbiAgICAgICAgOiBpc1N1c3BlbnNlKHR5cGUpXHJcbiAgICAgICAgICAgID8gMTI4IC8qIFNVU1BFTlNFICovXHJcbiAgICAgICAgICAgIDogaXNUZWxlcG9ydCh0eXBlKVxyXG4gICAgICAgICAgICAgICAgPyA2NCAvKiBURUxFUE9SVCAqL1xyXG4gICAgICAgICAgICAgICAgOiBpc09iamVjdCQxKHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbiQxKHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMiAvKiBGVU5DVElPTkFMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovICYmIGlzUHJveHkodHlwZSkpIHtcclxuICAgICAgICB0eXBlID0gdG9SYXcodHlwZSk7XHJcbiAgICAgICAgd2FybihgVnVlIHJlY2VpdmVkIGEgQ29tcG9uZW50IHdoaWNoIHdhcyBtYWRlIGEgcmVhY3RpdmUgb2JqZWN0LiBUaGlzIGNhbiBgICtcclxuICAgICAgICAgICAgYGxlYWQgdG8gdW5uZWNlc3NhcnkgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQsIGFuZCBzaG91bGQgYmUgYXZvaWRlZCBieSBgICtcclxuICAgICAgICAgICAgYG1hcmtpbmcgdGhlIGNvbXBvbmVudCB3aXRoIFxcYG1hcmtSYXdcXGAgb3IgdXNpbmcgXFxgc2hhbGxvd1JlZlxcYCBgICtcclxuICAgICAgICAgICAgYGluc3RlYWQgb2YgXFxgcmVmXFxgLmAsIGBcXG5Db21wb25lbnQgdGhhdCB3YXMgbWFkZSByZWFjdGl2ZTogYCwgdHlwZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2bm9kZSA9IHtcclxuICAgICAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcclxuICAgICAgICBfX3Zfc2tpcDogdHJ1ZSxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHByb3BzLFxyXG4gICAgICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcclxuICAgICAgICByZWY6IHByb3BzICYmIG5vcm1hbGl6ZVJlZihwcm9wcyksXHJcbiAgICAgICAgc2NvcGVJZDogY3VycmVudFNjb3BlSWQsXHJcbiAgICAgICAgc2xvdFNjb3BlSWRzOiBudWxsLFxyXG4gICAgICAgIGNoaWxkcmVuOiBudWxsLFxyXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcclxuICAgICAgICBzdXNwZW5zZTogbnVsbCxcclxuICAgICAgICBzc0NvbnRlbnQ6IG51bGwsXHJcbiAgICAgICAgc3NGYWxsYmFjazogbnVsbCxcclxuICAgICAgICBkaXJzOiBudWxsLFxyXG4gICAgICAgIHRyYW5zaXRpb246IG51bGwsXHJcbiAgICAgICAgZWw6IG51bGwsXHJcbiAgICAgICAgYW5jaG9yOiBudWxsLFxyXG4gICAgICAgIHRhcmdldDogbnVsbCxcclxuICAgICAgICB0YXJnZXRBbmNob3I6IG51bGwsXHJcbiAgICAgICAgc2hhcGVGbGFnLFxyXG4gICAgICAgIHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcHMsXHJcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuOiBudWxsLFxyXG4gICAgICAgIGFwcENvbnRleHQ6IG51bGxcclxuICAgIH07XHJcbiAgICAvLyB2YWxpZGF0ZSBrZXlcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdm5vZGUua2V5ICE9PSB2bm9kZS5rZXkpIHtcclxuICAgICAgICB3YXJuKGBWTm9kZSBjcmVhdGVkIHdpdGggaW52YWxpZCBrZXkgKE5hTikuIFZOb2RlIHR5cGU6YCwgdm5vZGUudHlwZSk7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pO1xyXG4gICAgLy8gbm9ybWFsaXplIHN1c3BlbnNlIGNoaWxkcmVuXHJcbiAgICBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgdHlwZS5ub3JtYWxpemUodm5vZGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiZcclxuICAgICAgICAvLyBhdm9pZCBhIGJsb2NrIG5vZGUgZnJvbSB0cmFja2luZyBpdHNlbGZcclxuICAgICAgICAhaXNCbG9ja05vZGUgJiZcclxuICAgICAgICAvLyBoYXMgY3VycmVudCBwYXJlbnQgYmxvY2tcclxuICAgICAgICBjdXJyZW50QmxvY2sgJiZcclxuICAgICAgICAvLyBwcmVzZW5jZSBvZiBhIHBhdGNoIGZsYWcgaW5kaWNhdGVzIHRoaXMgbm9kZSBuZWVkcyBwYXRjaGluZyBvbiB1cGRhdGVzLlxyXG4gICAgICAgIC8vIGNvbXBvbmVudCBub2RlcyBhbHNvIHNob3VsZCBhbHdheXMgYmUgcGF0Y2hlZCwgYmVjYXVzZSBldmVuIGlmIHRoZVxyXG4gICAgICAgIC8vIGNvbXBvbmVudCBkb2Vzbid0IG5lZWQgdG8gdXBkYXRlLCBpdCBuZWVkcyB0byBwZXJzaXN0IHRoZSBpbnN0YW5jZSBvbiB0b1xyXG4gICAgICAgIC8vIHRoZSBuZXh0IHZub2RlIHNvIHRoYXQgaXQgY2FuIGJlIHByb3Blcmx5IHVubW91bnRlZCBsYXRlci5cclxuICAgICAgICAocGF0Y2hGbGFnID4gMCB8fCBzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykgJiZcclxuICAgICAgICAvLyB0aGUgRVZFTlRTIGZsYWcgaXMgb25seSBmb3IgaHlkcmF0aW9uIGFuZCBpZiBpdCBpcyB0aGUgb25seSBmbGFnLCB0aGVcclxuICAgICAgICAvLyB2bm9kZSBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgZHluYW1pYyBkdWUgdG8gaGFuZGxlciBjYWNoaW5nLlxyXG4gICAgICAgIHBhdGNoRmxhZyAhPT0gMzIgLyogSFlEUkFURV9FVkVOVFMgKi8pIHtcclxuICAgICAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gY2xvbmVWTm9kZSh2bm9kZSwgZXh0cmFQcm9wcywgbWVyZ2VSZWYgPSBmYWxzZSkge1xyXG4gICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IE5PVCB1c2luZyBzcHJlYWQgb3IgZXh0ZW5kIHRvIGF2b2lkIHRoZSBydW50aW1lXHJcbiAgICAvLyBrZXkgZW51bWVyYXRpb24gY29zdC5cclxuICAgIGNvbnN0IHsgcHJvcHMsIHJlZiwgcGF0Y2hGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBtZXJnZWRQcm9wcyA9IGV4dHJhUHJvcHMgPyBtZXJnZVByb3BzKHByb3BzIHx8IHt9LCBleHRyYVByb3BzKSA6IHByb3BzO1xyXG4gICAgY29uc3QgY2xvbmVkID0ge1xyXG4gICAgICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxyXG4gICAgICAgIF9fdl9za2lwOiB0cnVlLFxyXG4gICAgICAgIHR5cGU6IHZub2RlLnR5cGUsXHJcbiAgICAgICAgcHJvcHM6IG1lcmdlZFByb3BzLFxyXG4gICAgICAgIGtleTogbWVyZ2VkUHJvcHMgJiYgbm9ybWFsaXplS2V5KG1lcmdlZFByb3BzKSxcclxuICAgICAgICByZWY6IGV4dHJhUHJvcHMgJiYgZXh0cmFQcm9wcy5yZWZcclxuICAgICAgICAgICAgPyAvLyAjMjA3OCBpbiB0aGUgY2FzZSBvZiA8Y29tcG9uZW50IDppcz1cInZub2RlXCIgcmVmPVwiZXh0cmFcIi8+XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdm5vZGUgaXRzZWxmIGFscmVhZHkgaGFzIGEgcmVmLCBjbG9uZVZOb2RlIHdpbGwgbmVlZCB0byBtZXJnZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlZnMgc28gdGhlIHNpbmdsZSB2bm9kZSBjYW4gYmUgc2V0IG9uIG11bHRpcGxlIHJlZnNcclxuICAgICAgICAgICAgICAgIG1lcmdlUmVmICYmIHJlZlxyXG4gICAgICAgICAgICAgICAgICAgID8gaXNBcnJheShyZWYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmLmNvbmNhdChub3JtYWxpemVSZWYoZXh0cmFQcm9wcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW3JlZiwgbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXVxyXG4gICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXHJcbiAgICAgICAgICAgIDogcmVmLFxyXG4gICAgICAgIHNjb3BlSWQ6IHZub2RlLnNjb3BlSWQsXHJcbiAgICAgICAgc2xvdFNjb3BlSWRzOiB2bm9kZS5zbG90U2NvcGVJZHMsXHJcbiAgICAgICAgY2hpbGRyZW46IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXRjaEZsYWcgPT09IC0xIC8qIEhPSVNURUQgKi8gJiYgaXNBcnJheShjaGlsZHJlbilcclxuICAgICAgICAgICAgPyBjaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpXHJcbiAgICAgICAgICAgIDogY2hpbGRyZW4sXHJcbiAgICAgICAgdGFyZ2V0OiB2bm9kZS50YXJnZXQsXHJcbiAgICAgICAgdGFyZ2V0QW5jaG9yOiB2bm9kZS50YXJnZXRBbmNob3IsXHJcbiAgICAgICAgc3RhdGljQ291bnQ6IHZub2RlLnN0YXRpY0NvdW50LFxyXG4gICAgICAgIHN0YXRpY0NhY2hlOiB2bm9kZS5zdGF0aWNDYWNoZSxcclxuICAgICAgICBzaGFwZUZsYWc6IHZub2RlLnNoYXBlRmxhZyxcclxuICAgICAgICAvLyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIHdpdGggZXh0cmEgcHJvcHMsIHdlIGNhbiBubyBsb25nZXIgYXNzdW1lIGl0c1xyXG4gICAgICAgIC8vIGV4aXN0aW5nIHBhdGNoIGZsYWcgdG8gYmUgcmVsaWFibGUgYW5kIG5lZWQgdG8gYWRkIHRoZSBGVUxMX1BST1BTIGZsYWcuXHJcbiAgICAgICAgLy8gbm90ZTogcGVyc2VydmUgZmxhZyBmb3IgZnJhZ21lbnRzIHNpbmNlIHRoZXkgdXNlIHRoZSBmbGFnIGZvciBjaGlsZHJlblxyXG4gICAgICAgIC8vIGZhc3QgcGF0aHMgb25seS5cclxuICAgICAgICBwYXRjaEZsYWc6IGV4dHJhUHJvcHMgJiYgdm5vZGUudHlwZSAhPT0gRnJhZ21lbnRcclxuICAgICAgICAgICAgPyBwYXRjaEZsYWcgPT09IC0xIC8vIGhvaXN0ZWQgbm9kZVxyXG4gICAgICAgICAgICAgICAgPyAxNiAvKiBGVUxMX1BST1BTICovXHJcbiAgICAgICAgICAgICAgICA6IHBhdGNoRmxhZyB8IDE2IC8qIEZVTExfUFJPUFMgKi9cclxuICAgICAgICAgICAgOiBwYXRjaEZsYWcsXHJcbiAgICAgICAgZHluYW1pY1Byb3BzOiB2bm9kZS5keW5hbWljUHJvcHMsXHJcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuOiB2bm9kZS5keW5hbWljQ2hpbGRyZW4sXHJcbiAgICAgICAgYXBwQ29udGV4dDogdm5vZGUuYXBwQ29udGV4dCxcclxuICAgICAgICBkaXJzOiB2bm9kZS5kaXJzLFxyXG4gICAgICAgIHRyYW5zaXRpb246IHZub2RlLnRyYW5zaXRpb24sXHJcbiAgICAgICAgLy8gVGhlc2Ugc2hvdWxkIHRlY2huaWNhbGx5IG9ubHkgYmUgbm9uLW51bGwgb24gbW91bnRlZCBWTm9kZXMuIEhvd2V2ZXIsXHJcbiAgICAgICAgLy8gdGhleSAqc2hvdWxkKiBiZSBjb3BpZWQgZm9yIGtlcHQtYWxpdmUgdm5vZGVzLiBTbyB3ZSBqdXN0IGFsd2F5cyBjb3B5XHJcbiAgICAgICAgLy8gdGhlbSBzaW5jZSB0aGVtIGJlaW5nIG5vbi1udWxsIGR1cmluZyBhIG1vdW50IGRvZXNuJ3QgYWZmZWN0IHRoZSBsb2dpYyBhc1xyXG4gICAgICAgIC8vIHRoZXkgd2lsbCBzaW1wbHkgYmUgb3ZlcndyaXR0ZW4uXHJcbiAgICAgICAgY29tcG9uZW50OiB2bm9kZS5jb21wb25lbnQsXHJcbiAgICAgICAgc3VzcGVuc2U6IHZub2RlLnN1c3BlbnNlLFxyXG4gICAgICAgIHNzQ29udGVudDogdm5vZGUuc3NDb250ZW50ICYmIGNsb25lVk5vZGUodm5vZGUuc3NDb250ZW50KSxcclxuICAgICAgICBzc0ZhbGxiYWNrOiB2bm9kZS5zc0ZhbGxiYWNrICYmIGNsb25lVk5vZGUodm5vZGUuc3NGYWxsYmFjayksXHJcbiAgICAgICAgZWw6IHZub2RlLmVsLFxyXG4gICAgICAgIGFuY2hvcjogdm5vZGUuYW5jaG9yXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGNsb25lZDtcclxufVxyXG4vKipcclxuICogRGV2IG9ubHksIGZvciBITVIgb2YgaG9pc3RlZCB2bm9kZXMgcmV1c2VkIGluIHYtZm9yXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS9pc3N1ZXMvMjAyMlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcENsb25lVk5vZGUodm5vZGUpIHtcclxuICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodm5vZGUpO1xyXG4gICAgaWYgKGlzQXJyYXkodm5vZGUuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgY2xvbmVkLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjbG9uZWQ7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodGV4dCA9ICcgJywgZmxhZyA9IDApIHtcclxuICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCB0ZXh0LCBmbGFnKTtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZOb2RlKGNvbnRlbnQsIG51bWJlck9mTm9kZXMpIHtcclxuICAgIC8vIEEgc3RhdGljIHZub2RlIGNhbiBjb250YWluIG11bHRpcGxlIHN0cmluZ2lmaWVkIGVsZW1lbnRzLCBhbmQgdGhlIG51bWJlclxyXG4gICAgLy8gb2YgZWxlbWVudHMgaXMgbmVjZXNzYXJ5IGZvciBoeWRyYXRpb24uXHJcbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKFN0YXRpYywgbnVsbCwgY29udGVudCk7XHJcbiAgICB2bm9kZS5zdGF0aWNDb3VudCA9IG51bWJlck9mTm9kZXM7XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50Vk5vZGUodGV4dCA9ICcnLCBcclxuLy8gd2hlbiB1c2VkIGFzIHRoZSB2LWVsc2UgYnJhbmNoLCB0aGUgY29tbWVudCBub2RlIG11c3QgYmUgY3JlYXRlZCBhcyBhXHJcbi8vIGJsb2NrIHRvIGVuc3VyZSBjb3JyZWN0IHVwZGF0ZXMuXHJcbmFzQmxvY2sgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGFzQmxvY2tcclxuICAgICAgICA/IChvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soQ29tbWVudCQxLCBudWxsLCB0ZXh0KSlcclxuICAgICAgICA6IGNyZWF0ZVZOb2RlKENvbW1lbnQkMSwgbnVsbCwgdGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUoY2hpbGQpIHtcclxuICAgIGlmIChjaGlsZCA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgLy8gZW1wdHkgcGxhY2Vob2xkZXJcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoQ29tbWVudCQxKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkoY2hpbGQpKSB7XHJcbiAgICAgICAgLy8gZnJhZ21lbnRcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoRnJhZ21lbnQsIG51bGwsIFxyXG4gICAgICAgIC8vICMzNjY2LCBhdm9pZCByZWZlcmVuY2UgcG9sbHV0aW9uIHdoZW4gcmV1c2luZyB2bm9kZVxyXG4gICAgICAgIGNoaWxkLnNsaWNlKCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIGFscmVhZHkgdm5vZGUsIHRoaXMgc2hvdWxkIGJlIHRoZSBtb3N0IGNvbW1vbiBzaW5jZSBjb21waWxlZCB0ZW1wbGF0ZXNcclxuICAgICAgICAvLyBhbHdheXMgcHJvZHVjZSBhbGwtdm5vZGUgY2hpbGRyZW4gYXJyYXlzXHJcbiAgICAgICAgcmV0dXJuIGNsb25lSWZNb3VudGVkKGNoaWxkKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHN0cmluZ3MgYW5kIG51bWJlcnNcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgU3RyaW5nKGNoaWxkKSk7XHJcbiAgICB9XHJcbn1cclxuLy8gb3B0aW1pemVkIG5vcm1hbGl6YXRpb24gZm9yIHRlbXBsYXRlLWNvbXBpbGVkIHJlbmRlciBmbnNcclxuZnVuY3Rpb24gY2xvbmVJZk1vdW50ZWQoY2hpbGQpIHtcclxuICAgIHJldHVybiBjaGlsZC5lbCA9PT0gbnVsbCA/IGNoaWxkIDogY2xvbmVWTm9kZShjaGlsZCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKSB7XHJcbiAgICBsZXQgdHlwZSA9IDA7XHJcbiAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gdm5vZGU7XHJcbiAgICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgICAgIGNoaWxkcmVuID0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgdHlwZSA9IDE2IC8qIEFSUkFZX0NISUxEUkVOICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gfHwgc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHNsb3QgdG8gcGxhaW4gY2hpbGRyZW4gZm9yIHBsYWluIGVsZW1lbnQgYW5kIFRlbGVwb3J0XHJcbiAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZHJlbi5kZWZhdWx0O1xyXG4gICAgICAgICAgICBpZiAoc2xvdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gX2MgbWFya2VyIGlzIGFkZGVkIGJ5IHdpdGhDdHgoKSBpbmRpY2F0aW5nIHRoaXMgaXMgYSBjb21waWxlZCBzbG90XHJcbiAgICAgICAgICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIHNsb3QoKSk7XHJcbiAgICAgICAgICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHlwZSA9IDMyIC8qIFNMT1RTX0NISUxEUkVOICovO1xyXG4gICAgICAgICAgICBjb25zdCBzbG90RmxhZyA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgICAgIGlmICghc2xvdEZsYWcgJiYgIShJbnRlcm5hbE9iamVjdEtleSBpbiBjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLl9jdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xvdEZsYWcgPT09IDMgLyogRk9SV0FSREVEICovICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gYSBjaGlsZCBjb21wb25lbnQgcmVjZWl2ZXMgZm9yd2FyZGVkIHNsb3RzIGZyb20gdGhlIHBhcmVudC5cclxuICAgICAgICAgICAgICAgIC8vIGl0cyBzbG90IHR5cGUgaXMgZGV0ZXJtaW5lZCBieSBpdHMgcGFyZW50J3Mgc2xvdCB0eXBlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5zbG90cy5fID09PSAxIC8qIFNUQUJMRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLl8gPSAxIC8qIFNUQUJMRSAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLl8gPSAyIC8qIERZTkFNSUMgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUucGF0Y2hGbGFnIHw9IDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24kMShjaGlsZHJlbikpIHtcclxuICAgICAgICBjaGlsZHJlbiA9IHsgZGVmYXVsdDogY2hpbGRyZW4sIF9jdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB9O1xyXG4gICAgICAgIHR5cGUgPSAzMiAvKiBTTE9UU19DSElMRFJFTiAqLztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNoaWxkcmVuID0gU3RyaW5nKGNoaWxkcmVuKTtcclxuICAgICAgICAvLyBmb3JjZSB0ZWxlcG9ydCBjaGlsZHJlbiB0byBhcnJheSBzbyBpdCBjYW4gYmUgbW92ZWQgYXJvdW5kXHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLztcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0eXBlID0gOCAvKiBURVhUX0NISUxEUkVOICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICB2bm9kZS5zaGFwZUZsYWcgfD0gdHlwZTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZVByb3BzKC4uLmFyZ3MpIHtcclxuICAgIGNvbnN0IHJldCA9IGV4dGVuZCh7fSwgYXJnc1swXSk7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCB0b01lcmdlID0gYXJnc1tpXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0b01lcmdlKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXQuY2xhc3MgIT09IHRvTWVyZ2UuY2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXQuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhbcmV0LmNsYXNzLCB0b01lcmdlLmNsYXNzXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXQuc3R5bGUgPSBub3JtYWxpemVTdHlsZShbcmV0LnN0eWxlLCB0b01lcmdlLnN0eWxlXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHJldFtrZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5jb21pbmcgPSB0b01lcmdlW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcgIT09IGluY29taW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSBleGlzdGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaW5jb21pbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5jb21pbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSB0b01lcmdlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiBBY3R1YWwgaW1wbGVtZW50YXRpb25cclxuICovXHJcbmZ1bmN0aW9uIHJlbmRlckxpc3Qoc291cmNlLCByZW5kZXJJdGVtKSB7XHJcbiAgICBsZXQgcmV0O1xyXG4gICAgaWYgKGlzQXJyYXkoc291cmNlKSB8fCBpc1N0cmluZyhzb3VyY2UpKSB7XHJcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtpXSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFOdW1iZXIuaXNJbnRlZ2VyKHNvdXJjZSkpIHtcclxuICAgICAgICAgICAgd2FybihgVGhlIHYtZm9yIHJhbmdlIGV4cGVjdCBhbiBpbnRlZ2VyIHZhbHVlIGJ1dCBnb3QgJHtzb3VyY2V9LmApO1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlOyBpKyspIHtcclxuICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShpICsgMSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QkMShzb3VyY2UpKSB7XHJcbiAgICAgICAgaWYgKHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKSB7XHJcbiAgICAgICAgICAgIHJldCA9IEFycmF5LmZyb20oc291cmNlLCByZW5kZXJJdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xyXG4gICAgICAgICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2Vba2V5XSwga2V5LCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldCA9IFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxuXG4vKipcclxuICogQ29tcGlsZXIgcnVudGltZSBoZWxwZXIgZm9yIGNyZWF0aW5nIGR5bmFtaWMgc2xvdHMgb2JqZWN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTbG90cyhzbG90cywgZHluYW1pY1Nsb3RzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHNsb3QgPSBkeW5hbWljU2xvdHNbaV07XHJcbiAgICAgICAgLy8gYXJyYXkgb2YgZHluYW1pYyBzbG90IGdlbmVyYXRlZCBieSA8dGVtcGxhdGUgdi1mb3I9XCIuLi5cIiAjWy4uLl0+XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoc2xvdCkpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzbG90Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBzbG90c1tzbG90W2pdLm5hbWVdID0gc2xvdFtqXS5mbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzbG90KSB7XHJcbiAgICAgICAgICAgIC8vIGNvbmRpdGlvbmFsIHNpbmdsZSBzbG90IGdlbmVyYXRlZCBieSA8dGVtcGxhdGUgdi1pZj1cIi4uLlwiICNmb28+XHJcbiAgICAgICAgICAgIHNsb3RzW3Nsb3QubmFtZV0gPSBzbG90LmZuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzbG90cztcclxufVxuXG4vKipcclxuICogQ29tcGlsZXIgcnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBgPHNsb3QvPmBcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlbmRlclNsb3Qoc2xvdHMsIG5hbWUsIHByb3BzID0ge30sIFxyXG4vLyB0aGlzIGlzIG5vdCBhIHVzZXItZmFjaW5nIGZ1bmN0aW9uLCBzbyB0aGUgZmFsbGJhY2sgaXMgYWx3YXlzIGdlbmVyYXRlZCBieVxyXG4vLyB0aGUgY29tcGlsZXIgYW5kIGd1YXJhbnRlZWQgdG8gYmUgYSBmdW5jdGlvbiByZXR1cm5pbmcgYW4gYXJyYXlcclxuZmFsbGJhY2ssIG5vU2xvdHRlZCkge1xyXG4gICAgbGV0IHNsb3QgPSBzbG90c1tuYW1lXTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2xvdCAmJiBzbG90Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgICB3YXJuKGBTU1Itb3B0aW1pemVkIHNsb3QgZnVuY3Rpb24gZGV0ZWN0ZWQgaW4gYSBub24tU1NSLW9wdGltaXplZCByZW5kZXIgYCArXHJcbiAgICAgICAgICAgIGBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBgICtcclxuICAgICAgICAgICAgYHBhcmVudCB0ZW1wbGF0ZS5gKTtcclxuICAgICAgICBzbG90ID0gKCkgPT4gW107XHJcbiAgICB9XHJcbiAgICAvLyBhIGNvbXBpbGVkIHNsb3QgZGlzYWJsZXMgYmxvY2sgdHJhY2tpbmcgYnkgZGVmYXVsdCB0byBhdm9pZCBtYW51YWxcclxuICAgIC8vIGludm9jYXRpb24gaW50ZXJmZXJpbmcgd2l0aCB0ZW1wbGF0ZS1iYXNlZCBibG9jayB0cmFja2luZywgYnV0IGluXHJcbiAgICAvLyBgcmVuZGVyU2xvdGAgd2UgY2FuIGJlIHN1cmUgdGhhdCBpdCdzIHRlbXBsYXRlLWJhc2VkIHNvIHdlIGNhbiBmb3JjZVxyXG4gICAgLy8gZW5hYmxlIGl0LlxyXG4gICAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xyXG4gICAgICAgIHNsb3QuX2QgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIG9wZW5CbG9jaygpO1xyXG4gICAgY29uc3QgdmFsaWRTbG90Q29udGVudCA9IHNsb3QgJiYgZW5zdXJlVmFsaWRWTm9kZShzbG90KHByb3BzKSk7XHJcbiAgICBjb25zdCByZW5kZXJlZCA9IGNyZWF0ZUJsb2NrKEZyYWdtZW50LCB7IGtleTogcHJvcHMua2V5IHx8IGBfJHtuYW1lfWAgfSwgdmFsaWRTbG90Q29udGVudCB8fCAoZmFsbGJhY2sgPyBmYWxsYmFjaygpIDogW10pLCB2YWxpZFNsb3RDb250ZW50ICYmIHNsb3RzLl8gPT09IDEgLyogU1RBQkxFICovXHJcbiAgICAgICAgPyA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9cclxuICAgICAgICA6IC0yIC8qIEJBSUwgKi8pO1xyXG4gICAgaWYgKCFub1Nsb3R0ZWQgJiYgcmVuZGVyZWQuc2NvcGVJZCkge1xyXG4gICAgICAgIHJlbmRlcmVkLnNsb3RTY29wZUlkcyA9IFtyZW5kZXJlZC5zY29wZUlkICsgJy1zJ107XHJcbiAgICB9XHJcbiAgICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XHJcbiAgICAgICAgc2xvdC5fZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVuZGVyZWQ7XHJcbn1cclxuZnVuY3Rpb24gZW5zdXJlVmFsaWRWTm9kZSh2bm9kZXMpIHtcclxuICAgIHJldHVybiB2bm9kZXMuc29tZShjaGlsZCA9PiB7XHJcbiAgICAgICAgaWYgKCFpc1ZOb2RlKGNoaWxkKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQkMSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCAmJlxyXG4gICAgICAgICAgICAhZW5zdXJlVmFsaWRWTm9kZShjaGlsZC5jaGlsZHJlbikpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pXHJcbiAgICAgICAgPyB2bm9kZXNcclxuICAgICAgICA6IG51bGw7XHJcbn1cblxuLyoqXHJcbiAqIEZvciBwcmVmaXhpbmcga2V5cyBpbiB2LW9uPVwib2JqXCIgd2l0aCBcIm9uXCJcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHRvSGFuZGxlcnMob2JqKSB7XHJcbiAgICBjb25zdCByZXQgPSB7fTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzT2JqZWN0JDEob2JqKSkge1xyXG4gICAgICAgIHdhcm4oYHYtb24gd2l0aCBubyBhcmd1bWVudCBleHBlY3RzIGFuIG9iamVjdCB2YWx1ZS5gKTtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgcmV0W3RvSGFuZGxlcktleShrZXkpXSA9IG9ialtrZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxuXG4vKipcclxuICogIzI0MzcgSW4gVnVlIDMsIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBkbyBub3QgaGF2ZSBhIHB1YmxpYyBpbnN0YW5jZSBwcm94eSBidXRcclxuICogdGhleSBleGlzdCBpbiB0aGUgaW50ZXJuYWwgcGFyZW50IGNoYWluLiBGb3IgY29kZSB0aGF0IHJlbGllcyBvbiB0cmF2ZXJzaW5nXHJcbiAqIHB1YmxpYyAkcGFyZW50IGNoYWlucywgc2tpcCBmdW5jdGlvbmFsIG9uZXMgYW5kIGdvIHRvIHRoZSBwYXJlbnQgaW5zdGVhZC5cclxuICovXHJcbmNvbnN0IGdldFB1YmxpY0luc3RhbmNlID0gKGkpID0+IHtcclxuICAgIGlmICghaSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIGlmIChpc1N0YXRlZnVsQ29tcG9uZW50KGkpKVxyXG4gICAgICAgIHJldHVybiBnZXRFeHBvc2VQcm94eShpKSB8fCBpLnByb3h5O1xyXG4gICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KTtcclxufTtcclxuY29uc3QgcHVibGljUHJvcGVydGllc01hcCA9IGV4dGVuZChPYmplY3QuY3JlYXRlKG51bGwpLCB7XHJcbiAgICAkOiBpID0+IGksXHJcbiAgICAkZWw6IGkgPT4gaS52bm9kZS5lbCxcclxuICAgICRkYXRhOiBpID0+IGkuZGF0YSxcclxuICAgICRwcm9wczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkucHJvcHMpIDogaS5wcm9wcyksXHJcbiAgICAkYXR0cnM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLmF0dHJzKSA6IGkuYXR0cnMpLFxyXG4gICAgJHNsb3RzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5zbG90cykgOiBpLnNsb3RzKSxcclxuICAgICRyZWZzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5yZWZzKSA6IGkucmVmcyksXHJcbiAgICAkcGFyZW50OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KSxcclxuICAgICRyb290OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucm9vdCksXHJcbiAgICAkZW1pdDogaSA9PiBpLmVtaXQsXHJcbiAgICAkb3B0aW9uczogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IHJlc29sdmVNZXJnZWRPcHRpb25zKGkpIDogaS50eXBlKSxcclxuICAgICRmb3JjZVVwZGF0ZTogaSA9PiAoKSA9PiBxdWV1ZUpvYihpLnVwZGF0ZSksXHJcbiAgICAkbmV4dFRpY2s6IGkgPT4gbmV4dFRpY2suYmluZChpLnByb3h5KSxcclxuICAgICR3YXRjaDogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IGluc3RhbmNlV2F0Y2guYmluZChpKSA6IE5PT1ApXHJcbn0pO1xyXG5jb25zdCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSB7XHJcbiAgICBnZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXkpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSwgZGF0YSwgcHJvcHMsIGFjY2Vzc0NhY2hlLCB0eXBlLCBhcHBDb250ZXh0IH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgZm9ybWF0dGVycyB0byBrbm93IHRoYXQgdGhpcyBpcyBhIFZ1ZSBpbnN0YW5jZVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5ID09PSAnX19pc1Z1ZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHByaW9yaXRpemUgPHNjcmlwdCBzZXR1cD4gYmluZGluZ3MgZHVyaW5nIGRldi5cclxuICAgICAgICAvLyB0aGlzIGFsbG93cyBldmVuIHByb3BlcnRpZXMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJCB0byBiZSB1c2VkIC0gc28gdGhhdFxyXG4gICAgICAgIC8vIGl0IGFsaWducyB3aXRoIHRoZSBwcm9kdWN0aW9uIGJlaGF2aW9yIHdoZXJlIHRoZSByZW5kZXIgZm4gaXMgaW5saW5lZCBhbmRcclxuICAgICAgICAvLyBpbmRlZWQgaGFzIGFjY2VzcyB0byBhbGwgZGVjbGFyZWQgdmFyaWFibGVzLlxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKICYmXHJcbiAgICAgICAgICAgIHNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwICYmXHJcbiAgICAgICAgICAgIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRhdGEgLyBwcm9wcyAvIGN0eFxyXG4gICAgICAgIC8vIFRoaXMgZ2V0dGVyIGdldHMgY2FsbGVkIGZvciBldmVyeSBwcm9wZXJ0eSBhY2Nlc3Mgb24gdGhlIHJlbmRlciBjb250ZXh0XHJcbiAgICAgICAgLy8gZHVyaW5nIHJlbmRlciBhbmQgaXMgYSBtYWpvciBob3RzcG90LiBUaGUgbW9zdCBleHBlbnNpdmUgcGFydCBvZiB0aGlzXHJcbiAgICAgICAgLy8gaXMgdGhlIG11bHRpcGxlIGhhc093bigpIGNhbGxzLiBJdCdzIG11Y2ggZmFzdGVyIHRvIGRvIGEgc2ltcGxlIHByb3BlcnR5XHJcbiAgICAgICAgLy8gYWNjZXNzIG9uIGEgcGxhaW4gb2JqZWN0LCBzbyB3ZSB1c2UgYW4gYWNjZXNzQ2FjaGUgb2JqZWN0ICh3aXRoIG51bGxcclxuICAgICAgICAvLyBwcm90b3R5cGUpIHRvIG1lbW9pemUgd2hhdCBhY2Nlc3MgdHlwZSBhIGtleSBjb3JyZXNwb25kcyB0by5cclxuICAgICAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xyXG4gICAgICAgIGlmIChrZXlbMF0gIT09ICckJykge1xyXG4gICAgICAgICAgICBjb25zdCBuID0gYWNjZXNzQ2FjaGVba2V5XTtcclxuICAgICAgICAgICAgaWYgKG4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwIC8qIFNFVFVQICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBEQVRBICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBDT05URVhUICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyIC8qIFBST1BTICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0OiBqdXN0IGZhbGx0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMCAvKiBTRVRVUCAqLztcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMSAvKiBEQVRBICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAgICAgLy8gb25seSBjYWNoZSBvdGhlciBwcm9wZXJ0aWVzIHdoZW4gaW5zdGFuY2UgaGFzIGRlY2xhcmVkICh0aHVzIHN0YWJsZSlcclxuICAgICAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICAgICAgKG5vcm1hbGl6ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkgJiZcclxuICAgICAgICAgICAgICAgIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAyIC8qIFBST1BTICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDMgLyogQ09OVEVYVCAqLztcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghX19WVUVfT1BUSU9OU19BUElfXyB8fCBzaG91bGRDYWNoZUFjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogT1RIRVIgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHVibGljR2V0dGVyID0gcHVibGljUHJvcGVydGllc01hcFtrZXldO1xyXG4gICAgICAgIGxldCBjc3NNb2R1bGUsIGdsb2JhbFByb3BlcnRpZXM7XHJcbiAgICAgICAgLy8gcHVibGljICR4eHggcHJvcGVydGllc1xyXG4gICAgICAgIGlmIChwdWJsaWNHZXR0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJyRhdHRycycpIHtcclxuICAgICAgICAgICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiIC8qIEdFVCAqLywga2V5KTtcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwdWJsaWNHZXR0ZXIoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAvLyBjc3MgbW9kdWxlIChpbmplY3RlZCBieSB2dWUtbG9hZGVyKVxyXG4gICAgICAgIChjc3NNb2R1bGUgPSB0eXBlLl9fY3NzTW9kdWxlcykgJiZcclxuICAgICAgICAgICAgKGNzc01vZHVsZSA9IGNzc01vZHVsZVtrZXldKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3NzTW9kdWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XHJcbiAgICAgICAgICAgIC8vIHVzZXIgbWF5IHNldCBjdXN0b20gcHJvcGVydGllcyB0byBgdGhpc2AgdGhhdCBzdGFydCB3aXRoIGAkYFxyXG4gICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMyAvKiBDT05URVhUICovO1xyXG4gICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgIC8vIGdsb2JhbCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgKChnbG9iYWxQcm9wZXJ0aWVzID0gYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcyksXHJcbiAgICAgICAgICAgIGhhc093bihnbG9iYWxQcm9wZXJ0aWVzLCBrZXkpKSkge1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2xvYmFsUHJvcGVydGllc1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgJiZcclxuICAgICAgICAgICAgKCFpc1N0cmluZyhrZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAvLyAjMTA5MSBhdm9pZCBpbnRlcm5hbCBpc1JlZi9pc1ZOb2RlIGNoZWNrcyBvbiBjb21wb25lbnQgaW5zdGFuY2UgbGVhZGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gdG8gaW5maW5pdGUgd2FybmluZyBsb29wXHJcbiAgICAgICAgICAgICAgICBrZXkuaW5kZXhPZignX192JykgIT09IDApKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiZcclxuICAgICAgICAgICAgICAgIChrZXlbMF0gPT09ICckJyB8fCBrZXlbMF0gPT09ICdfJykgJiZcclxuICAgICAgICAgICAgICAgIGhhc093bihkYXRhLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IG11c3QgYmUgYWNjZXNzZWQgdmlhICRkYXRhIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYSByZXNlcnZlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgY2hhcmFjdGVyIChcIiRcIiBvciBcIl9cIikgYW5kIGlzIG5vdCBwcm94aWVkIG9uIHRoZSByZW5kZXIgY29udGV4dC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpbnN0YW5jZSA9PT0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHdhcyBhY2Nlc3NlZCBkdXJpbmcgcmVuZGVyIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBidXQgaXMgbm90IGRlZmluZWQgb24gaW5zdGFuY2UuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2V0KHsgXzogaW5zdGFuY2UgfSwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4IH0gPSBpbnN0YW5jZTtcclxuICAgICAgICBpZiAoc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHNldHVwU3RhdGVba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhhc093bihpbnN0YW5jZS5wcm9wcywga2V5KSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHByb3AgXCIke2tleX1cIi4gUHJvcHMgYXJlIHJlYWRvbmx5LmAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoa2V5WzBdID09PSAnJCcgJiYga2V5LnNsaWNlKDEpIGluIGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBQcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggJCBhcmUgcmVzZXJ2ZWQgYW5kIHJlYWRvbmx5LmAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgaW4gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBoYXMoeyBfOiB7IGRhdGEsIHNldHVwU3RhdGUsIGFjY2Vzc0NhY2hlLCBjdHgsIGFwcENvbnRleHQsIHByb3BzT3B0aW9ucyB9IH0sIGtleSkge1xyXG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XHJcbiAgICAgICAgcmV0dXJuIChhY2Nlc3NDYWNoZVtrZXldICE9PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkgfHxcclxuICAgICAgICAgICAgKHNldHVwU3RhdGUgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkgfHxcclxuICAgICAgICAgICAgKChub3JtYWxpemVkUHJvcHMgPSBwcm9wc09wdGlvbnNbMF0pICYmIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSkpIHx8XHJcbiAgICAgICAgICAgIGhhc093bihjdHgsIGtleSkgfHxcclxuICAgICAgICAgICAgaGFzT3duKHB1YmxpY1Byb3BlcnRpZXNNYXAsIGtleSkgfHxcclxuICAgICAgICAgICAgaGFzT3duKGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGtleSkpO1xyXG4gICAgfVxyXG59O1xyXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFmYWxzZSkge1xyXG4gICAgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLm93bktleXMgPSAodGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgd2FybihgQXZvaWQgYXBwIGxvZ2ljIHRoYXQgcmVsaWVzIG9uIGVudW1lcmF0aW5nIGtleXMgb24gYSBjb21wb25lbnQgaW5zdGFuY2UuIGAgK1xyXG4gICAgICAgICAgICBgVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuYCk7XHJcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSBleHRlbmQoe30sIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycywge1xyXG4gICAgZ2V0KHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgLy8gZmFzdCBwYXRoIGZvciB1bnNjb3BhYmxlcyB3aGVuIHVzaW5nIGB3aXRoYCBibG9ja1xyXG4gICAgICAgIGlmIChrZXkgPT09IFN5bWJvbC51bnNjb3BhYmxlcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuZ2V0KHRhcmdldCwga2V5LCB0YXJnZXQpO1xyXG4gICAgfSxcclxuICAgIGhhcyhfLCBrZXkpIHtcclxuICAgICAgICBjb25zdCBoYXMgPSBrZXlbMF0gIT09ICdfJyAmJiAhaXNHbG9iYWxseVdoaXRlbGlzdGVkKGtleSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaGFzICYmIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5oYXMoXywga2V5KSkge1xyXG4gICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBfIHdoaWNoIGlzIGEgcmVzZXJ2ZWQgcHJlZml4IGZvciBWdWUgaW50ZXJuYWxzLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzO1xyXG4gICAgfVxyXG59KTtcclxuLy8gSW4gZGV2IG1vZGUsIHRoZSBwcm94eSB0YXJnZXQgZXhwb3NlcyB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHNlZW4gb24gYHRoaXNgXHJcbi8vIGZvciBlYXNpZXIgY29uc29sZSBpbnNwZWN0aW9uLiBJbiBwcm9kIG1vZGUgaXQgd2lsbCBiZSBhbiBlbXB0eSBvYmplY3Qgc29cclxuLy8gdGhlc2UgcHJvcGVydGllcyBkZWZpbml0aW9ucyBjYW4gYmUgc2tpcHBlZC5cclxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0ge307XHJcbiAgICAvLyBleHBvc2UgaW50ZXJuYWwgaW5zdGFuY2UgZm9yIHByb3h5IGhhbmRsZXJzXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBgX2AsIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgZ2V0OiAoKSA9PiBpbnN0YW5jZVxyXG4gICAgfSk7XHJcbiAgICAvLyBleHBvc2UgcHVibGljIHByb3BlcnRpZXNcclxuICAgIE9iamVjdC5rZXlzKHB1YmxpY1Byb3BlcnRpZXNNYXApLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpLFxyXG4gICAgICAgICAgICAvLyBpbnRlcmNlcHRlZCBieSB0aGUgcHJveHkgc28gbm8gbmVlZCBmb3IgaW1wbGVtZW50YXRpb24sXHJcbiAgICAgICAgICAgIC8vIGJ1dCBuZWVkZWQgdG8gcHJldmVudCBzZXQgZXJyb3JzXHJcbiAgICAgICAgICAgIHNldDogTk9PUFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcbi8vIGRldiBvbmx5XHJcbmZ1bmN0aW9uIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCB7IGN0eCwgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSB9ID0gaW5zdGFuY2U7XHJcbiAgICBpZiAocHJvcHNPcHRpb25zKSB7XHJcbiAgICAgICAgT2JqZWN0LmtleXMocHJvcHNPcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gaW5zdGFuY2UucHJvcHNba2V5XSxcclxuICAgICAgICAgICAgICAgIHNldDogTk9PUFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vLyBkZXYgb25seVxyXG5mdW5jdGlvbiBleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSB9ID0gaW5zdGFuY2U7XHJcbiAgICBPYmplY3Qua2V5cyh0b1JhdyhzZXR1cFN0YXRlKSkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGlmICghc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiYgKGtleVswXSA9PT0gJyQnIHx8IGtleVswXSA9PT0gJ18nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBzZXR1cCgpIHJldHVybiBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBcIiRcIiBvciBcIl9cIiBgICtcclxuICAgICAgICAgICAgICAgIGB3aGljaCBhcmUgcmVzZXJ2ZWQgcHJlZml4ZXMgZm9yIFZ1ZSBpbnRlcm5hbHMuYCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBzZXR1cFN0YXRlW2tleV0sXHJcbiAgICAgICAgICAgIHNldDogTk9PUFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cblxuY29uc3QgZW1wdHlBcHBDb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xyXG5sZXQgdWlkJDEgPSAwO1xyXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSh2bm9kZSwgcGFyZW50LCBzdXNwZW5zZSkge1xyXG4gICAgY29uc3QgdHlwZSA9IHZub2RlLnR5cGU7XHJcbiAgICAvLyBpbmhlcml0IHBhcmVudCBhcHAgY29udGV4dCAtIG9yIC0gaWYgcm9vdCwgYWRvcHQgZnJvbSByb290IHZub2RlXHJcbiAgICBjb25zdCBhcHBDb250ZXh0ID0gKHBhcmVudCA/IHBhcmVudC5hcHBDb250ZXh0IDogdm5vZGUuYXBwQ29udGV4dCkgfHwgZW1wdHlBcHBDb250ZXh0O1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSB7XHJcbiAgICAgICAgdWlkOiB1aWQkMSsrLFxyXG4gICAgICAgIHZub2RlLFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgcGFyZW50LFxyXG4gICAgICAgIGFwcENvbnRleHQsXHJcbiAgICAgICAgcm9vdDogbnVsbCxcclxuICAgICAgICBuZXh0OiBudWxsLFxyXG4gICAgICAgIHN1YlRyZWU6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlOiBudWxsLFxyXG4gICAgICAgIHJlbmRlcjogbnVsbCxcclxuICAgICAgICBwcm94eTogbnVsbCxcclxuICAgICAgICBleHBvc2VkOiBudWxsLFxyXG4gICAgICAgIGV4cG9zZVByb3h5OiBudWxsLFxyXG4gICAgICAgIHdpdGhQcm94eTogbnVsbCxcclxuICAgICAgICBlZmZlY3RzOiBudWxsLFxyXG4gICAgICAgIHByb3ZpZGVzOiBwYXJlbnQgPyBwYXJlbnQucHJvdmlkZXMgOiBPYmplY3QuY3JlYXRlKGFwcENvbnRleHQucHJvdmlkZXMpLFxyXG4gICAgICAgIGFjY2Vzc0NhY2hlOiBudWxsLFxyXG4gICAgICAgIHJlbmRlckNhY2hlOiBbXSxcclxuICAgICAgICAvLyBsb2NhbCByZXNvdmxlZCBhc3NldHNcclxuICAgICAgICBjb21wb25lbnRzOiBudWxsLFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IG51bGwsXHJcbiAgICAgICAgLy8gcmVzb2x2ZWQgcHJvcHMgYW5kIGVtaXRzIG9wdGlvbnNcclxuICAgICAgICBwcm9wc09wdGlvbnM6IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyh0eXBlLCBhcHBDb250ZXh0KSxcclxuICAgICAgICBlbWl0c09wdGlvbnM6IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyh0eXBlLCBhcHBDb250ZXh0KSxcclxuICAgICAgICAvLyBlbWl0XHJcbiAgICAgICAgZW1pdDogbnVsbCxcclxuICAgICAgICBlbWl0dGVkOiBudWxsLFxyXG4gICAgICAgIC8vIHByb3BzIGRlZmF1bHQgdmFsdWVcclxuICAgICAgICBwcm9wc0RlZmF1bHRzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgLy8gaW5oZXJpdEF0dHJzXHJcbiAgICAgICAgaW5oZXJpdEF0dHJzOiB0eXBlLmluaGVyaXRBdHRycyxcclxuICAgICAgICAvLyBzdGF0ZVxyXG4gICAgICAgIGN0eDogRU1QVFlfT0JKLFxyXG4gICAgICAgIGRhdGE6IEVNUFRZX09CSixcclxuICAgICAgICBwcm9wczogRU1QVFlfT0JKLFxyXG4gICAgICAgIGF0dHJzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgc2xvdHM6IEVNUFRZX09CSixcclxuICAgICAgICByZWZzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgc2V0dXBTdGF0ZTogRU1QVFlfT0JKLFxyXG4gICAgICAgIHNldHVwQ29udGV4dDogbnVsbCxcclxuICAgICAgICAvLyBzdXNwZW5zZSByZWxhdGVkXHJcbiAgICAgICAgc3VzcGVuc2UsXHJcbiAgICAgICAgc3VzcGVuc2VJZDogc3VzcGVuc2UgPyBzdXNwZW5zZS5wZW5kaW5nSWQgOiAwLFxyXG4gICAgICAgIGFzeW5jRGVwOiBudWxsLFxyXG4gICAgICAgIGFzeW5jUmVzb2x2ZWQ6IGZhbHNlLFxyXG4gICAgICAgIC8vIGxpZmVjeWNsZSBob29rc1xyXG4gICAgICAgIC8vIG5vdCB1c2luZyBlbnVtcyBoZXJlIGJlY2F1c2UgaXQgcmVzdWx0cyBpbiBjb21wdXRlZCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaXNNb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBpc1VubW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgaXNEZWFjdGl2YXRlZDogZmFsc2UsXHJcbiAgICAgICAgYmM6IG51bGwsXHJcbiAgICAgICAgYzogbnVsbCxcclxuICAgICAgICBibTogbnVsbCxcclxuICAgICAgICBtOiBudWxsLFxyXG4gICAgICAgIGJ1OiBudWxsLFxyXG4gICAgICAgIHU6IG51bGwsXHJcbiAgICAgICAgdW06IG51bGwsXHJcbiAgICAgICAgYnVtOiBudWxsLFxyXG4gICAgICAgIGRhOiBudWxsLFxyXG4gICAgICAgIGE6IG51bGwsXHJcbiAgICAgICAgcnRnOiBudWxsLFxyXG4gICAgICAgIHJ0YzogbnVsbCxcclxuICAgICAgICBlYzogbnVsbCxcclxuICAgICAgICBzcDogbnVsbFxyXG4gICAgfTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBpbnN0YW5jZS5jdHggPSBjcmVhdGVSZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGluc3RhbmNlLmN0eCA9IHsgXzogaW5zdGFuY2UgfTtcclxuICAgIH1cclxuICAgIGluc3RhbmNlLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IGluc3RhbmNlO1xyXG4gICAgaW5zdGFuY2UuZW1pdCA9IGVtaXQuYmluZChudWxsLCBpbnN0YW5jZSk7XHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbn1cclxubGV0IGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XHJcbmNvbnN0IGdldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbmNvbnN0IHNldEN1cnJlbnRJbnN0YW5jZSA9IChpbnN0YW5jZSkgPT4ge1xyXG4gICAgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XHJcbn07XHJcbmNvbnN0IGlzQnVpbHRJblRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnKTtcclxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbmZpZykge1xyXG4gICAgY29uc3QgYXBwSXNOYXRpdmVUYWcgPSBjb25maWcuaXNOYXRpdmVUYWcgfHwgTk87XHJcbiAgICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGFwcElzTmF0aXZlVGFnKG5hbWUpKSB7XHJcbiAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCBpZDogJyArIG5hbWUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLztcclxufVxyXG5sZXQgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XHJcbmZ1bmN0aW9uIHNldHVwQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUiA9IGZhbHNlKSB7XHJcbiAgICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBpc1NTUjtcclxuICAgIGNvbnN0IHsgcHJvcHMsIGNoaWxkcmVuIH0gPSBpbnN0YW5jZS52bm9kZTtcclxuICAgIGNvbnN0IGlzU3RhdGVmdWwgPSBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKTtcclxuICAgIGluaXRQcm9wcyhpbnN0YW5jZSwgcHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSKTtcclxuICAgIGluaXRTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xyXG4gICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBpc1N0YXRlZnVsXHJcbiAgICAgICAgPyBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUilcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHNldHVwUmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSB7XHJcbiAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGlmIChDb21wb25lbnQubmFtZSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoQ29tcG9uZW50Lm5hbWUsIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmNvbXBvbmVudHMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZXNbaV0sIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcG9uZW50LmRpcmVjdGl2ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuZGlyZWN0aXZlcyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5jb21waWxlck9wdGlvbnMgJiYgaXNSdW50aW1lT25seSgpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFwiY29tcGlsZXJPcHRpb25zXCIgaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZSB0aGF0IGAgK1xyXG4gICAgICAgICAgICAgICAgYGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyLiBTaW5jZSB5b3UgYXJlIHVzaW5nIGEgcnVudGltZS1vbmx5IGAgK1xyXG4gICAgICAgICAgICAgICAgYGJ1aWxkLCB0aGUgb3B0aW9ucyBzaG91bGQgYmUgcGFzc2VkIHZpYSB5b3VyIGJ1aWxkIHRvb2wgY29uZmlnIGluc3RlYWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gMC4gY3JlYXRlIHJlbmRlciBwcm94eSBwcm9wZXJ0eSBhY2Nlc3MgY2FjaGVcclxuICAgIGluc3RhbmNlLmFjY2Vzc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIC8vIDEuIGNyZWF0ZSBwdWJsaWMgaW5zdGFuY2UgLyByZW5kZXIgcHJveHlcclxuICAgIC8vIGFsc28gbWFyayBpdCByYXcgc28gaXQncyBuZXZlciBvYnNlcnZlZFxyXG4gICAgaW5zdGFuY2UucHJveHkgPSBtYXJrUmF3KG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycykpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIC8vIDIuIGNhbGwgc2V0dXAoKVxyXG4gICAgY29uc3QgeyBzZXR1cCB9ID0gQ29tcG9uZW50O1xyXG4gICAgaWYgKHNldHVwKSB7XHJcbiAgICAgICAgY29uc3Qgc2V0dXBDb250ZXh0ID0gKGluc3RhbmNlLnNldHVwQ29udGV4dCA9XHJcbiAgICAgICAgICAgIHNldHVwLmxlbmd0aCA+IDEgPyBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIDogbnVsbCk7XHJcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHNldHVwLCBpbnN0YW5jZSwgMCAvKiBTRVRVUF9GVU5DVElPTiAqLywgWyhwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpbnN0YW5jZS5wcm9wcykgOiBpbnN0YW5jZS5wcm9wcywgc2V0dXBDb250ZXh0XSk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKGlzUHJvbWlzZSQxKHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgICAgICBjb25zdCB1bnNldEluc3RhbmNlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEluc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgc2V0dXBSZXN1bHQudGhlbih1bnNldEluc3RhbmNlLCB1bnNldEluc3RhbmNlKTtcclxuICAgICAgICAgICAgaWYgKGlzU1NSKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIHByb21pc2Ugc28gc2VydmVyLXJlbmRlcmVyIGNhbiB3YWl0IG9uIGl0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBSZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICAudGhlbigocmVzb2x2ZWRSZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgcmVzb2x2ZWRSZXN1bHQsIGlzU1NSKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGluc3RhbmNlLCAwIC8qIFNFVFVQX0ZVTkNUSU9OICovKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gYXN5bmMgc2V0dXAgcmV0dXJuZWQgUHJvbWlzZS5cclxuICAgICAgICAgICAgICAgIC8vIGJhaWwgaGVyZSBhbmQgd2FpdCBmb3IgcmUtZW50cnkuXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5hc3luY0RlcCA9IHNldHVwUmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uJDEoc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgLy8gc2V0dXAgcmV0dXJuZWQgYW4gaW5saW5lIHJlbmRlciBmdW5jdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QkMShzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzVk5vZGUoc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHNldHVwKCkgc2hvdWxkIG5vdCByZXR1cm4gVk5vZGVzIGRpcmVjdGx5IC0gYCArXHJcbiAgICAgICAgICAgICAgICBgcmV0dXJuIGEgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldHVwIHJldHVybmVkIGJpbmRpbmdzLlxyXG4gICAgICAgIC8vIGFzc3VtaW5nIGEgcmVuZGVyIGZ1bmN0aW9uIGNvbXBpbGVkIGZyb20gdGVtcGxhdGUgaXMgcHJlc2VudC5cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5kZXZ0b29sc1Jhd1NldHVwU3RhdGUgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2Uuc2V0dXBTdGF0ZSA9IHByb3h5UmVmcyhzZXR1cFJlc3VsdCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2V0dXBSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHdhcm4oYHNldHVwKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuIFJlY2VpdmVkOiAke3NldHVwUmVzdWx0ID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHNldHVwUmVzdWx0fWApO1xyXG4gICAgfVxyXG4gICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcclxufVxyXG5sZXQgY29tcGlsZTtcclxuLy8gZGV2IG9ubHlcclxuY29uc3QgaXNSdW50aW1lT25seSA9ICgpID0+ICFjb21waWxlO1xyXG4vKipcclxuICogRm9yIHJ1bnRpbWUtZG9tIHRvIHJlZ2lzdGVyIHRoZSBjb21waWxlci5cclxuICogTm90ZSB0aGUgZXhwb3J0ZWQgbWV0aG9kIHVzZXMgYW55IHRvIGF2b2lkIGQudHMgcmVseWluZyBvbiB0aGUgY29tcGlsZXIgdHlwZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlclJ1bnRpbWVDb21waWxlcihfY29tcGlsZSkge1xyXG4gICAgY29tcGlsZSA9IF9jb21waWxlO1xyXG59XHJcbmZ1bmN0aW9uIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUiwgc2tpcE9wdGlvbnMpIHtcclxuICAgIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICAvLyB0ZW1wbGF0ZSAvIHJlbmRlciBmdW5jdGlvbiBub3JtYWxpemF0aW9uXHJcbiAgICBpZiAoIWluc3RhbmNlLnJlbmRlcikge1xyXG4gICAgICAgIC8vIGNvdWxkIGJlIHNldCBmcm9tIHNldHVwKClcclxuICAgICAgICBpZiAoY29tcGlsZSAmJiAhQ29tcG9uZW50LnJlbmRlcikge1xyXG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IENvbXBvbmVudC50ZW1wbGF0ZTtcclxuICAgICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpc0N1c3RvbUVsZW1lbnQsIGNvbXBpbGVyT3B0aW9ucyB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGltaXRlcnMsIGNvbXBpbGVyT3B0aW9uczogY29tcG9uZW50Q29tcGlsZXJPcHRpb25zIH0gPSBDb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5hbENvbXBpbGVyT3B0aW9ucyA9IGV4dGVuZChleHRlbmQoe1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXJzXHJcbiAgICAgICAgICAgICAgICB9LCBjb21waWxlck9wdGlvbnMpLCBjb21wb25lbnRDb21waWxlck9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnJlbmRlciA9IGNvbXBpbGUodGVtcGxhdGUsIGZpbmFsQ29tcGlsZXJPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IChDb21wb25lbnQucmVuZGVyIHx8IE5PT1ApO1xyXG4gICAgICAgIC8vIGZvciBydW50aW1lLWNvbXBpbGVkIHJlbmRlciBmdW5jdGlvbnMgdXNpbmcgYHdpdGhgIGJsb2NrcywgdGhlIHJlbmRlclxyXG4gICAgICAgIC8vIHByb3h5IHVzZWQgbmVlZHMgYSBkaWZmZXJlbnQgYGhhc2AgaGFuZGxlciB3aGljaCBpcyBtb3JlIHBlcmZvcm1hbnQgYW5kXHJcbiAgICAgICAgLy8gYWxzbyBvbmx5IGFsbG93cyBhIHdoaXRlbGlzdCBvZiBnbG9iYWxzIHRvIGZhbGx0aHJvdWdoLlxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5yZW5kZXIuX3JjKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLndpdGhQcm94eSA9IG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gc3VwcG9ydCBmb3IgMi54IG9wdGlvbnNcclxuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICEoZmFsc2UgKSkge1xyXG4gICAgICAgIGN1cnJlbnRJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICBhcHBseU9wdGlvbnMoaW5zdGFuY2UpO1xyXG4gICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gd2FybiBtaXNzaW5nIHRlbXBsYXRlL3JlbmRlclxyXG4gICAgLy8gdGhlIHJ1bnRpbWUgY29tcGlsYXRpb24gb2YgdGVtcGxhdGUgaW4gU1NSIGlzIGRvbmUgYnkgc2VydmVyLXJlbmRlclxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhQ29tcG9uZW50LnJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1AgJiYgIWlzU1NSKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCFjb21waWxlICYmIENvbXBvbmVudC50ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgcHJvdmlkZWQgdGVtcGxhdGUgb3B0aW9uIGJ1dCBgICtcclxuICAgICAgICAgICAgICAgIGBydW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArXHJcbiAgICAgICAgICAgICAgICAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gXHJcbiAgICAgICAgICAgICAgICAgICAgKSAvKiBzaG91bGQgbm90IGhhcHBlbiAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgaXMgbWlzc2luZyB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IGF0dHJEZXZQcm94eUhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAodGFyZ2V0LCBrZXkpID0+IHtcclxuICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxuICAgIH0sXHJcbiAgICBzZXQ6ICgpID0+IHtcclxuICAgICAgICB3YXJuKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuICAgIGRlbGV0ZVByb3BlcnR5OiAoKSA9PiB7XHJcbiAgICAgICAgd2Fybihgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCBleHBvc2UgPSBleHBvc2VkID0+IHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGluc3RhbmNlLmV4cG9zZWQpIHtcclxuICAgICAgICAgICAgd2FybihgZXhwb3NlKCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UgcGVyIHNldHVwKCkuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLmV4cG9zZWQgPSBleHBvc2VkIHx8IHt9O1xyXG4gICAgfTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBsZXQgYXR0cnM7XHJcbiAgICAgICAgLy8gV2UgdXNlIGdldHRlcnMgaW4gZGV2IGluIGNhc2UgbGlicyBsaWtlIHRlc3QtdXRpbHMgb3ZlcndyaXRlIGluc3RhbmNlXHJcbiAgICAgICAgLy8gcHJvcGVydGllcyAob3ZlcndyaXRlcyBzaG91bGQgbm90IGJlIGRvbmUgaW4gcHJvZClcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgICAgIGdldCBhdHRycygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoYXR0cnMgfHwgKGF0dHJzID0gbmV3IFByb3h5KGluc3RhbmNlLmF0dHJzLCBhdHRyRGV2UHJveHlIYW5kbGVycykpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0IHNsb3RzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dSZWFkb25seShpbnN0YW5jZS5zbG90cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCBlbWl0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4gaW5zdGFuY2UuZW1pdChldmVudCwgLi4uYXJncyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV4cG9zZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYXR0cnM6IGluc3RhbmNlLmF0dHJzLFxyXG4gICAgICAgICAgICBzbG90czogaW5zdGFuY2Uuc2xvdHMsXHJcbiAgICAgICAgICAgIGVtaXQ6IGluc3RhbmNlLmVtaXQsXHJcbiAgICAgICAgICAgIGV4cG9zZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0RXhwb3NlUHJveHkoaW5zdGFuY2UpIHtcclxuICAgIGlmIChpbnN0YW5jZS5leHBvc2VkKSB7XHJcbiAgICAgICAgcmV0dXJuIChpbnN0YW5jZS5leHBvc2VQcm94eSB8fFxyXG4gICAgICAgICAgICAoaW5zdGFuY2UuZXhwb3NlUHJveHkgPSBuZXcgUHJveHkocHJveHlSZWZzKG1hcmtSYXcoaW5zdGFuY2UuZXhwb3NlZCkpLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5IGluIHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSBpbiBwdWJsaWNQcm9wZXJ0aWVzTWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpKTtcclxuICAgIH1cclxufVxyXG4vLyByZWNvcmQgZWZmZWN0cyBjcmVhdGVkIGR1cmluZyBhIGNvbXBvbmVudCdzIHNldHVwKCkgc28gdGhhdCB0aGV5IGNhbiBiZVxyXG4vLyBzdG9wcGVkIHdoZW4gdGhlIGNvbXBvbmVudCB1bm1vdW50c1xyXG5mdW5jdGlvbiByZWNvcmRJbnN0YW5jZUJvdW5kRWZmZWN0KGVmZmVjdCwgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIChpbnN0YW5jZS5lZmZlY3RzIHx8IChpbnN0YW5jZS5lZmZlY3RzID0gW10pKS5wdXNoKGVmZmVjdCk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcclxuY29uc3QgY2xhc3NpZnkgPSAoc3RyKSA9PiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCBjID0+IGMudG9VcHBlckNhc2UoKSkucmVwbGFjZSgvWy1fXS9nLCAnJyk7XHJcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB7XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbiQxKENvbXBvbmVudClcclxuICAgICAgICA/IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZVxyXG4gICAgICAgIDogQ29tcG9uZW50Lm5hbWU7XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gZm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgQ29tcG9uZW50LCBpc1Jvb3QgPSBmYWxzZSkge1xyXG4gICAgbGV0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCk7XHJcbiAgICBpZiAoIW5hbWUgJiYgQ29tcG9uZW50Ll9fZmlsZSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gQ29tcG9uZW50Ll9fZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC5cXHcrJC8pO1xyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICBuYW1lID0gbWF0Y2hbMV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFuYW1lICYmIGluc3RhbmNlICYmIGluc3RhbmNlLnBhcmVudCkge1xyXG4gICAgICAgIC8vIHRyeSB0byBpbmZlciB0aGUgbmFtZSBiYXNlZCBvbiByZXZlcnNlIHJlc29sdXRpb25cclxuICAgICAgICBjb25zdCBpbmZlckZyb21SZWdpc3RyeSA9IChyZWdpc3RyeSkgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZWdpc3RyeSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lzdHJ5W2tleV0gPT09IENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIG5hbWUgPVxyXG4gICAgICAgICAgICBpbmZlckZyb21SZWdpc3RyeShpbnN0YW5jZS5jb21wb25lbnRzIHx8XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQudHlwZS5jb21wb25lbnRzKSB8fCBpbmZlckZyb21SZWdpc3RyeShpbnN0YW5jZS5hcHBDb250ZXh0LmNvbXBvbmVudHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5hbWUgPyBjbGFzc2lmeShuYW1lKSA6IGlzUm9vdCA/IGBBcHBgIDogYEFub255bW91c2A7XHJcbn1cclxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24kMSh2YWx1ZSkgJiYgJ19fdmNjT3B0cycgaW4gdmFsdWU7XHJcbn1cblxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zKSB7XHJcbiAgICBjb25zdCBjID0gY29tcHV0ZWQkMShnZXR0ZXJPck9wdGlvbnMpO1xyXG4gICAgcmVjb3JkSW5zdGFuY2VCb3VuZEVmZmVjdChjLmVmZmVjdCk7XHJcbiAgICByZXR1cm4gYztcclxufVxuXG4ocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcclxuICAgIDoge307XHJcbihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XHJcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xyXG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JztcclxuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xyXG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xyXG59O1xuXG4vLyBkZXYgb25seVxyXG5jb25zdCB3YXJuUnVudGltZVVzYWdlID0gKG1ldGhvZCkgPT4gd2FybihgJHttZXRob2R9KCkgaXMgYSBjb21waWxlci1oaW50IGhlbHBlciB0aGF0IGlzIG9ubHkgdXNhYmxlIGluc2lkZSBgICtcclxuICAgIGA8c2NyaXB0IHNldHVwPiBvZiBhIHNpbmdsZSBmaWxlIGNvbXBvbmVudC4gSXRzIGFyZ3VtZW50cyBzaG91bGQgYmUgYCArXHJcbiAgICBgY29tcGlsZWQgYXdheSBhbmQgcGFzc2luZyBpdCBhdCBydW50aW1lIGhhcyBubyBlZmZlY3QuYCk7XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGRlZmluZVByb3BzKCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVByb3BzYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBkZWZpbmVFbWl0cygpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFbWl0c2ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIEBkZXByZWNhdGVkIHVzZSBgZGVmaW5lRW1pdHNgIGluc3RlYWQuXHJcbiAqL1xyXG5jb25zdCBkZWZpbmVFbWl0ID0gZGVmaW5lRW1pdHM7XHJcbi8qKlxyXG4gKiBWdWUgYDxzY3JpcHQgc2V0dXA+YCBjb21waWxlciBtYWNybyBmb3IgZGVjbGFyaW5nIGEgY29tcG9uZW50J3MgZXhwb3NlZFxyXG4gKiBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gaXQgaXMgYWNjZXNzZWQgYnkgYSBwYXJlbnQgY29tcG9uZW50IHZpYSB0ZW1wbGF0ZVxyXG4gKiByZWZzLlxyXG4gKlxyXG4gKiBgPHNjcmlwdCBzZXR1cD5gIGNvbXBvbmVudHMgYXJlIGNsb3NlZCBieSBkZWZhdWx0IC0gaS5lLiB2YXJhaWJsZXMgaW5zaWRlXHJcbiAqIHRoZSBgPHNjcmlwdCBzZXR1cD5gIHNjb3BlIGlzIG5vdCBleHBvc2VkIHRvIHBhcmVudCB1bmxlc3MgZXhwbGljaXRseSBleHBvc2VkXHJcbiAqIHZpYSBgZGVmaW5lRXhwb3NlYC5cclxuICpcclxuICogVGhpcyBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgYDxzY3JpcHQgc2V0dXA+YCwgaXMgY29tcGlsZWQgYXdheSBpbiB0aGVcclxuICogb3V0cHV0IGFuZCBzaG91bGQgKipub3QqKiBiZSBhY3R1YWxseSBjYWxsZWQgYXQgcnVudGltZS5cclxuICovXHJcbmZ1bmN0aW9uIGRlZmluZUV4cG9zZShleHBvc2VkKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRXhwb3NlYCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFZ1ZSBgPHNjcmlwdCBzZXR1cD5gIGNvbXBpbGVyIG1hY3JvIGZvciBwcm92aWRpbmcgcHJvcHMgZGVmYXVsdCB2YWx1ZXMgd2hlblxyXG4gKiB1c2luZyB0eXBlLWJhc2VkIGBkZWZpbmVQcm9wc2AgZGVjYWxyYXRpb24uXHJcbiAqXHJcbiAqIEV4YW1wbGUgdXNhZ2U6XHJcbiAqIGBgYHRzXHJcbiAqIHdpdGhEZWZhdWx0cyhkZWZpbmVQcm9wczx7XHJcbiAqICAgc2l6ZT86IG51bWJlclxyXG4gKiAgIGxhYmVscz86IHN0cmluZ1tdXHJcbiAqIH0+KCksIHtcclxuICogICBzaXplOiAzLFxyXG4gKiAgIGxhYmVsczogKCkgPT4gWydkZWZhdWx0IGxhYmVsJ11cclxuICogfSlcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoaXMgaXMgb25seSB1c2FibGUgaW5zaWRlIGA8c2NyaXB0IHNldHVwPmAsIGlzIGNvbXBpbGVkIGF3YXkgaW4gdGhlIG91dHB1dFxyXG4gKiBhbmQgc2hvdWxkICoqbm90KiogYmUgYWN0dWFsbHkgY2FsbGVkIGF0IHJ1bnRpbWUuXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoRGVmYXVsdHMocHJvcHMsIGRlZmF1bHRzKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FyblJ1bnRpbWVVc2FnZShgd2l0aERlZmF1bHRzYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vKipcclxuICogQGRlcHJlY2F0ZWQgdXNlIGB1c2VTbG90c2AgYW5kIGB1c2VBdHRyc2AgaW5zdGVhZC5cclxuICovXHJcbmZ1bmN0aW9uIHVzZUNvbnRleHQoKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgXFxgdXNlQ29udGV4dCgpXFxgIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgYCArXHJcbiAgICAgICAgICAgIGBuZXh0IG1pbm9yIHJlbGVhc2UuIFVzZSBcXGB1c2VTbG90cygpXFxgIGFuZCBcXGB1c2VBdHRycygpXFxgIGluc3RlYWQuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpO1xyXG59XHJcbmZ1bmN0aW9uIHVzZVNsb3RzKCkge1xyXG4gICAgcmV0dXJuIGdldENvbnRleHQoKS5zbG90cztcclxufVxyXG5mdW5jdGlvbiB1c2VBdHRycygpIHtcclxuICAgIHJldHVybiBnZXRDb250ZXh0KCkuYXR0cnM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcclxuICAgIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWkpIHtcclxuICAgICAgICB3YXJuKGB1c2VDb250ZXh0KCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGkuc2V0dXBDb250ZXh0IHx8IChpLnNldHVwQ29udGV4dCA9IGNyZWF0ZVNldHVwQ29udGV4dChpKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIGRlZmF1bHQgZGVjbGFyYXRpb25zLiBJbXBvcnRlZCBieSBjb21waWxlZCBjb2RlXHJcbiAqIG9ubHkuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyhcclxuLy8gdGhlIGJhc2UgcHJvcHMgaXMgY29tcGlsZXItZ2VuZXJhdGVkIGFuZCBndWFyYW50ZWVkIHRvIGJlIGluIHRoaXMgc2hhcGUuXHJcbnByb3BzLCBkZWZhdWx0cykge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIHtcclxuICAgICAgICBjb25zdCB2YWwgPSBwcm9wc1trZXldO1xyXG4gICAgICAgIGlmICh2YWwpIHtcclxuICAgICAgICAgICAgdmFsLmRlZmF1bHQgPSBkZWZhdWx0c1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHsgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgcHJvcHMgZGVmYXVsdCBrZXkgXCIke2tleX1cIiBoYXMgbm8gY29ycmVzcG9uZGluZyBkZWNsYXJhdGlvbi5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcHM7XHJcbn1cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBzdG9yaW5nIGFuZCByZXN1bWluZyBjdXJyZW50IGluc3RhbmNlIGNvbnRleHQgaW5cclxuICogYXN5bmMgc2V0dXAoKS5cclxuICovXHJcbmZ1bmN0aW9uIHdpdGhBc3luY0NvbnRleHQoYXdhaXRhYmxlKSB7XHJcbiAgICBjb25zdCBjdHggPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIHNldEN1cnJlbnRJbnN0YW5jZShudWxsKTsgLy8gdW5zZXQgYWZ0ZXIgc3RvcmluZyBpbnN0YW5jZVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY3R4KSB7XHJcbiAgICAgICAgd2Fybihgd2l0aEFzeW5jQ29udGV4dCgpIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb250ZXh0IGluc3RhbmNlLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzUHJvbWlzZShhd2FpdGFibGUpXHJcbiAgICAgICAgPyBhd2FpdGFibGUudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9LCBlcnIgPT4ge1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgOiBhd2FpdGFibGU7XHJcbn1cblxuLy8gQWN0dWFsIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGgodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbikge1xyXG4gICAgY29uc3QgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICBpZiAobCA9PT0gMikge1xyXG4gICAgICAgIGlmIChpc09iamVjdCQxKHByb3BzT3JDaGlsZHJlbikgJiYgIWlzQXJyYXkocHJvcHNPckNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAvLyBzaW5nbGUgdm5vZGUgd2l0aG91dCBwcm9wc1xyXG4gICAgICAgICAgICBpZiAoaXNWTm9kZShwcm9wc09yQ2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgW3Byb3BzT3JDaGlsZHJlbl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByb3BzIHdpdGhvdXQgY2hpbGRyZW5cclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBvbWl0IHByb3BzXHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBwcm9wc09yQ2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChsID4gMykge1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGwgPT09IDMgJiYgaXNWTm9kZShjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY2hpbGRyZW5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbik7XHJcbiAgICB9XHJcbn1cblxuY29uc3Qgc3NyQ29udGV4dEtleSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgc3NyQ29udGV4dGAgOiBgYCk7XHJcbmNvbnN0IHVzZVNTUkNvbnRleHQgPSAoKSA9PiB7XHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gaW5qZWN0KHNzckNvbnRleHRLZXkpO1xyXG4gICAgICAgIGlmICghY3R4KSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFNlcnZlciByZW5kZXJpbmcgY29udGV4dCBub3QgcHJvdmlkZWQuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgYCArXHJcbiAgICAgICAgICAgICAgICBgdXNlU1NSQ29udGV4dCgpIGNvbmRpdGlvbmFsbHkgaW4gdGhlIHNlcnZlciBidWlsZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN0eDtcclxuICAgIH1cclxufTtcblxuZnVuY3Rpb24gaW5pdEN1c3RvbUZvcm1hdHRlcigpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG4gICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB2dWVTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojM2JhNzc2JyB9O1xyXG4gICAgY29uc3QgbnVtYmVyU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6IzBiMWJjOScgfTtcclxuICAgIGNvbnN0IHN0cmluZ1N0eWxlID0geyBzdHlsZTogJ2NvbG9yOiNiNjJlMjQnIH07XHJcbiAgICBjb25zdCBrZXl3b3JkU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6IzlkMjg4YycgfTtcclxuICAgIC8vIGN1c3RvbSBmb3JtYXR0ZXIgZm9yIENocm9tZVxyXG4gICAgLy8gaHR0cHM6Ly93d3cubWF0dHpldW5lcnQuY29tLzIwMTYvMDIvMTkvY3VzdG9tLWNocm9tZS1kZXZ0b29scy1vYmplY3QtZm9ybWF0dGVycy5odG1sXHJcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSB7XHJcbiAgICAgICAgaGVhZGVyKG9iaikge1xyXG4gICAgICAgICAgICAvLyBUT0RPIGFsc28gZm9ybWF0IENvbXBvbmVudFB1YmxpY0luc3RhbmNlICYgY3R4LnNsb3RzL2F0dHJzIGluIHNldHVwXHJcbiAgICAgICAgICAgIGlmICghaXNPYmplY3QkMShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2JqLl9faXNWdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2RpdicsIHZ1ZVN0eWxlLCBgVnVlSW5zdGFuY2VgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlZihvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIHZ1ZVN0eWxlLCBnZW5SZWZGbGFnKG9iaildLFxyXG4gICAgICAgICAgICAgICAgICAgICc8JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmoudmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIGA+YFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWN0aXZlKG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsICdSZWFjdGl2ZSddLFxyXG4gICAgICAgICAgICAgICAgICAgICc8JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxyXG4gICAgICAgICAgICAgICAgICAgIGA+JHtpc1JlYWRvbmx5KG9iaikgPyBgIChyZWFkb25seSlgIDogYGB9YFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWRvbmx5KG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsICdSZWFkb25seSddLFxyXG4gICAgICAgICAgICAgICAgICAgICc8JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxyXG4gICAgICAgICAgICAgICAgICAgICc+J1xyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhc0JvZHkob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgb2JqLl9faXNWdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5KG9iaikge1xyXG4gICAgICAgICAgICBpZiAob2JqICYmIG9iai5fX2lzVnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLmZvcm1hdEluc3RhbmNlKG9iai4kKVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBmb3JtYXRJbnN0YW5jZShpbnN0YW5jZSkge1xyXG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IFtdO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS50eXBlLnByb3BzICYmIGluc3RhbmNlLnByb3BzKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ3Byb3BzJywgdG9SYXcoaW5zdGFuY2UucHJvcHMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5zZXR1cFN0YXRlICE9PSBFTVBUWV9PQkopIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnc2V0dXAnLCBpbnN0YW5jZS5zZXR1cFN0YXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5kYXRhICE9PSBFTVBUWV9PQkopIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnZGF0YScsIHRvUmF3KGluc3RhbmNlLmRhdGEpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsICdjb21wdXRlZCcpO1xyXG4gICAgICAgIGlmIChjb21wdXRlZCkge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdjb21wdXRlZCcsIGNvbXB1dGVkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluamVjdGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsICdpbmplY3QnKTtcclxuICAgICAgICBpZiAoaW5qZWN0ZWQpIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnaW5qZWN0ZWQnLCBpbmplY3RlZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBibG9ja3MucHVzaChbXHJcbiAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgJ3NwYW4nLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBrZXl3b3JkU3R5bGUuc3R5bGUgKyAnO29wYWNpdHk6MC42NidcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAnJCAoaW50ZXJuYWwpOiAnXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFsnb2JqZWN0JywgeyBvYmplY3Q6IGluc3RhbmNlIH1dXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgcmV0dXJuIGJsb2NrcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQmxvY2sodHlwZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gZXh0ZW5kKHt9LCB0YXJnZXQpO1xyXG4gICAgICAgIGlmICghT2JqZWN0LmtleXModGFyZ2V0KS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHt9XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgIHsgc3R5bGU6ICdsaW5lLWhlaWdodDoxLjI1ZW07bWFyZ2luLWJvdHRvbTowLjZlbScgfSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdjb2xvcjojNDc2NTgyJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHR5cGVcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdwYWRkaW5nLWxlZnQ6MS4yNWVtJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKHRhcmdldCkubWFwKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCBrZXl3b3JkU3R5bGUsIGtleSArICc6ICddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZSh0YXJnZXRba2V5XSwgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodiwgYXNSYXcgPSB0cnVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgbnVtYmVyU3R5bGUsIHZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHN0cmluZ1N0eWxlLCBKU09OLnN0cmluZ2lmeSh2KV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIGtleXdvcmRTdHlsZSwgdl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0JDEodikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnb2JqZWN0JywgeyBvYmplY3Q6IGFzUmF3ID8gdG9SYXcodikgOiB2IH1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHN0cmluZ1N0eWxlLCBTdHJpbmcodildO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RLZXlzKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICAgICAgY29uc3QgQ29tcCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24kMShDb21wKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IHt9O1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLmN0eCkge1xyXG4gICAgICAgICAgICBpZiAoaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkW2tleV0gPSBpbnN0YW5jZS5jdHhba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXh0cmFjdGVkO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0cyA9IENvbXBbdHlwZV07XHJcbiAgICAgICAgaWYgKChpc0FycmF5KG9wdHMpICYmIG9wdHMuaW5jbHVkZXMoa2V5KSkgfHxcclxuICAgICAgICAgICAgKGlzT2JqZWN0JDEob3B0cykgJiYga2V5IGluIG9wdHMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcC5leHRlbmRzICYmIGlzS2V5T2ZUeXBlKENvbXAuZXh0ZW5kcywga2V5LCB0eXBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXAubWl4aW5zICYmIENvbXAubWl4aW5zLnNvbWUobSA9PiBpc0tleU9mVHlwZShtLCBrZXksIHR5cGUpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZW5SZWZGbGFnKHYpIHtcclxuICAgICAgICBpZiAodi5fc2hhbGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gYFNoYWxsb3dSZWZgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodi5lZmZlY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBDb21wdXRlZFJlZmA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBgUmVmYDtcclxuICAgIH1cclxuICAgIGlmICh3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzKSB7XHJcbiAgICAgICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzID0gW2Zvcm1hdHRlcl07XHJcbiAgICB9XHJcbn1cblxuLy8gQ29yZSBBUEkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbmNvbnN0IHZlcnNpb24gPSBcIjMuMS40XCI7XHJcbi8qKlxyXG4gKiBTU1IgdXRpbHMgZm9yIFxcQHZ1ZS9zZXJ2ZXItcmVuZGVyZXIuIE9ubHkgZXhwb3NlZCBpbiBjanMgYnVpbGRzLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IHNzclV0aWxzID0gKG51bGwpO1xyXG4vKipcclxuICogQGludGVybmFsIG9ubHkgZXhwb3NlZCBpbiBjb21wYXQgYnVpbGRzXHJcbiAqL1xyXG5jb25zdCByZXNvbHZlRmlsdGVyID0gbnVsbDtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBvbmx5IGV4cG9zZWQgaW4gY29tcGF0IGJ1aWxkcy5cclxuICovXHJcbmNvbnN0IGNvbXBhdFV0aWxzID0gKG51bGwpO1xuXG5leHBvcnQgeyBCYXNlVHJhbnNpdGlvbiwgQ29tbWVudCQxIGFzIENvbW1lbnQsIEZyYWdtZW50LCBLZWVwQWxpdmUsIFN0YXRpYywgU3VzcGVuc2UsIFRlbGVwb3J0LCBUZXh0LCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgY2FsbFdpdGhFcnJvckhhbmRsaW5nLCBjbG9uZVZOb2RlLCBjb21wYXRVdGlscywgY29tcHV0ZWQsIGNyZWF0ZUJsb2NrLCBjcmVhdGVDb21tZW50Vk5vZGUsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyLCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlU2xvdHMsIGNyZWF0ZVN0YXRpY1ZOb2RlLCBjcmVhdGVUZXh0Vk5vZGUsIGNyZWF0ZVZOb2RlLCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWZpbmVFbWl0LCBkZWZpbmVFbWl0cywgZGVmaW5lRXhwb3NlLCBkZWZpbmVQcm9wcywgZGV2dG9vbHMsIGdldEN1cnJlbnRJbnN0YW5jZSwgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuLCBoLCBoYW5kbGVFcnJvciwgaW5pdEN1c3RvbUZvcm1hdHRlciwgaW5qZWN0LCBpc1J1bnRpbWVPbmx5LCBpc1ZOb2RlLCBtZXJnZURlZmF1bHRzLCBtZXJnZVByb3BzLCBuZXh0VGljaywgb25BY3RpdmF0ZWQsIG9uQmVmb3JlTW91bnQsIG9uQmVmb3JlVW5tb3VudCwgb25CZWZvcmVVcGRhdGUsIG9uRGVhY3RpdmF0ZWQsIG9uRXJyb3JDYXB0dXJlZCwgb25Nb3VudGVkLCBvblJlbmRlclRyYWNrZWQsIG9uUmVuZGVyVHJpZ2dlcmVkLCBvblNlcnZlclByZWZldGNoLCBvblVubW91bnRlZCwgb25VcGRhdGVkLCBvcGVuQmxvY2ssIHBvcFNjb3BlSWQsIHByb3ZpZGUsIHB1c2hTY29wZUlkLCBxdWV1ZVBvc3RGbHVzaENiLCByZWdpc3RlclJ1bnRpbWVDb21waWxlciwgcmVuZGVyTGlzdCwgcmVuZGVyU2xvdCwgcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSwgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsIHJlc29sdmVGaWx0ZXIsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIHNldEJsb2NrVHJhY2tpbmcsIHNldERldnRvb2xzSG9vaywgc2V0VHJhbnNpdGlvbkhvb2tzLCBzc3JDb250ZXh0S2V5LCBzc3JVdGlscywgdG9IYW5kbGVycywgdHJhbnNmb3JtVk5vZGVBcmdzLCB1c2VBdHRycywgdXNlQ29udGV4dCwgdXNlU1NSQ29udGV4dCwgdXNlU2xvdHMsIHVzZVRyYW5zaXRpb25TdGF0ZSwgdmVyc2lvbiwgd2Fybiwgd2F0Y2gsIHdhdGNoRWZmZWN0LCB3aXRoQXN5bmNDb250ZXh0LCB3aXRoQ3R4LCB3aXRoRGVmYXVsdHMsIHdpdGhEaXJlY3RpdmVzLCB3aXRoU2NvcGVJZCB9O1xuIiwiaW1wb3J0IHsgY2FtZWxpemUsIHdhcm4sIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBnZXRDdXJyZW50SW5zdGFuY2UsIG9uTW91bnRlZCwgd2F0Y2hFZmZlY3QsIG9uVXBkYXRlZCwgRnJhZ21lbnQsIGgsIEJhc2VUcmFuc2l0aW9uLCB1c2VUcmFuc2l0aW9uU3RhdGUsIHRvUmF3LCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIHNldFRyYW5zaXRpb25Ib29rcywgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgY3JlYXRlVk5vZGUsIGNyZWF0ZVJlbmRlcmVyLCBpc1J1bnRpbWVPbmx5LCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciB9IGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0FycmF5LCBoeXBoZW5hdGUsIGNhcGl0YWxpemUsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc09uLCBpc01vZGVsTGlzdGVuZXIsIGlzRnVuY3Rpb24sIEVNUFRZX09CSiwgZXh0ZW5kLCBpc09iamVjdCwgdG9OdW1iZXIsIGludm9rZUFycmF5Rm5zLCBsb29zZUluZGV4T2YsIGlzU2V0LCBsb29zZUVxdWFsLCBpc0hUTUxUYWcsIGlzU1ZHVGFnIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcbmNvbnN0IGRvYyA9ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsKTtcclxuY29uc3Qgbm9kZU9wcyA9IHtcclxuICAgIGluc2VydDogKGNoaWxkLCBwYXJlbnQsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGFuY2hvciB8fCBudWxsKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmU6IGNoaWxkID0+IHtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlRWxlbWVudDogKHRhZywgaXNTVkcsIGlzLCBwcm9wcykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsID0gaXNTVkdcclxuICAgICAgICAgICAgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCB0YWcpXHJcbiAgICAgICAgICAgIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCBpcyA/IHsgaXMgfSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgaWYgKHRhZyA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMgJiYgcHJvcHMubXVsdGlwbGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgcHJvcHMubXVsdGlwbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlVGV4dDogdGV4dCA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCksXHJcbiAgICBjcmVhdGVDb21tZW50OiB0ZXh0ID0+IGRvYy5jcmVhdGVDb21tZW50KHRleHQpLFxyXG4gICAgc2V0VGV4dDogKG5vZGUsIHRleHQpID0+IHtcclxuICAgICAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XHJcbiAgICB9LFxyXG4gICAgc2V0RWxlbWVudFRleHQ6IChlbCwgdGV4dCkgPT4ge1xyXG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcclxuICAgIH0sXHJcbiAgICBwYXJlbnROb2RlOiBub2RlID0+IG5vZGUucGFyZW50Tm9kZSxcclxuICAgIG5leHRTaWJsaW5nOiBub2RlID0+IG5vZGUubmV4dFNpYmxpbmcsXHJcbiAgICBxdWVyeVNlbGVjdG9yOiBzZWxlY3RvciA9PiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXHJcbiAgICBzZXRTY29wZUlkKGVsLCBpZCkge1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShpZCwgJycpO1xyXG4gICAgfSxcclxuICAgIGNsb25lTm9kZShlbCkge1xyXG4gICAgICAgIGNvbnN0IGNsb25lZCA9IGVsLmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICAvLyAjMzA3MlxyXG4gICAgICAgIC8vIC0gaW4gYHBhdGNoRE9NUHJvcGAsIHdlIHN0b3JlIHRoZSBhY3R1YWwgdmFsdWUgaW4gdGhlIGBlbC5fdmFsdWVgIHByb3BlcnR5LlxyXG4gICAgICAgIC8vIC0gbm9ybWFsbHksIGVsZW1lbnRzIHVzaW5nIGA6dmFsdWVgIGJpbmRpbmdzIHdpbGwgbm90IGJlIGhvaXN0ZWQsIGJ1dCBpZlxyXG4gICAgICAgIC8vICAgdGhlIGJvdW5kIHZhbHVlIGlzIGEgY29uc3RhbnQsIGUuZy4gYDp2YWx1ZT1cInRydWVcImAgLSB0aGV5IGRvIGdldFxyXG4gICAgICAgIC8vICAgaG9pc3RlZC5cclxuICAgICAgICAvLyAtIGluIHByb2R1Y3Rpb24sIGhvaXN0ZWQgbm9kZXMgYXJlIGNsb25lZCB3aGVuIHN1YnNlcXVlbnQgaW5zZXJ0cywgYnV0XHJcbiAgICAgICAgLy8gICBjbG9uZU5vZGUoKSBkb2VzIG5vdCBjb3B5IHRoZSBjdXN0b20gcHJvcGVydHkgd2UgYXR0YWNoZWQuXHJcbiAgICAgICAgLy8gLSBUaGlzIG1heSBuZWVkIHRvIGFjY291bnQgZm9yIG90aGVyIGN1c3RvbSBET00gcHJvcGVydGllcyB3ZSBhdHRhY2ggdG9cclxuICAgICAgICAvLyAgIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIGBfdmFsdWVgIGluIHRoZSBmdXR1cmUuXHJcbiAgICAgICAgaWYgKGBfdmFsdWVgIGluIGVsKSB7XHJcbiAgICAgICAgICAgIGNsb25lZC5fdmFsdWUgPSBlbC5fdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZWQ7XHJcbiAgICB9LFxyXG4gICAgLy8gX19VTlNBRkVfX1xyXG4gICAgLy8gUmVhc29uOiBpbnNlcnRBZGphY2VudEhUTUwuXHJcbiAgICAvLyBTdGF0aWMgY29udGVudCBoZXJlIGNhbiBvbmx5IGNvbWUgZnJvbSBjb21waWxlZCB0ZW1wbGF0ZXMuXHJcbiAgICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxyXG4gICAgaW5zZXJ0U3RhdGljQ29udGVudChjb250ZW50LCBwYXJlbnQsIGFuY2hvciwgaXNTVkcsIGNhY2hlZCkge1xyXG4gICAgICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICAgICAgbGV0IGZpcnN0O1xyXG4gICAgICAgICAgICBsZXQgbGFzdDtcclxuICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICBsZXQgbCA9IGNhY2hlZC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gY2FjaGVkW2ldLmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpID09PSBsIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW2ZpcnN0LCBsYXN0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gPHBhcmVudD4gYmVmb3JlIHwgZmlyc3QgLi4uIGxhc3QgfCBhbmNob3IgPC9wYXJlbnQ+XHJcbiAgICAgICAgY29uc3QgYmVmb3JlID0gYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGQ7XHJcbiAgICAgICAgaWYgKGFuY2hvcikge1xyXG4gICAgICAgICAgICBsZXQgaW5zZXJ0aW9uUG9pbnQ7XHJcbiAgICAgICAgICAgIGxldCB1c2luZ1RlbXBJbnNlcnRpb25Qb2ludCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoYW5jaG9yIGluc3RhbmNlb2YgRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0aW9uUG9pbnQgPSBhbmNob3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnRBZGphY2VudEhUTUwgb25seSB3b3JrcyBmb3IgZWxlbWVudHMgYnV0IHRoZSBhbmNob3IgaXMgbm90IGFuXHJcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50Li4uXHJcbiAgICAgICAgICAgICAgICB1c2luZ1RlbXBJbnNlcnRpb25Qb2ludCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnRpb25Qb2ludCA9IGlzU1ZHXHJcbiAgICAgICAgICAgICAgICAgICAgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCAnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGluc2VydGlvblBvaW50LCBhbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluc2VydGlvblBvaW50Lmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlYmVnaW4nLCBjb250ZW50KTtcclxuICAgICAgICAgICAgaWYgKHVzaW5nVGVtcEluc2VydGlvblBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoaW5zZXJ0aW9uUG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBjb250ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGZpcnN0ID0gYmVmb3JlID8gYmVmb3JlLm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgY29uc3QgbGFzdCA9IGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xyXG4gICAgICAgIGNvbnN0IHJldCA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChmaXJzdCkge1xyXG4gICAgICAgICAgICByZXQucHVzaChmaXJzdCk7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdCA9PT0gbGFzdClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBmaXJzdCA9IGZpcnN0Lm5leHRTaWJsaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG59O1xuXG4vLyBjb21waWxlciBzaG91bGQgbm9ybWFsaXplIGNsYXNzICsgOmNsYXNzIGJpbmRpbmdzIG9uIHRoZSBzYW1lIGVsZW1lbnRcclxuLy8gaW50byBhIHNpbmdsZSBiaW5kaW5nIFsnc3RhdGljQ2xhc3MnLCBkeW5hbWljXVxyXG5mdW5jdGlvbiBwYXRjaENsYXNzKGVsLCB2YWx1ZSwgaXNTVkcpIHtcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdmFsdWUgPSAnJztcclxuICAgIH1cclxuICAgIGlmIChpc1NWRykge1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBkaXJlY3RseSBzZXR0aW5nIGNsYXNzTmFtZSBzaG91bGQgYmUgZmFzdGVyIHRoYW4gc2V0QXR0cmlidXRlIGluIHRoZW9yeVxyXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYW4gZWxlbWVudCBkdXJpbmcgYSB0cmFuc2l0aW9uLCB0YWtlIHRoZSB0ZW1wb3JhcnkgdHJhbnNpdGlvblxyXG4gICAgICAgIC8vIGNsYXNzZXMgaW50byBhY2NvdW50LlxyXG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3Z0YztcclxuICAgICAgICBpZiAodHJhbnNpdGlvbkNsYXNzZXMpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSAodmFsdWVcclxuICAgICAgICAgICAgICAgID8gW3ZhbHVlLCAuLi50cmFuc2l0aW9uQ2xhc3Nlc11cclxuICAgICAgICAgICAgICAgIDogWy4uLnRyYW5zaXRpb25DbGFzc2VzXSkuam9pbignICcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XHJcbiAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgaWYgKCFuZXh0KSB7XHJcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdHJpbmcobmV4dCkpIHtcclxuICAgICAgICBpZiAocHJldiAhPT0gbmV4dCkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gc3R5bGUuZGlzcGxheTtcclxuICAgICAgICAgICAgc3R5bGUuY3NzVGV4dCA9IG5leHQ7XHJcbiAgICAgICAgICAgIC8vIGluZGljYXRlcyB0aGF0IHRoZSBgZGlzcGxheWAgb2YgdGhlIGVsZW1lbnQgaXMgY29udHJvbGxlZCBieSBgdi1zaG93YCxcclxuICAgICAgICAgICAgLy8gc28gd2UgYWx3YXlzIGtlZXAgdGhlIGN1cnJlbnQgYGRpc3BsYXlgIHZhbHVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGBzdHlsZWAgdmFsdWUsXHJcbiAgICAgICAgICAgIC8vIHRodXMgaGFuZGluZyBvdmVyIGNvbnRyb2wgdG8gYHYtc2hvd2AuXHJcbiAgICAgICAgICAgIGlmICgnX3ZvZCcgaW4gZWwpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSBjdXJyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xyXG4gICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBuZXh0W2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldiAmJiAhaXNTdHJpbmcocHJldikpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XHJcbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2YWwpIHtcclxuICAgIGlmIChpc0FycmF5KHZhbCkpIHtcclxuICAgICAgICB2YWwuZm9yRWFjaCh2ID0+IHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCctLScpKSB7XHJcbiAgICAgICAgICAgIC8vIGN1c3RvbSBwcm9wZXJ0eSBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBwcmVmaXhlZCA9IGF1dG9QcmVmaXgoc3R5bGUsIG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAhaW1wb3J0YW50XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUocHJlZml4ZWQpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZVtwcmVmaXhlZF0gPSB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3QgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcclxuY29uc3QgcHJlZml4Q2FjaGUgPSB7fTtcclxuZnVuY3Rpb24gYXV0b1ByZWZpeChzdHlsZSwgcmF3TmFtZSkge1xyXG4gICAgY29uc3QgY2FjaGVkID0gcHJlZml4Q2FjaGVbcmF3TmFtZV07XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgIH1cclxuICAgIGxldCBuYW1lID0gY2FtZWxpemUocmF3TmFtZSk7XHJcbiAgICBpZiAobmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSBpbiBzdHlsZSkge1xyXG4gICAgICAgIHJldHVybiAocHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBuYW1lKTtcclxuICAgIH1cclxuICAgIG5hbWUgPSBjYXBpdGFsaXplKG5hbWUpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyBuYW1lO1xyXG4gICAgICAgIGlmIChwcmVmaXhlZCBpbiBzdHlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHByZWZpeENhY2hlW3Jhd05hbWVdID0gcHJlZml4ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByYXdOYW1lO1xyXG59XG5cbmNvbnN0IHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XHJcbmZ1bmN0aW9uIHBhdGNoQXR0cihlbCwga2V5LCB2YWx1ZSwgaXNTVkcsIGluc3RhbmNlKSB7XHJcbiAgICBpZiAoaXNTVkcgJiYga2V5LnN0YXJ0c1dpdGgoJ3hsaW5rOicpKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywga2V5LnNsaWNlKDYsIGtleS5sZW5ndGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIG5vdGUgd2UgYXJlIG9ubHkgY2hlY2tpbmcgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXQgZG9uJ3QgaGF2ZSBhXHJcbiAgICAgICAgLy8gY29ycmVzcG9uZGluZyBkb20gcHJvcCBvZiB0aGUgc2FtZSBuYW1lIGhlcmUuXHJcbiAgICAgICAgY29uc3QgaXNCb29sZWFuID0gaXNTcGVjaWFsQm9vbGVhbkF0dHIoa2V5KTtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCAoaXNCb29sZWFuICYmIHZhbHVlID09PSBmYWxzZSkpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0Jvb2xlYW4gPyAnJyA6IHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLy8gX19VTlNBRkVfX1xyXG4vLyBmdW5jdGlvbnMuIFRoZSB1c2VyIGlzIHJlc3BvbnNpYmxlIGZvciB1c2luZyB0aGVtIHdpdGggb25seSB0cnVzdGVkIGNvbnRlbnQuXHJcbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgXHJcbi8vIHRoZSBmb2xsb3dpbmcgYXJncyBhcmUgcGFzc2VkIG9ubHkgZHVlIHRvIHBvdGVudGlhbCBpbm5lckhUTUwvdGV4dENvbnRlbnRcclxuLy8gb3ZlcnJpZGluZyBleGlzdGluZyBWTm9kZXMsIGluIHdoaWNoIGNhc2UgdGhlIG9sZCB0cmVlIG11c3QgYmUgcHJvcGVybHlcclxuLy8gdW5tb3VudGVkLlxyXG5wcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikge1xyXG4gICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgfHwga2V5ID09PSAndGV4dENvbnRlbnQnKSB7XHJcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xyXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxba2V5XSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiYgZWwudGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xyXG4gICAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXHJcbiAgICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZC5cclxuICAgICAgICBlbC5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcclxuICAgICAgICBpZiAodmFsdWUgPT09ICcnICYmIHR5cGUgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAvLyBlLmcuIDxzZWxlY3QgbXVsdGlwbGU+IGNvbXBpbGVzIHRvIHsgbXVsdGlwbGU6ICcnIH1cclxuICAgICAgICAgICAgZWxba2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gbnVsbCAmJiB0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAvLyBlLmcuIDxkaXYgOmlkPVwibnVsbFwiPlxyXG4gICAgICAgICAgICBlbFtrZXldID0gJyc7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPGltZyA6d2lkdGg9XCJudWxsXCI+XHJcbiAgICAgICAgICAgIGVsW2tleV0gPSAwO1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHNvbWUgcHJvcGVydGllcyBwZXJmb3JtIHZhbHVlIHZhbGlkYXRpb24gYW5kIHRocm93XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGVsW2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBGYWlsZWQgc2V0dGluZyBwcm9wIFwiJHtrZXl9XCIgb24gPCR7ZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpfT46IGAgK1xyXG4gICAgICAgICAgICAgICAgYHZhbHVlICR7dmFsdWV9IGlzIGludmFsaWQuYCwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXHJcbmxldCBfZ2V0Tm93ID0gRGF0ZS5ub3c7XHJcbmxldCBza2lwVGltZXN0YW1wQ2hlY2sgPSBmYWxzZTtcclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyBEZXRlcm1pbmUgd2hhdCBldmVudCB0aW1lc3RhbXAgdGhlIGJyb3dzZXIgaXMgdXNpbmcuIEFubm95aW5nbHksIHRoZVxyXG4gICAgLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcclxuICAgIC8vIChyZWxhdGl2ZSB0byBVTklYIGVwb2NoKSwgc28gaW4gb3JkZXIgdG8gY29tcGFyZSB0aW1lIHdlIGhhdmUgdG8gdXNlIHRoZVxyXG4gICAgLy8gc2FtZSB0aW1lc3RhbXAgdHlwZSB3aGVuIHNhdmluZyB0aGUgZmx1c2ggdGltZXN0YW1wLlxyXG4gICAgaWYgKF9nZXROb3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcCkge1xyXG4gICAgICAgIC8vIGlmIHRoZSBsb3ctcmVzIHRpbWVzdGFtcCB3aGljaCBpcyBiaWdnZXIgdGhhbiB0aGUgZXZlbnQgdGltZXN0YW1wXHJcbiAgICAgICAgLy8gKHdoaWNoIGlzIGV2YWx1YXRlZCBBRlRFUikgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcclxuICAgICAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lcnMgYXMgd2VsbC5cclxuICAgICAgICBfZ2V0Tm93ID0gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICB9XHJcbiAgICAvLyAjMzQ4NTogRmlyZWZveCA8PSA1MyBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcCBpbXBsZW1lbnRhdGlvblxyXG4gICAgLy8gYW5kIGRvZXMgbm90IGZpcmUgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLCBzbyBzYWZlIHRvIGV4Y2x1ZGUuXHJcbiAgICBjb25zdCBmZk1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS9pKTtcclxuICAgIHNraXBUaW1lc3RhbXBDaGVjayA9ICEhKGZmTWF0Y2ggJiYgTnVtYmVyKGZmTWF0Y2hbMV0pIDw9IDUzKTtcclxufVxyXG4vLyBUbyBhdm9pZCB0aGUgb3ZlcmhlYWQgb2YgcmVwZWF0ZWRseSBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpLCB3ZSBjYWNoZVxyXG4vLyBhbmQgdXNlIHRoZSBzYW1lIHRpbWVzdGFtcCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVycyBhdHRhY2hlZCBpbiB0aGUgc2FtZSB0aWNrLlxyXG5sZXQgY2FjaGVkTm93ID0gMDtcclxuY29uc3QgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5jb25zdCByZXNldCA9ICgpID0+IHtcclxuICAgIGNhY2hlZE5vdyA9IDA7XHJcbn07XHJcbmNvbnN0IGdldE5vdyA9ICgpID0+IGNhY2hlZE5vdyB8fCAocC50aGVuKHJlc2V0KSwgKGNhY2hlZE5vdyA9IF9nZXROb3coKSkpO1xyXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xyXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGNoRXZlbnQoZWwsIHJhd05hbWUsIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpbnN0YW5jZSA9IG51bGwpIHtcclxuICAgIC8vIHZlaSA9IHZ1ZSBldmVudCBpbnZva2Vyc1xyXG4gICAgY29uc3QgaW52b2tlcnMgPSBlbC5fdmVpIHx8IChlbC5fdmVpID0ge30pO1xyXG4gICAgY29uc3QgZXhpc3RpbmdJbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV07XHJcbiAgICBpZiAobmV4dFZhbHVlICYmIGV4aXN0aW5nSW52b2tlcikge1xyXG4gICAgICAgIC8vIHBhdGNoXHJcbiAgICAgICAgZXhpc3RpbmdJbnZva2VyLnZhbHVlID0gbmV4dFZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgW25hbWUsIG9wdGlvbnNdID0gcGFyc2VOYW1lKHJhd05hbWUpO1xyXG4gICAgICAgIGlmIChuZXh0VmFsdWUpIHtcclxuICAgICAgICAgICAgLy8gYWRkXHJcbiAgICAgICAgICAgIGNvbnN0IGludm9rZXIgPSAoaW52b2tlcnNbcmF3TmFtZV0gPSBjcmVhdGVJbnZva2VyKG5leHRWYWx1ZSwgaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaW52b2tlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV4aXN0aW5nSW52b2tlcikge1xyXG4gICAgICAgICAgICAvLyByZW1vdmVcclxuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgZXhpc3RpbmdJbnZva2VyLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgaW52b2tlcnNbcmF3TmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IG9wdGlvbnNNb2RpZmllclJFID0gLyg/Ok9uY2V8UGFzc2l2ZXxDYXB0dXJlKSQvO1xyXG5mdW5jdGlvbiBwYXJzZU5hbWUobmFtZSkge1xyXG4gICAgbGV0IG9wdGlvbnM7XHJcbiAgICBpZiAob3B0aW9uc01vZGlmaWVyUkUudGVzdChuYW1lKSkge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBsZXQgbTtcclxuICAgICAgICB3aGlsZSAoKG0gPSBuYW1lLm1hdGNoKG9wdGlvbnNNb2RpZmllclJFKSkpIHtcclxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGggLSBtWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIG9wdGlvbnNbbVswXS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtoeXBoZW5hdGUobmFtZS5zbGljZSgyKSksIG9wdGlvbnNdO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUludm9rZXIoaW5pdGlhbFZhbHVlLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgaW52b2tlciA9IChlKSA9PiB7XHJcbiAgICAgICAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxyXG4gICAgICAgIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXHJcbiAgICAgICAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXHJcbiAgICAgICAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxyXG4gICAgICAgIC8vIGFuZCB0aGUgaGFuZGxlciB3b3VsZCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHBhc3NlZCB0byBpdCB3YXMgZmlyZWRcclxuICAgICAgICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXHJcbiAgICAgICAgY29uc3QgdGltZVN0YW1wID0gZS50aW1lU3RhbXAgfHwgX2dldE5vdygpO1xyXG4gICAgICAgIGlmIChza2lwVGltZXN0YW1wQ2hlY2sgfHwgdGltZVN0YW1wID49IGludm9rZXIuYXR0YWNoZWQgLSAxKSB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIGludm9rZXIudmFsdWUpLCBpbnN0YW5jZSwgNSAvKiBOQVRJVkVfRVZFTlRfSEFORExFUiAqLywgW2VdKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaW52b2tlci52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcclxuICAgIGludm9rZXIuYXR0YWNoZWQgPSBnZXROb3coKTtcclxuICAgIHJldHVybiBpbnZva2VyO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIHZhbHVlKSB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcclxuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgb3JpZ2luYWxTdG9wLmNhbGwoZSk7XHJcbiAgICAgICAgICAgIGUuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmbiA9PiAoZSkgPT4gIWUuX3N0b3BwZWQgJiYgZm4oZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IG5hdGl2ZU9uUkUgPSAvXm9uW2Etel0vO1xyXG5jb25zdCBmb3JjZVBhdGNoUHJvcCA9IChfLCBrZXkpID0+IGtleSA9PT0gJ3ZhbHVlJztcclxuY29uc3QgcGF0Y2hQcm9wID0gKGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpc1NWRyA9IGZhbHNlLCBwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikgPT4ge1xyXG4gICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICAvLyBzcGVjaWFsXHJcbiAgICAgICAgY2FzZSAnY2xhc3MnOlxyXG4gICAgICAgICAgICBwYXRjaENsYXNzKGVsLCBuZXh0VmFsdWUsIGlzU1ZHKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnc3R5bGUnOlxyXG4gICAgICAgICAgICBwYXRjaFN0eWxlKGVsLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB2LW1vZGVsIGxpc3RlbmVyc1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRXZlbnQoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIHBhcmVudENvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaERPTVByb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIDxpbnB1dCB2LW1vZGVsIHR5cGU9XCJjaGVja2JveFwiPiB3aXRoXHJcbiAgICAgICAgICAgICAgICAvLyA6dHJ1ZS12YWx1ZSAmIDpmYWxzZS12YWx1ZVxyXG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgZG9tIHByb3BlcnRpZXMgc2luY2Ugbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZVxyXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5naWZpZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAndHJ1ZS12YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5fdHJ1ZVZhbHVlID0gbmV4dFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnZmFsc2UtdmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuX2ZhbHNlVmFsdWUgPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXRjaEF0dHIoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNob3VsZFNldEFzUHJvcChlbCwga2V5LCB2YWx1ZSwgaXNTVkcpIHtcclxuICAgIGlmIChpc1NWRykge1xyXG4gICAgICAgIC8vIG1vc3Qga2V5cyBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGUgb24gc3ZnIGVsZW1lbnRzIHRvIHdvcmtcclxuICAgICAgICAvLyAuLi5leGNlcHQgaW5uZXJIVE1MXHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG9yIG5hdGl2ZSBvbmNsaWNrIHdpdGggZnVuY3Rpb24gdmFsdWVzXHJcbiAgICAgICAgaWYgKGtleSBpbiBlbCAmJiBuYXRpdmVPblJFLnRlc3Qoa2V5KSAmJiBpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gc3BlbGxjaGVjayBhbmQgZHJhZ2dhYmxlIGFyZSBudW1lcmF0ZWQgYXR0cnMsIGhvd2V2ZXIgdGhlaXJcclxuICAgIC8vIGNvcnJlc3BvbmRpbmcgRE9NIHByb3BlcnRpZXMgYXJlIGFjdHVhbGx5IGJvb2xlYW5zIC0gdGhpcyBsZWFkcyB0b1xyXG4gICAgLy8gc2V0dGluZyBpdCB3aXRoIGEgc3RyaW5nIFwiZmFsc2VcIiB2YWx1ZSBsZWFkaW5nIGl0IHRvIGJlIGNvZXJjZWQgdG9cclxuICAgIC8vIGB0cnVlYCwgc28gd2UgbmVlZCB0byBhbHdheXMgdHJlYXQgdGhlbSBhcyBhdHRyaWJ1dGVzLlxyXG4gICAgLy8gTm90ZSB0aGF0IGBjb250ZW50RWRpdGFibGVgIGRvZXNuJ3QgaGF2ZSB0aGlzIHByb2JsZW06IGl0cyBET01cclxuICAgIC8vIHByb3BlcnR5IGlzIGFsc28gZW51bWVyYXRlZCBzdHJpbmcgdmFsdWVzLlxyXG4gICAgaWYgKGtleSA9PT0gJ3NwZWxsY2hlY2snIHx8IGtleSA9PT0gJ2RyYWdnYWJsZScpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyAjMTc4NywgIzI4NDAgZm9ybSBwcm9wZXJ0eSBvbiBmb3JtIGVsZW1lbnRzIGlzIHJlYWRvbmx5IGFuZCBtdXN0IGJlIHNldCBhc1xyXG4gICAgLy8gYXR0cmlidXRlLlxyXG4gICAgaWYgKGtleSA9PT0gJ2Zvcm0nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gIzE1MjYgPGlucHV0IGxpc3Q+IG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZVxyXG4gICAgaWYgKGtleSA9PT0gJ2xpc3QnICYmIGVsLnRhZ05hbWUgPT09ICdJTlBVVCcpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyAjMjc2NiA8dGV4dGFyZWEgdHlwZT4gbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlXHJcbiAgICBpZiAoa2V5ID09PSAndHlwZScgJiYgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIG5hdGl2ZSBvbmNsaWNrIHdpdGggc3RyaW5nIHZhbHVlLCBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcclxuICAgIGlmIChuYXRpdmVPblJFLnRlc3Qoa2V5KSAmJiBpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5IGluIGVsO1xyXG59XG5cbmZ1bmN0aW9uIHVzZUNzc01vZHVsZShuYW1lID0gJyRzdHlsZScpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICBpZiAoIWluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGB1c2VDc3NNb2R1bGUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHNldHVwKClgKTtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX09CSjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbW9kdWxlcyA9IGluc3RhbmNlLnR5cGUuX19jc3NNb2R1bGVzO1xyXG4gICAgICAgIGlmICghbW9kdWxlcykge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGVzIGluamVjdGVkLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtb2QgPSBtb2R1bGVzW25hbWVdO1xyXG4gICAgICAgIGlmICghbW9kKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGUgbmFtZWQgXCIke25hbWV9XCIuYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9PQko7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtb2Q7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBTRkMncyBDU1MgdmFyaWFibGUgaW5qZWN0aW9uIGZlYXR1cmUuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VDc3NWYXJzKGdldHRlcikge1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAoIWluc3RhbmNlKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHdhcm4oYHVzZUNzc1ZhcnMgaXMgY2FsbGVkIHdpdGhvdXQgY3VycmVudCBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLmApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHNldFZhcnMgPSAoKSA9PiBzZXRWYXJzT25WTm9kZShpbnN0YW5jZS5zdWJUcmVlLCBnZXR0ZXIoaW5zdGFuY2UucHJveHkpKTtcclxuICAgIG9uTW91bnRlZCgoKSA9PiB3YXRjaEVmZmVjdChzZXRWYXJzLCB7IGZsdXNoOiAncG9zdCcgfSkpO1xyXG4gICAgb25VcGRhdGVkKHNldFZhcnMpO1xyXG59XHJcbmZ1bmN0aW9uIHNldFZhcnNPblZOb2RlKHZub2RlLCB2YXJzKSB7XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZTtcclxuICAgICAgICB2bm9kZSA9IHN1c3BlbnNlLmFjdGl2ZUJyYW5jaDtcclxuICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNldFZhcnNPblZOb2RlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgdmFycyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGRyaWxsIGRvd24gSE9DcyB1bnRpbCBpdCdzIGEgbm9uLWNvbXBvbmVudCB2bm9kZVxyXG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudCkge1xyXG4gICAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XHJcbiAgICB9XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmIHZub2RlLmVsKSB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB2bm9kZS5lbC5zdHlsZTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YXJzKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KGAtLSR7a2V5fWAsIHZhcnNba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKGMgPT4gc2V0VmFyc09uVk5vZGUoYywgdmFycykpO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XHJcbmNvbnN0IEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xyXG4vLyBET00gVHJhbnNpdGlvbiBpcyBhIGhpZ2hlci1vcmRlci1jb21wb25lbnQgYmFzZWQgb24gdGhlIHBsYXRmb3JtLWFnbm9zdGljXHJcbi8vIGJhc2UgVHJhbnNpdGlvbiBjb21wb25lbnQsIHdpdGggRE9NLXNwZWNpZmljIGxvZ2ljLlxyXG5jb25zdCBUcmFuc2l0aW9uID0gKHByb3BzLCB7IHNsb3RzIH0pID0+IGgoQmFzZVRyYW5zaXRpb24sIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocHJvcHMpLCBzbG90cyk7XHJcblRyYW5zaXRpb24uZGlzcGxheU5hbWUgPSAnVHJhbnNpdGlvbic7XHJcbmNvbnN0IERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XHJcbiAgICBuYW1lOiBTdHJpbmcsXHJcbiAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICBjc3M6IHtcclxuICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcclxuICAgIH0sXHJcbiAgICBkdXJhdGlvbjogW1N0cmluZywgTnVtYmVyLCBPYmplY3RdLFxyXG4gICAgZW50ZXJGcm9tQ2xhc3M6IFN0cmluZyxcclxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGVudGVyVG9DbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyRnJvbUNsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVGcm9tQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlVG9DbGFzczogU3RyaW5nXHJcbn07XHJcbmNvbnN0IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSAoVHJhbnNpdGlvbi5wcm9wcyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBCYXNlVHJhbnNpdGlvbi5wcm9wcywgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpO1xyXG4vKipcclxuICogIzMyMjcgSW5jb21pbmcgaG9va3MgbWF5IGJlIG1lcmdlZCBpbnRvIGFycmF5cyB3aGVuIHdyYXBwaW5nIFRyYW5zaXRpb25cclxuICogd2l0aCBjdXN0b20gSE9Dcy5cclxuICovXHJcbmNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MgPSBbXSkgPT4ge1xyXG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcclxuICAgICAgICBob29rLmZvckVhY2goaCA9PiBoKC4uLmFyZ3MpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhvb2spIHtcclxuICAgICAgICBob29rKC4uLmFyZ3MpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQ2hlY2sgaWYgYSBob29rIGV4cGVjdHMgYSBjYWxsYmFjayAoMm5kIGFyZyksIHdoaWNoIG1lYW5zIHRoZSB1c2VyXHJcbiAqIGludGVuZHMgdG8gZXhwbGljaXRseSBjb250cm9sIHRoZSBlbmQgb2YgdGhlIHRyYW5zaXRpb24uXHJcbiAqL1xyXG5jb25zdCBoYXNFeHBsaWNpdENhbGxiYWNrID0gKGhvb2spID0+IHtcclxuICAgIHJldHVybiBob29rXHJcbiAgICAgICAgPyBpc0FycmF5KGhvb2spXHJcbiAgICAgICAgICAgID8gaG9vay5zb21lKGggPT4gaC5sZW5ndGggPiAxKVxyXG4gICAgICAgICAgICA6IGhvb2subGVuZ3RoID4gMVxyXG4gICAgICAgIDogZmFsc2U7XHJcbn07XHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpIHtcclxuICAgIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3UHJvcHMpIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpIHtcclxuICAgICAgICAgICAgYmFzZVByb3BzW2tleV0gPSByYXdQcm9wc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChyYXdQcm9wcy5jc3MgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VQcm9wcztcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbmFtZSA9ICd2JywgdHlwZSwgZHVyYXRpb24sIGVudGVyRnJvbUNsYXNzID0gYCR7bmFtZX0tZW50ZXItZnJvbWAsIGVudGVyQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLCBlbnRlclRvQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci10b2AsIGFwcGVhckZyb21DbGFzcyA9IGVudGVyRnJvbUNsYXNzLCBhcHBlYXJBY3RpdmVDbGFzcyA9IGVudGVyQWN0aXZlQ2xhc3MsIGFwcGVhclRvQ2xhc3MgPSBlbnRlclRvQ2xhc3MsIGxlYXZlRnJvbUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtZnJvbWAsIGxlYXZlQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgLCBsZWF2ZVRvQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS10b2AgfSA9IHJhd1Byb3BzO1xyXG4gICAgY29uc3QgZHVyYXRpb25zID0gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pO1xyXG4gICAgY29uc3QgZW50ZXJEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMF07XHJcbiAgICBjb25zdCBsZWF2ZUR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1sxXTtcclxuICAgIGNvbnN0IHsgb25CZWZvcmVFbnRlciwgb25FbnRlciwgb25FbnRlckNhbmNlbGxlZCwgb25MZWF2ZSwgb25MZWF2ZUNhbmNlbGxlZCwgb25CZWZvcmVBcHBlYXIgPSBvbkJlZm9yZUVudGVyLCBvbkFwcGVhciA9IG9uRW50ZXIsIG9uQXBwZWFyQ2FuY2VsbGVkID0gb25FbnRlckNhbmNlbGxlZCB9ID0gYmFzZVByb3BzO1xyXG4gICAgY29uc3QgZmluaXNoRW50ZXIgPSAoZWwsIGlzQXBwZWFyLCBkb25lKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIGRvbmUgJiYgZG9uZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGZpbmlzaExlYXZlID0gKGVsLCBkb25lKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgZG9uZSAmJiBkb25lKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbWFrZUVudGVySG9vayA9IChpc0FwcGVhcikgPT4ge1xyXG4gICAgICAgIHJldHVybiAoZWwsIGRvbmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaG9vayA9IGlzQXBwZWFyID8gb25BcHBlYXIgOiBvbkVudGVyO1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcclxuICAgICAgICAgICAgY2FsbEhvb2soaG9vaywgW2VsLCByZXNvbHZlXSk7XHJcbiAgICAgICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyRnJvbUNsYXNzIDogZW50ZXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKGhvb2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBlbnRlckR1cmF0aW9uLCByZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xyXG4gICAgICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVFbnRlciwgW2VsXSk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25CZWZvcmVBcHBlYXIoZWwpIHtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVBcHBlYXIsIFtlbF0pO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXHJcbiAgICAgICAgb25BcHBlYXI6IG1ha2VFbnRlckhvb2sodHJ1ZSksXHJcbiAgICAgICAgb25MZWF2ZShlbCwgZG9uZSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoTGVhdmUoZWwsIGRvbmUpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgLy8gZm9yY2UgcmVmbG93IHNvICotbGVhdmUtZnJvbSBjbGFzc2VzIGltbWVkaWF0ZWx5IHRha2UgZWZmZWN0ICgjMjU5MylcclxuICAgICAgICAgICAgZm9yY2VSZWZsb3coKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcclxuICAgICAgICAgICAgbmV4dEZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKG9uTGVhdmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBsZWF2ZUR1cmF0aW9uLCByZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmUsIFtlbCwgcmVzb2x2ZV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FbnRlckNhbmNlbGxlZChlbCkge1xyXG4gICAgICAgICAgICBmaW5pc2hFbnRlcihlbCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkVudGVyQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkKGVsKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlKTtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25BcHBlYXJDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25MZWF2ZUNhbmNlbGxlZChlbCkge1xyXG4gICAgICAgICAgICBmaW5pc2hMZWF2ZShlbCk7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKSB7XHJcbiAgICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QoZHVyYXRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIFtOdW1iZXJPZihkdXJhdGlvbi5lbnRlciksIE51bWJlck9mKGR1cmF0aW9uLmxlYXZlKV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBuID0gTnVtYmVyT2YoZHVyYXRpb24pO1xyXG4gICAgICAgIHJldHVybiBbbiwgbl07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gTnVtYmVyT2YodmFsKSB7XHJcbiAgICBjb25zdCByZXMgPSB0b051bWJlcih2YWwpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSlcclxuICAgICAgICB2YWxpZGF0ZUR1cmF0aW9uKHJlcyk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlRHVyYXRpb24odmFsKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gYCArXHJcbiAgICAgICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcclxuICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb24gaXMgTmFOIC0gYCArXHJcbiAgICAgICAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGVsLmNsYXNzTGlzdC5hZGQoYykpO1xyXG4gICAgKGVsLl92dGMgfHxcclxuICAgICAgICAoZWwuX3Z0YyA9IG5ldyBTZXQoKSkpLmFkZChjbHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XHJcbiAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcclxuICAgIGNvbnN0IHsgX3Z0YyB9ID0gZWw7XHJcbiAgICBpZiAoX3Z0Yykge1xyXG4gICAgICAgIF92dGMuZGVsZXRlKGNscyk7XHJcbiAgICAgICAgaWYgKCFfdnRjLnNpemUpIHtcclxuICAgICAgICAgICAgZWwuX3Z0YyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV4dEZyYW1lKGNiKSB7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XHJcbiAgICB9KTtcclxufVxyXG5sZXQgZW5kSWQgPSAwO1xyXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgZXhwbGljaXRUaW1lb3V0LCByZXNvbHZlKSB7XHJcbiAgICBjb25zdCBpZCA9IChlbC5fZW5kSWQgPSArK2VuZElkKTtcclxuICAgIGNvbnN0IHJlc29sdmVJZk5vdFN0YWxlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChpZCA9PT0gZWwuX2VuZElkKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKGV4cGxpY2l0VGltZW91dCkge1xyXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmVJZk5vdFN0YWxlLCBleHBsaWNpdFRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyB0eXBlLCB0aW1lb3V0LCBwcm9wQ291bnQgfSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xyXG4gICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVuZEV2ZW50ID0gdHlwZSArICdlbmQnO1xyXG4gICAgbGV0IGVuZGVkID0gMDtcclxuICAgIGNvbnN0IGVuZCA9ICgpID0+IHtcclxuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XHJcbiAgICAgICAgcmVzb2x2ZUlmTm90U3RhbGUoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBvbkVuZCA9IChlKSA9PiB7XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCAmJiArK2VuZGVkID49IHByb3BDb3VudCkge1xyXG4gICAgICAgICAgICBlbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XHJcbiAgICAgICAgICAgIGVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHRpbWVvdXQgKyAxKTtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKSB7XHJcbiAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XHJcbiAgICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXHJcbiAgICBjb25zdCBnZXRTdHlsZVByb3BlcnRpZXMgPSAoa2V5KSA9PiAoc3R5bGVzW2tleV0gfHwgJycpLnNwbGl0KCcsICcpO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhUUkFOU0lUSU9OICsgJ0RlbGF5Jyk7XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKFRSQU5TSVRJT04gKyAnRHVyYXRpb24nKTtcclxuICAgIGNvbnN0IHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhBTklNQVRJT04gKyAnRGVsYXknKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhBTklNQVRJT04gKyAnRHVyYXRpb24nKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcclxuICAgIGxldCB0eXBlID0gbnVsbDtcclxuICAgIGxldCB0aW1lb3V0ID0gMDtcclxuICAgIGxldCBwcm9wQ291bnQgPSAwO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcclxuICAgICAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xyXG4gICAgICAgICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xyXG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gQU5JTUFUSU9OO1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcclxuICAgICAgICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xyXG4gICAgICAgIHR5cGUgPVxyXG4gICAgICAgICAgICB0aW1lb3V0ID4gMFxyXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcclxuICAgICAgICAgICAgICAgICAgICA/IFRSQU5TSVRJT05cclxuICAgICAgICAgICAgICAgICAgICA6IEFOSU1BVElPTlxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIHByb3BDb3VudCA9IHR5cGVcclxuICAgICAgICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXHJcbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcclxuICAgICAgICAgICAgOiAwO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaGFzVHJhbnNmb3JtID0gdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxyXG4gICAgICAgIC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS8udGVzdChzdHlsZXNbVFJBTlNJVElPTiArICdQcm9wZXJ0eSddKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICB0aW1lb3V0LFxyXG4gICAgICAgIHByb3BDb3VudCxcclxuICAgICAgICBoYXNUcmFuc2Zvcm1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xyXG4gICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLmR1cmF0aW9ucy5tYXAoKGQsIGkpID0+IHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSkpKTtcclxufVxyXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlclxyXG4vLyBudW1iZXJzIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cclxuLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93blxyXG4vLyAoaS5lLiBhY3RpbmcgYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xyXG5mdW5jdGlvbiB0b01zKHMpIHtcclxuICAgIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMDtcclxufVxyXG4vLyBzeW5jaHJvbm91c2x5IGZvcmNlIGxheW91dCB0byBwdXQgZWxlbWVudHMgaW50byBhIGNlcnRhaW4gc3RhdGVcclxuZnVuY3Rpb24gZm9yY2VSZWZsb3coKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XHJcbn1cblxuY29uc3QgcG9zaXRpb25NYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBuZXdQb3NpdGlvbk1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IFRyYW5zaXRpb25Hcm91cEltcGwgPSB7XHJcbiAgICBuYW1lOiAnVHJhbnNpdGlvbkdyb3VwJyxcclxuICAgIHByb3BzOiAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywge1xyXG4gICAgICAgIHRhZzogU3RyaW5nLFxyXG4gICAgICAgIG1vdmVDbGFzczogU3RyaW5nXHJcbiAgICB9KSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XHJcbiAgICAgICAgbGV0IHByZXZDaGlsZHJlbjtcclxuICAgICAgICBsZXQgY2hpbGRyZW47XHJcbiAgICAgICAgb25VcGRhdGVkKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gY2hpbGRyZW4gaXMgZ3VhcmFudGVlZCB0byBleGlzdCBhZnRlciBpbml0aWFsIHJlbmRlclxyXG4gICAgICAgICAgICBpZiAoIXByZXZDaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtb3ZlQ2xhc3MgPSBwcm9wcy5tb3ZlQ2xhc3MgfHwgYCR7cHJvcHMubmFtZSB8fCAndid9LW1vdmVgO1xyXG4gICAgICAgICAgICBpZiAoIWhhc0NTU1RyYW5zZm9ybShwcmV2Q2hpbGRyZW5bMF0uZWwsIGluc3RhbmNlLnZub2RlLmVsLCBtb3ZlQ2xhc3MpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXHJcbiAgICAgICAgICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxyXG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgbW92ZWRDaGlsZHJlbiA9IHByZXZDaGlsZHJlbi5maWx0ZXIoYXBwbHlUcmFuc2xhdGlvbik7XHJcbiAgICAgICAgICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxyXG4gICAgICAgICAgICBmb3JjZVJlZmxvdygpO1xyXG4gICAgICAgICAgICBtb3ZlZENoaWxkcmVuLmZvckVhY2goYyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGMuZWw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IChlbC5fbW92ZUNiID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBjYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgY2IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgY3NzVHJhbnNpdGlvblByb3BzID0gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcyk7XHJcbiAgICAgICAgICAgIGxldCB0YWcgPSByYXdQcm9wcy50YWcgfHwgRnJhZ21lbnQ7XHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgPyBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpKSA6IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGNoaWxkLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgPFRyYW5zaXRpb25Hcm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJldkNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gcHJldkNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhjaGlsZCwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoY2hpbGQsIGNoaWxkLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodGFnLCBudWxsLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuY29uc3QgVHJhbnNpdGlvbkdyb3VwID0gVHJhbnNpdGlvbkdyb3VwSW1wbDtcclxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMoYykge1xyXG4gICAgY29uc3QgZWwgPSBjLmVsO1xyXG4gICAgaWYgKGVsLl9tb3ZlQ2IpIHtcclxuICAgICAgICBlbC5fbW92ZUNiKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZWwuX2VudGVyQ2IpIHtcclxuICAgICAgICBlbC5fZW50ZXJDYigpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uKGMpIHtcclxuICAgIG5ld1Bvc2l0aW9uTWFwLnNldChjLCBjLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcclxufVxyXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uKGMpIHtcclxuICAgIGNvbnN0IG9sZFBvcyA9IHBvc2l0aW9uTWFwLmdldChjKTtcclxuICAgIGNvbnN0IG5ld1BvcyA9IG5ld1Bvc2l0aW9uTWFwLmdldChjKTtcclxuICAgIGNvbnN0IGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcclxuICAgIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XHJcbiAgICBpZiAoZHggfHwgZHkpIHtcclxuICAgICAgICBjb25zdCBzID0gYy5lbC5zdHlsZTtcclxuICAgICAgICBzLnRyYW5zZm9ybSA9IHMud2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2R4fXB4LCR7ZHl9cHgpYDtcclxuICAgICAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFzQ1NTVHJhbnNmb3JtKGVsLCByb290LCBtb3ZlQ2xhc3MpIHtcclxuICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xyXG4gICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXHJcbiAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXHJcbiAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcclxuICAgIC8vIGlzIGFwcGxpZWQuXHJcbiAgICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xyXG4gICAgaWYgKGVsLl92dGMpIHtcclxuICAgICAgICBlbC5fdnRjLmZvckVhY2goY2xzID0+IHtcclxuICAgICAgICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LnJlbW92ZShjKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtb3ZlQ2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QuYWRkKGMpKTtcclxuICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSAocm9vdC5ub2RlVHlwZSA9PT0gMVxyXG4gICAgICAgID8gcm9vdFxyXG4gICAgICAgIDogcm9vdC5wYXJlbnROb2RlKTtcclxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjbG9uZSk7XHJcbiAgICBjb25zdCB7IGhhc1RyYW5zZm9ybSB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xyXG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNsb25lKTtcclxuICAgIHJldHVybiBoYXNUcmFuc2Zvcm07XHJcbn1cblxuY29uc3QgZ2V0TW9kZWxBc3NpZ25lciA9ICh2bm9kZSkgPT4ge1xyXG4gICAgY29uc3QgZm4gPSB2bm9kZS5wcm9wc1snb25VcGRhdGU6bW9kZWxWYWx1ZSddO1xyXG4gICAgcmV0dXJuIGlzQXJyYXkoZm4pID8gdmFsdWUgPT4gaW52b2tlQXJyYXlGbnMoZm4sIHZhbHVlKSA6IGZuO1xyXG59O1xyXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xyXG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xyXG4gICAgaWYgKHRhcmdldC5jb21wb3NpbmcpIHtcclxuICAgICAgICB0YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsICdpbnB1dCcpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXIoZWwsIHR5cGUpIHtcclxuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xyXG4gICAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xyXG59XHJcbi8vIFdlIGFyZSBleHBvcnRpbmcgdGhlIHYtbW9kZWwgcnVudGltZSBkaXJlY3RseSBhcyB2bm9kZSBob29rcyBzbyB0aGF0IGl0IGNhblxyXG4vLyBiZSB0cmVlLXNoYWtlbiBpbiBjYXNlIHYtbW9kZWwgaXMgbmV2ZXIgdXNlZC5cclxuY29uc3Qgdk1vZGVsVGV4dCA9IHtcclxuICAgIGNyZWF0ZWQoZWwsIHsgbW9kaWZpZXJzOiB7IGxhenksIHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGNhc3RUb051bWJlciA9IG51bWJlciB8fCBlbC50eXBlID09PSAnbnVtYmVyJztcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBsYXp5ID8gJ2NoYW5nZScgOiAnaW5wdXQnLCBlID0+IHtcclxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0LmNvbXBvc2luZylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgbGV0IGRvbVZhbHVlID0gZWwudmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgICAgICAgICBkb21WYWx1ZSA9IGRvbVZhbHVlLnRyaW0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjYXN0VG9OdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIGRvbVZhbHVlID0gdG9OdW1iZXIoZG9tVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsLl9hc3NpZ24oZG9tVmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlbC52YWx1ZSA9IGVsLnZhbHVlLnRyaW0oKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbGF6eSkge1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xyXG4gICAgICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXHJcbiAgICAgICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcclxuICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxyXG4gICAgICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyBzZXQgdmFsdWUgb24gbW91bnRlZCBzbyBpdCdzIGFmdGVyIG1pbi9tYXggZm9yIHR5cGU9XCJyYW5nZVwiXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBlbC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzOiB7IHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIC8vIGF2b2lkIGNsZWFyaW5nIHVucmVzb2x2ZWQgdGV4dC4gIzIzMDJcclxuICAgICAgICBpZiAoZWwuY29tcG9zaW5nKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7XHJcbiAgICAgICAgICAgIGlmICh0cmltICYmIGVsLnZhbHVlLnRyaW0oKSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKG51bWJlciB8fCBlbC50eXBlID09PSAnbnVtYmVyJykgJiYgdG9OdW1iZXIoZWwudmFsdWUpID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XHJcbiAgICAgICAgaWYgKGVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgdk1vZGVsQ2hlY2tib3ggPSB7XHJcbiAgICBjcmVhdGVkKGVsLCBfLCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2RlbFZhbHVlID0gZWwuX21vZGVsVmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IGdldFZhbHVlKGVsKTtcclxuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IGVsLmNoZWNrZWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGFzc2lnbiA9IGVsLl9hc3NpZ247XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG1vZGVsVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGxvb3NlSW5kZXhPZihtb2RlbFZhbHVlLCBlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSBpbmRleCAhPT0gLTE7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCAmJiAhZm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NpZ24obW9kZWxWYWx1ZS5jb25jYXQoZWxlbWVudFZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hlY2tlZCAmJiBmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gWy4uLm1vZGVsVmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKGZpbHRlcmVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1NldChtb2RlbFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gbmV3IFNldChtb2RlbFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmFkZChlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmRlbGV0ZShlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXNzaWduKGNsb25lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhc3NpZ24oZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgLy8gc2V0IGluaXRpYWwgY2hlY2tlZCBvbiBtb3VudCB0byB3YWl0IGZvciB0cnVlLXZhbHVlL2ZhbHNlLXZhbHVlXHJcbiAgICBtb3VudGVkOiBzZXRDaGVja2VkLFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBzZXRDaGVja2VkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldENoZWNrZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICBlbC5fbW9kZWxWYWx1ZSA9IHZhbHVlO1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcclxuICAgICAgICBlbC5jaGVja2VkID0gdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBnZXRDaGVja2JveFZhbHVlKGVsLCB0cnVlKSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3Qgdk1vZGVsUmFkaW8gPSB7XHJcbiAgICBjcmVhdGVkKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihnZXRWYWx1ZShlbCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgdk1vZGVsU2VsZWN0ID0ge1xyXG4gICAgY3JlYXRlZChlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzOiB7IG51bWJlciB9IH0sIHZub2RlKSB7XHJcbiAgICAgICAgY29uc3QgaXNTZXRNb2RlbCA9IGlzU2V0KHZhbHVlKTtcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFZhbCA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXJcclxuICAgICAgICAgICAgICAgIC5jYWxsKGVsLm9wdGlvbnMsIChvKSA9PiBvLnNlbGVjdGVkKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgobykgPT4gbnVtYmVyID8gdG9OdW1iZXIoZ2V0VmFsdWUobykpIDogZ2V0VmFsdWUobykpO1xyXG4gICAgICAgICAgICBlbC5fYXNzaWduKGVsLm11bHRpcGxlXHJcbiAgICAgICAgICAgICAgICA/IGlzU2V0TW9kZWxcclxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBTZXQoc2VsZWN0ZWRWYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxlY3RlZFZhbFxyXG4gICAgICAgICAgICAgICAgOiBzZWxlY3RlZFZhbFswXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgfSxcclxuICAgIC8vIHNldCB2YWx1ZSBpbiBtb3VudGVkICYgdXBkYXRlZCBiZWNhdXNlIDxzZWxlY3Q+IHJlbGllcyBvbiBpdHMgY2hpbGRyZW5cclxuICAgIC8vIDxvcHRpb24+cy5cclxuICAgIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBfYmluZGluZywgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlZChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKSB7XHJcbiAgICBjb25zdCBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XHJcbiAgICBpZiAoaXNNdWx0aXBsZSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgIWlzU2V0KHZhbHVlKSkge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB3YXJuKGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw+IGV4cGVjdHMgYW4gQXJyYXkgb3IgU2V0IHZhbHVlIGZvciBpdHMgYmluZGluZywgYCArXHJcbiAgICAgICAgICAgICAgICBgYnV0IGdvdCAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpfS5gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcclxuICAgICAgICBjb25zdCBvcHRpb25WYWx1ZSA9IGdldFZhbHVlKG9wdGlvbik7XHJcbiAgICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIG9wdGlvblZhbHVlKSA+IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaGFzKG9wdGlvblZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSlcclxuICAgICAgICAgICAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghaXNNdWx0aXBsZSAmJiBlbC5zZWxlY3RlZEluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgIH1cclxufVxyXG4vLyByZXRyaWV2ZSByYXcgdmFsdWUgc2V0IHZpYSA6dmFsdWUgYmluZGluZ3NcclxuZnVuY3Rpb24gZ2V0VmFsdWUoZWwpIHtcclxuICAgIHJldHVybiAnX3ZhbHVlJyBpbiBlbCA/IGVsLl92YWx1ZSA6IGVsLnZhbHVlO1xyXG59XHJcbi8vIHJldHJpZXZlIHJhdyB2YWx1ZSBmb3IgdHJ1ZS12YWx1ZSBhbmQgZmFsc2UtdmFsdWUgc2V0IHZpYSA6dHJ1ZS12YWx1ZSBvciA6ZmFsc2UtdmFsdWUgYmluZGluZ3NcclxuZnVuY3Rpb24gZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkge1xyXG4gICAgY29uc3Qga2V5ID0gY2hlY2tlZCA/ICdfdHJ1ZVZhbHVlJyA6ICdfZmFsc2VWYWx1ZSc7XHJcbiAgICByZXR1cm4ga2V5IGluIGVsID8gZWxba2V5XSA6IGNoZWNrZWQ7XHJcbn1cclxuY29uc3Qgdk1vZGVsRHluYW1pYyA9IHtcclxuICAgIGNyZWF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsICdjcmVhdGVkJyk7XHJcbiAgICB9LFxyXG4gICAgbW91bnRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgJ21vdW50ZWQnKTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCAnYmVmb3JlVXBkYXRlJyk7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xyXG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsICd1cGRhdGVkJyk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIGhvb2spIHtcclxuICAgIGxldCBtb2RlbFRvVXNlO1xyXG4gICAgc3dpdGNoIChlbC50YWdOYW1lKSB7XHJcbiAgICAgICAgY2FzZSAnU0VMRUNUJzpcclxuICAgICAgICAgICAgbW9kZWxUb1VzZSA9IHZNb2RlbFNlbGVjdDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnVEVYVEFSRUEnOlxyXG4gICAgICAgICAgICBtb2RlbFRvVXNlID0gdk1vZGVsVGV4dDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgc3dpdGNoICh2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxUb1VzZSA9IHZNb2RlbENoZWNrYm94O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxSYWRpbztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxUb1VzZSA9IHZNb2RlbFRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGZuID0gbW9kZWxUb1VzZVtob29rXTtcclxuICAgIGZuICYmIGZuKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKTtcclxufVxuXG5jb25zdCBzeXN0ZW1Nb2RpZmllcnMgPSBbJ2N0cmwnLCAnc2hpZnQnLCAnYWx0JywgJ21ldGEnXTtcclxuY29uc3QgbW9kaWZpZXJHdWFyZHMgPSB7XHJcbiAgICBzdG9wOiBlID0+IGUuc3RvcFByb3BhZ2F0aW9uKCksXHJcbiAgICBwcmV2ZW50OiBlID0+IGUucHJldmVudERlZmF1bHQoKSxcclxuICAgIHNlbGY6IGUgPT4gZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCxcclxuICAgIGN0cmw6IGUgPT4gIWUuY3RybEtleSxcclxuICAgIHNoaWZ0OiBlID0+ICFlLnNoaWZ0S2V5LFxyXG4gICAgYWx0OiBlID0+ICFlLmFsdEtleSxcclxuICAgIG1ldGE6IGUgPT4gIWUubWV0YUtleSxcclxuICAgIGxlZnQ6IGUgPT4gJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMCxcclxuICAgIG1pZGRsZTogZSA9PiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uICE9PSAxLFxyXG4gICAgcmlnaHQ6IGUgPT4gJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMixcclxuICAgIGV4YWN0OiAoZSwgbW9kaWZpZXJzKSA9PiBzeXN0ZW1Nb2RpZmllcnMuc29tZShtID0+IGVbYCR7bX1LZXlgXSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKG0pKVxyXG59O1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHdpdGhNb2RpZmllcnMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xyXG4gICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGd1YXJkID0gbW9kaWZpZXJHdWFyZHNbbW9kaWZpZXJzW2ldXTtcclxuICAgICAgICAgICAgaWYgKGd1YXJkICYmIGd1YXJkKGV2ZW50LCBtb2RpZmllcnMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm4oZXZlbnQsIC4uLmFyZ3MpO1xyXG4gICAgfTtcclxufTtcclxuLy8gS2VwdCBmb3IgMi54IGNvbXBhdC5cclxuLy8gTm90ZTogSUUxMSBjb21wYXQgZm9yIGBzcGFjZWJhcmAgYW5kIGBkZWxgIGlzIHJlbW92ZWQgZm9yIG5vdy5cclxuY29uc3Qga2V5TmFtZXMgPSB7XHJcbiAgICBlc2M6ICdlc2NhcGUnLFxyXG4gICAgc3BhY2U6ICcgJyxcclxuICAgIHVwOiAnYXJyb3ctdXAnLFxyXG4gICAgbGVmdDogJ2Fycm93LWxlZnQnLFxyXG4gICAgcmlnaHQ6ICdhcnJvdy1yaWdodCcsXHJcbiAgICBkb3duOiAnYXJyb3ctZG93bicsXHJcbiAgICBkZWxldGU6ICdiYWNrc3BhY2UnXHJcbn07XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3Qgd2l0aEtleXMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xyXG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xyXG4gICAgICAgIGlmICghKCdrZXknIGluIGV2ZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV2ZW50S2V5ID0gaHlwaGVuYXRlKGV2ZW50LmtleSk7XHJcbiAgICAgICAgaWYgKG1vZGlmaWVycy5zb21lKGsgPT4gayA9PT0gZXZlbnRLZXkgfHwga2V5TmFtZXNba10gPT09IGV2ZW50S2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm4oZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XG5cbmNvbnN0IHZTaG93ID0ge1xyXG4gICAgYmVmb3JlTW91bnQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcclxuICAgICAgICBlbC5fdm9kID0gZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmxlYXZlKGVsLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVW5tb3VudChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBzZXREaXNwbGF5KGVsLCB2YWx1ZSkge1xyXG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX3ZvZCA6ICdub25lJztcclxufVxuXG5jb25zdCByZW5kZXJlck9wdGlvbnMgPSBleHRlbmQoeyBwYXRjaFByb3AsIGZvcmNlUGF0Y2hQcm9wIH0sIG5vZGVPcHMpO1xyXG4vLyBsYXp5IGNyZWF0ZSB0aGUgcmVuZGVyZXIgLSB0aGlzIG1ha2VzIGNvcmUgcmVuZGVyZXIgbG9naWMgdHJlZS1zaGFrYWJsZVxyXG4vLyBpbiBjYXNlIHRoZSB1c2VyIG9ubHkgaW1wb3J0cyByZWFjdGl2aXR5IHV0aWxpdGllcyBmcm9tIFZ1ZS5cclxubGV0IHJlbmRlcmVyO1xyXG5sZXQgZW5hYmxlZEh5ZHJhdGlvbiA9IGZhbHNlO1xyXG5mdW5jdGlvbiBlbnN1cmVSZW5kZXJlcigpIHtcclxuICAgIHJldHVybiByZW5kZXJlciB8fCAocmVuZGVyZXIgPSBjcmVhdGVSZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpKTtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpIHtcclxuICAgIHJlbmRlcmVyID0gZW5hYmxlZEh5ZHJhdGlvblxyXG4gICAgICAgID8gcmVuZGVyZXJcclxuICAgICAgICA6IGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucyk7XHJcbiAgICBlbmFibGVkSHlkcmF0aW9uID0gdHJ1ZTtcclxuICAgIHJldHVybiByZW5kZXJlcjtcclxufVxyXG4vLyB1c2UgZXhwbGljaXQgdHlwZSBjYXN0cyBoZXJlIHRvIGF2b2lkIGltcG9ydCgpIGNhbGxzIGluIHJvbGxlZC11cCBkLnRzXHJcbmNvbnN0IHJlbmRlciA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgZW5zdXJlUmVuZGVyZXIoKS5yZW5kZXIoLi4uYXJncyk7XHJcbn0pO1xyXG5jb25zdCBoeWRyYXRlID0gKCguLi5hcmdzKSA9PiB7XHJcbiAgICBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmh5ZHJhdGUoLi4uYXJncyk7XHJcbn0pO1xyXG5jb25zdCBjcmVhdGVBcHAgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGNvbnN0IGFwcCA9IGVuc3VyZVJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XHJcbiAgICAgICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcclxuICAgIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xyXG4gICAgICAgIGlmICghY29udGFpbmVyKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gYXBwLl9jb21wb25lbnQ7XHJcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGNvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5yZW5kZXIgJiYgIWNvbXBvbmVudC50ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAvLyBfX1VOU0FGRV9fXHJcbiAgICAgICAgICAgIC8vIFJlYXNvbjogcG90ZW50aWFsIGV4ZWN1dGlvbiBvZiBKUyBleHByZXNzaW9ucyBpbiBpbi1ET00gdGVtcGxhdGUuXHJcbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIG11c3QgbWFrZSBzdXJlIHRoZSBpbi1ET00gdGVtcGxhdGUgaXMgdHJ1c3RlZC4gSWYgaXQnc1xyXG4gICAgICAgICAgICAvLyByZW5kZXJlZCBieSB0aGUgc2VydmVyLCB0aGUgdGVtcGxhdGUgc2hvdWxkIG5vdCBjb250YWluIGFueSB1c2VyIGRhdGEuXHJcbiAgICAgICAgICAgIGNvbXBvbmVudC50ZW1wbGF0ZSA9IGNvbnRhaW5lci5pbm5lckhUTUw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNsZWFyIGNvbnRlbnQgYmVmb3JlIG1vdW50aW5nXHJcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgIGNvbnN0IHByb3h5ID0gbW91bnQoY29udGFpbmVyLCBmYWxzZSwgY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudCk7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgndi1jbG9haycpO1xyXG4gICAgICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCdkYXRhLXYtYXBwJywgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJveHk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGFwcDtcclxufSk7XHJcbmNvbnN0IGNyZWF0ZVNTUkFwcCA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgYXBwID0gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcclxuICAgICAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xyXG4gICAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbW91bnQoY29udGFpbmVyLCB0cnVlLCBjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGFwcDtcclxufSk7XHJcbmZ1bmN0aW9uIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCkge1xyXG4gICAgLy8gSW5qZWN0IGBpc05hdGl2ZVRhZ2BcclxuICAgIC8vIHRoaXMgaXMgdXNlZCBmb3IgY29tcG9uZW50IG5hbWUgdmFsaWRhdGlvbiAoZGV2IG9ubHkpXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgJ2lzTmF0aXZlVGFnJywge1xyXG4gICAgICAgIHZhbHVlOiAodGFnKSA9PiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWR1RhZyh0YWcpLFxyXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuZnVuY3Rpb24gaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKSB7XHJcbiAgICBpZiAoaXNSdW50aW1lT25seSgpKSB7XHJcbiAgICAgICAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gYXBwLmNvbmZpZy5pc0N1c3RvbUVsZW1lbnQ7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdpc0N1c3RvbUVsZW1lbnQnLCB7XHJcbiAgICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0N1c3RvbUVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFRoZSBcXGBpc0N1c3RvbUVsZW1lbnRcXGAgY29uZmlnIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFxcYGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnRcXGAgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGNvbXBpbGVyT3B0aW9ucyA9IGFwcC5jb25maWcuY29tcGlsZXJPcHRpb25zO1xyXG4gICAgICAgIGNvbnN0IG1zZyA9IGBUaGUgXFxgY29tcGlsZXJPcHRpb25zXFxgIGNvbmZpZyBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyBgICtcclxuICAgICAgICAgICAgYGEgYnVpbGQgb2YgVnVlLmpzIHRoYXQgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIgKGFrYSBcImZ1bGwgYnVpbGRcIikuIGAgK1xyXG4gICAgICAgICAgICBgU2luY2UgeW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkLCBcXGBjb21waWxlck9wdGlvbnNcXGAgYCArXHJcbiAgICAgICAgICAgIGBtdXN0IGJlIHBhc3NlZCB0byBcXGBAdnVlL2NvbXBpbGVyLWRvbVxcYCBpbiB0aGUgYnVpbGQgc2V0dXAgaW5zdGVhZC5cXG5gICtcclxuICAgICAgICAgICAgYC0gRm9yIHZ1ZS1sb2FkZXI6IHBhc3MgaXQgdmlhIHZ1ZS1sb2FkZXIncyBcXGBjb21waWxlck9wdGlvbnNcXGAgbG9hZGVyIG9wdGlvbi5cXG5gICtcclxuICAgICAgICAgICAgYC0gRm9yIHZ1ZS1jbGk6IHNlZSBodHRwczovL2NsaS52dWVqcy5vcmcvZ3VpZGUvd2VicGFjay5odG1sI21vZGlmeWluZy1vcHRpb25zLW9mLWEtbG9hZGVyXFxuYCArXHJcbiAgICAgICAgICAgIGAtIEZvciB2aXRlOiBwYXNzIGl0IHZpYSBAdml0ZWpzL3BsdWdpbi12dWUgb3B0aW9ucy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS90cmVlL21haW4vcGFja2FnZXMvcGx1Z2luLXZ1ZSNleGFtcGxlLWZvci1wYXNzaW5nLW9wdGlvbnMtdG8tdnVlY29tcGlsZXItZG9tYDtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgJ2NvbXBpbGVyT3B0aW9ucycsIHtcclxuICAgICAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgd2Fybihtc2cpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyT3B0aW9ucztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0KCkge1xyXG4gICAgICAgICAgICAgICAgd2Fybihtc2cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gICAgaWYgKGlzU3RyaW5nKGNvbnRhaW5lcikpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lcik7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhcmVzKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBtb3VudCBhcHA6IG1vdW50IHRhcmdldCBzZWxlY3RvciBcIiR7Y29udGFpbmVyfVwiIHJldHVybmVkIG51bGwuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgY29udGFpbmVyIGluc3RhbmNlb2Ygd2luZG93LlNoYWRvd1Jvb3QgJiZcclxuICAgICAgICBjb250YWluZXIubW9kZSA9PT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgICB3YXJuKGBtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBcXGB7bW9kZTogXCJjbG9zZWRcIn1cXGAgbWF5IGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBidWdzYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGFpbmVyO1xyXG59XG5cbmV4cG9ydCB7IFRyYW5zaXRpb24sIFRyYW5zaXRpb25Hcm91cCwgY3JlYXRlQXBwLCBjcmVhdGVTU1JBcHAsIGh5ZHJhdGUsIHJlbmRlciwgdXNlQ3NzTW9kdWxlLCB1c2VDc3NWYXJzLCB2TW9kZWxDaGVja2JveCwgdk1vZGVsRHluYW1pYywgdk1vZGVsUmFkaW8sIHZNb2RlbFNlbGVjdCwgdk1vZGVsVGV4dCwgdlNob3csIHdpdGhLZXlzLCB3aXRoTW9kaWZpZXJzIH07XG4iLCIvKipcclxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XHJcbiAqIGlzIGluIHRoYXQgbWFwLlxyXG4gKiBJTVBPUlRBTlQ6IGFsbCBjYWxscyBvZiB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgcHJlZml4ZWQgd2l0aFxyXG4gKiBcXC9cXCojXFxfXFxfUFVSRVxcX1xcX1xcKlxcL1xyXG4gKiBTbyB0aGF0IHJvbGx1cCBjYW4gdHJlZS1zaGFrZSB0aGVtIGlmIG5lY2Vzc2FyeS5cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XHJcbiAgICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgY29uc3QgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gdmFsID0+ICEhbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXSA6IHZhbCA9PiAhIW1hcFt2YWxdO1xyXG59XG5cbi8qKlxyXG4gKiBkZXYgb25seSBmbGFnIC0+IG5hbWUgbWFwcGluZ1xyXG4gKi9cclxuY29uc3QgUGF0Y2hGbGFnTmFtZXMgPSB7XHJcbiAgICBbMSAvKiBURVhUICovXTogYFRFWFRgLFxyXG4gICAgWzIgLyogQ0xBU1MgKi9dOiBgQ0xBU1NgLFxyXG4gICAgWzQgLyogU1RZTEUgKi9dOiBgU1RZTEVgLFxyXG4gICAgWzggLyogUFJPUFMgKi9dOiBgUFJPUFNgLFxyXG4gICAgWzE2IC8qIEZVTExfUFJPUFMgKi9dOiBgRlVMTF9QUk9QU2AsXHJcbiAgICBbMzIgLyogSFlEUkFURV9FVkVOVFMgKi9dOiBgSFlEUkFURV9FVkVOVFNgLFxyXG4gICAgWzY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL106IGBTVEFCTEVfRlJBR01FTlRgLFxyXG4gICAgWzEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqL106IGBLRVlFRF9GUkFHTUVOVGAsXHJcbiAgICBbMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi9dOiBgVU5LRVlFRF9GUkFHTUVOVGAsXHJcbiAgICBbNTEyIC8qIE5FRURfUEFUQ0ggKi9dOiBgTkVFRF9QQVRDSGAsXHJcbiAgICBbMTAyNCAvKiBEWU5BTUlDX1NMT1RTICovXTogYERZTkFNSUNfU0xPVFNgLFxyXG4gICAgWzIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi9dOiBgREVWX1JPT1RfRlJBR01FTlRgLFxyXG4gICAgWy0xIC8qIEhPSVNURUQgKi9dOiBgSE9JU1RFRGAsXHJcbiAgICBbLTIgLyogQkFJTCAqL106IGBCQUlMYFxyXG59O1xuXG4vKipcclxuICogRGV2IG9ubHlcclxuICovXHJcbmNvbnN0IHNsb3RGbGFnc1RleHQgPSB7XHJcbiAgICBbMSAvKiBTVEFCTEUgKi9dOiAnU1RBQkxFJyxcclxuICAgIFsyIC8qIERZTkFNSUMgKi9dOiAnRFlOQU1JQycsXHJcbiAgICBbMyAvKiBGT1JXQVJERUQgKi9dOiAnRk9SV0FSREVEJ1xyXG59O1xuXG5jb25zdCBHTE9CQUxTX1dISVRFX0xJU1RFRCA9ICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLCcgK1xyXG4gICAgJ2RlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksJyArXHJcbiAgICAnT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQnO1xyXG5jb25zdCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoR0xPQkFMU19XSElURV9MSVNURUQpO1xuXG5jb25zdCByYW5nZSA9IDI7XHJcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XHJcbiAgICBjb25zdCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyP1xcbi8pO1xyXG4gICAgbGV0IGNvdW50ID0gMDtcclxuICAgIGNvbnN0IHJlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIDE7XHJcbiAgICAgICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAke2xpbmV9JHsnICcucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoMSwgZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgJyAnLnJlcGVhdChwYWQpICsgJ14nLnJlcGVhdChsZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPiBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgJ14nLnJlcGVhdChsZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKTtcclxufVxuXG4vKipcclxuICogT24gdGhlIGNsaWVudCB3ZSBvbmx5IG5lZWQgdG8gb2ZmZXIgc3BlY2lhbCBjYXNlcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXRcclxuICogaGF2ZSBkaWZmZXJlbnQgbmFtZXMgZnJvbSB0aGVpciBjb3JyZXNwb25kaW5nIGRvbSBwcm9wZXJ0aWVzOlxyXG4gKiAtIGl0ZW1zY29wZSAtPiBOL0FcclxuICogLSBhbGxvd2Z1bGxzY3JlZW4gLT4gYWxsb3dGdWxsc2NyZWVuXHJcbiAqIC0gZm9ybW5vdmFsaWRhdGUgLT4gZm9ybU5vVmFsaWRhdGVcclxuICogLSBpc21hcCAtPiBpc01hcFxyXG4gKiAtIG5vbW9kdWxlIC0+IG5vTW9kdWxlXHJcbiAqIC0gbm92YWxpZGF0ZSAtPiBub1ZhbGlkYXRlXHJcbiAqIC0gcmVhZG9ubHkgLT4gcmVhZE9ubHlcclxuICovXHJcbmNvbnN0IHNwZWNpYWxCb29sZWFuQXR0cnMgPSBgaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5YDtcclxuY29uc3QgaXNTcGVjaWFsQm9vbGVhbkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyk7XHJcbi8qKlxyXG4gKiBUaGUgZnVsbCBsaXN0IGlzIG5lZWRlZCBkdXJpbmcgU1NSIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgaW5pdGlhbCBtYXJrdXAuXHJcbiAqL1xyXG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMgK1xyXG4gICAgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4sYCArXHJcbiAgICBgbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxgICtcclxuICAgIGBjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYCk7XHJcbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcclxuY29uc3QgYXR0clZhbGlkYXRpb25DYWNoZSA9IHt9O1xyXG5mdW5jdGlvbiBpc1NTUlNhZmVBdHRyTmFtZShuYW1lKSB7XHJcbiAgICBpZiAoYXR0clZhbGlkYXRpb25DYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XHJcbiAgICBpZiAoaXNVbnNhZmUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGB1bnNhZmUgYXR0cmlidXRlIG5hbWU6ICR7bmFtZX1gKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXSA9ICFpc1Vuc2FmZSk7XHJcbn1cclxuY29uc3QgcHJvcHNUb0F0dHJNYXAgPSB7XHJcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxyXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxyXG4gICAgaHRtbEZvcjogJ2ZvcicsXHJcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xyXG59O1xyXG4vKipcclxuICogQ1NTIHByb3BlcnRpZXMgdGhhdCBhY2NlcHQgcGxhaW4gbnVtYmVyc1xyXG4gKi9cclxuY29uc3QgaXNOb1VuaXROdW1lcmljU3R5bGVQcm9wID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50LGJvcmRlci1pbWFnZS1vdXRzZXQsYm9yZGVyLWltYWdlLXNsaWNlLGAgK1xyXG4gICAgYGJvcmRlci1pbWFnZS13aWR0aCxib3gtZmxleCxib3gtZmxleC1ncm91cCxib3gtb3JkaW5hbC1ncm91cCxjb2x1bW4tY291bnQsYCArXHJcbiAgICBgY29sdW1ucyxmbGV4LGZsZXgtZ3JvdyxmbGV4LXBvc2l0aXZlLGZsZXgtc2hyaW5rLGZsZXgtbmVnYXRpdmUsZmxleC1vcmRlcixgICtcclxuICAgIGBncmlkLXJvdyxncmlkLXJvdy1lbmQsZ3JpZC1yb3ctc3BhbixncmlkLXJvdy1zdGFydCxncmlkLWNvbHVtbixgICtcclxuICAgIGBncmlkLWNvbHVtbi1lbmQsZ3JpZC1jb2x1bW4tc3BhbixncmlkLWNvbHVtbi1zdGFydCxmb250LXdlaWdodCxsaW5lLWNsYW1wLGAgK1xyXG4gICAgYGxpbmUtaGVpZ2h0LG9wYWNpdHksb3JkZXIsb3JwaGFucyx0YWItc2l6ZSx3aWRvd3Msei1pbmRleCx6b29tLGAgK1xyXG4gICAgLy8gU1ZHXHJcbiAgICBgZmlsbC1vcGFjaXR5LGZsb29kLW9wYWNpdHksc3RvcC1vcGFjaXR5LHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsYCArXHJcbiAgICBgc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoYCk7XHJcbi8qKlxyXG4gKiBLbm93biBhdHRyaWJ1dGVzLCB0aGlzIGlzIHVzZWQgZm9yIHN0cmluZ2lmaWNhdGlvbiBvZiBydW50aW1lIHN0YXRpYyBub2Rlc1xyXG4gKiBzbyB0aGF0IHdlIGRvbid0IHN0cmluZ2lmeSBiaW5kaW5ncyB0aGF0IGNhbm5vdCBiZSBzZXQgZnJvbSBIVE1MLlxyXG4gKiBEb24ndCBhbHNvIGZvcmdldCB0byBhbGxvdyBgZGF0YS0qYCBhbmQgYGFyaWEtKmAhXHJcbiAqIEdlbmVyYXRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQXR0cmlidXRlc1xyXG4gKi9cclxuY29uc3QgaXNLbm93bkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxgICtcclxuICAgIGBhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixgICtcclxuICAgIGBib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxgICtcclxuICAgIGBjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsYCArXHJcbiAgICBgY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsYCArXHJcbiAgICBgZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGAgK1xyXG4gICAgYGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsYCArXHJcbiAgICBgaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW50ZWdyaXR5LGAgK1xyXG4gICAgYGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxgICtcclxuICAgIGBtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLGAgK1xyXG4gICAgYG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxgICtcclxuICAgIGByZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLGAgK1xyXG4gICAgYHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxgICtcclxuICAgIGBzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCxgICtcclxuICAgIGB2YWx1ZSx3aWR0aCx3cmFwYCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBjb25zdCByZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVN0eWxlKGlzU3RyaW5nKGl0ZW0pID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKSA6IGl0ZW0pO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplZFtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgbGlzdERlbGltaXRlclJFID0gLzsoPyFbXihdKlxcKSkvZztcclxuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KC4rKS87XHJcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCkge1xyXG4gICAgY29uc3QgcmV0ID0ge307XHJcbiAgICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXJSRSkuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICBpZiAoaXRlbSkge1xyXG4gICAgICAgICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyUkUpO1xyXG4gICAgICAgICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xyXG4gICAgbGV0IHJldCA9ICcnO1xyXG4gICAgaWYgKCFzdHlsZXMpIHtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcclxuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8XHJcbiAgICAgICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcChub3JtYWxpemVkS2V5KSkpIHtcclxuICAgICAgICAgICAgLy8gb25seSByZW5kZXIgdmFsaWQgdmFsdWVzXHJcbiAgICAgICAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3ModmFsdWUpIHtcclxuICAgIGxldCByZXMgPSAnJztcclxuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICByZXMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IG5vcm1hbGl6ZWQgKyAnICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gbmFtZSArICcgJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXMudHJpbSgpO1xyXG59XG5cbi8vIFRoZXNlIHRhZyBjb25maWdzIGFyZSBzaGFyZWQgYmV0d2VlbiBjb21waWxlci1kb20gYW5kIHJ1bnRpbWUtZG9tLCBzbyB0aGV5XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudFxyXG5jb25zdCBIVE1MX1RBR1MgPSAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlciwnICtcclxuICAgICdoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLCcgK1xyXG4gICAgJ2ZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLCcgK1xyXG4gICAgJ2RhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCwnICtcclxuICAgICd0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLCcgK1xyXG4gICAgJ2NhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCwnICtcclxuICAgICd0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsJyArXHJcbiAgICAnb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSwnICtcclxuICAgICdzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290JztcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnRcclxuY29uc3QgU1ZHX1RBR1MgPSAnc3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLCcgK1xyXG4gICAgJ2RlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsJyArXHJcbiAgICAnZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCwnICtcclxuICAgICdmZURpc3RhbmNlTGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUiwnICtcclxuICAgICdmZUdhdXNzaWFuQmx1cixmZUltYWdlLGZlTWVyZ2UsZmVNZXJnZU5vZGUsZmVNb3JwaG9sb2d5LGZlT2Zmc2V0LCcgK1xyXG4gICAgJ2ZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsJyArXHJcbiAgICAnZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLCcgK1xyXG4gICAgJ21lc2gsbWVzaGdyYWRpZW50LG1lc2hwYXRjaCxtZXNocm93LG1ldGFkYXRhLG1wYXRoLHBhdGgscGF0dGVybiwnICtcclxuICAgICdwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLCcgK1xyXG4gICAgJ3RleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlldyc7XHJcbmNvbnN0IFZPSURfVEFHUyA9ICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicic7XHJcbmNvbnN0IGlzSFRNTFRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xyXG5jb25zdCBpc1NWR1RhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChTVkdfVEFHUyk7XHJcbmNvbnN0IGlzVm9pZFRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XHJcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XHJcbiAgICBjb25zdCBzdHIgPSAnJyArIHN0cmluZztcclxuICAgIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xyXG4gICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbiAgICBsZXQgaHRtbCA9ICcnO1xyXG4gICAgbGV0IGVzY2FwZWQ7XHJcbiAgICBsZXQgaW5kZXg7XHJcbiAgICBsZXQgbGFzdEluZGV4ID0gMDtcclxuICAgIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcclxuICAgICAgICAgICAgY2FzZSAzNDogLy8gXCJcclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJnF1b3Q7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM4OiAvLyAmXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZhbXA7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM5OiAvLyAnXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyYjMzk7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDYwOiAvLyA8XHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZsdDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNjI6IC8vID5cclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmd0Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xyXG4gICAgICAgICAgICBodG1sICs9IHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICBodG1sICs9IGVzY2FwZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcclxufVxyXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUyL3N5bnRheC5odG1sI2NvbW1lbnRzXHJcbmNvbnN0IGNvbW1lbnRTdHJpcFJFID0gL14tPz58PCEtLXwtLT58LS0hPnw8IS0kL2c7XHJcbmZ1bmN0aW9uIGVzY2FwZUh0bWxDb21tZW50KHNyYykge1xyXG4gICAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRTdHJpcFJFLCAnJyk7XHJcbn1cblxuZnVuY3Rpb24gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIHtcclxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgbGV0IGVxdWFsID0gdHJ1ZTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBlcXVhbCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlcXVhbDtcclxufVxyXG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgbGV0IGFWYWxpZFR5cGUgPSBpc0RhdGUoYSk7XHJcbiAgICBsZXQgYlZhbGlkVHlwZSA9IGlzRGF0ZShiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcclxuICAgIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xyXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikgOiBmYWxzZTtcclxuICAgIH1cclxuICAgIGFWYWxpZFR5cGUgPSBpc09iamVjdChhKTtcclxuICAgIGJWYWxpZFR5cGUgPSBpc09iamVjdChiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHRoaXMgaWYgd2lsbCBwcm9iYWJseSBuZXZlciBiZSBjYWxsZWQgKi9cclxuICAgICAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYSkubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFIYXNLZXkgPSBhLmhhc093blByb3BlcnR5KGtleSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XHJcbiAgICAgICAgICAgIGlmICgoYUhhc0tleSAmJiAhYkhhc0tleSkgfHxcclxuICAgICAgICAgICAgICAgICghYUhhc0tleSAmJiBiSGFzS2V5KSB8fFxyXG4gICAgICAgICAgICAgICAgIWxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XHJcbn1cclxuZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XHJcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChpdGVtID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XHJcbn1cblxuLyoqXHJcbiAqIEZvciBjb252ZXJ0aW5nIHt7IGludGVycG9sYXRpb24gfX0gdmFsdWVzIHRvIGRpc3BsYXllZCBzdHJpbmdzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgdG9EaXNwbGF5U3RyaW5nID0gKHZhbCkgPT4ge1xyXG4gICAgcmV0dXJuIHZhbCA9PSBudWxsXHJcbiAgICAgICAgPyAnJ1xyXG4gICAgICAgIDogaXNPYmplY3QodmFsKVxyXG4gICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpXHJcbiAgICAgICAgICAgIDogU3RyaW5nKHZhbCk7XHJcbn07XHJcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xyXG4gICAgaWYgKGlzTWFwKHZhbCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBbYE1hcCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC5lbnRyaWVzKCldLnJlZHVjZSgoZW50cmllcywgW2tleSwgdmFsXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZW50cmllc1tgJHtrZXl9ID0+YF0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cmllcztcclxuICAgICAgICAgICAgfSwge30pXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheSh2YWwpICYmICFpc1BsYWluT2JqZWN0KHZhbCkpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsO1xyXG59O1xuXG4vKipcclxuICogTGlzdCBvZiBAYmFiZWwvcGFyc2VyIHBsdWdpbnMgdGhhdCBhcmUgdXNlZCBmb3IgdGVtcGxhdGUgZXhwcmVzc2lvblxyXG4gKiB0cmFuc2Zvcm1zIGFuZCBTRkMgc2NyaXB0IHRyYW5zZm9ybXMuIEJ5IGRlZmF1bHQgd2UgZW5hYmxlIHByb3Bvc2FscyBzbGF0ZWRcclxuICogZm9yIEVTMjAyMC4gVGhpcyB3aWxsIG5lZWQgdG8gYmUgdXBkYXRlZCBhcyB0aGUgc3BlYyBtb3ZlcyBmb3J3YXJkLlxyXG4gKiBGdWxsIGxpc3QgYXQgaHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvZW4vbmV4dC9iYWJlbC1wYXJzZXIjcGx1Z2luc1xyXG4gKi9cclxuY29uc3QgYmFiZWxQYXJzZXJEZWZhdWx0UGx1Z2lucyA9IFtcclxuICAgICdiaWdJbnQnLFxyXG4gICAgJ29wdGlvbmFsQ2hhaW5pbmcnLFxyXG4gICAgJ251bGxpc2hDb2FsZXNjaW5nT3BlcmF0b3InXHJcbl07XHJcbmNvbnN0IEVNUFRZX09CSiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgPyBPYmplY3QuZnJlZXplKHt9KVxyXG4gICAgOiB7fTtcclxuY29uc3QgRU1QVFlfQVJSID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcclxuY29uc3QgTk9PUCA9ICgpID0+IHsgfTtcclxuLyoqXHJcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG5jb25zdCBOTyA9ICgpID0+IGZhbHNlO1xyXG5jb25zdCBvblJFID0gL15vblteYS16XS87XHJcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBvblJFLnRlc3Qoa2V5KTtcclxuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoJ29uVXBkYXRlOicpO1xyXG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xyXG5jb25zdCByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xyXG4gICAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcclxuICAgIGlmIChpID4gLTEpIHtcclxuICAgICAgICBhcnIuc3BsaWNlKGksIDEpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbmNvbnN0IGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XHJcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xyXG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBNYXBdJztcclxuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgU2V0XSc7XHJcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHZhbCBpbnN0YW5jZW9mIERhdGU7XHJcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xyXG5jb25zdCBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xyXG5jb25zdCBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzeW1ib2wnO1xyXG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JztcclxuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xyXG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xyXG59O1xyXG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XHJcbmNvbnN0IHRvUmF3VHlwZSA9ICh2YWx1ZSkgPT4ge1xyXG4gICAgLy8gZXh0cmFjdCBcIlJhd1R5cGVcIiBmcm9tIHN0cmluZ3MgbGlrZSBcIltvYmplY3QgUmF3VHlwZV1cIlxyXG4gICAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xyXG59O1xyXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xyXG5jb25zdCBpc0ludGVnZXJLZXkgPSAoa2V5KSA9PiBpc1N0cmluZyhrZXkpICYmXHJcbiAgICBrZXkgIT09ICdOYU4nICYmXHJcbiAgICBrZXlbMF0gIT09ICctJyAmJlxyXG4gICAgJycgKyBwYXJzZUludChrZXksIDEwKSA9PT0ga2V5O1xyXG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChcclxuLy8gdGhlIGxlYWRpbmcgY29tbWEgaXMgaW50ZW50aW9uYWwgc28gZW1wdHkgc3RyaW5nIFwiXCIgaXMgYWxzbyBpbmNsdWRlZFxyXG4nLGtleSxyZWYsJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZCcpO1xyXG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XHJcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICByZXR1cm4gKChzdHIpID0+IHtcclxuICAgICAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xyXG4gICAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IChjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpKTtcclxufSk7XHJcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKSk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpKTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IChzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGApKTtcclxuLy8gY29tcGFyZSB3aGV0aGVyIGEgdmFsdWUgaGFzIGNoYW5nZWQsIGFjY291bnRpbmcgZm9yIE5hTi5cclxuY29uc3QgaGFzQ2hhbmdlZCA9ICh2YWx1ZSwgb2xkVmFsdWUpID0+IHZhbHVlICE9PSBvbGRWYWx1ZSAmJiAodmFsdWUgPT09IHZhbHVlIHx8IG9sZFZhbHVlID09PSBvbGRWYWx1ZSk7XHJcbmNvbnN0IGludm9rZUFycmF5Rm5zID0gKGZucywgYXJnKSA9PiB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGZuc1tpXShhcmcpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBkZWYgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgdmFsdWVcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCB0b051bWJlciA9ICh2YWwpID0+IHtcclxuICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XHJcbiAgICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xyXG59O1xyXG5sZXQgX2dsb2JhbFRoaXM7XHJcbmNvbnN0IGdldEdsb2JhbFRoaXMgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gKF9nbG9iYWxUaGlzIHx8XHJcbiAgICAgICAgKF9nbG9iYWxUaGlzID1cclxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXNcclxuICAgICAgICAgICAgICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHdpbmRvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGdsb2JhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpO1xyXG59O1xuXG5leHBvcnQgeyBFTVBUWV9BUlIsIEVNUFRZX09CSiwgTk8sIE5PT1AsIFBhdGNoRmxhZ05hbWVzLCBiYWJlbFBhcnNlckRlZmF1bHRQbHVnaW5zLCBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgZGVmLCBlc2NhcGVIdG1sLCBlc2NhcGVIdG1sQ29tbWVudCwgZXh0ZW5kLCBnZW5lcmF0ZUNvZGVGcmFtZSwgZ2V0R2xvYmFsVGhpcywgaGFzQ2hhbmdlZCwgaGFzT3duLCBoeXBoZW5hdGUsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0RhdGUsIGlzRnVuY3Rpb24sIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25BdHRyLCBpc01hcCwgaXNNb2RlbExpc3RlbmVyLCBpc05vVW5pdE51bWVyaWNTdHlsZVByb3AsIGlzT2JqZWN0LCBpc09uLCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVzZXJ2ZWRQcm9wLCBpc1NTUlNhZmVBdHRyTmFtZSwgaXNTVkdUYWcsIGlzU2V0LCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNTdHJpbmcsIGlzU3ltYm9sLCBpc1ZvaWRUYWcsIGxvb3NlRXF1YWwsIGxvb3NlSW5kZXhPZiwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVN0eWxlLCBvYmplY3RUb1N0cmluZywgcGFyc2VTdHJpbmdTdHlsZSwgcHJvcHNUb0F0dHJNYXAsIHJlbW92ZSwgc2xvdEZsYWdzVGV4dCwgc3RyaW5naWZ5U3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgdG9SYXdUeXBlLCB0b1R5cGVTdHJpbmcgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBidWlsZEZ1bGxQYXRoID0gcmVxdWlyZSgnLi4vY29yZS9idWlsZEZ1bGxQYXRoJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLmF1dGgucGFzc3dvcmQpKSA6ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlXG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICB2YXIgdGltZW91dEVycm9yTWVzc2FnZSA9ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCc7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKHRpbWVvdXRFcnJvck1lc3NhZ2UsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihmdWxsUGF0aCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG4gICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFjb25maWcud2l0aENyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBFeHBlY3RlZCBET01FeGNlcHRpb24gdGhyb3duIGJ5IGJyb3dzZXJzIG5vdCBjb21wYXRpYmxlIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIuXG4gICAgICAgIC8vIEJ1dCwgdGhpcyBjYW4gYmUgc3VwcHJlc3NlZCBmb3IgJ2pzb24nIHR5cGUgYXMgaXQgY2FuIGJlIHBhcnNlZCBieSBkZWZhdWx0ICd0cmFuc2Zvcm1SZXNwb25zZScgZnVuY3Rpb24uXG4gICAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25VcGxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlamVjdChjYW5jZWwpO1xuICAgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFyZXF1ZXN0RGF0YSkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9jb3JlL21lcmdlQ29uZmlnJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG5heGlvcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGF4aW9zLmRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpO1xufTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxuYXhpb3MuaXNBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzQXhpb3NFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9tZXJnZUNvbmZpZycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuICAgIGNvbmZpZy51cmwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICB9XG5cbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcblxuICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICBpZiAoY29uZmlnLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSBjb25maWcubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5kZWZhdWx0cy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gdGhpcy5kZWZhdWx0cy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcubWV0aG9kID0gJ2dldCc7XG4gIH1cblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuQXhpb3MucHJvdG90eXBlLmdldFVyaSA9IGZ1bmN0aW9uIGdldFVyaShjb25maWcpIHtcbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgcmV0dXJuIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKS5yZXBsYWNlKC9eXFw/LywgJycpO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogKGNvbmZpZyB8fCB7fSkuZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vZW5oYW5jZUVycm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1xuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG5cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIGVycm9yLmlzQXhpb3NFcnJvciA9IHRydWU7XG5cbiAgZXJyb3IudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgY29kZTogdGhpcy5jb2RlXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGVycm9yO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIHZhciBjb25maWcgPSB7fTtcblxuICB2YXIgdmFsdWVGcm9tQ29uZmlnMktleXMgPSBbJ3VybCcsICdtZXRob2QnLCAnZGF0YSddO1xuICB2YXIgbWVyZ2VEZWVwUHJvcGVydGllc0tleXMgPSBbJ2hlYWRlcnMnLCAnYXV0aCcsICdwcm94eScsICdwYXJhbXMnXTtcbiAgdmFyIGRlZmF1bHRUb0NvbmZpZzJLZXlzID0gW1xuICAgICdiYXNlVVJMJywgJ3RyYW5zZm9ybVJlcXVlc3QnLCAndHJhbnNmb3JtUmVzcG9uc2UnLCAncGFyYW1zU2VyaWFsaXplcicsXG4gICAgJ3RpbWVvdXQnLCAndGltZW91dE1lc3NhZ2UnLCAnd2l0aENyZWRlbnRpYWxzJywgJ2FkYXB0ZXInLCAncmVzcG9uc2VUeXBlJywgJ3hzcmZDb29raWVOYW1lJyxcbiAgICAneHNyZkhlYWRlck5hbWUnLCAnb25VcGxvYWRQcm9ncmVzcycsICdvbkRvd25sb2FkUHJvZ3Jlc3MnLCAnZGVjb21wcmVzcycsXG4gICAgJ21heENvbnRlbnRMZW5ndGgnLCAnbWF4Qm9keUxlbmd0aCcsICdtYXhSZWRpcmVjdHMnLCAndHJhbnNwb3J0JywgJ2h0dHBBZ2VudCcsXG4gICAgJ2h0dHBzQWdlbnQnLCAnY2FuY2VsVG9rZW4nLCAnc29ja2V0UGF0aCcsICdyZXNwb25zZUVuY29kaW5nJ1xuICBdO1xuICB2YXIgZGlyZWN0TWVyZ2VLZXlzID0gWyd2YWxpZGF0ZVN0YXR1cyddO1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiB1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgdXRpbHMuZm9yRWFjaCh2YWx1ZUZyb21Db25maWcyS2V5cywgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gobWVyZ2VEZWVwUHJvcGVydGllc0tleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHV0aWxzLmZvckVhY2goZGVmYXVsdFRvQ29uZmlnMktleXMsIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKGRpcmVjdE1lcmdlS2V5cywgZnVuY3Rpb24gbWVyZ2UocHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGF4aW9zS2V5cyA9IHZhbHVlRnJvbUNvbmZpZzJLZXlzXG4gICAgLmNvbmNhdChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cylcbiAgICAuY29uY2F0KGRlZmF1bHRUb0NvbmZpZzJLZXlzKVxuICAgIC5jb25jYXQoZGlyZWN0TWVyZ2VLZXlzKTtcblxuICB2YXIgb3RoZXJLZXlzID0gT2JqZWN0XG4gICAgLmtleXMoY29uZmlnMSlcbiAgICAuY29uY2F0KE9iamVjdC5rZXlzKGNvbmZpZzIpKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gZmlsdGVyQXhpb3NLZXlzKGtleSkge1xuICAgICAgcmV0dXJuIGF4aW9zS2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xuICAgIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gob3RoZXJLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICByZXR1cm4gY29uZmlnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi9jcmVhdGVFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbihkYXRhLCBoZWFkZXJzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdBY2NlcHQnKTtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHZhciBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG5cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gKHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JykgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgdmFyIG9yaWdpblVSTDtcblxuICAgICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xuICBpZiAodG9TdHJpbmcuY2FsbCh2YWwpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOUycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuZnVuY3Rpb24gc3RyaXBCT00oY29udGVudCkge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW0sXG4gIHN0cmlwQk9NOiBzdHJpcEJPTVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciAmJiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdKTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pIHtcbiAgdmFyIF9pdGVtID0gX3NsaWNlZFRvQXJyYXkoaXRlbSwgNCksXG4gICAgICBjb250ZW50ID0gX2l0ZW1bMV0sXG4gICAgICBjc3NNYXBwaW5nID0gX2l0ZW1bM107XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwiPGRpdiBjbGFzcz1cInN1bW1hcnlcIj48ZGl2IGNsYXNzPVwic3VtbWFyeS10aXRsZVwiPlN0b3JlIFN1bW1hcnk8L2Rpdj48ZGl2IGNsYXNzPVwic3VtbWFyeS1idG5zXCI+PGRpdiBjbGFzcz1cImJ0biBzdW1tYXJ5LWJ0blwiIHYtYmluZD1cInsgY2xhc3M6IHJlc3VsdFR5cGUgPT09ICdjb3VudCcgJmFtcDsmYW1wOyAnYWN0aXZlJyB8fCAnJyB9XCIgQGNsaWNrPVwicmVzdWx0VHlwZSA9ICdjb3VudCdcIj5DT1VOVDwvZGl2PjxkaXYgY2xhc3M9XCJidG4gc3VtbWFyeS1idG5cIiB2LWJpbmQ9XCJ7IGNsYXNzOiByZXN1bHRUeXBlID09PSAncGVyY2VudCcgJmFtcDsmYW1wOyAnYWN0aXZlJyB8fCAnJyB9XCIgQGNsaWNrPVwicmVzdWx0VHlwZSA9ICdwZXJjZW50J1wiPlBFUkNFTlQ8L2Rpdj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVwicmVzdWx0c1wiPjxoZWFkZXIgY2xhc3M9XCJyZXN1bHRcIj48ZGl2IGNsYXNzPVwicmVzdWx0LXRpdGxlXCI+QnJhbmQ8L2Rpdj48ZGl2IGNsYXNzPVwicmVzdWx0LXN0b3JlXCI+PGRpdiBjbGFzcz1cInJlc3VsdC1zdG9yZS10aXRsZVwiPnt7IFBhc2NhbFNwYWNlQ2FzZSgnYmVzdEJ1eScpIH19PC9kaXY+PGRpdiBjbGFzcz1cInJlc3VsdC1tb250aHNcIj48ZGl2IGNsYXNzPVwicmVzdWx0LW1vbnRoXCI+e3sgdXBwZXJBYmJyZXZpYXRlTW9udGgoJ2phbnVhcnknKSB9fTwvZGl2PjxkaXYgY2xhc3M9XCJyZXN1bHQtbW9udGhcIj57eyB1cHBlckFiYnJldmlhdGVNb250aCgnZmVicnVhcnknKSB9fTwvZGl2PjxkaXYgY2xhc3M9XCJyZXN1bHQtbW9udGhcIj57eyB1cHBlckFiYnJldmlhdGVNb250aCgnbWFyY2gnKSB9fTwvZGl2PjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XCJyZXN1bHQtc3RvcmVcIj48ZGl2IGNsYXNzPVwicmVzdWx0LXN0b3JlLXRpdGxlXCI+e3sgUGFzY2FsU3BhY2VDYXNlKCdob21lRGVwb3QnKSB9fTwvZGl2PjxkaXYgY2xhc3M9XCJyZXN1bHQtbW9udGhzXCI+PGRpdiBjbGFzcz1cInJlc3VsdC1tb250aFwiPnt7IHVwcGVyQWJicmV2aWF0ZU1vbnRoKCdqYW51YXJ5JykgfX08L2Rpdj48ZGl2IGNsYXNzPVwicmVzdWx0LW1vbnRoXCI+e3sgdXBwZXJBYmJyZXZpYXRlTW9udGgoJ2ZlYnJ1YXJ5JykgfX08L2Rpdj48ZGl2IGNsYXNzPVwicmVzdWx0LW1vbnRoXCI+e3sgdXBwZXJBYmJyZXZpYXRlTW9udGgoJ21hcmNoJykgfX08L2Rpdj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVwicmVzdWx0LXN0b3JlXCI+PGRpdiBjbGFzcz1cInJlc3VsdC1zdG9yZS10aXRsZVwiPnt7IFBhc2NhbFNwYWNlQ2FzZSgnbG93ZXMnKSB9fTwvZGl2PjxkaXYgY2xhc3M9XCJyZXN1bHQtbW9udGhzXCI+PGRpdiBjbGFzcz1cInJlc3VsdC1tb250aFwiPnt7IHVwcGVyQWJicmV2aWF0ZU1vbnRoKCdqYW51YXJ5JykgfX08L2Rpdj48ZGl2IGNsYXNzPVwicmVzdWx0LW1vbnRoXCI+e3sgdXBwZXJBYmJyZXZpYXRlTW9udGgoJ2ZlYnJ1YXJ5JykgfX08L2Rpdj48ZGl2IGNsYXNzPVwicmVzdWx0LW1vbnRoXCI+e3sgdXBwZXJBYmJyZXZpYXRlTW9udGgoJ21hcmNoJykgfX08L2Rpdj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVwicmVzdWx0LXRvdGFsIHJlc3VsdC1oZWFkZXItdG90YWxcIj5HcmFuZCBUb3RhbDwvZGl2PjwvaGVhZGVyPjxkaXYgY2xhc3M9XCJyZXN1bHRcIiB2LWZvcj1cInJlc3VsdCBpbiByZXN1bHRzXCI+PGRpdiBjbGFzcz1cInJlc3VsdC10aXRsZVwiPnt7IHJlc3VsdC5icmFuZCB9fTwvZGl2PjxkaXYgY2xhc3M9XCJyZXN1bHQtY291bnRcIiB2LWZvcj1cImNvdW50IGluIHJlc3VsdFtgJHtyZXN1bHRUeXBlfXNgXVwiPnt7IGAke2NvdW50fSR7cmVzdWx0VHlwZSA9PT0gJ3BlcmNlbnQnICYmICclJyB8fCAnJ31gIH19PC9kaXY+PGRpdiBjbGFzcz1cInJlc3VsdC10b3RhbFwiPnt7IHJlc3VsdFR5cGUgPT09ICdwZXJjZW50JyA/IGAke3Jlc3VsdC50b3RhbF9wZXJjZW50fSVgIDogcmVzdWx0LnRvdGFsIH19PC9kaXY+PC9kaXY+PC9kaXY+IiwiaW1wb3J0IHsgaW5pdEN1c3RvbUZvcm1hdHRlciwgd2FybiB9IGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5cbmZ1bmN0aW9uIGluaXREZXYoKSB7XHJcbiAgICB7XHJcbiAgICAgICAgaW5pdEN1c3RvbUZvcm1hdHRlcigpO1xyXG4gICAgfVxyXG59XG5cbi8vIFRoaXMgZW50cnkgZXhwb3J0cyB0aGUgcnVudGltZSBvbmx5LCBhbmQgaXMgYnVpbHQgYXNcclxuaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgaW5pdERldigpO1xyXG59XHJcbmNvbnN0IGNvbXBpbGUgPSAoKSA9PiB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgUnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLmAgK1xyXG4gICAgICAgICAgICAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gXHJcbiAgICAgICAgICAgICAgICApIC8qIHNob3VsZCBub3QgaGFwcGVuICovKTtcclxuICAgIH1cclxufTtcblxuZXhwb3J0IHsgY29tcGlsZSB9O1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiYm9keSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTVlZGYxO1xcbiAgZm9udC1mYW1pbHk6IEFyaWFsO1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9hcHAuc3R5bFwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLHlCQUFpQjtFQUNqQixrQkFBWTtFQUNaLFNBQU87QUFDVFwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJib2R5XFxuICBiYWNrZ3JvdW5kLWNvbG9yICNlNWVkZjFcXG4gIGZvbnQtZmFtaWx5IEFyaWFsXFxuICBtYXJnaW4gMFxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIubWV0cmljcyB7XFxuICBwYWRkaW5nLWlubGluZTogOHB4O1xcbiAgcGFkZGluZy10b3A6IDIwcHg7XFxuICBwYWRkaW5nLWJvdHRvbTogNXB4O1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9tZXRyaWNzLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFDQTtFQUNFLG1CQUFlO0VBQ2YsaUJBQVk7RUFDWixtQkFBZTtBQUFqQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGUgbGFuZz1cXFwicHVnXFxcIj5cXG4tIGNvbnN0IHN0b3JlcyA9IFsnYmVzdEJ1eScsICdob21lRGVwb3QnLCAnbG93ZXMnXVxcbi0gY29uc3QgbW9udGhzID0gWydqYW51YXJ5JywgJ2ZlYnJ1YXJ5JywgJ21hcmNoJ11cXG5cXG4uc3VtbWFyeVxcbiAgLnN1bW1hcnktdGl0bGUgU3RvcmUgU3VtbWFyeVxcbiAgLnN1bW1hcnktYnRuc1xcbiAgICAuYnRuLnN1bW1hcnktYnRuKHYtYmluZD0neyBjbGFzczogcmVzdWx0VHlwZSA9PT0gXFxcXCdjb3VudFxcXFwnICYmIFxcXFwnYWN0aXZlXFxcXCcgfHwgXFxcXCdcXFxcJyB9JywgQGNsaWNrPSdyZXN1bHRUeXBlID0gXFxcXCdjb3VudFxcXFwnJykgQ09VTlRcXG4gICAgLmJ0bi5zdW1tYXJ5LWJ0bih2LWJpbmQ9J3sgY2xhc3M6IHJlc3VsdFR5cGUgPT09IFxcXFwncGVyY2VudFxcXFwnICYmIFxcXFwnYWN0aXZlXFxcXCcgfHwgXFxcXCdcXFxcJyB9JywgQGNsaWNrPSdyZXN1bHRUeXBlID0gXFxcXCdwZXJjZW50XFxcXCcnKSBQRVJDRU5UXFxuXFxuLnJlc3VsdHNcXG4gIGhlYWRlci5yZXN1bHRcXG4gICAgLnJlc3VsdC10aXRsZSBCcmFuZFxcblxcbiAgICBlYWNoIHN0b3JlIGluIHN0b3Jlc1xcbiAgICAgIC5yZXN1bHQtc3RvcmVcXG4gICAgICAgIC5yZXN1bHQtc3RvcmUtdGl0bGU9IGB7eyBQYXNjYWxTcGFjZUNhc2UoJyR7c3RvcmV9JykgfX1gXFxuXFxuICAgICAgICAucmVzdWx0LW1vbnRoc1xcbiAgICAgICAgICBlYWNoIG1vbnRoIGluIG1vbnRoc1xcbiAgICAgICAgICAgIC5yZXN1bHQtbW9udGg9IGB7eyB1cHBlckFiYnJldmlhdGVNb250aCgnJHttb250aH0nKSB9fWBcXG5cXG4gICAgLnJlc3VsdC10b3RhbC5yZXN1bHQtaGVhZGVyLXRvdGFsIEdyYW5kIFRvdGFsXFxuXFxuICAucmVzdWx0KHYtZm9yPSdyZXN1bHQgaW4gcmVzdWx0cycpXFxuICAgIC5yZXN1bHQtdGl0bGUge3sgcmVzdWx0LmJyYW5kIH19XFxuXFxuICAgIC5yZXN1bHQtY291bnQodi1mb3I9J2NvdW50IGluIHJlc3VsdFtgJHtyZXN1bHRUeXBlfXNgXScpIHt7IGAke2NvdW50fSR7cmVzdWx0VHlwZSA9PT0gJ3BlcmNlbnQnICYmICclJyB8fCAnJ31gIH19XFxuXFxuICAgIC5yZXN1bHQtdG90YWwge3sgcmVzdWx0VHlwZSA9PT0gJ3BlcmNlbnQnID8gYCR7cmVzdWx0LnRvdGFsX3BlcmNlbnR9JWAgOiByZXN1bHQudG90YWwgfX1cXG48L3RlbXBsYXRlPlxcblxcbjxzY3JpcHQ+XFxuY29uc3QgbWV0cmljc1VybCA9ICdodHRwOi8vcGxhbm9ncmFtLnN0ZXZlbnNvbmNvbXBhbnkuY29tL2FwaS9tZXRyaWNzL3N0b3JlJztcXG5cXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xcblxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gIGFzeW5jIGJlZm9yZUNyZWF0ZSgpIHtcXG4gICAgbGV0IHJlc3VsdHM7XFxuICAgIHRyeSB7XFxuICAgICAgKHtkYXRhOiB7ZGF0YTogcmVzdWx0c319ID0gYXdhaXQgYXhpb3MobWV0cmljc1VybCkpO1xcbiAgICB9IGNhdGNoIHt9XFxuXFxuICAgIHRoaXMucmVzdWx0cyA9IHBhcnNlTWV0cmljcyhyZXN1bHRzKTtcXG4gIH0sXFxuXFxuICBtZXRob2RzOiB7XFxuICAgIFBhc2NhbFNwYWNlQ2FzZSxcXG4gICAgdXBwZXJBYmJyZXZpYXRlTW9udGgsXFxuICB9LFxcblxcbiAgZGF0YTogKCkgPT4gKHtyZXN1bHRzOiBbXSwgcmVzdWx0VHlwZTogJ2NvdW50J30pLFxcbn07XFxuXFxuZnVuY3Rpb24gcGFyc2VNZXRyaWNzKHJlc3VsdHMpIHtcXG4gIGZvcihjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xcbiAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwge1xcbiAgICAgIGNvdW50czogW1xcbiAgICAgICAgcmVzdWx0LmJlc3RfYnV5XzIwMjEwMyxcXG4gICAgICAgIHJlc3VsdC5iZXN0X2J1eV8yMDIxMDQsXFxuICAgICAgICByZXN1bHQuYmVzdF9idXlfMjAyMTA1LFxcbiAgICAgICAgcmVzdWx0LmhvbWVfZGVwb3RfMjAyMTAzLFxcbiAgICAgICAgcmVzdWx0LmhvbWVfZGVwb3RfMjAyMTA0LFxcbiAgICAgICAgcmVzdWx0LmhvbWVfZGVwb3RfMjAyMTA1LFxcbiAgICAgICAgcmVzdWx0Lmxvd2VzXzIwMjEwMyxcXG4gICAgICAgIHJlc3VsdC5sb3dlc18yMDIxMDQsXFxuICAgICAgICByZXN1bHQubG93ZXNfMjAyMTA1LFxcbiAgICAgIF0sXFxuXFxuICAgICAgcGVyY2VudHM6IFtcXG4gICAgICAgIHJlc3VsdC5iZXN0X2J1eV8yMDIxMDNfcGVyY2VudCxcXG4gICAgICAgIHJlc3VsdC5iZXN0X2J1eV8yMDIxMDRfcGVyY2VudCxcXG4gICAgICAgIHJlc3VsdC5iZXN0X2J1eV8yMDIxMDVfcGVyY2VudCxcXG4gICAgICAgIHJlc3VsdC5ob21lX2RlcG90XzIwMjEwM19wZXJjZW50LFxcbiAgICAgICAgcmVzdWx0LmhvbWVfZGVwb3RfMjAyMTA0X3BlcmNlbnQsXFxuICAgICAgICByZXN1bHQuaG9tZV9kZXBvdF8yMDIxMDVfcGVyY2VudCxcXG4gICAgICAgIHJlc3VsdC5sb3dlc18yMDIxMDNfcGVyY2VudCxcXG4gICAgICAgIHJlc3VsdC5sb3dlc18yMDIxMDRfcGVyY2VudCxcXG4gICAgICAgIHJlc3VsdC5sb3dlc18yMDIxMDVfcGVyY2VudCxcXG4gICAgICBdLFxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHJldHVybiByZXN1bHRzO1xcbn1cXG5cXG5mdW5jdGlvbiBQYXNjYWxTcGFjZUNhc2Uoc3RyKSB7XFxuICBjb25zdCBjYW1lbFNwYWNlQ2FzZWQgPSBzdHI/LnJlcGxhY2VBbGw/LigvW0EtWl0vZywgJyAkJicpO1xcblxcbiAgcmV0dXJuIGNhcGl0YWxpemUoY2FtZWxTcGFjZUNhc2VkKTtcXG59XFxuXFxuZnVuY3Rpb24gdXBwZXJBYmJyZXZpYXRlTW9udGgobW9udGgpIHtcXG4gIGNvbnN0IGFiYnJldmlhdGVkID0gbW9udGg/LnN1YnN0cj8uKDAsIDMpO1xcblxcbiAgcmV0dXJuIGNhcGl0YWxpemUoYWJicmV2aWF0ZWQpO1xcbn1cXG5cXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xcbiAgcmV0dXJuIGAke3N0cj8uY2hhckF0Py4oMCkudG9Mb2NhbGVVcHBlckNhc2UoKX0ke3N0cj8uc2xpY2U/LigxKX1gO1xcbn1cXG48L3NjcmlwdD5cXG5cXG48c3R5bGUgbGFuZz1cXFwic3R5bHVzXFxcIj5cXG4ubWV0cmljc1xcbiAgcGFkZGluZy1pbmxpbmUgOHB4XFxuICBwYWRkaW5nLXRvcCAyMHB4XFxuICBwYWRkaW5nLWJvdHRvbSA1cHhcXG48L3N0eWxlPlxcblxcbjxzdHlsZSBsYW5nPVxcXCJzdHlsdXNcXFwiIHNjb3BlZD5cXG4uYnRuXFxuICBiYWNrZ3JvdW5kLWNvbG9yIHdoaXRlXFxuICBjb2xvciAjNDM4NmFiXFxuICBjdXJzb3IgcG9pbnRlclxcbiAgcGFkZGluZy1pbmxpbmUgMTJweFxcbiAgaGVpZ2h0IDM0cHhcXG4gIGRpc3BsYXkgZmxleFxcbiAganVzdGlmeS1jb250ZW50IGNlbnRlclxcbiAgYWxpZ24taXRlbXMgY2VudGVyXFxuXFxuICAmLmFjdGl2ZVxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yICM0Mzg2YWJcXG4gICAgY29sb3Igd2hpdGVcXG5cXG4uc3VtbWFyeVxcbiAgbWFyZ2luLWJvdHRvbSAyMHB4XFxuICBkaXNwbGF5IGZsZXhcXG5cXG4uc3VtbWFyeS10aXRsZVxcbiAgZm9udC13ZWlnaHQgYm9sZFxcbiAgbWFyZ2luLXJpZ2h0IDQwcHhcXG4gIGRpc3BsYXkgZmxleFxcbiAgYWxpZ24taXRlbXMgY2VudGVyXFxuXFxuLnN1bW1hcnktYnRuc1xcbiAgZGlzcGxheSBmbGV4XFxuXFxuLnN1bW1hcnktYnRuXFxuICB3aWR0aCAxMDBweFxcblxcbiAgJjpmaXJzdC1jaGlsZFxcbiAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXMgNXB4XFxuICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyA1cHhcXG5cXG4gICY6bGFzdC1jaGlsZFxcbiAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzIDVweFxcbiAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzIDVweFxcblxcbi5yZXN1bHRzXFxuICAmIGhlYWRlclxcbiAgICBjb2xvciAjN2E4ZjlmXFxuICAgIGZvbnQtd2VpZ2h0IGJvbGRcXG4gICAgbWFyZ2luLWJvdHRvbSAxMHB4XFxuICAgIGhlaWdodCAxMDBweFxcblxcbi5yZXN1bHRcXG4gIGJhY2tncm91bmQtY29sb3Igd2hpdGVcXG4gIG1hcmdpbi1ib3R0b20gNXB4XFxuICBib3JkZXItcmFkaXVzIDVweFxcbiAgaGVpZ2h0IDUwcHhcXG4gIGRpc3BsYXkgZmxleFxcbiAgYWxpZ24taXRlbXMgY2VudGVyXFxuXFxuICAmOmxhc3QtY2hpbGRcXG4gICAgbWFyZ2luLWJvdHRvbSAwXFxuXFxuLnJlc3VsdC1jb3VudFxcbiAgZmxleC1ncm93IDFcXG4gIHdpZHRoOiAwXFxuICBkaXNwbGF5IGZsZXhcXG4gIGFsaWduLWl0ZW1zIGNlbnRlclxcbiAganVzdGlmeS1jb250ZW50IGNlbnRlclxcblxcbi5yZXN1bHQtdGl0bGVcXG4gIHBhZGRpbmctbGVmdCAxNXB4XFxuICB3aWR0aCAyMDBweFxcbiAgZGlzcGxheSBmbGV4XFxuICBhbGlnbi1pdGVtcyBjZW50ZXJcXG5cXG4ucmVzdWx0LXN0b3JlXFxuICBmbGV4LWdyb3cgMVxcbiAgYWxpZ24tc2VsZiBzdHJldGNoXFxuICBib3JkZXItbGVmdCAxcHggc29saWQgI2U2ZWVmMVxcbiAgZGlzcGxheSBmbGV4XFxuICBmbGV4LWRpcmVjdGlvbiBjb2x1bW5cXG5cXG4ucmVzdWx0LXN0b3JlLXRpdGxlXFxuICBmbGV4LWdyb3cgMVxcbiAgYm9yZGVyLWJvdHRvbSAxcHggc29saWQgI2U2ZWVmMVxcbiAgZGlzcGxheSBmbGV4XFxuICBqdXN0aWZ5LWNvbnRlbnQgY2VudGVyXFxuICBhbGlnbi1pdGVtcyBjZW50ZXJcXG5cXG4ucmVzdWx0LW1vbnRoc1xcbiAgZmxleC1ncm93IDFcXG4gIGRpc3BsYXkgZmxleFxcblxcbi5yZXN1bHQtbW9udGhcXG4gIGZsZXgtZ3JvdyAxXFxuICBkaXNwbGF5IGZsZXhcXG4gIGp1c3RpZnktY29udGVudCBjZW50ZXJcXG4gIGFsaWduLWl0ZW1zIGNlbnRlclxcblxcbi5yZXN1bHQtdG90YWxcXG4gIHRleHQtYWxpZ24gY2VudGVyXFxuICBhbGlnbi1zZWxmIHN0cmV0Y2hcXG4gIG1hcmdpbi1yaWdodCAxNXB4XFxuICB3aWR0aCAxNTBweFxcbiAgZGlzcGxheSBmbGV4XFxuICBqdXN0aWZ5LWNvbnRlbnQgZmxleC1lbmRcXG4gIGFsaWduLWl0ZW1zIGNlbnRlclxcblxcbi5yZXN1bHQtaGVhZGVyLXRvdGFsXFxuICBtYXJnaW4tbGVmdCAwXFxuICBib3JkZXItbGVmdCAxcHggc29saWQgI2U2ZWVmMVxcbiAganVzdGlmeS1jb250ZW50IGNlbnRlclxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5idG5bZGF0YS12LTEzODRkODI1XSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgY29sb3I6ICM0Mzg2YWI7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBwYWRkaW5nLWlubGluZTogMTJweDtcXG4gIGhlaWdodDogMzRweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5idG4uYWN0aXZlW2RhdGEtdi0xMzg0ZDgyNV0ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzQzODZhYjtcXG4gIGNvbG9yOiAjZmZmO1xcbn1cXG4uc3VtbWFyeVtkYXRhLXYtMTM4NGQ4MjVdIHtcXG4gIG1hcmdpbi1ib3R0b206IDIwcHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbn1cXG4uc3VtbWFyeS10aXRsZVtkYXRhLXYtMTM4NGQ4MjVdIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgbWFyZ2luLXJpZ2h0OiA0MHB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5zdW1tYXJ5LWJ0bnNbZGF0YS12LTEzODRkODI1XSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbn1cXG4uc3VtbWFyeS1idG5bZGF0YS12LTEzODRkODI1XSB7XFxuICB3aWR0aDogMTAwcHg7XFxufVxcbi5zdW1tYXJ5LWJ0bltkYXRhLXYtMTM4NGQ4MjVdOmZpcnN0LWNoaWxkIHtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDVweDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDVweDtcXG59XFxuLnN1bW1hcnktYnRuW2RhdGEtdi0xMzg0ZDgyNV06bGFzdC1jaGlsZCB7XFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogNXB4O1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDVweDtcXG59XFxuLnJlc3VsdHMgaGVhZGVyW2RhdGEtdi0xMzg0ZDgyNV0ge1xcbiAgY29sb3I6ICM3YThmOWY7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIG1hcmdpbi1ib3R0b206IDEwcHg7XFxuICBoZWlnaHQ6IDEwMHB4O1xcbn1cXG4ucmVzdWx0W2RhdGEtdi0xMzg0ZDgyNV0ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIG1hcmdpbi1ib3R0b206IDVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIGhlaWdodDogNTBweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG4ucmVzdWx0W2RhdGEtdi0xMzg0ZDgyNV06bGFzdC1jaGlsZCB7XFxuICBtYXJnaW4tYm90dG9tOiAwO1xcbn1cXG4ucmVzdWx0LWNvdW50W2RhdGEtdi0xMzg0ZDgyNV0ge1xcbiAgZmxleC1ncm93OiAxO1xcbiAgd2lkdGg6IDA7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG4ucmVzdWx0LXRpdGxlW2RhdGEtdi0xMzg0ZDgyNV0ge1xcbiAgcGFkZGluZy1sZWZ0OiAxNXB4O1xcbiAgd2lkdGg6IDIwMHB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5yZXN1bHQtc3RvcmVbZGF0YS12LTEzODRkODI1XSB7XFxuICBmbGV4LWdyb3c6IDE7XFxuICBhbGlnbi1zZWxmOiBzdHJldGNoO1xcbiAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjZTZlZWYxO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcbi5yZXN1bHQtc3RvcmUtdGl0bGVbZGF0YS12LTEzODRkODI1XSB7XFxuICBmbGV4LWdyb3c6IDE7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2U2ZWVmMTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5yZXN1bHQtbW9udGhzW2RhdGEtdi0xMzg0ZDgyNV0ge1xcbiAgZmxleC1ncm93OiAxO1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuLnJlc3VsdC1tb250aFtkYXRhLXYtMTM4NGQ4MjVdIHtcXG4gIGZsZXgtZ3JvdzogMTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5yZXN1bHQtdG90YWxbZGF0YS12LTEzODRkODI1XSB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBhbGlnbi1zZWxmOiBzdHJldGNoO1xcbiAgbWFyZ2luLXJpZ2h0OiAxNXB4O1xcbiAgd2lkdGg6IDE1MHB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG4ucmVzdWx0LWhlYWRlci10b3RhbFtkYXRhLXYtMTM4NGQ4MjVdIHtcXG4gIG1hcmdpbi1sZWZ0OiAwO1xcbiAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjZTZlZWYxO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL21ldHJpY3MudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUNBO0VBQ0Usc0JBQWlCO0VBQ2pCLGNBQU07RUFDTixlQUFPO0VBQ1Asb0JBQWU7RUFDZixZQUFPO0VBQ1AsYUFBUTtFQUNSLHVCQUFnQjtFQUNoQixtQkFBWTtBQUFkO0FBRUU7RUFDRSx5QkFBaUI7RUFDakIsV0FBTTtBQUFWO0FBRUE7RUFDRSxtQkFBYztFQUNkLGFBQVE7QUFBVjtBQUVBO0VBQ0UsaUJBQVk7RUFDWixrQkFBYTtFQUNiLGFBQVE7RUFDUixtQkFBWTtBQUFkO0FBRUE7RUFDRSxhQUFRO0FBQVY7QUFFQTtFQUNFLFlBQU07QUFBUjtBQUVFO0VBQ0MsMkJBQXVCO0VBQ3ZCLDhCQUEwQjtBQUE3QjtBQUVFO0VBQ0MsNEJBQXdCO0VBQ3hCLCtCQUEyQjtBQUE5QjtBQUdFO0VBQ0UsY0FBTTtFQUNOLGlCQUFZO0VBQ1osbUJBQWM7RUFDZCxhQUFPO0FBRFg7QUFHQTtFQUNFLHNCQUFpQjtFQUNqQixrQkFBYztFQUNkLGtCQUFjO0VBQ2QsWUFBTztFQUNQLGFBQVE7RUFDUixtQkFBWTtBQURkO0FBR0U7RUFDRSxnQkFBYztBQURsQjtBQUdBO0VBQ0UsWUFBVTtFQUNWLFFBQU87RUFDUCxhQUFRO0VBQ1IsbUJBQVk7RUFDWix1QkFBZ0I7QUFEbEI7QUFHQTtFQUNFLGtCQUFhO0VBQ2IsWUFBTTtFQUNOLGFBQVE7RUFDUixtQkFBWTtBQURkO0FBR0E7RUFDRSxZQUFVO0VBQ1YsbUJBQVc7RUFDWCw4QkFBWTtFQUNaLGFBQVE7RUFDUixzQkFBZTtBQURqQjtBQUdBO0VBQ0UsWUFBVTtFQUNWLGdDQUFjO0VBQ2QsYUFBUTtFQUNSLHVCQUFnQjtFQUNoQixtQkFBWTtBQURkO0FBR0E7RUFDRSxZQUFVO0VBQ1YsYUFBUTtBQURWO0FBR0E7RUFDRSxZQUFVO0VBQ1YsYUFBUTtFQUNSLHVCQUFnQjtFQUNoQixtQkFBWTtBQURkO0FBR0E7RUFDRSxrQkFBVztFQUNYLG1CQUFXO0VBQ1gsa0JBQWE7RUFDYixZQUFNO0VBQ04sYUFBUTtFQUNSLHlCQUFnQjtFQUNoQixtQkFBWTtBQURkO0FBR0E7RUFDRSxjQUFZO0VBQ1osOEJBQVk7RUFDWix1QkFBZ0I7QUFEbEJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlIGxhbmc9XFxcInB1Z1xcXCI+XFxuLSBjb25zdCBzdG9yZXMgPSBbJ2Jlc3RCdXknLCAnaG9tZURlcG90JywgJ2xvd2VzJ11cXG4tIGNvbnN0IG1vbnRocyA9IFsnamFudWFyeScsICdmZWJydWFyeScsICdtYXJjaCddXFxuXFxuLnN1bW1hcnlcXG4gIC5zdW1tYXJ5LXRpdGxlIFN0b3JlIFN1bW1hcnlcXG4gIC5zdW1tYXJ5LWJ0bnNcXG4gICAgLmJ0bi5zdW1tYXJ5LWJ0bih2LWJpbmQ9J3sgY2xhc3M6IHJlc3VsdFR5cGUgPT09IFxcXFwnY291bnRcXFxcJyAmJiBcXFxcJ2FjdGl2ZVxcXFwnIHx8IFxcXFwnXFxcXCcgfScsIEBjbGljaz0ncmVzdWx0VHlwZSA9IFxcXFwnY291bnRcXFxcJycpIENPVU5UXFxuICAgIC5idG4uc3VtbWFyeS1idG4odi1iaW5kPSd7IGNsYXNzOiByZXN1bHRUeXBlID09PSBcXFxcJ3BlcmNlbnRcXFxcJyAmJiBcXFxcJ2FjdGl2ZVxcXFwnIHx8IFxcXFwnXFxcXCcgfScsIEBjbGljaz0ncmVzdWx0VHlwZSA9IFxcXFwncGVyY2VudFxcXFwnJykgUEVSQ0VOVFxcblxcbi5yZXN1bHRzXFxuICBoZWFkZXIucmVzdWx0XFxuICAgIC5yZXN1bHQtdGl0bGUgQnJhbmRcXG5cXG4gICAgZWFjaCBzdG9yZSBpbiBzdG9yZXNcXG4gICAgICAucmVzdWx0LXN0b3JlXFxuICAgICAgICAucmVzdWx0LXN0b3JlLXRpdGxlPSBge3sgUGFzY2FsU3BhY2VDYXNlKCcke3N0b3JlfScpIH19YFxcblxcbiAgICAgICAgLnJlc3VsdC1tb250aHNcXG4gICAgICAgICAgZWFjaCBtb250aCBpbiBtb250aHNcXG4gICAgICAgICAgICAucmVzdWx0LW1vbnRoPSBge3sgdXBwZXJBYmJyZXZpYXRlTW9udGgoJyR7bW9udGh9JykgfX1gXFxuXFxuICAgIC5yZXN1bHQtdG90YWwucmVzdWx0LWhlYWRlci10b3RhbCBHcmFuZCBUb3RhbFxcblxcbiAgLnJlc3VsdCh2LWZvcj0ncmVzdWx0IGluIHJlc3VsdHMnKVxcbiAgICAucmVzdWx0LXRpdGxlIHt7IHJlc3VsdC5icmFuZCB9fVxcblxcbiAgICAucmVzdWx0LWNvdW50KHYtZm9yPSdjb3VudCBpbiByZXN1bHRbYCR7cmVzdWx0VHlwZX1zYF0nKSB7eyBgJHtjb3VudH0ke3Jlc3VsdFR5cGUgPT09ICdwZXJjZW50JyAmJiAnJScgfHwgJyd9YCB9fVxcblxcbiAgICAucmVzdWx0LXRvdGFsIHt7IHJlc3VsdFR5cGUgPT09ICdwZXJjZW50JyA/IGAke3Jlc3VsdC50b3RhbF9wZXJjZW50fSVgIDogcmVzdWx0LnRvdGFsIH19XFxuPC90ZW1wbGF0ZT5cXG5cXG48c2NyaXB0PlxcbmNvbnN0IG1ldHJpY3NVcmwgPSAnaHR0cDovL3BsYW5vZ3JhbS5zdGV2ZW5zb25jb21wYW55LmNvbS9hcGkvbWV0cmljcy9zdG9yZSc7XFxuXFxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICBhc3luYyBiZWZvcmVDcmVhdGUoKSB7XFxuICAgIGxldCByZXN1bHRzO1xcbiAgICB0cnkge1xcbiAgICAgICh7ZGF0YToge2RhdGE6IHJlc3VsdHN9fSA9IGF3YWl0IGF4aW9zKG1ldHJpY3NVcmwpKTtcXG4gICAgfSBjYXRjaCB7fVxcblxcbiAgICB0aGlzLnJlc3VsdHMgPSBwYXJzZU1ldHJpY3MocmVzdWx0cyk7XFxuICB9LFxcblxcbiAgbWV0aG9kczoge1xcbiAgICBQYXNjYWxTcGFjZUNhc2UsXFxuICAgIHVwcGVyQWJicmV2aWF0ZU1vbnRoLFxcbiAgfSxcXG5cXG4gIGRhdGE6ICgpID0+ICh7cmVzdWx0czogW10sIHJlc3VsdFR5cGU6ICdjb3VudCd9KSxcXG59O1xcblxcbmZ1bmN0aW9uIHBhcnNlTWV0cmljcyhyZXN1bHRzKSB7XFxuICBmb3IoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcXG4gICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHtcXG4gICAgICBjb3VudHM6IFtcXG4gICAgICAgIHJlc3VsdC5iZXN0X2J1eV8yMDIxMDMsXFxuICAgICAgICByZXN1bHQuYmVzdF9idXlfMjAyMTA0LFxcbiAgICAgICAgcmVzdWx0LmJlc3RfYnV5XzIwMjEwNSxcXG4gICAgICAgIHJlc3VsdC5ob21lX2RlcG90XzIwMjEwMyxcXG4gICAgICAgIHJlc3VsdC5ob21lX2RlcG90XzIwMjEwNCxcXG4gICAgICAgIHJlc3VsdC5ob21lX2RlcG90XzIwMjEwNSxcXG4gICAgICAgIHJlc3VsdC5sb3dlc18yMDIxMDMsXFxuICAgICAgICByZXN1bHQubG93ZXNfMjAyMTA0LFxcbiAgICAgICAgcmVzdWx0Lmxvd2VzXzIwMjEwNSxcXG4gICAgICBdLFxcblxcbiAgICAgIHBlcmNlbnRzOiBbXFxuICAgICAgICByZXN1bHQuYmVzdF9idXlfMjAyMTAzX3BlcmNlbnQsXFxuICAgICAgICByZXN1bHQuYmVzdF9idXlfMjAyMTA0X3BlcmNlbnQsXFxuICAgICAgICByZXN1bHQuYmVzdF9idXlfMjAyMTA1X3BlcmNlbnQsXFxuICAgICAgICByZXN1bHQuaG9tZV9kZXBvdF8yMDIxMDNfcGVyY2VudCxcXG4gICAgICAgIHJlc3VsdC5ob21lX2RlcG90XzIwMjEwNF9wZXJjZW50LFxcbiAgICAgICAgcmVzdWx0LmhvbWVfZGVwb3RfMjAyMTA1X3BlcmNlbnQsXFxuICAgICAgICByZXN1bHQubG93ZXNfMjAyMTAzX3BlcmNlbnQsXFxuICAgICAgICByZXN1bHQubG93ZXNfMjAyMTA0X3BlcmNlbnQsXFxuICAgICAgICByZXN1bHQubG93ZXNfMjAyMTA1X3BlcmNlbnQsXFxuICAgICAgXSxcXG4gICAgfSk7XFxuICB9XFxuXFxuICByZXR1cm4gcmVzdWx0cztcXG59XFxuXFxuZnVuY3Rpb24gUGFzY2FsU3BhY2VDYXNlKHN0cikge1xcbiAgY29uc3QgY2FtZWxTcGFjZUNhc2VkID0gc3RyPy5yZXBsYWNlQWxsPy4oL1tBLVpdL2csICcgJCYnKTtcXG5cXG4gIHJldHVybiBjYXBpdGFsaXplKGNhbWVsU3BhY2VDYXNlZCk7XFxufVxcblxcbmZ1bmN0aW9uIHVwcGVyQWJicmV2aWF0ZU1vbnRoKG1vbnRoKSB7XFxuICBjb25zdCBhYmJyZXZpYXRlZCA9IG1vbnRoPy5zdWJzdHI/LigwLCAzKTtcXG5cXG4gIHJldHVybiBjYXBpdGFsaXplKGFiYnJldmlhdGVkKTtcXG59XFxuXFxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcXG4gIHJldHVybiBgJHtzdHI/LmNoYXJBdD8uKDApLnRvTG9jYWxlVXBwZXJDYXNlKCl9JHtzdHI/LnNsaWNlPy4oMSl9YDtcXG59XFxuPC9zY3JpcHQ+XFxuXFxuPHN0eWxlIGxhbmc9XFxcInN0eWx1c1xcXCI+XFxuLm1ldHJpY3NcXG4gIHBhZGRpbmctaW5saW5lIDhweFxcbiAgcGFkZGluZy10b3AgMjBweFxcbiAgcGFkZGluZy1ib3R0b20gNXB4XFxuPC9zdHlsZT5cXG5cXG48c3R5bGUgbGFuZz1cXFwic3R5bHVzXFxcIiBzY29wZWQ+XFxuLmJ0blxcbiAgYmFja2dyb3VuZC1jb2xvciB3aGl0ZVxcbiAgY29sb3IgIzQzODZhYlxcbiAgY3Vyc29yIHBvaW50ZXJcXG4gIHBhZGRpbmctaW5saW5lIDEycHhcXG4gIGhlaWdodCAzNHB4XFxuICBkaXNwbGF5IGZsZXhcXG4gIGp1c3RpZnktY29udGVudCBjZW50ZXJcXG4gIGFsaWduLWl0ZW1zIGNlbnRlclxcblxcbiAgJi5hY3RpdmVcXG4gICAgYmFja2dyb3VuZC1jb2xvciAjNDM4NmFiXFxuICAgIGNvbG9yIHdoaXRlXFxuXFxuLnN1bW1hcnlcXG4gIG1hcmdpbi1ib3R0b20gMjBweFxcbiAgZGlzcGxheSBmbGV4XFxuXFxuLnN1bW1hcnktdGl0bGVcXG4gIGZvbnQtd2VpZ2h0IGJvbGRcXG4gIG1hcmdpbi1yaWdodCA0MHB4XFxuICBkaXNwbGF5IGZsZXhcXG4gIGFsaWduLWl0ZW1zIGNlbnRlclxcblxcbi5zdW1tYXJ5LWJ0bnNcXG4gIGRpc3BsYXkgZmxleFxcblxcbi5zdW1tYXJ5LWJ0blxcbiAgd2lkdGggMTAwcHhcXG5cXG4gICY6Zmlyc3QtY2hpbGRcXG4gICBib3JkZXItdG9wLWxlZnQtcmFkaXVzIDVweFxcbiAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMgNXB4XFxuXFxuICAmOmxhc3QtY2hpbGRcXG4gICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1cyA1cHhcXG4gICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1cyA1cHhcXG5cXG4ucmVzdWx0c1xcbiAgJiBoZWFkZXJcXG4gICAgY29sb3IgIzdhOGY5ZlxcbiAgICBmb250LXdlaWdodCBib2xkXFxuICAgIG1hcmdpbi1ib3R0b20gMTBweFxcbiAgICBoZWlnaHQgMTAwcHhcXG5cXG4ucmVzdWx0XFxuICBiYWNrZ3JvdW5kLWNvbG9yIHdoaXRlXFxuICBtYXJnaW4tYm90dG9tIDVweFxcbiAgYm9yZGVyLXJhZGl1cyA1cHhcXG4gIGhlaWdodCA1MHB4XFxuICBkaXNwbGF5IGZsZXhcXG4gIGFsaWduLWl0ZW1zIGNlbnRlclxcblxcbiAgJjpsYXN0LWNoaWxkXFxuICAgIG1hcmdpbi1ib3R0b20gMFxcblxcbi5yZXN1bHQtY291bnRcXG4gIGZsZXgtZ3JvdyAxXFxuICB3aWR0aDogMFxcbiAgZGlzcGxheSBmbGV4XFxuICBhbGlnbi1pdGVtcyBjZW50ZXJcXG4gIGp1c3RpZnktY29udGVudCBjZW50ZXJcXG5cXG4ucmVzdWx0LXRpdGxlXFxuICBwYWRkaW5nLWxlZnQgMTVweFxcbiAgd2lkdGggMjAwcHhcXG4gIGRpc3BsYXkgZmxleFxcbiAgYWxpZ24taXRlbXMgY2VudGVyXFxuXFxuLnJlc3VsdC1zdG9yZVxcbiAgZmxleC1ncm93IDFcXG4gIGFsaWduLXNlbGYgc3RyZXRjaFxcbiAgYm9yZGVyLWxlZnQgMXB4IHNvbGlkICNlNmVlZjFcXG4gIGRpc3BsYXkgZmxleFxcbiAgZmxleC1kaXJlY3Rpb24gY29sdW1uXFxuXFxuLnJlc3VsdC1zdG9yZS10aXRsZVxcbiAgZmxleC1ncm93IDFcXG4gIGJvcmRlci1ib3R0b20gMXB4IHNvbGlkICNlNmVlZjFcXG4gIGRpc3BsYXkgZmxleFxcbiAganVzdGlmeS1jb250ZW50IGNlbnRlclxcbiAgYWxpZ24taXRlbXMgY2VudGVyXFxuXFxuLnJlc3VsdC1tb250aHNcXG4gIGZsZXgtZ3JvdyAxXFxuICBkaXNwbGF5IGZsZXhcXG5cXG4ucmVzdWx0LW1vbnRoXFxuICBmbGV4LWdyb3cgMVxcbiAgZGlzcGxheSBmbGV4XFxuICBqdXN0aWZ5LWNvbnRlbnQgY2VudGVyXFxuICBhbGlnbi1pdGVtcyBjZW50ZXJcXG5cXG4ucmVzdWx0LXRvdGFsXFxuICB0ZXh0LWFsaWduIGNlbnRlclxcbiAgYWxpZ24tc2VsZiBzdHJldGNoXFxuICBtYXJnaW4tcmlnaHQgMTVweFxcbiAgd2lkdGggMTUwcHhcXG4gIGRpc3BsYXkgZmxleFxcbiAganVzdGlmeS1jb250ZW50IGZsZXgtZW5kXFxuICBhbGlnbi1pdGVtcyBjZW50ZXJcXG5cXG4ucmVzdWx0LWhlYWRlci10b3RhbFxcbiAgbWFyZ2luLWxlZnQgMFxcbiAgYm9yZGVyLWxlZnQgMXB4IHNvbGlkICNlNmVlZjFcXG4gIGp1c3RpZnktY29udGVudCBjZW50ZXJcXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBnZXRUYXJnZXQgZnJvbSBcIiEuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2dldFRhcmdldC5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvZGlzdC9janMuanMhLi9hcHAuc3R5bFwiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNzcywgc3R5bGUpe1xuICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG4gIH07XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICB2YXIgbm9uY2UgPVxuICAgICAgICAgIHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKHN0eWxlKXtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KFwiaGVhZFwiKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiXG4gICAgICApO1xuICAgIH1cblxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH07XG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9zdHlsdXMtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vYXBwLnN0eWxcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBnZXRUYXJnZXQgZnJvbSBcIiEuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2dldFRhcmdldC5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10udXNlWzBdIS4vbWV0cmljcy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xMzg0ZDgyNSZsYW5nPXN0eWx1c1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNzcywgc3R5bGUpe1xuICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG4gIH07XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICB2YXIgbm9uY2UgPVxuICAgICAgICAgIHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKHN0eWxlKXtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KFwiaGVhZFwiKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiXG4gICAgICApO1xuICAgIH1cblxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH07XG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLnVzZVswXSEuL21ldHJpY3MudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MTM4NGQ4MjUmbGFuZz1zdHlsdXNcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBnZXRUYXJnZXQgZnJvbSBcIiEuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2dldFRhcmdldC5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10udXNlWzBdIS4vbWV0cmljcy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MSZpZD0xMzg0ZDgyNSZsYW5nPXN0eWx1cyZzY29wZWQ9dHJ1ZVwiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNzcywgc3R5bGUpe1xuICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG4gIH07XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICB2YXIgbm9uY2UgPVxuICAgICAgICAgIHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKHN0eWxlKXtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KFwiaGVhZFwiKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiXG4gICAgICApO1xuICAgIH1cblxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH07XG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLnVzZVswXSEuL21ldHJpY3MudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTEmaWQ9MTM4NGQ4MjUmbGFuZz1zdHlsdXMmc2NvcGVkPXRydWVcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYXJnZXQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xuICBhcGkudXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoc3R5bGUsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFN0eWxlRWxlbWVudDsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzO1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoXCJtZWRpYVwiKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgb3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZSwgb3B0aW9ucywgb2JqKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL21ldHJpY3MudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTEzODRkODI1JnNjb3BlZD10cnVlJmxhbmc9cHVnXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vbWV0cmljcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vbWV0cmljcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuXG5pbXBvcnQgXCIuL21ldHJpY3MudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MTM4NGQ4MjUmbGFuZz1zdHlsdXNcIlxuaW1wb3J0IFwiLi9tZXRyaWNzLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0xJmlkPTEzODRkODI1Jmxhbmc9c3R5bHVzJnNjb3BlZD10cnVlXCJcbnNjcmlwdC5yZW5kZXIgPSByZW5kZXJcbnNjcmlwdC5fX3Njb3BlSWQgPSBcImRhdGEtdi0xMzg0ZDgyNVwiXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICBzY3JpcHQuX19obXJJZCA9IFwiMTM4NGQ4MjVcIlxuICBjb25zdCBhcGkgPSBfX1ZVRV9ITVJfUlVOVElNRV9fXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFhcGkuY3JlYXRlUmVjb3JkKCcxMzg0ZDgyNScsIHNjcmlwdCkpIHtcbiAgICBhcGkucmVsb2FkKCcxMzg0ZDgyNScsIHNjcmlwdClcbiAgfVxuICBcbiAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL21ldHJpY3MudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTEzODRkODI1JnNjb3BlZD10cnVlJmxhbmc9cHVnXCIsICgpID0+IHtcbiAgICBhcGkucmVyZW5kZXIoJzEzODRkODI1JywgcmVuZGVyKVxuICB9KVxuXG59XG5cbnNjcmlwdC5fX2ZpbGUgPSBcIm1ldHJpY3MudnVlXCJcblxuZXhwb3J0IGRlZmF1bHQgc2NyaXB0IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2UhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLnVzZVswXSEuL21ldHJpY3MudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2UhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLnVzZVswXSEuL21ldHJpY3MudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgJy4vYXBwLnN0eWwnO1xuXG5pbXBvcnQge2NyZWF0ZUFwcH0gZnJvbSAndnVlJztcbmltcG9ydCBNZXRyaWNzIGZyb20gJy4vbWV0cmljcyc7XG5cbmNyZWF0ZUFwcChNZXRyaWNzKS5tb3VudCgnbWFpbicpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==